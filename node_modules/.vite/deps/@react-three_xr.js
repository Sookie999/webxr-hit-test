import {
  CombinedPointer,
  Pointer,
  PointerEvent,
  createGrabPointer,
  createLinesPointer,
  createRayPointer,
  createTouchPointer,
  forwardHtmlEvents,
  forwardObjectEvents
} from "./chunk-ZXV4YWI6.js";
import {
  MeshLineGeometry,
  MeshLineMaterial,
  tunnel
} from "./chunk-RTJLXOXJ.js";
import {
  require_client
} from "./chunk-IO64F4HD.js";
import "./chunk-D7552MD7.js";
import {
  addEffect,
  context,
  createPortal,
  reconciler,
  suspend,
  useFrame,
  useLoader,
  useStore,
  useThree
} from "./chunk-42ZEVU5E.js";
import "./chunk-HTPD32MN.js";
import {
  require_jsx_runtime
} from "./chunk-OBYCLIUT.js";
import {
  require_with_selector
} from "./chunk-KI7NY2S2.js";
import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@react-three/xr/dist/space.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/@pmndrs/xr/dist/controller/gamepad.js
import { clamp } from "three/src/math/MathUtils.js";
var ButtonTouchThreshold = 0.05;
var AxisTouchThreshold = 0.1;
function updateXRControllerGamepadState(target, inputSource, layout) {
  const gamepad = inputSource.gamepad;
  if (gamepad == null) {
    return;
  }
  const layoutComponents = layout.components;
  for (const key in layoutComponents) {
    let component = target[key];
    if (component == null) {
      target[key] = component = {};
    }
    const { gamepadIndices } = layoutComponents[key];
    let pressed = false;
    let touched = false;
    if (gamepadIndices.button != null && gamepadIndices.button < gamepad.buttons.length) {
      const gamepadButton = gamepad.buttons[gamepadIndices.button];
      component.button = clamp(gamepadButton.value, 0, 1);
      pressed ||= gamepadButton.pressed || component.button === 1;
      touched ||= gamepadButton.touched || component.button > ButtonTouchThreshold;
    }
    if (gamepadIndices.xAxis != null && gamepadIndices.xAxis < gamepad.axes.length) {
      component.xAxis = clamp(gamepad.axes[gamepadIndices.xAxis], -1, 1);
      touched ||= Math.abs(component.xAxis) > AxisTouchThreshold;
    }
    if (gamepadIndices.yAxis != null && gamepadIndices.yAxis < gamepad.axes.length) {
      component.yAxis = clamp(gamepad.axes[gamepadIndices.yAxis], -1, 1);
      touched ||= Math.abs(component.yAxis) > AxisTouchThreshold;
    }
    component.state = pressed ? "pressed" : touched ? "touched" : "default";
  }
}

// node_modules/@pmndrs/xr/dist/index.js
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

// node_modules/@pmndrs/xr/dist/hand/pose.js
import { Matrix4 } from "three";
function createHandPoseState(hand) {
  return {
    //distances: {},
    //name: undefined,
    data: new Float32Array(hand.size * 16)
  };
}
function updateXRHandPoseState(state, frame, hand, manager, handedness) {
  const referenceSpace = manager.getReferenceSpace();
  if (referenceSpace == null || frame == null || frame.session.visibilityState === "visible-blurred" || frame.session.visibilityState === "hidden") {
    return;
  }
  const validPose = updateXRHandPoseData(frame, referenceSpace, hand, state.data);
  if (!validPose) {
    return;
  }
  let closestPoseName;
  let closestPoseDistance;
}
var invertedWirstHelper = new Matrix4();
var matrixHelper = new Matrix4();
function updateXRHandPoseData(frame, referenceSpace, hand, handPoseData) {
  const validPose = frame.fillPoses(hand.values(), referenceSpace, handPoseData);
  if (!validPose) {
    return false;
  }
  invertedWirstHelper.fromArray(handPoseData, 0);
  invertedWirstHelper.invert();
  for (let i2 = 0; i2 < handPoseData.length; i2 += 16) {
    matrixHelper.fromArray(handPoseData, i2);
    matrixHelper.premultiply(invertedWirstHelper);
    matrixHelper.toArray(handPoseData, i2);
  }
  return true;
}

// node_modules/@pmndrs/xr/dist/hand/model.js
import { Material, Mesh } from "three";
import { clone as cloneSkeleton } from "three/examples/jsm/utils/SkeletonUtils.js";
var DefaultDefaultXRHandProfileId = "generic-hand";
function getXRHandAssetPath(handedness, options) {
  const baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;
  const defaultProfileId = options?.defaultXRHandProfileId ?? DefaultDefaultXRHandProfileId;
  return new URL(`${defaultProfileId}/${handedness}.glb`, baseAssetPath).href;
}
function cloneXRHandGltf({ scene }) {
  const result = cloneSkeleton(scene);
  const mesh = result.getObjectByProperty("type", "SkinnedMesh");
  if (mesh == null) {
    throw new Error(`missing SkinnedMesh in loaded XRHand model`);
  }
  mesh.frustumCulled = false;
  return result;
}
function configureXRHandModel(model, options) {
  model.renderOrder = options?.renderOrder ?? 0;
  model.traverse((child) => {
    if (child instanceof Mesh && child.material instanceof Material) {
      child.material.colorWrite = options?.colorWrite ?? true;
    }
  });
}

// node_modules/@pmndrs/xr/dist/hand/state.js
function createXRHandState(id, inputSource, options, events, isPrimary) {
  return {
    id,
    isPrimary,
    type: "hand",
    inputSource,
    pose: createHandPoseState(inputSource.hand),
    assetPath: getXRHandAssetPath(inputSource.handedness, options),
    events
  };
}
function updateXRHandState({ inputSource, pose }, frame, manager) {
  updateXRHandPoseState(pose, frame, inputSource.hand, manager, inputSource.handedness);
}

// node_modules/@pmndrs/xr/dist/hand/visual.js
var joints = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
function createUpdateXRHandVisuals(hand, handModel, referenceSpace) {
  const buffer = new Float32Array(hand.size * 16);
  const jointObjects = joints.map((joint) => {
    const jointObject = handModel.getObjectByName(joint);
    if (jointObject == null) {
      throw new Error(`missing joint "${joint}" in hand model`);
    }
    jointObject.matrixAutoUpdate = false;
    return jointObject;
  });
  return (frame) => {
    const resolvedReferenceSpace = typeof referenceSpace === "function" ? referenceSpace() : referenceSpace;
    if (frame == null || resolvedReferenceSpace == null) {
      return;
    }
    frame.fillPoses(hand.values(), resolvedReferenceSpace, buffer);
    const length = jointObjects.length;
    for (let i2 = 0; i2 < length; i2++) {
      jointObjects[i2].matrix.fromArray(buffer, i2 * 16);
    }
  };
}

// node_modules/@pmndrs/xr/dist/input.js
function isXRInputSourceState(val) {
  return val != null && typeof val === "object" && "inputSource" in val;
}
function setupEvents(session, events) {
  const listener = (e) => events.push(e);
  session.addEventListener("selectstart", listener);
  session.addEventListener("selectend", listener);
  session.addEventListener("select", listener);
  session.addEventListener("squeeze", listener);
  session.addEventListener("squeezestart", listener);
  session.addEventListener("squeezeend", listener);
  return () => {
    session.removeEventListener("selectstart", listener);
    session.removeEventListener("selectend", listener);
    session.removeEventListener("select", listener);
    session.removeEventListener("squeeze", listener);
    session.removeEventListener("squeezestart", listener);
    session.removeEventListener("squeezeend", listener);
  };
}
var idCounter = 0;
function createSyncXRInputSourceStates(addController, options) {
  const cleanupMap = /* @__PURE__ */ new Map();
  const controllerLayoutLoader = new XRControllerLayoutLoader(options);
  const idMap = /* @__PURE__ */ new Map();
  return (session, current, changes) => {
    if (changes === "remove-all") {
      for (const cleanup of cleanupMap.values()) {
        cleanup();
      }
      return current;
    }
    const target = [...current];
    for (const { added, isPrimary, removed } of changes) {
      if (removed != null) {
        for (const inputSource of removed) {
          const index = target.findIndex(({ inputSource: is, isPrimary: ip }) => ip === isPrimary && is === inputSource);
          if (index === -1) {
            continue;
          }
          target.splice(index, 1);
          cleanupMap.get(inputSource)?.();
          cleanupMap.delete(inputSource);
        }
      }
      if (added == null) {
        continue;
      }
      for (const inputSource of added) {
        const events = [];
        let cleanup = setupEvents(session, events);
        const key = `${inputSource.handedness}-${inputSource.hand ? "hand" : "nohand"}-${inputSource.targetRayMode}-${inputSource.profiles.join(",")}`;
        let id;
        if ((id = idMap.get(key)) == null) {
          idMap.set(key, id = `${idCounter++}`);
        }
        if (inputSource.hand != null) {
          target.push(createXRHandState(id, inputSource, options, events, isPrimary));
        } else {
          switch (inputSource.targetRayMode) {
            case "gaze":
              target.push({ id, isPrimary, type: "gaze", inputSource, events });
              break;
            case "screen":
              target.push({ id, isPrimary, type: "screenInput", inputSource, events });
              break;
            case "transient-pointer":
              target.push({ id, isPrimary, type: "transientPointer", inputSource, events });
              break;
            case "tracked-pointer":
              let aborted = false;
              const cleanupEvents = cleanup;
              cleanup = () => {
                cleanupEvents();
                aborted = true;
              };
              const stateResult = createXRControllerState(id, inputSource, controllerLayoutLoader, events, isPrimary);
              if (stateResult instanceof Promise) {
                stateResult.then((state) => !aborted && addController(state)).catch(console.error);
              } else {
                target.push(stateResult);
              }
              break;
          }
        }
        cleanupMap.set(inputSource, cleanup);
      }
    }
    return target;
  };
}

// node_modules/@pmndrs/xr/dist/visible.js
function setupSyncIsVisible(store, setIsVisible) {
  const update = (state, prevState) => {
    if (prevState != null && state.visibilityState === prevState.visibilityState) {
      return;
    }
    setIsVisible(state.visibilityState === "visible");
  };
  update(store.getState());
  return store.subscribe(update);
}

// node_modules/@pmndrs/xr/dist/pointer/cursor.js
import { MeshBasicMaterial, Quaternion, Vector3 } from "three";
var PointerCursorMaterial = class extends MeshBasicMaterial {
  constructor() {
    super({ transparent: true, toneMapped: false, depthWrite: false });
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = `varying vec2 vLocalPosition;
` + parameters.vertexShader;
    parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>
        vLocalPosition = position.xy * 2.0;`);
    parameters.fragmentShader = `varying vec2 vLocalPosition;
` + parameters.fragmentShader;
    parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", `#include <color_fragment>
          float value = max(0.0, 1.0 - sqrt(dot(vLocalPosition, vLocalPosition)));
          diffuseColor.a = diffuseColor.a * value * value;`);
  }
};
var ZAxis = new Vector3(0, 0, 1);
var quaternionHelper = new Quaternion();
var offsetHelper = new Vector3();
function updatePointerCursorModel(pointerGroup, mesh, material, pointer, options) {
  const intersection = pointer.getIntersection();
  if (intersection == null || !pointer.getEnabled() || intersection.object.isVoidObject === true || !isVisble(pointerGroup)) {
    mesh.visible = false;
    return;
  }
  mesh.visible = true;
  const color = typeof options.color === "function" ? options.color(pointer) : options.color;
  if (Array.isArray(color)) {
    material.color.set(...color);
  } else {
    material.color.set(color ?? "white");
  }
  material.opacity = typeof options.opacity === "function" ? options.opacity(pointer) : options.opacity ?? 0.4;
  mesh.position.copy(intersection.pointOnFace);
  mesh.scale.setScalar(options.size ?? 0.1);
  const normal = intersection.normal ?? intersection.face?.normal;
  if (normal != null) {
    quaternionHelper.setFromUnitVectors(ZAxis, normal);
    intersection.object.getWorldQuaternion(mesh.quaternion);
    mesh.quaternion.multiply(quaternionHelper);
    offsetHelper.set(0, 0, options.cursorOffset ?? 0.01);
    offsetHelper.applyQuaternion(mesh.quaternion);
    mesh.position.add(offsetHelper);
  }
  mesh.updateMatrix();
}
function isVisble({ visible, parent }) {
  if (!visible) {
    return false;
  }
  if (parent == null) {
    return true;
  }
  return isVisble(parent);
}

// node_modules/@pmndrs/xr/dist/pointer/ray.js
import { MeshBasicMaterial as MeshBasicMaterial2 } from "three";
var PointerRayMaterial = class extends MeshBasicMaterial2 {
  constructor() {
    super({ transparent: true, toneMapped: false });
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    parameters.vertexShader = `varying float vFade;
` + parameters.vertexShader;
    parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>
            vFade = position.z + 0.5;`);
    parameters.fragmentShader = `varying float vFade;
` + parameters.fragmentShader;
    parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", `#include <color_fragment>
              diffuseColor.a *= vFade;`);
  }
};
function updatePointerRayModel(mesh, material, pointer, options) {
  const intersection = pointer.getIntersection();
  if (!pointer.getEnabled() || intersection == null) {
    mesh.visible = false;
    return;
  }
  mesh.visible = true;
  const color = typeof options.color === "function" ? options.color(pointer) : options.color;
  if (Array.isArray(color)) {
    material.color.set(...color);
  } else {
    material.color.set(color ?? "white");
  }
  material.opacity = typeof options.opacity === "function" ? options.opacity(pointer) : options.opacity ?? 0.4;
  const length = Math.min(options.maxLength ?? 1, intersection.distance);
  mesh.position.z = -length / 2;
  const size = options.size ?? 5e-3;
  mesh.scale.set(size, size, length);
  mesh.updateMatrix();
}

// node_modules/@pmndrs/xr/dist/pointer/event.js
function bindXRInputSourceEvent(session, inputSource, event, fn) {
  const filterFn = (event2) => {
    if (inputSource != "all" && event2.inputSource != inputSource) {
      return;
    }
    fn(event2);
  };
  session.addEventListener(event, filterFn);
  return () => session.removeEventListener(event, filterFn);
}
function bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents, options = {}) {
  const downListener = (e) => {
    if (e.inputSource === inputSource) {
      pointer.down(Object.assign(e, { button: options.button ?? 0 }));
    }
  };
  const upListener = (e) => {
    if (e.inputSource === inputSource) {
      pointer.up(Object.assign(e, { button: options.button ?? 0 }));
    }
  };
  const downEventName = `${event}start`;
  const upEventName = `${event}end`;
  const length = missingEvents.length;
  for (let i2 = 0; i2 < length; i2++) {
    const event2 = missingEvents[i2];
    switch (event2.type) {
      case downEventName:
        downListener(event2);
        break;
      case upEventName:
        upListener(event2);
        break;
    }
  }
  session.addEventListener(downEventName, downListener);
  session.addEventListener(upEventName, upListener);
  return () => {
    session.removeEventListener(downEventName, downListener);
    session.removeEventListener(upEventName, upListener);
  };
}

// node_modules/@pmndrs/xr/dist/pointer/default.js
function defaultGrabPointerOpacity(pointer) {
  if (pointer.getButtonsDown().size > 0) {
    return 0.6;
  }
  return map(pointer.getIntersection()?.distance ?? Infinity, 0.07, 0, 0.2, 0.4);
}
function defaultRayPointerOpacity(pointer) {
  if (pointer.getButtonsDown().size > 0) {
    return 0.6;
  }
  return 0.4;
}
function defaultTouchPointerOpacity(pointer) {
  return map(pointer.getIntersection()?.distance ?? Infinity, 0.1, 0.03, 0.2, 0.6);
}
function map(value, fromMin, fromMax, toMin, toMax) {
  return toMin + Math.max(0, Math.min(1, (value - fromMin) / (fromMax - fromMin))) * (toMax - toMin);
}

// node_modules/@pmndrs/xr/dist/vanilla/space.js
import { Object3D as Object3D3 } from "three";

// node_modules/@pmndrs/xr/dist/space.js
function createGetXRSpaceMatrix(space, referenceSpace) {
  return (target, frame) => {
    if (space === referenceSpace) {
      target.identity();
      return true;
    }
    const resolvedReferenceSpace = typeof referenceSpace === "function" ? referenceSpace() : referenceSpace;
    if (resolvedReferenceSpace == null) {
      return false;
    }
    const pose = frame?.getPose(space, resolvedReferenceSpace);
    if (pose == null) {
      return false;
    }
    target.fromArray(pose.transform.matrix);
    return true;
  };
}
function getSpaceFromAncestors(object, origin, originReferenceSpace, targetOffsetMatrix) {
  targetOffsetMatrix?.copy(object.matrix);
  const result = getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);
  if (result != null) {
    return result;
  }
  if (targetOffsetMatrix != null) {
    computeOriginReferenceSpaceOffset(object, origin, targetOffsetMatrix);
  }
  return originReferenceSpace;
}
function computeOriginReferenceSpaceOffset(object, origin, target) {
  object.updateWorldMatrix(true, false);
  if (origin == null) {
    target.copy(object.matrixWorld);
    return;
  }
  origin.updateWorldMatrix(true, false);
  target.copy(origin.matrixWorld).invert().multiply(object.matrixWorld);
}
function getXRSpaceFromAncestorsRec(object, targetOffsetMatrix) {
  if (object == null) {
    return void 0;
  }
  if (object.xrSpace != null) {
    return object.xrSpace;
  }
  targetOffsetMatrix?.premultiply(object.matrix);
  return getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);
}

// node_modules/@pmndrs/xr/dist/vanilla/elements.js
import { Group as Group2 } from "three";

// node_modules/@pmndrs/xr/dist/store.js
import { Vector3 as Vector33 } from "three";

// node_modules/@pmndrs/xr/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@pmndrs/xr/dist/misc.js
import { Quaternion as Quaternion2, Vector3 as Vector32 } from "three";
var vectorHelper = new Vector32();
var directionHelper = new Vector32();
var positionHelper = new Vector32();
var quaternionHelper2 = new Quaternion2();
function isFacingCamera(camera, object, direction, angle) {
  object.getWorldQuaternion(quaternionHelper2);
  directionHelper.copy(direction).applyQuaternion(quaternionHelper2);
  object.getWorldPosition(positionHelper);
  camera.getWorldPosition(vectorHelper);
  vectorHelper.sub(positionHelper);
  return vectorHelper.angleTo(directionHelper) < angle / 2;
}
function isAppleVisionPro() {
  return navigator.userAgent.includes("Macintosh") && navigator.xr != null;
}

// node_modules/@pmndrs/xr/dist/init.js
function buildXRSessionInit(mode, domOverlayRoot, {
  anchors = true,
  handTracking = isAppleVisionPro() ? false : true,
  layers = true,
  meshDetection = true,
  planeDetection = true,
  customSessionInit,
  depthSensing = false,
  hitTest = true,
  domOverlay = true,
  bodyTracking = false,
  //until 6.7 since breaking change
  bounded
} = {}) {
  if (customSessionInit != null) {
    return customSessionInit;
  }
  const requiredFeatures = bounded == null ? ["local-floor"] : bounded ? ["bounded-floor"] : ["unbounded", "local-floor"];
  const optionalFeatures = [];
  if (domOverlay instanceof Element) {
    domOverlay = true;
  }
  addXRSessionFeature(anchors, "anchors", requiredFeatures, optionalFeatures);
  addXRSessionFeature(handTracking, "hand-tracking", requiredFeatures, optionalFeatures);
  addXRSessionFeature(layers, "layers", requiredFeatures, optionalFeatures);
  addXRSessionFeature(meshDetection, "mesh-detection", requiredFeatures, optionalFeatures);
  addXRSessionFeature(planeDetection, "plane-detection", requiredFeatures, optionalFeatures);
  addXRSessionFeature(depthSensing, "depth-sensing", requiredFeatures, optionalFeatures);
  addXRSessionFeature(domOverlay, "dom-overlay", requiredFeatures, optionalFeatures);
  addXRSessionFeature(hitTest, "hit-test", requiredFeatures, optionalFeatures);
  addXRSessionFeature(bodyTracking, "body-tracking", requiredFeatures, optionalFeatures);
  const init = {
    requiredFeatures,
    optionalFeatures
  };
  if (domOverlayRoot != null) {
    init.domOverlay = { root: domOverlayRoot };
  }
  if (depthSensing) {
    Object.assign(init, { depthSensing: { usagePreference: ["gpu-optimized"], dataFormatPreference: [] } });
  }
  return init;
}
function addXRSessionFeature(value, key, requiredFeatures, optionalFeatures) {
  if (value === false) {
    return;
  }
  if (value === true) {
    optionalFeatures.push(key);
    return;
  }
  requiredFeatures.push(key);
}

// node_modules/@pmndrs/xr/dist/store.js
function resolveInputSourceImplementation(implementation, handedness, defaultValue) {
  if (typeof implementation === "function") {
    return implementation;
  }
  if (typeof implementation === "object") {
    if (handedness != null && hasKey(implementation, handedness)) {
      implementation = implementation[handedness];
    } else if ("default" in implementation) {
      implementation = implementation.default;
    }
  }
  if (implementation === false) {
    return false;
  }
  if (implementation === true) {
    return defaultValue;
  }
  return implementation ?? defaultValue;
}
function hasKey(val, key) {
  return key in val;
}
var baseInitialState = {
  session: void 0,
  mediaBinding: void 0,
  originReferenceSpace: void 0,
  visibilityState: void 0,
  mode: null,
  frameRate: void 0,
  inputSourceStates: [],
  detectedMeshes: [],
  detectedPlanes: [],
  layerEntries: []
};
async function injectEmulator(store, emulateOptions, alert) {
  if (typeof navigator === "undefined") {
    return false;
  }
  const [vr, ar] = await Promise.all([
    navigator.xr?.isSessionSupported("immersive-vr").catch((e) => {
      console.error(e);
      return false;
    }),
    navigator.xr?.isSessionSupported("immersive-ar").catch((e) => {
      console.error(e);
      return false;
    })
  ]);
  if (ar || vr) {
    return false;
  }
  const { emulate } = await import("./emulate-AKS6W5VK.js");
  if (alert) {
    window.alert(`emulator started`);
  }
  store.setState({
    emulator: emulate(emulateOptions === true ? "metaQuest3" : emulateOptions)
  });
  return true;
}
var cameraWorldPosition = new Vector33();
var tempLayerWorldPosition = new Vector33();
function createXRStore(options) {
  const domOverlayRoot = typeof HTMLElement === "undefined" ? void 0 : options?.domOverlay instanceof HTMLElement ? options.domOverlay : document.createElement("div");
  const store = createStore(() => ({
    ...baseInitialState,
    controller: options?.controller,
    hand: options?.hand,
    gaze: options?.gaze,
    screenInput: options?.screenInput,
    transientPointer: options?.transientPointer,
    domOverlayRoot
  }));
  const unsubscribeSessionOffer = store.subscribe(({ session }, { session: oldSession }) => {
    if (oldSession != null && session == null && xrManager != null) {
      offerSession(xrManager, options, domOverlayRoot).catch(console.error);
    }
  });
  const emulate = options?.emulate ?? "metaQuest3";
  let cleanupEmulate;
  if (typeof window !== "undefined" && emulate != false) {
    const inject = (typeof emulate === "object" ? emulate.inject : void 0) ?? { hostname: "localhost" };
    if (inject === true || typeof inject != "boolean" && window.location.hostname === inject.hostname) {
      injectEmulator(store, emulate, false).then((emulate2) => {
        if (!emulate2 || xrManager == null) {
          return;
        }
        offerSession(xrManager, options, domOverlayRoot);
      });
    }
    const keydownListener = (e) => {
      if (e.altKey && e.metaKey && e.code === "KeyE") {
        injectEmulator(store, emulate, true).then((emulate2) => {
          if (!emulate2 || xrManager == null) {
            return;
          }
          offerSession(xrManager, options, domOverlayRoot);
        });
      }
    };
    window.addEventListener("keydown", keydownListener);
    cleanupEmulate = () => window.removeEventListener("keydown", keydownListener);
  }
  let cleanupDomOverlayRoot;
  if (domOverlayRoot != null) {
    if (domOverlayRoot.parentNode == null) {
      const setupDisplay = (state) => {
        domOverlayRoot.style.display = state.session != null ? "block" : "none";
      };
      const unsubscribe = store.subscribe(setupDisplay);
      setupDisplay(store.getState());
      document.body.appendChild(domOverlayRoot);
      cleanupDomOverlayRoot = () => {
        domOverlayRoot.remove();
        unsubscribe();
      };
    }
    document.body.append(domOverlayRoot);
  }
  const syncXRInputSourceStates = createSyncXRInputSourceStates((state) => store.setState({ inputSourceStates: [...store.getState().inputSourceStates, state] }), options);
  const bindToSession = createBindToSession(store, syncXRInputSourceStates, options?.secondaryInputSources ?? false);
  const cleanupSessionGrantedListener = setupSessionGrantedListener(options?.enterGrantedSession, (mode) => enterXRSession(domOverlayRoot, mode, options, xrManager));
  const frameRequests = [];
  let xrManager;
  const onSessionStart = () => {
    store.setState(bindToSession(xrManager.getSession()));
  };
  return Object.assign(store, {
    addLayerEntry(layerEntry) {
      if (store.getState().session == null) {
        return;
      }
      store.setState({ layerEntries: [...store.getState().layerEntries, layerEntry] });
    },
    removeLayerEntry(layerEntry) {
      if (store.getState().session == null) {
        return;
      }
      store.setState({ layerEntries: store.getState().layerEntries.filter((entry) => entry != layerEntry) });
    },
    requestFrame() {
      return new Promise((resolve) => frameRequests.push(resolve));
    },
    setWebXRManager(newXrManager) {
      if (xrManager === newXrManager) {
        return;
      }
      xrManager?.removeEventListener("sessionstart", onSessionStart);
      xrManager = newXrManager;
      xrManager.addEventListener("sessionstart", onSessionStart);
      const { foveation, bounded } = options ?? {};
      xrManager.setReferenceSpaceType(bounded ? "bounded-floor" : "local-floor");
      if (foveation != null) {
        xrManager.setFoveation(foveation);
      }
      offerSession(xrManager, options, domOverlayRoot).catch(console.error);
    },
    setFrameRate(value) {
      const { session } = store.getState();
      if (session == null) {
        return;
      }
      setFrameRate(session, value);
    },
    setHand(implementation, handedness) {
      if (handedness == null) {
        store.setState({ hand: implementation });
        return;
      }
      const currentImplementation = store.getState().hand;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        hand: newControllerImplementation
      });
    },
    setController(implementation, handedness) {
      if (handedness == null) {
        store.setState({ controller: implementation });
        return;
      }
      const currentImplementation = store.getState().controller;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        controller: newControllerImplementation
      });
    },
    setTransientPointer(implementation, handedness) {
      if (handedness == null) {
        store.setState({ transientPointer: implementation });
        return;
      }
      const currentImplementation = store.getState().transientPointer;
      const newControllerImplementation = {};
      if (typeof currentImplementation === "object") {
        Object.assign(newControllerImplementation, currentImplementation);
      }
      Object.assign(newControllerImplementation, {
        default: resolveInputSourceImplementation(currentImplementation, void 0, {}),
        [handedness]: implementation
      });
      store.setState({
        transientPointer: newControllerImplementation
      });
    },
    setGaze(implementation) {
      store.setState({ gaze: implementation });
    },
    setScreenInput(implementation) {
      store.setState({ screenInput: implementation });
    },
    destroy() {
      xrManager?.removeEventListener("sessionstart", onSessionStart);
      cleanupEmulate?.();
      cleanupDomOverlayRoot?.();
      cleanupSessionGrantedListener?.();
      unsubscribeSessionOffer();
      bindToSession(void 0);
    },
    enterXR: (mode) => enterXRSession(domOverlayRoot, mode, options, xrManager),
    enterAR: () => enterXRSession(domOverlayRoot, "immersive-ar", options, xrManager),
    enterVR: () => enterXRSession(domOverlayRoot, "immersive-vr", options, xrManager),
    onBeforeFrame(scene, camera, frame) {
      let update;
      const referenceSpace = xrManager?.getReferenceSpace() ?? void 0;
      const state = store.getState();
      const origin = camera.parent ?? scene;
      if (state.origin != origin) {
        update ??= {};
        update.origin = origin;
      }
      if (referenceSpace != state.originReferenceSpace) {
        update ??= {};
        update.originReferenceSpace = referenceSpace;
      }
      origin.xrSpace = referenceSpace;
      if (state.origin != origin && state.origin != null) {
        state.origin.xrSpace = void 0;
      }
      if (frame != null) {
        if (xrManager != null) {
          updateSession(store, frame, xrManager);
        }
        if (state.body != frame.body) {
          update ??= {};
          update.body = frame.body;
        }
      }
      if (update != null) {
        store.setState(update);
      }
      if (frame != null) {
        const length = frameRequests.length;
        for (let i2 = 0; i2 < length; i2++) {
          frameRequests[i2](frame);
        }
        frameRequests.length = 0;
      }
    },
    onBeforeRender() {
      const { session, layerEntries } = store.getState();
      if (session == null || xrManager == null) {
        return;
      }
      const xrCamera = xrManager.getCamera();
      xrCamera.aspect = xrCamera.projectionMatrix.elements[5] / xrCamera.projectionMatrix.elements[0];
      const currentLayers = session?.renderState.layers;
      if (currentLayers == null) {
        return;
      }
      xrCamera.getWorldPosition(cameraWorldPosition);
      layerEntries.sort((entryA, entryB) => {
        const renderOrderDifference = entryA.renderOrder - entryB.renderOrder;
        if (renderOrderDifference !== 0) {
          return renderOrderDifference;
        }
        entryA.object3D.getWorldPosition(tempLayerWorldPosition);
        const distA_sq = tempLayerWorldPosition.distanceToSquared(cameraWorldPosition);
        entryB.object3D.getWorldPosition(tempLayerWorldPosition);
        const distB_sq = tempLayerWorldPosition.distanceToSquared(cameraWorldPosition);
        return distB_sq - distA_sq;
      });
      let changed = false;
      const layers = layerEntries.map(({ layer }, i2) => {
        if (layer != currentLayers[i2]) {
          changed = true;
        }
        return layer;
      });
      if (!changed) {
        return;
      }
      layers.push(xrManager.getBaseLayer());
      session.updateRenderState({
        layers
      });
    }
  });
}
async function offerSession(manager, options, domOverlayRoot) {
  const offerSessionOptions = options?.offerSession ?? true;
  if (navigator.xr?.offerSession == null || offerSessionOptions === false) {
    return;
  }
  let mode;
  if (offerSessionOptions === true) {
    const arSupported = await navigator.xr.isSessionSupported("immersive-ar") ?? false;
    mode = arSupported ? "immersive-ar" : "immersive-vr";
  } else {
    mode = offerSessionOptions;
  }
  const session = await navigator.xr.offerSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));
  setupXRSession(session, manager, options);
}
async function setFrameRate(session, frameRate) {
  if (frameRate === false) {
    return;
  }
  const { supportedFrameRates } = session;
  if (supportedFrameRates == null || supportedFrameRates.length === 0) {
    return;
  }
  if (typeof frameRate === "function") {
    const value = frameRate(supportedFrameRates);
    if (value === false) {
      return;
    }
    await session.updateTargetFrameRate(value);
    return;
  }
  const multiplier = frameRate === "high" ? 1 : frameRate === "mid" ? 0.5 : 0;
  await session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);
}
async function enterXRSession(domOverlayRoot, mode, options, manager) {
  if (typeof navigator === "undefined" || navigator.xr == null) {
    return Promise.reject(new Error(`WebXR not supported`));
  }
  if (manager == null) {
    return Promise.reject(new Error(`not connected to three.js. You either might be missing the <XR> component or the canvas is not yet loaded?`));
  }
  const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));
  await setupXRSession(session, manager, options);
  return session;
}
async function setupXRSession(session, manager, options) {
  await Promise.all([setFrameRate(session, options?.frameRate ?? "high"), setupXRManager(manager, session, options)]);
}
async function setupXRManager(xr, session, options) {
  if (xr == null) {
    return;
  }
  const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
  let frameBufferScaling = options?.frameBufferScaling;
  if (typeof frameBufferScaling === "function") {
    frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);
  }
  if (typeof frameBufferScaling === "string") {
    frameBufferScaling = frameBufferScaling === "high" ? maxFrameBufferScalingFactor : frameBufferScaling === "mid" ? 1 : 0.5;
  }
  if (frameBufferScaling != null) {
    xr?.setFramebufferScaleFactor(frameBufferScaling);
  }
  await xr?.setSession(session);
}
var allSessionModes = ["immersive-ar", "immersive-vr", "inline"];
function setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR) {
  if (typeof navigator === "undefined" || enterGrantedSession === false) {
    return;
  }
  if (enterGrantedSession === true) {
    enterGrantedSession = allSessionModes;
  }
  const sessionGrantedListener = async () => {
    for (const mode of enterGrantedSession) {
      if (!await navigator.xr?.isSessionSupported(mode)) {
        continue;
      }
      enterXR(mode);
    }
  };
  navigator.xr?.addEventListener("sessiongranted", sessionGrantedListener);
  return () => navigator.xr?.removeEventListener("sessiongranted", sessionGrantedListener);
}
function createBindToSession(store, syncXRInputSourceStates, secondayInputSources) {
  let cleanupSession;
  return (session) => {
    cleanupSession?.();
    if (session == null) {
      return {};
    }
    const inputSourceChangesList = [];
    let inputSourceChangesTimeout;
    const applySourcesChange = () => {
      inputSourceChangesTimeout = void 0;
      store.setState({
        inputSourceStates: syncXRInputSourceStates(session, store.getState().inputSourceStates, inputSourceChangesList)
      });
      inputSourceChangesList.length = 0;
    };
    const onSourcesChange = (isPrimary, e) => {
      inputSourceChangesList.push({ isPrimary, added: e.added, removed: e.removed });
      if (inputSourceChangesTimeout != null) {
        return;
      }
      if (secondayInputSources) {
        inputSourceChangesTimeout = setTimeout(applySourcesChange, 100);
      } else {
        applySourcesChange();
      }
    };
    const onInputSourcesChange = onSourcesChange.bind(null, true);
    session.addEventListener("inputsourceschange", onInputSourcesChange);
    let cleanupSecondaryInputSources;
    if (secondayInputSources) {
      const onTrackedSourcesChange = onSourcesChange.bind(null, false);
      session.addEventListener("trackedsourceschange", onTrackedSourcesChange);
      cleanupSecondaryInputSources = () => session.removeEventListener("trackedsourceschange", onTrackedSourcesChange);
    }
    const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });
    session.addEventListener("frameratechange", onChange);
    session.addEventListener("visibilitychange", onChange);
    const onEnd = () => {
      cleanupSession?.();
      cleanupSession = void 0;
      store.setState({
        emulator: store.getState().emulator,
        ...baseInitialState
      });
    };
    session.addEventListener("end", onEnd);
    const initialChanges = [
      { isPrimary: true, added: session.inputSources }
    ];
    if (secondayInputSources) {
      initialChanges.push({ isPrimary: false, added: session.trackedSources });
    }
    const inputSourceStates = syncXRInputSourceStates(session, [], initialChanges);
    cleanupSession = () => {
      cleanupSecondaryInputSources?.();
      clearTimeout(inputSourceChangesTimeout);
      syncXRInputSourceStates(session, store.getState().inputSourceStates, "remove-all");
      session.removeEventListener("end", onEnd);
      session.removeEventListener("frameratechange", onChange);
      session.removeEventListener("visibilitychange", onChange);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
    };
    return {
      inputSourceStates,
      frameRate: session.frameRate,
      visibilityState: session.visibilityState,
      detectedMeshes: [],
      detectedPlanes: [],
      mode: session.environmentBlendMode === "opaque" ? "immersive-vr" : "immersive-ar",
      session,
      mediaBinding: typeof XRMediaBinding == "undefined" ? void 0 : new XRMediaBinding(session)
    };
  };
}
function updateSession(store, frame, manager) {
  const referenceSpace = manager.getReferenceSpace();
  const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, inputSourceStates } = store.getState();
  if (referenceSpace == null || session == null) {
    return;
  }
  const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);
  const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);
  if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {
    store.setState({ detectedPlanes, detectedMeshes });
  }
  const inputSourceStatesLength = inputSourceStates.length;
  for (let i2 = 0; i2 < inputSourceStatesLength; i2++) {
    const inputSourceState = inputSourceStates[i2];
    switch (inputSourceState.type) {
      case "controller":
        updateXRControllerState(inputSourceState);
        break;
      case "hand":
        updateXRHandState(inputSourceState, frame, manager);
        break;
    }
  }
}
var emptyArray = [];
function updateDetectedEntities(prevDetectedEntities, detectedEntities) {
  if (detectedEntities == null) {
    return emptyArray;
  }
  if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {
    return prevDetectedEntities;
  }
  return Array.from(detectedEntities);
}
function equalContent(set, arr) {
  if (set.size != arr.length) {
    return false;
  }
  for (const entry of arr) {
    if (!set.has(entry)) {
      return false;
    }
  }
  return true;
}

// node_modules/@pmndrs/xr/dist/vanilla/default.js
import { Group } from "three";

// node_modules/@pmndrs/xr/dist/vanilla/hand.js
import { Object3D } from "three";

// node_modules/@pmndrs/xr/dist/vanilla/pointer.js
import { BoxGeometry, Mesh as Mesh2, PlaneGeometry } from "three";
var pointerRayGeometry = new BoxGeometry();
var pointerCursorGeometry = new PlaneGeometry();

// node_modules/@pmndrs/xr/dist/vanilla/controller.js
import { Object3D as Object3D2 } from "three";

// node_modules/@pmndrs/xr/dist/controller/model.js
import { Material as Material2, Mesh as Mesh3 } from "three";
async function loadXRControllerModel(layout, loader = DefaultGltfLoader) {
  const { scene } = await loader.loadAsync(layout.assetPath);
  return scene.clone(true);
}
function configureXRControllerModel(model, options) {
  model.renderOrder = options?.renderOrder ?? 0;
  model.traverse((child) => {
    if (child instanceof Mesh3 && child.material instanceof Material2) {
      child.material.colorWrite = options?.colorWrite ?? true;
    }
  });
}

// node_modules/@pmndrs/xr/dist/controller/visual.js
import { Vector2 } from "three";
function createUpdateXRControllerVisuals(model, layout, gamepadState) {
  const updateVisuals = [];
  for (const componentName in layout.components) {
    const component = layout.components[componentName];
    let state = gamepadState[componentName];
    if (state == null) {
      gamepadState[componentName] = state = {
        state: "default"
      };
    }
    updateVisuals.push(...Object.values(component.visualResponses).map((visualResponse) => createUpdateVisualResponse(model, state, visualResponse)));
  }
  return () => {
    const length = updateVisuals.length;
    for (let i2 = 0; i2 < length; i2++) {
      updateVisuals[i2]();
    }
  };
}
function createUpdateVisualResponse(model, componentState, visualResponse) {
  const valueNode = model.getObjectByName(visualResponse.valueNodeName);
  componentState.object = valueNode;
  if (valueNode == null) {
    return () => {
    };
  }
  if (visualResponse.valueNodeProperty === "visibility") {
    return () => valueNode.visible = visualResponse.states.includes(componentState.state);
  }
  const minNode = model.getObjectByName(visualResponse.minNodeName);
  const maxNode = model.getObjectByName(visualResponse.maxNodeName);
  if (minNode == null || maxNode == null) {
    return () => {
    };
  }
  return () => {
    const value = getVisualReponseValue(componentState, visualResponse);
    valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
    valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
    valueNode.updateMatrix();
  };
}
function getVisualReponseValue(componentState, { componentProperty, states }) {
  const stateIsActive = states.includes(componentState.state);
  switch (componentProperty) {
    case "xAxis":
      return stateIsActive ? getNormalizesAxis(componentState).x : 0.5;
    case "yAxis":
      return stateIsActive ? getNormalizesAxis(componentState).y : 0.5;
    case "button":
      return stateIsActive ? componentState.button ?? 0 : 0;
    case "state":
      return stateIsActive ? 1 : 0;
  }
}
var vector2Helper = new Vector2();
function getNormalizesAxis({ xAxis = 0, yAxis = 0 }) {
  const hypotenuse = vector2Helper.lengthSq();
  if (hypotenuse > 1) {
    const theta = Math.atan2(yAxis, xAxis);
    vector2Helper.set(Math.cos(theta), Math.sin(theta));
  } else {
    vector2Helper.set(xAxis, yAxis);
  }
  vector2Helper.multiplyScalar(0.5).addScalar(0.5);
  return vector2Helper;
}

// node_modules/@pmndrs/xr/dist/vanilla/mesh.js
import { Mesh as Mesh4 } from "three";

// node_modules/@pmndrs/xr/dist/mesh.js
import { BufferAttribute, BufferGeometry } from "three";
function updateXRMeshGeometry(mesh, geometry) {
  if (geometry != null && geometry.createdAt != null && geometry.createdAt >= mesh.lastChangedTime) {
    return geometry;
  }
  const newGeometry = new BufferGeometry();
  newGeometry.setIndex(new BufferAttribute(mesh.indices, 1));
  newGeometry.setAttribute("position", new BufferAttribute(mesh.vertices, 3));
  return Object.assign(newGeometry, { creationTime: mesh.lastChangedTime });
}

// node_modules/@pmndrs/xr/dist/vanilla/plane.js
import { Mesh as Mesh5 } from "three";

// node_modules/@pmndrs/xr/dist/plane.js
import { Box2, BufferGeometry as BufferGeometry2, Shape, ShapeGeometry, Vector2 as Vector22 } from "three";
function updateXRPlaneGeometry(plane, geometry) {
  if (geometry != null && geometry.createdAt != null && geometry.createdAt >= plane.lastChangedTime) {
    return geometry;
  }
  return Object.assign(createGeometryFromPolygon(plane.polygon), { createdAt: plane.lastChangedTime });
}
var boxHelper = new Box2();
var sizeHelper = new Vector22();
function createGeometryFromPolygon(polygon) {
  if (polygon.length === 0) {
    return new BufferGeometry2();
  }
  const shape = new Shape();
  const points = polygon.map(({ x, z }) => new Vector22(x, z));
  boxHelper.setFromPoints(points);
  boxHelper.getSize(sizeHelper);
  for (const point of points) {
    point.sub(boxHelper.min);
    point.divide(sizeHelper);
  }
  shape.setFromPoints(points);
  const geometry = new ShapeGeometry(shape);
  geometry.scale(sizeHelper.x, sizeHelper.y, 1);
  geometry.translate(boxHelper.min.x, boxHelper.min.y, 0);
  geometry.rotateX(Math.PI / 2);
  return geometry;
}

// node_modules/@pmndrs/xr/dist/vanilla/origin.js
import { Group as Group3 } from "three";

// node_modules/@pmndrs/xr/dist/vanilla/layer.js
import { Mesh as Mesh6, MeshBasicMaterial as MeshBasicMaterial3, WebGLRenderTarget as WebGLRenderTarget2 } from "three";

// node_modules/@pmndrs/xr/dist/layer.js
import { CylinderGeometry, DepthTexture, HalfFloatType, LinearFilter, Matrix4 as Matrix42, PlaneGeometry as PlaneGeometry2, Quaternion as Quaternion3, SphereGeometry, SRGBColorSpace, Texture, Vector3 as Vector34, VideoTexture, WebGLRenderTarget } from "three";

// node_modules/@pmndrs/xr/dist/utils.js
function toDOMPointInit(value, defaultW = 1) {
  if (value == null) {
    return void 0;
  }
  return {
    x: nanToDefault(value.x),
    y: nanToDefault(value.y),
    z: nanToDefault(value.z),
    w: "w" in value ? nanToDefault(value.w, defaultW) : defaultW
  };
}
function nanToDefault(value, defaultValue = 0) {
  if (isNaN(value)) {
    return defaultValue;
  }
  return value;
}

// node_modules/@pmndrs/xr/dist/layer.js
var DefaultCentralAngle = 60 / 180 * Math.PI;
var DefaultCentralHorizontalAngle = 60 / 180 * Math.PI;
var DefaultLowerVerticalAngle = -30 / 180 * Math.PI;
var DefaultUpperVerticalAngle = 30 / 180 * Math.PI;
function createXRLayer(src, state, originReferenceSpace, xrManager, relativeTo, options, properties) {
  return src instanceof HTMLVideoElement ? createXRVideoLayer(src, state, originReferenceSpace, relativeTo, options, properties) : createXRNormalLayer(src, state.origin, originReferenceSpace, xrManager, relativeTo, options, properties);
}
function createXRVideoLayer(src, state, originReferenceSpace, relativeTo, { invertStereo, layout, shape = "quad" }, properties = {}) {
  const space = getSpaceFromAncestors(relativeTo, state.origin, originReferenceSpace, matrixHelper2);
  const transform = matrixToRigidTransform(matrixHelper2, scaleHelper);
  const init = {
    invertStereo,
    layout,
    space,
    transform
  };
  applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);
  const fnName = `create${capitalize(shape)}Layer`;
  const layer = state.mediaBinding?.[fnName](src, init);
  if (layer == null) {
    return void 0;
  }
  updateXRLayerProperties(layer, properties);
  return layer;
}
function createXRNormalLayer(src, origin, originReferenceSpace, xrManager, relativeTo, { shape = "quad", ...options }, properties = {}) {
  const space = getSpaceFromAncestors(relativeTo, origin, originReferenceSpace, matrixHelper2);
  const transform = matrixToRigidTransform(matrixHelper2, scaleHelper);
  const init = {
    ...options,
    isStatic: !(src instanceof WebGLRenderTarget),
    textureType: "texture",
    viewPixelWidth: options.layout === "stereo-left-right" ? src.width / 2 : src.width,
    viewPixelHeight: options.layout === "stereo-top-bottom" ? src.height / 2 : src.height,
    space,
    transform
  };
  applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);
  const fnName = `create${capitalize(shape)}Layer`;
  const layer = xrManager.getBinding()?.[fnName](init);
  if (layer == null) {
    return void 0;
  }
  updateXRLayerProperties(layer, properties);
  return layer;
}
var matrixHelper2 = new Matrix42();
var vectorHelper2 = new Vector34();
var quaternionHelper3 = new Quaternion3();
var scaleHelper = new Vector34();
function matrixToRigidTransform(matrix, scaleTarget = scaleHelper) {
  matrix.decompose(vectorHelper2, quaternionHelper3, scaleTarget);
  scaleTarget.x = nanToDefault(scaleTarget.x);
  scaleTarget.y = nanToDefault(scaleTarget.y);
  scaleTarget.z = nanToDefault(scaleTarget.z);
  return new XRRigidTransform(toDOMPointInit(vectorHelper2), toDOMPointInit(quaternionHelper3));
}
var segmentPerAngle = 64 / Math.PI;
function computeSegmentAmount(angle) {
  return Math.ceil(angle * segmentPerAngle);
}
function setXRLayerRenderTarget(renderer, renderTarget, layerEntry, frame) {
  if (layerEntry != null && frame != null) {
    const subImage = renderer.xr.getBinding().getSubImage(layerEntry.layer, frame);
    renderer.setRenderTargetTextures(renderTarget, subImage.colorTexture);
  }
  renderer.setRenderTarget(renderTarget);
}
function createXRLayerGeometry(shape, properties) {
  switch (shape) {
    case "cylinder":
      const centralAngle = properties.centralAngle ?? DefaultCentralAngle;
      return new CylinderGeometry(1, 1, 1, computeSegmentAmount(centralAngle), 1, true, Math.PI - centralAngle / 2, centralAngle).scale(-1, 1, 1);
    case "equirect": {
      const centralHorizontalAngle = properties.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;
      const upperVerticalAngle = properties.upperVerticalAngle ?? DefaultUpperVerticalAngle;
      const lowerVerticalAngle = properties.lowerVerticalAngle ?? DefaultLowerVerticalAngle;
      const centralVerticalAngle = upperVerticalAngle - lowerVerticalAngle;
      return new SphereGeometry(1, computeSegmentAmount(centralHorizontalAngle), computeSegmentAmount(centralVerticalAngle), -Math.PI / 2 - centralHorizontalAngle / 2, centralHorizontalAngle, Math.PI / 2 - upperVerticalAngle, centralVerticalAngle).scale(-1, 1, 1);
    }
    case "quad":
      return new PlaneGeometry2();
  }
}
function capitalize(text) {
  return `${text[0].toUpperCase()}${text.slice(1)}`;
}
function updateXRLayerProperties(target, properties = {}) {
  target.chromaticAberrationCorrection = properties.chromaticAberrationCorrection;
  target.quality = properties.quality ?? "default";
  target.blendTextureSourceAlpha = properties.blendTextureSourceAlpha ?? false;
  if (target instanceof XRCylinderLayer) {
    target.centralAngle = properties?.centralAngle ?? DefaultCentralAngle;
    return;
  }
  if (target instanceof XREquirectLayer) {
    target.centralHorizontalAngle = properties?.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;
    target.lowerVerticalAngle = properties?.lowerVerticalAngle ?? DefaultLowerVerticalAngle;
    target.upperVerticalAngle = properties?.upperVerticalAngle ?? DefaultUpperVerticalAngle;
  }
}
function setupXRImageLayer(renderer, store, layer, src) {
  let stop = false;
  const draw = async () => {
    const frame = await store.requestFrame();
    if (stop) {
      return;
    }
    writeContentToXRLayer(renderer, layer, frame, src);
  };
  layer.addEventListener("redraw", draw);
  draw();
  return () => {
    stop = true;
    layer.removeEventListener("redraw", draw);
  };
}
async function waitForXRLayerSrcSize(src) {
  if (src instanceof HTMLImageElement && !src.complete) {
    await new Promise((resolve) => {
      const onResolve = () => {
        resolve();
        src.removeEventListener("load", onResolve);
      };
      src.addEventListener("load", onResolve);
    });
  }
  if (src instanceof HTMLVideoElement && src.readyState < 1) {
    return new Promise((resolve) => {
      const onResolve = () => {
        resolve();
        src.removeEventListener("loadedmetadata", onResolve);
      };
      src.addEventListener("loadedmetadata", onResolve);
    });
  }
}
function getXRLayerSrcTexture(src) {
  if (src instanceof WebGLRenderTarget) {
    return src.texture;
  }
  const texture = src instanceof HTMLVideoElement ? new VideoTexture(src) : new Texture(src);
  texture.colorSpace = SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}
function writeContentToXRLayer(renderer, layer, frame, content) {
  const context2 = renderer.getContext();
  const subImage = renderer.xr.getBinding().getSubImage(layer, frame);
  renderer.state.bindTexture(context2.TEXTURE_2D, subImage.colorTexture);
  context2.pixelStorei(context2.UNPACK_FLIP_Y_WEBGL, true);
  context2.texSubImage2D(context2.TEXTURE_2D, 0, 0, 0, content.width, content.height, context2.RGBA, context2.UNSIGNED_BYTE, content);
}
function updateXRLayerTransform(state, target, centralAngle, relativeTo) {
  if (state.originReferenceSpace == null) {
    return;
  }
  target.space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper2);
  target.transform = matrixToRigidTransform(matrixHelper2, scaleHelper);
  applyXRLayerScale(getLayerShape(target), target, centralAngle, scaleHelper);
}
function applyXRLayerScale(shape, target, centralAngle, scale) {
  if (shape === "cylinder") {
    const scaleXZ = (scale.x + scale.z) / 2;
    const radius = scaleXZ;
    const layerWidth = radius * (centralAngle ?? DefaultCentralAngle);
    target.radius = radius;
    target.aspectRatio = scale.y === 0 ? 1 : layerWidth / scale.y;
  } else if (shape === "quad") {
    target.width = scale.x / 2;
    target.height = scale.y / 2;
  } else {
    target.radius = (scale.x + scale.y + scale.z) / 3;
  }
}
function getLayerShape(layer) {
  if (layer instanceof XRCylinderLayer) {
    return "cylinder";
  }
  if (layer instanceof XREquirectLayer) {
    return "equirect";
  }
  return "quad";
}
function createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr) {
  return new WebGLRenderTarget(pixelWidth * dpr, pixelHeight * dpr, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    type: HalfFloatType,
    depthTexture: new DepthTexture(pixelWidth, pixelHeight)
  });
}

// node_modules/@pmndrs/xr/dist/teleport.js
import { Euler, Mesh as Mesh7, QuadraticBezierCurve3, Quaternion as Quaternion4, Vector3 as Vector35 } from "three";
import { clamp as clamp2 } from "three/src/math/MathUtils.js";
function makeTeleportTarget(root, camera, onTeleport) {
  root.traverse((object) => object.userData.teleportTarget = true);
  const listener = (e) => {
    if ("point" in e && e.point instanceof Vector35) {
      const c = typeof camera === "function" ? camera() : camera;
      const point = new Vector35().setFromMatrixPosition(c.matrix).negate().setComponent(1, 0).add(e.point);
      onTeleport(point, e);
    }
  };
  root.addEventListener("pointerup", listener);
  return () => {
    root.traverse((object) => object.userData.teleportTarget = false);
    root.removeEventListener("pointerup", listener);
  };
}
var eulerHelper = new Euler(0, 0, 0, "YXZ");
var quaternionHelper4 = new Quaternion4();
function syncTeleportPointerRayGroup(space, rayGroup, deltaTimeMs) {
  space.updateWorldMatrix(true, false);
  space.matrixWorld.decompose(rayGroup.position, quaternionHelper4, rayGroup.scale);
  eulerHelper.setFromQuaternion(quaternionHelper4);
  eulerHelper.z = 0;
  eulerHelper.x = clamp2(eulerHelper.x - 10 * Math.PI / 180, -Math.PI / 2, 1.1 * Math.PI / 4);
  quaternionHelper4.setFromEuler(eulerHelper);
  rayGroup.quaternion.slerp(quaternionHelper4, deltaTimeMs / 100);
}
function isTeleportTarget(object) {
  return object.userData.teleportTarget === true;
}
function buildTeleportTargetFilter(options = {}) {
  return (object, pointerEvents, pointerEventsType, pointerEventsOrder) => {
    if (!isTeleportTarget(object)) {
      return false;
    }
    if (options.filter != null && !options.filter(object, pointerEvents, pointerEventsType, pointerEventsOrder)) {
      return false;
    }
    return true;
  };
}
function createTeleportRayLine() {
  const curve = new QuadraticBezierCurve3(new Vector35(0, 0, 0), new Vector35(0, 0, -8), new Vector35(0, -20, -15));
  return curve.getPoints(20);
}
var TeleportPointerRayModel = class extends Mesh7 {
  multiplier;
  lineLengths;
  options = {};
  constructor(points) {
    const geometry = new MeshLineGeometry();
    const float32Array = new Float32Array(points.length * 3);
    for (let i2 = 0; i2 < points.length; i2++) {
      points[i2].toArray(float32Array, i2 * 3);
    }
    geometry.setPoints(float32Array);
    const multiplier = (points.length * 3 - 3) / (points.length * 3 - 1);
    const material = new MeshLineMaterial({
      lineWidth: 0.1,
      resolution: void 0,
      visibility: multiplier
    });
    super(geometry, material);
    this.material.transparent = true;
    this.multiplier = multiplier;
    this.material = material;
    this.lineLengths = points.slice(0, -1).map((p, i2) => p.distanceTo(points[i2 + 1]));
  }
  update(pointer) {
    const enabled = pointer.getEnabled();
    const intersection = pointer.getIntersection();
    if (!enabled || pointer.getButtonsDown().size === 0 || intersection == null) {
      this.visible = false;
      return;
    }
    this.visible = true;
    if (intersection.details.type != "lines") {
      this.material.visibility = this.multiplier;
      return;
    }
    const { distanceOnLine, lineIndex } = intersection.details;
    const lineLength = this.lineLengths[lineIndex];
    this.material.visibility = this.multiplier * (lineIndex + distanceOnLine / lineLength) / this.lineLengths.length;
    const { color = "white", opacity = 0.4, size = 0.01 } = this.options;
    this.material.lineWidth = size;
    this.material.opacity = typeof opacity === "function" ? opacity(pointer) : opacity;
    const resolvedColor = typeof color === "function" ? color(pointer) : color;
    if (Array.isArray(resolvedColor)) {
      this.material.color.set(...resolvedColor);
    } else {
      this.material.color.set(resolvedColor);
    }
  }
};

// node_modules/@pmndrs/xr/dist/hit-test.js
import { Matrix4 as Matrix43, Quaternion as Quaternion5, Vector3 as Vector36 } from "three";
var matrixHelper3 = new Matrix43();
var vectorHelper3 = new Vector36();
var scaleHelper2 = new Vector36();
var quaternionHelper5 = new Quaternion5();
async function createXRHitTestSource(store, session, relativeTo, trackableType = ["point", "plane", "mesh"]) {
  if (typeof relativeTo === "string") {
    relativeTo = await session.requestReferenceSpace(relativeTo);
  }
  const entityTypes = Array.isArray(trackableType) ? trackableType : [trackableType];
  let options;
  let baseSpace;
  let object;
  const state = store.getState();
  if (relativeTo instanceof XRSpace) {
    options = { space: relativeTo, entityTypes };
    object = state.origin;
  } else {
    const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper3);
    if (space == null) {
      return void 0;
    }
    matrixHelper3.decompose(vectorHelper3, quaternionHelper5, scaleHelper2);
    const point = toDOMPointInit(vectorHelper3);
    vectorHelper3.set(0, 0, -1).applyQuaternion(quaternionHelper5);
    const offsetRay = new XRRay(point, toDOMPointInit(vectorHelper3, 0));
    object = relativeTo;
    options = { space, offsetRay, entityTypes };
    baseSpace = space;
  }
  const source = await session?.requestHitTestSource?.(options);
  if (source == null) {
    return void 0;
  }
  return {
    source,
    getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, store, baseSpace, object)
  };
}
async function requestXRHitTest(store, relativeTo, trackableType) {
  const session = store.getState().session;
  if (session == null) {
    return;
  }
  const sourceData = await createXRHitTestSource(store, session, relativeTo, trackableType);
  if (sourceData == null) {
    return void 0;
  }
  const { source, getWorldMatrix } = sourceData;
  const frame = await store.requestFrame();
  const results = frame.getHitTestResults?.(source) ?? [];
  source.cancel();
  if (results == null) {
    return void 0;
  }
  return { results, getWorldMatrix };
}
function computeWorldMatrixFromXRHitTestResult(store, baseSpace, object, target, result) {
  baseSpace ??= store.getState().originReferenceSpace;
  if (baseSpace == null) {
    return false;
  }
  const pose = result.getPose(baseSpace);
  if (pose == null) {
    return false;
  }
  target.fromArray(pose.transform.matrix);
  if (object != null) {
    object.updateWorldMatrix(true, false);
    target.premultiply(object.matrixWorld);
  }
  return true;
}

// node_modules/@pmndrs/xr/dist/anchor.js
import { Matrix4 as Matrix44, Quaternion as Quaternion6, Vector3 as Vector37 } from "three";
var OneVector = new Vector37(1, 1, 1);
var ZeroVector = new Vector37(0, 0, 0);
var NeutralQuaternion = new Quaternion6();
var matrixHelper1 = new Matrix44();
var matrixHelper22 = new Matrix44();
var quaternionHelper6 = new Quaternion6();
var positionHelper2 = new Vector37();
var vectorHelper4 = new Vector37();
async function requestXRAnchor(store, options) {
  if (options.relativeTo === "hit-test-result") {
    return options.hitTestResult.createAnchor?.(new XRRigidTransform(toDOMPointInit(options.offsetPosition), toDOMPointInit(options.offsetQuaternion)));
  }
  let frame;
  let space;
  if (options.relativeTo === "world") {
    frame = options.frame ?? await store.requestFrame();
    const { origin, originReferenceSpace } = store.getState();
    if (originReferenceSpace == null) {
      return void 0;
    }
    space = originReferenceSpace;
    const { worldPosition, worldQuaternion } = options;
    if (origin != null) {
      origin.updateWorldMatrix(true, false);
      matrixHelper1.copy(origin.matrixWorld).invert();
      matrixHelper22.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);
      matrixHelper22.decompose(positionHelper2, quaternionHelper6, vectorHelper4);
    } else {
      positionHelper2.copy(worldPosition);
      quaternionHelper6.copy(worldQuaternion);
    }
  } else {
    frame = options.frame ?? await store.requestFrame();
    space = options.space;
    const { offsetPosition, offsetQuaternion } = options;
    positionHelper2.copy(offsetPosition ?? ZeroVector);
    quaternionHelper6.copy(offsetQuaternion ?? NeutralQuaternion);
  }
  return frame.createAnchor?.(new XRRigidTransform(toDOMPointInit(positionHelper2), toDOMPointInit(quaternionHelper6)), space);
}

// node_modules/@pmndrs/xr/dist/controller-locomotion.js
import { Euler as Euler2, MathUtils, Quaternion as Quaternion7, Vector3 as Vector38 } from "three";
var defaultSpeed = 2;
var defaultSmoothTurningSpeed = 2;
var defaultSnapDegrees = 45;
var defaultDeadZone = 0.5;
var thumbstickPropName = "xr-standard-thumbstick";
var vectorHelper5 = new Vector38();
var quaternionHelper7 = new Quaternion7();
var eulerHelper2 = new Euler2();
var positionHelper3 = new Vector38();
var scaleHelper3 = new Vector38();
function createXRControllerLocomotionUpdate() {
  let canRotate = true;
  return (target, store, camera, delta, translationOptions = {}, rotationOptions = {}, translationControllerHand = "left", ...params) => {
    const { inputSourceStates } = store.getState();
    const rotationControllerHand = translationControllerHand === "left" ? "right" : "left";
    const translationController = inputSourceStates.find((state) => isControllerWithHandedness(state, translationControllerHand));
    const rotationController = inputSourceStates.find((state) => isControllerWithHandedness(state, rotationControllerHand));
    if (translationController == null || rotationController == null) {
      return;
    }
    const translationThumbstickState = translationController.gamepad[thumbstickPropName];
    const translationXAxis = translationThumbstickState?.xAxis ?? 0;
    const translationYAxis = translationThumbstickState?.yAxis ?? 0;
    const rotationXAxis = rotationController.gamepad[thumbstickPropName]?.xAxis ?? 0;
    let yRotationChange;
    if (rotationOptions !== false) {
      if (rotationOptions === true) {
        rotationOptions = {};
      }
      if (rotationOptions.type === "smooth") {
        if (Math.abs(rotationXAxis) > (rotationOptions.deadZone ?? defaultDeadZone)) {
          yRotationChange = (rotationXAxis < 0 ? -1 : 1) * delta * (rotationOptions.speed ?? defaultSmoothTurningSpeed);
        }
      } else {
        if (Math.abs(rotationXAxis) < (rotationOptions.deadZone ?? defaultDeadZone)) {
          canRotate = true;
        } else if (canRotate) {
          canRotate = false;
          yRotationChange = (rotationXAxis > 0 ? -1 : 1) * MathUtils.degToRad(rotationOptions.degrees ?? defaultSnapDegrees);
        }
      }
    }
    const translationChanged = translationXAxis != 0 || translationYAxis != 0;
    if (translationOptions !== false && translationChanged) {
      if (translationOptions === true) {
        translationOptions = {};
      }
      const { speed = defaultSpeed } = translationOptions;
      vectorHelper5.set(translationXAxis * speed, 0, translationYAxis * speed);
      camera.matrixWorld.decompose(positionHelper3, quaternionHelper7, scaleHelper3);
      vectorHelper5.applyQuaternion(quaternionHelper7);
      if (yRotationChange) {
        vectorHelper5.applyEuler(eulerHelper2.set(0, yRotationChange, 0, "YXZ"));
      }
    }
    if (!translationChanged && yRotationChange == null) {
      return;
    }
    if (typeof target === "function") {
      target(vectorHelper5, yRotationChange ?? 0, ...params);
      return;
    }
    if (target == null) {
      return;
    }
    target.position.x += vectorHelper5.x * delta;
    target.position.z += vectorHelper5.z * delta;
    target.rotation.y += yRotationChange ?? 0;
  };
}
function isControllerWithHandedness(state, handedness) {
  return state.type === "controller" && state.inputSource.handedness === handedness;
}

// node_modules/@pmndrs/xr/dist/index.js
var DefaultGltfLoader = new GLTFLoader();
var DefaultAssetBasePath = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/";

// node_modules/@pmndrs/xr/dist/controller/utils.js
function syncAsync(fn, ...fns) {
  let value = fn();
  for (const fnEntry of fns) {
    if (value instanceof Promise) {
      value = value.then(fnEntry);
    } else {
      value = fnEntry(value);
    }
  }
  return value;
}

// node_modules/@pmndrs/xr/dist/controller/layout.js
var DefaultDefaultControllerProfileId = "generic-trigger";
var XRControllerLayoutLoader = class {
  baseAssetPath;
  defaultProfileId;
  //cache
  profilesListCache;
  profileCacheMap = /* @__PURE__ */ new Map();
  constructor(options) {
    this.baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;
    this.defaultProfileId = options?.defaultControllerProfileId ?? DefaultDefaultControllerProfileId;
  }
  load(inputSourceProfileIds, handedness) {
    return syncAsync(
      //load profile
      () => this.loadProfile(inputSourceProfileIds),
      //get controller layout from profile
      (profile) => {
        for (const key in profile.layouts) {
          if (!key.includes(handedness)) {
            continue;
          }
          return profile.layouts[key];
        }
        throw new Error(`No matching layout for "${handedness}", in profile ${profile.profileId} with layouts ${Object.keys(profile.layouts).join(", ")}.`);
      }
    );
  }
  //alias for Loader compatibility
  loadAsync = this.load;
  loadProfile(inputSourceProfileIds) {
    return syncAsync(
      //load profiles list
      () => this.profilesListCache ?? fetchJson(new URL("profilesList.json", this.baseAssetPath).href).then((profilesList) => this.profilesListCache = profilesList),
      //load profile
      (profilesList) => {
        const length = inputSourceProfileIds.length;
        let profileInfo;
        for (let i2 = 0; i2 < length; i2++) {
          profileInfo = profilesList[inputSourceProfileIds[i2]];
          if (profileInfo != null) {
            break;
          }
        }
        profileInfo ??= profilesList[this.defaultProfileId];
        if (profileInfo == null) {
          throw new Error(`no matching profile found for profiles "${inputSourceProfileIds.join(", ")}" in profile list ${JSON.stringify(profilesList)}`);
        }
        return this.loadProfileFromPath(profileInfo.path);
      }
    );
  }
  loadProfileFromPath(relativeProfilePath) {
    const result = this.profileCacheMap.get(relativeProfilePath);
    if (result != null) {
      return result;
    }
    const absoluteProfilePath = new URL(relativeProfilePath, this.baseAssetPath).href;
    return fetchJson(absoluteProfilePath).then((profile) => {
      for (const key in profile.layouts) {
        const layout = profile.layouts[key];
        if (layout == null) {
          continue;
        }
        layout.assetPath = new URL(layout.assetPath, absoluteProfilePath).href;
      }
      this.profileCacheMap.set(relativeProfilePath, profile);
      return profile;
    });
  }
};
async function fetchJson(url) {
  let response = await fetch(url);
  if (!response.ok) {
    return Promise.reject(new Error(response.statusText));
  }
  return response.json();
}

// node_modules/@pmndrs/xr/dist/controller/state.js
function createXRControllerState(id, inputSource, layoutLoader, events, isPrimary) {
  return syncAsync(() => layoutLoader.load(inputSource.profiles, inputSource.handedness), (layout) => {
    const gamepad = {};
    updateXRControllerGamepadState(gamepad, inputSource, layout);
    return {
      id,
      isPrimary,
      events,
      type: "controller",
      inputSource,
      gamepad,
      layout
    };
  });
}
function updateXRControllerState({ gamepad, inputSource, layout }) {
  updateXRControllerGamepadState(gamepad, inputSource, layout);
}

// node_modules/@react-three/xr/dist/space.js
var import_react12 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/contexts.js
var import_react = __toESM(require_react(), 1);
var xrContext = (0, import_react.createContext)(void 0);
var xrInputSourceStateContext = (0, import_react.createContext)(void 0);
var xrSpaceContext = (0, import_react.createContext)(void 0);
var combinedPointerContext = (0, import_react.createContext)(void 0);

// node_modules/@react-three/xr/dist/input.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/xr.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl2 = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore2 = (createState) => createState ? createStoreImpl2(createState) : createStoreImpl2;

// node_modules/@react-three/xr/node_modules/zustand/esm/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue } = import_react2.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore2(api, selector = identity, equalityFn) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore2(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore2(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/@react-three/xr/dist/elements.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/node_modules/zustand/esm/shallow.mjs
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}

// node_modules/@react-three/xr/dist/default.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/controller.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var XRControllerComponent = (0, import_react3.forwardRef)(({ id, children, onPress, onRelease }, ref) => {
  const state = useXRInputSourceStateContext("controller");
  const [object, setObject] = (0, import_react3.useState)(void 0);
  (0, import_react3.useImperativeHandle)(ref, () => object, [object]);
  useXRControllerButtonEvent(state, id, (state2) => state2 === "pressed" ? onPress?.() : onRelease?.());
  useFrame(() => setObject(state.gamepad[id]?.object));
  if (object == null) {
    return;
  }
  return createPortal(children, object);
});
function useXRControllerButtonEvent(controller, id, onChange) {
  const state = (0, import_react3.useRef)(void 0);
  useFrame(() => {
    const currentState = controller?.gamepad[id]?.state;
    if (currentState != null && currentState != state.current) {
      onChange(currentState);
    }
    state.current = currentState;
  });
}
var LoadXRControllerModelSymbol = Symbol("loadXRControllerModel");
var XRControllerModel2 = (0, import_react3.forwardRef)((options, ref) => {
  const state = useXRInputSourceStateContext("controller");
  const model = suspend(loadXRControllerModel, [state.layout, void 0, LoadXRControllerModelSymbol]);
  configureXRControllerModel(model, options);
  state.object = model;
  (0, import_react3.useImperativeHandle)(ref, () => model, [model]);
  const update = (0, import_react3.useMemo)(() => createUpdateXRControllerVisuals(model, state.layout, state.gamepad), [model, state.layout, state.gamepad]);
  useFrame(update);
  return (0, import_jsx_runtime.jsx)(XRSpace3, { space: "grip-space", children: (0, import_jsx_runtime.jsx)("primitive", { object: model }) });
});
var LoadXRControllerLayoutSymbol = Symbol("loadXRControllerLayout");
function useLoadXRControllerLayout(profileIds, handedness, { baseAssetPath, defaultControllerProfileId } = {}) {
  const loader = (0, import_react3.useMemo)(() => new XRControllerLayoutLoader({ baseAssetPath, defaultControllerProfileId }), [baseAssetPath, defaultControllerProfileId]);
  return suspend(() => {
    const result = loader.loadAsync(profileIds, handedness);
    return result instanceof Promise ? result : Promise.resolve(result);
  }, [LoadXRControllerLayoutSymbol, handedness, ...profileIds]);
}
function useLoadXRControllerModel(layout) {
  return suspend(loadXRControllerModel, [layout, void 0, LoadXRControllerModelSymbol]);
}

// node_modules/@react-three/xr/dist/hand.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
import { GLTFLoader as GLTFLoader2 } from "three/examples/jsm/loaders/GLTFLoader.js";
var XRHandModel2 = (0, import_react4.forwardRef)((options, ref) => {
  const state = useXRInputSourceStateContext("hand");
  const gltf = useLoader(GLTFLoader2, state.assetPath);
  const model = (0, import_react4.useMemo)(() => cloneXRHandGltf(gltf), [gltf]);
  configureXRHandModel(model, options);
  state.object = model;
  (0, import_react4.useImperativeHandle)(ref, () => model, [model]);
  const referenceSpace = useXRSpace();
  const update = (0, import_react4.useMemo)(() => createUpdateXRHandVisuals(state.inputSource.hand, model, referenceSpace), [state.inputSource, model, referenceSpace]);
  useFrame((_state, _delta, frame) => update(frame));
  return (0, import_jsx_runtime2.jsx)("primitive", { object: model });
});
var XRHandJoint = (0, import_react4.forwardRef)(({ joint, children }, ref) => {
  return (0, import_jsx_runtime2.jsx)(XRSpace3, { ref, space: joint, children });
});

// node_modules/@react-three/xr/dist/pointer.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
function CombinedPointer2({ children }) {
  const pointer = (0, import_react5.useMemo)(() => new CombinedPointer(false), []);
  useSetupPointer(pointer);
  return (0, import_jsx_runtime3.jsx)(combinedPointerContext.Provider, { value: pointer, children });
}
function clearObject(object) {
  for (const key of Object.keys(object)) {
    delete object[key];
  }
}
function useGrabPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react5.useMemo)(() => ({}), []);
  clearObject(options);
  Object.assign(options, currentOptions);
  const store = useStore();
  const pointer = (0, import_react5.useMemo)(() => createGrabPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions?.makeDefault);
  return pointer;
}
function useRayPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react5.useMemo)(() => ({}), []);
  clearObject(options);
  Object.assign(options, currentOptions);
  const store = useStore();
  const pointer = (0, import_react5.useMemo)(() => createRayPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions?.makeDefault);
  return pointer;
}
function useLinesPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react5.useMemo)(() => ({}), []);
  clearObject(options);
  Object.assign(options, currentOptions);
  const store = useStore();
  const pointer = (0, import_react5.useMemo)(() => createLinesPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions?.makeDefault);
  return pointer;
}
function useTouchPointer(spaceRef, pointerState, currentOptions, pointerType) {
  const options = (0, import_react5.useMemo)(() => ({}), []);
  clearObject(options);
  Object.assign(options, currentOptions);
  const store = useStore();
  const pointer = (0, import_react5.useMemo)(() => createTouchPointer(() => store.getState().camera, spaceRef, pointerState, options, pointerType), [store, spaceRef, pointerState, options, pointerType]);
  useSetupPointer(pointer, currentOptions?.makeDefault);
  return pointer;
}
var PointerRayModel2 = (0, import_react5.forwardRef)((props, ref) => {
  const material = (0, import_react5.useMemo)(() => {
    const MaterialClass = props.materialClass ?? PointerRayMaterial;
    return new MaterialClass();
  }, [props.materialClass]);
  const internalRef = (0, import_react5.useRef)(null);
  (0, import_react5.useImperativeHandle)(ref, () => internalRef.current, []);
  useFrame(() => internalRef.current != null && updatePointerRayModel(internalRef.current, material, props.pointer, props));
  return (0, import_jsx_runtime3.jsx)("mesh", { matrixAutoUpdate: false, renderOrder: props.renderOrder ?? 2, ref: internalRef, material, children: (0, import_jsx_runtime3.jsx)("boxGeometry", {}) });
});
var PointerCursorModel2 = (0, import_react5.forwardRef)((props, ref) => {
  const material = (0, import_react5.useMemo)(() => {
    const MaterialClass = props.materialClass ?? PointerCursorMaterial;
    return new MaterialClass();
  }, [props.materialClass]);
  const internalRef = (0, import_react5.useRef)(null);
  const groupRef = (0, import_react5.useRef)(null);
  (0, import_react5.useImperativeHandle)(ref, () => internalRef.current, []);
  useFrame(() => internalRef.current != null && groupRef.current != null && updatePointerCursorModel(groupRef.current, internalRef.current, material, props.pointer, props));
  const scene = useThree((s) => s.scene);
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [(0, import_jsx_runtime3.jsx)("group", { ref: groupRef }), createPortal((0, import_jsx_runtime3.jsx)("mesh", { renderOrder: props.renderOrder ?? 1, ref: internalRef, matrixAutoUpdate: false, material, children: (0, import_jsx_runtime3.jsx)("planeGeometry", {}) }), scene)] });
});
function usePointerXRInputSourceEvents(pointer, inputSource, event, missingEvents) {
  const session = useXR((xr) => xr.session);
  (0, import_react5.useEffect)(() => {
    if (session == null) {
      return;
    }
    return bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents);
  }, [event, inputSource, pointer, session, missingEvents]);
}
function useSetupPointer(pointer, makeDefault = false) {
  const combinedPointer = (0, import_react5.useContext)(combinedPointerContext);
  if (combinedPointer == null) {
    throw new Error(`xr pointers can only be used inside the XR component`);
  }
  (0, import_react5.useEffect)(() => {
    const unregister = combinedPointer.register(pointer, makeDefault);
    return () => {
      unregister();
    };
  }, [combinedPointer, pointer, makeDefault]);
  (0, import_react5.useEffect)(() => {
    if (!(pointer instanceof Pointer)) {
      return;
    }
    return () => pointer.exit({ timeStamp: performance.now() });
  }, [pointer]);
}

// node_modules/@react-three/xr/dist/teleport.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function TeleportTarget({ children, onTeleport }) {
  const ref = (0, import_react6.useRef)(null);
  const teleportRef = (0, import_react6.useRef)(onTeleport);
  teleportRef.current = onTeleport;
  const store = useStore();
  (0, import_react6.useEffect)(() => {
    if (ref.current == null) {
      return;
    }
    return makeTeleportTarget(ref.current, () => store.getState().camera, (point, event) => teleportRef.current?.(point, event));
  }, [store]);
  return (0, import_jsx_runtime4.jsx)("group", { pointerEventsType: { allow: "teleport" }, ref, children });
}
var TeleportPointerRayModel2 = (0, import_react6.forwardRef)(({ pointer, linePoints, ...options }, ref) => {
  const mesh = (0, import_react6.useMemo)(() => new TeleportPointerRayModel(linePoints), [linePoints]);
  (0, import_react6.useImperativeHandle)(ref, () => mesh, [mesh]);
  mesh.options = options;
  useFrame(() => mesh.update(pointer));
  return (0, import_jsx_runtime4.jsx)("primitive", { object: mesh });
});

// node_modules/@react-three/xr/dist/default.js
function DefaultXRInputSourceGrabPointer(event, spaceType, options) {
  const state = (0, import_react7.useContext)(xrInputSourceStateContext);
  if (state == null) {
    throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);
  }
  const ref = (0, import_react7.useRef)(null);
  const pointer = useGrabPointer(ref, state, options);
  usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);
  const cursorModelOptions = options.cursorModel;
  return (0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: spaceType, children: cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) }) });
}
var DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, "select", "index-finger-tip");
var DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, "squeeze", "grip-space");
function DefaultXRInputSourceRayPointer(props) {
  const state = useXRInputSourceStateContext();
  const ref = (0, import_react7.useRef)(null);
  const pointer = useRayPointer(ref, state, props);
  usePointerXRInputSourceEvents(pointer, state.inputSource, "select", state.events);
  const rayModelOptions = props.rayModel;
  const cursorModelOptions = props.cursorModel;
  return (0, import_jsx_runtime5.jsxs)(XRSpace3, { ref, space: "target-ray-space", children: [rayModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerRayModel2, { pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) }), cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) })] });
}
function DefaultXRHandTouchPointer(props) {
  const state = useXRInputSourceStateContext("hand");
  const ref = (0, import_react7.useRef)(null);
  const pointer = useTouchPointer(ref, state, props);
  const cursorModelOptions = props.cursorModel;
  return (0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: state.inputSource.hand.get("index-finger-tip"), children: cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) }) });
}
function DefaultXRController(props) {
  const modelOptions = props.model;
  const grabPointerOptions = props.grabPointer;
  const rayPointerOptions = props.rayPointer;
  const teleportPointerOptions = props.teleportPointer ?? false;
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [modelOptions !== false && (0, import_jsx_runtime5.jsx)(import_react7.Suspense, { children: (0, import_jsx_runtime5.jsx)(XRControllerModel2, { ...spreadable(modelOptions) }) }), (0, import_jsx_runtime5.jsxs)(CombinedPointer2, { children: [grabPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) }), teleportPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) })] })] });
}
function DefaultXRHand(props) {
  const modelOptions = props.model;
  const grabPointerOptions = props.grabPointer;
  const rayPointerOptions = props.rayPointer;
  const touchPointerOptions = props.touchPointer;
  const teleportPointerOptions = props.teleportPointer ?? false;
  const rayPointerRayModelOptions = rayPointerOptions === false ? false : spreadable(rayPointerOptions)?.rayModel;
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [modelOptions !== false && (0, import_jsx_runtime5.jsx)(import_react7.Suspense, { children: (0, import_jsx_runtime5.jsx)(XRHandModel2, { ...spreadable(modelOptions) }) }), (0, import_jsx_runtime5.jsxs)(CombinedPointer2, { children: [grabPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } }), teleportPointerOptions !== false && (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) })] })] });
}
function DefaultXRTransientPointer(props) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...props, rayModel: false });
}
function DefaultXRGaze(props) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...props, rayModel: false });
}
function DefaultXRScreenInput(props) {
  return (0, import_jsx_runtime5.jsx)(DefaultXRInputSourceRayPointer, { ...props, cursorModel: false, rayModel: false });
}
function DefaultXRInputSourceTeleportPointer(props) {
  const state = (0, import_react7.useContext)(xrInputSourceStateContext);
  if (state == null) {
    throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);
  }
  const ref = (0, import_react7.useRef)(null);
  const groupRef = (0, import_react7.useRef)(null);
  const linePoints = (0, import_react7.useMemo)(() => createTeleportRayLine(), []);
  const pointer = useLinesPointer(groupRef, state, {
    ...props,
    linePoints,
    filter: buildTeleportTargetFilter(props)
  }, "teleport");
  usePointerXRInputSourceEvents(pointer, state.inputSource, "select", state.events);
  const rayModelOptions = props.rayModel;
  const cursorModelOptions = props.cursorModel;
  const scene = useThree((state2) => state2.scene);
  const cursorRef = (0, import_react7.useRef)(null);
  useFrame((_, delta) => {
    if (cursorRef.current != null) {
      cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;
    }
    const target = groupRef.current;
    const source = ref.current;
    if (target == null || source == null) {
      return;
    }
    syncTeleportPointerRayGroup(source, target, delta * 1e3);
  });
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [(0, import_jsx_runtime5.jsx)(XRSpace3, { ref, space: "target-ray-space" }), createPortal((0, import_jsx_runtime5.jsxs)("group", { ref: groupRef, children: [rayModelOptions !== false && (0, import_jsx_runtime5.jsx)(TeleportPointerRayModel2, { linePoints, pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) }), cursorModelOptions !== false && (0, import_jsx_runtime5.jsx)(PointerCursorModel2, { ref: cursorRef, pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) })] }), scene)] });
}
function spreadable(value) {
  if (value === true) {
    return void 0;
  }
  return value;
}

// node_modules/@react-three/xr/dist/hooks.js
var import_react8 = __toESM(require_react(), 1);
function useHover(ref, onChange) {
  let setHover;
  let hover;
  if (onChange == null) {
    const [_hover, _setHover] = (0, import_react8.useState)(false);
    setHover = _setHover;
    hover = _hover;
  } else {
    setHover = onChange;
  }
  (0, import_react8.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    const set = /* @__PURE__ */ new Set();
    const enter = (e) => {
      if (set.size === 0) {
        setHover(true, e);
      }
      set.add(e.pointerId);
    };
    const leave = (e) => {
      set.delete(e.pointerId);
      if (set.size === 0) {
        setHover(false, e);
      }
    };
    current.addEventListener("pointerenter", enter);
    current.addEventListener("pointerleave", leave);
    return () => {
      current.removeEventListener("pointerenter", enter);
      current.removeEventListener("pointerleave", leave);
    };
  }, [ref, setHover]);
  return hover;
}
function useXRSessionVisibilityState() {
  return useXR((xr) => xr.visibilityState);
}
function useInitRoomCapture() {
  return useXR((xr) => xr.session?.initiateRoomCapture?.bind(xr.session));
}
function useXRSessionModeSupported(mode, onError) {
  const onErrorRef = (0, import_react8.useRef)(onError);
  onErrorRef.current = onError;
  const [subscribe, getSnapshot] = (0, import_react8.useMemo)(() => {
    let sessionSupported = void 0;
    return [
      (onChange) => {
        let canceled = false;
        if (typeof navigator === "undefined" || navigator.xr == null) {
          sessionSupported = false;
          return () => {
          };
        }
        navigator.xr.isSessionSupported(mode).then((isSupported) => {
          sessionSupported = isSupported;
          if (canceled) {
            return;
          }
          onChange();
        }).catch((e) => {
          if (canceled) {
            return;
          }
          onErrorRef.current?.(e);
        });
        return () => canceled = true;
      },
      () => sessionSupported
    ];
  }, [mode]);
  return (0, import_react8.useSyncExternalStore)(subscribe, getSnapshot);
}
var useSessionModeSupported = useXRSessionModeSupported;
function useXRSessionFeatureEnabled(feature) {
  return useXR(({ session }) => session?.enabledFeatures?.includes(feature) ?? false);
}
var useSessionFeatureEnabled = useXRSessionFeatureEnabled;

// node_modules/@react-three/xr/dist/utils.js
var i = 0;
var map2 = /* @__PURE__ */ new Map();
function objectToKey(object) {
  let key = map2.get(object);
  if (key == null) {
    map2.set(object, key = i++);
  }
  return key;
}

// node_modules/@react-three/xr/dist/elements.js
function XRElements({ children }) {
  const referenceSpace = useXR((xr) => xr.originReferenceSpace);
  const origin = useXR((xr) => xr.origin);
  const visible = useXRSessionVisibilityState() === "visible";
  const store = useStore();
  const storeWithOriginAsScene = (0, import_react9.useMemo)(() => Object.assign({}, store, {
    getState() {
      return { ...store.getState(), scene: origin };
    }
  }), [origin, store]);
  if (origin == null || referenceSpace == null) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: reconciler.createPortal((0, import_jsx_runtime6.jsx)(context.Provider, { value: store, children: (0, import_jsx_runtime6.jsxs)(xrSpaceContext.Provider, { value: referenceSpace, children: [(0, import_jsx_runtime6.jsxs)("group", { matrixAutoUpdate: false, visible, children: [(0, import_jsx_runtime6.jsx)(XRControllers, {}), (0, import_jsx_runtime6.jsx)(XRHands, {}), (0, import_jsx_runtime6.jsx)(XRTransientPointers, {}), (0, import_jsx_runtime6.jsx)(XRGazes, {}), (0, import_jsx_runtime6.jsx)(XRScreenInputs, {})] }), children] }) }), storeWithOriginAsScene, null) });
}
function XRControllers() {
  const controllerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "controller"), shallow$1);
  let Implementation = useXR((xr) => xr.controller);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: controllerStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(XRSpace3, { space: "target-ray-space", children: (0, import_jsx_runtime6.jsx)(import_react9.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRController, { ...ResolvedImpl }) }) }) }, state.id);
  }) });
}
function XRHands() {
  const handStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "hand"), shallow$1);
  const Implementation = useXR((xr) => xr.hand);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: handStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(XRSpace3, { space: "target-ray-space", children: (0, import_jsx_runtime6.jsx)(import_react9.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRHand, { ...ResolvedImpl }) }) }) }, objectToKey(state));
  }) });
}
function XRTransientPointers() {
  const transientPointerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "transientPointer"), shallow$1);
  const Implementation = useXR((xr) => xr.transientPointer);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: transientPointerStates.map((state) => {
    const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});
    if (ResolvedImpl === false) {
      return null;
    }
    return (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(XRSpace3, { space: "target-ray-space", children: (0, import_jsx_runtime6.jsx)(import_react9.Suspense, { children: typeof ResolvedImpl === "function" ? (0, import_jsx_runtime6.jsx)(ResolvedImpl, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRTransientPointer, { ...ResolvedImpl }) }) }) }, objectToKey(state));
  }) });
}
function XRGazes() {
  const gazeStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "gaze"), shallow$1);
  const Implementation = useXR((xr) => xr.gaze);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: gazeStates.map((state) => {
    return (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(XRSpace3, { space: "target-ray-space", children: (0, import_jsx_runtime6.jsx)(import_react9.Suspense, { children: typeof Implementation === "function" ? (0, import_jsx_runtime6.jsx)(Implementation, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRGaze, { ...spreadable2(Implementation) }) }) }) }, objectToKey(state));
  }) });
}
function XRScreenInputs() {
  const screenInputStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === "screenInput"), shallow$1);
  const Implementation = useXR((xr) => xr.screenInput);
  if (Implementation === false) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: screenInputStates.map((state) => {
    return (0, import_jsx_runtime6.jsx)(xrInputSourceStateContext.Provider, { value: state, children: (0, import_jsx_runtime6.jsx)(XRSpace3, { space: "target-ray-space", children: (0, import_jsx_runtime6.jsx)(import_react9.Suspense, { children: typeof Implementation === "function" ? (0, import_jsx_runtime6.jsx)(Implementation, {}) : (0, import_jsx_runtime6.jsx)(DefaultXRScreenInput, { ...spreadable2(Implementation) }) }) }) }, objectToKey(state));
  }) });
}
function spreadable2(value) {
  if (value === true) {
    return void 0;
  }
  return value;
}

// node_modules/@react-three/xr/dist/xr.js
function createXRStore2(options) {
  return createXRStore(options);
}
function XR({ children, store }) {
  store.setWebXRManager(useThree((s) => s.gl.xr));
  const rootStore = useStore();
  (0, import_react10.useEffect)(() => {
    let initialCamera;
    return store.subscribe((state, prevState) => {
      if (state.session === prevState.session) {
        return;
      }
      if (state.session != null) {
        const { camera, gl } = rootStore.getState();
        initialCamera = camera;
        rootStore.setState({ camera: gl.xr.getCamera() });
        return;
      }
      if (initialCamera == null) {
        return;
      }
      rootStore.setState({ camera: initialCamera });
    });
  }, [rootStore, store]);
  useFrame((state, _delta, frame) => store.onBeforeFrame(state.scene, state.camera, frame), -1e3);
  useFrame(() => store.onBeforeRender());
  return (0, import_jsx_runtime7.jsx)(xrContext.Provider, { value: store, children: (0, import_jsx_runtime7.jsxs)(RootCombinedPointer, { children: [(0, import_jsx_runtime7.jsx)(XRElements, {}), children] }) });
}
function NotInXR({ children }) {
  const emptyStore = (0, import_react10.useMemo)(() => createXRStore2(), []);
  return (0, import_jsx_runtime7.jsx)(xrContext.Provider, { value: emptyStore, children });
}
function RootCombinedPointer({ children }) {
  const store = useXRStore();
  const pointer = (0, import_react10.useMemo)(() => new CombinedPointer(true), []);
  (0, import_react10.useEffect)(() => setupSyncIsVisible(store, (visible) => pointer.setEnabled(visible, { timeStamp: performance.now() })), [store, pointer]);
  useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);
  return (0, import_jsx_runtime7.jsx)(combinedPointerContext.Provider, { value: pointer, children });
}
function useXRStore() {
  const store = (0, import_react10.useContext)(xrContext);
  if (store == null) {
    throw new Error(`XR features can only be used inside the <XR> component`);
  }
  return store;
}
function UNSAFE_useXRStore() {
  const store = (0, import_react10.useContext)(xrContext);
  return store;
}
function useXR(selector = (state) => state, equalityFn) {
  return useStore2(useXRStore(), selector, equalityFn);
}

// node_modules/@react-three/xr/dist/input.js
function useXRInputSourceStates() {
  return useXR((xr) => xr.inputSourceStates);
}
function useXRInputSourceState(type, handedness) {
  return useXR((s) => s.inputSourceStates.find((state) => state.type === type && (handedness == null || state.inputSource.handedness === handedness)));
}
function useXRInputSourceStateContext(type) {
  const state = (0, import_react11.useContext)(xrInputSourceStateContext);
  if (state == null) {
    throw new Error(`useXRInputSourceStateContext() can only be used inside the xr store config`);
  }
  if (type != null && state.type != type) {
    throw new Error(`useXRInputSourceStateContext(${type}) can not be used inside a component for input type "${state.type}"`);
  }
  return state;
}
function useXRInputSourceEvent(inputSource, event, fn, deps) {
  const session = useXR((xr) => xr.session);
  (0, import_react11.useEffect)(() => {
    if (session == null || inputSource == null) {
      return;
    }
    return bindXRInputSourceEvent(session, inputSource, event, fn);
  }, [event, inputSource, session, ...deps]);
}

// node_modules/@react-three/xr/dist/space.js
var XRSpace3 = (0, import_react12.forwardRef)(({ space, children }, ref) => {
  const internalRef = (0, import_react12.useRef)(null);
  const resolvedSpace = typeof space === "string" ? useXRSpace(space) : space;
  (0, import_react12.useImperativeHandle)(ref, () => internalRef.current, []);
  useApplyXRSpaceMatrix(internalRef, resolvedSpace);
  const setRef = (0, import_react12.useCallback)((group) => {
    if (group != null) {
      group.transformReady = false;
      group.visible = false;
    }
    internalRef.current = group;
  }, []);
  return (0, import_jsx_runtime8.jsx)("group", { xrSpace: resolvedSpace, matrixAutoUpdate: false, ref: setRef, children: resolvedSpace && (0, import_jsx_runtime8.jsx)(xrSpaceContext.Provider, { value: resolvedSpace, children }) });
});
function useXRSpace(type) {
  switch (type) {
    case "grip-space":
      return useXRInputSourceStateContext().inputSource.gripSpace;
    case "target-ray-space":
      return useXRInputSourceStateContext().inputSource.targetRaySpace;
    case "wrist":
    case "thumb-metacarpal":
    case "thumb-phalanx-proximal":
    case "thumb-phalanx-distal":
    case "thumb-tip":
    case "index-finger-metacarpal":
    case "index-finger-phalanx-proximal":
    case "index-finger-phalanx-intermediate":
    case "index-finger-phalanx-distal":
    case "index-finger-tip":
    case "middle-finger-metacarpal":
    case "middle-finger-phalanx-proximal":
    case "middle-finger-phalanx-intermediate":
    case "middle-finger-phalanx-distal":
    case "middle-finger-tip":
    case "ring-finger-metacarpal":
    case "ring-finger-phalanx-proximal":
    case "ring-finger-phalanx-intermediate":
    case "ring-finger-phalanx-distal":
    case "ring-finger-tip":
    case "pinky-finger-metacarpal":
    case "pinky-finger-phalanx-proximal":
    case "pinky-finger-phalanx-intermediate":
    case "pinky-finger-phalanx-distal":
    case "pinky-finger-tip":
      return useXRInputSourceStateContext("hand").inputSource.hand.get(type);
    case "root":
    case "hips":
    case "spine-lower":
    case "spine-middle":
    case "spine-upper":
    case "chest":
    case "neck":
    case "head":
    case "left-shoulder":
    case "left-scapula":
    case "left-arm-upper":
    case "left-arm-lower":
    case "left-hand-wrist-twist":
    case "right-shoulder":
    case "right-scapula":
    case "right-arm-upper":
    case "right-arm-lower":
    case "right-hand-wrist-twist":
    case "left-hand-palm":
    case "left-hand-wrist":
    case "left-hand-thumb-metacarpal":
    case "left-hand-thumb-phalanx-proximal":
    case "left-hand-thumb-phalanx-distal":
    case "left-hand-thumb-tip":
    case "left-hand-index-metacarpal":
    case "left-hand-index-phalanx-proximal":
    case "left-hand-index-phalanx-intermediate":
    case "left-hand-index-phalanx-distal":
    case "left-hand-index-tip":
    case "left-hand-middle-metacarpal":
    case "left-hand-middle-phalanx-proximal":
    case "left-hand-middle-phalanx-intermediate":
    case "left-hand-middle-phalanx-distal":
    case "left-hand-middle-tip":
    case "left-hand-ring-metacarpal":
    case "left-hand-ring-phalanx-proximal":
    case "left-hand-ring-phalanx-intermediate":
    case "left-hand-ring-phalanx-distal":
    case "left-hand-ring-tip":
    case "left-hand-little-metacarpal":
    case "left-hand-little-phalanx-proximal":
    case "left-hand-little-phalanx-intermediate":
    case "left-hand-little-phalanx-distal":
    case "left-hand-little-tip":
    case "right-hand-palm":
    case "right-hand-wrist":
    case "right-hand-thumb-metacarpal":
    case "right-hand-thumb-phalanx-proximal":
    case "right-hand-thumb-phalanx-distal":
    case "right-hand-thumb-tip":
    case "right-hand-index-metacarpal":
    case "right-hand-index-phalanx-proximal":
    case "right-hand-index-phalanx-intermediate":
    case "right-hand-index-phalanx-distal":
    case "right-hand-index-tip":
    case "right-hand-middle-metacarpal":
    case "right-hand-middle-phalanx-proximal":
    case "right-hand-middle-phalanx-intermediate":
    case "right-hand-middle-phalanx-distal":
    case "right-hand-middle-tip":
    case "right-hand-ring-metacarpal":
    case "right-hand-ring-phalanx-proximal":
    case "right-hand-ring-phalanx-intermediate":
    case "right-hand-ring-phalanx-distal":
    case "right-hand-ring-tip":
    case "right-hand-little-metacarpal":
    case "right-hand-little-phalanx-proximal":
    case "right-hand-little-phalanx-intermediate":
    case "right-hand-little-phalanx-distal":
    case "right-hand-little-tip":
    case "left-upper-leg":
    case "left-lower-leg":
    case "left-foot-ankle-twist":
    case "left-foot-ankle":
    case "left-foot-subtalar":
    case "left-foot-transverse":
    case "left-foot-ball":
    case "right-upper-leg":
    case "right-lower-leg":
    case "right-foot-ankle-twist":
    case "right-foot-ankle":
    case "right-foot-subtalar":
    case "right-foot-transverse":
    case "right-foot-ball":
      return useXR((state) => state.body)?.get(type);
  }
  if (type == null) {
    const context2 = (0, import_react12.useContext)(xrSpaceContext);
    if (context2 == null) {
      throw new Error(`XR objects must be placed inside the XROrigin`);
    }
    return context2;
  }
  const [referenceSpace, setReferenceSpace] = (0, import_react12.useState)(void 0);
  const session = useXR((xr) => xr.session);
  (0, import_react12.useEffect)(() => {
    if (session == null) {
      return;
    }
    let aborted = false;
    session.requestReferenceSpace(type).then((space) => {
      if (aborted) {
        return;
      }
      setReferenceSpace(space);
    });
    return () => void (aborted = true);
  }, [session, type]);
  return referenceSpace;
}
function useGetXRSpaceMatrix(space) {
  const localReferenceSpace = (0, import_react12.useContext)(xrSpaceContext);
  const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);
  return (0, import_react12.useMemo)(() => space == null || referenceSpace == null ? void 0 : createGetXRSpaceMatrix(space, referenceSpace), [space, referenceSpace]);
}
function useApplyXRSpaceMatrix(ref, space, onFrame) {
  const getXRSpaceMatrix = useGetXRSpaceMatrix(space);
  useFrame((state, delta, frame) => {
    if (ref.current != null) {
      ref.current.visible = ref.current.transformReady = getXRSpaceMatrix?.(ref.current.matrix, frame) ?? false;
    }
    onFrame?.(state, delta, frame);
  }, -100);
}

// node_modules/@react-three/xr/dist/mesh.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var XRMeshModel = (0, import_react13.forwardRef)(({ mesh, ...rest }, ref) => {
  const geometry = useXRMeshGeometry(mesh);
  return (0, import_jsx_runtime9.jsx)("mesh", { ref, geometry, ...rest });
});
function useXRMeshes(semanticLabel) {
  const meshes = useXR((xr) => xr.detectedMeshes);
  return (0, import_react13.useMemo)(() => semanticLabel == null ? meshes : meshes.filter((mesh) => mesh.semanticLabel === semanticLabel), [meshes, semanticLabel]);
}
function useXRMeshGeometry(mesh, disposeBuffer = true) {
  const [geometry, setGeometry] = (0, import_react13.useState)(updateXRMeshGeometry(mesh, void 0));
  useFrame(() => setGeometry((geometry2) => updateXRMeshGeometry(mesh, geometry2)));
  (0, import_react13.useEffect)(() => {
    if (!disposeBuffer) {
      return;
    }
    return () => geometry.dispose();
  }, [geometry]);
  return geometry;
}

// node_modules/@react-three/xr/dist/plane.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var XRPlaneModel = (0, import_react14.forwardRef)(({ plane, ...rest }, ref) => {
  const geometry = useXRPlaneGeometry(plane);
  return (0, import_jsx_runtime10.jsx)("mesh", { ref, geometry, ...rest });
});
function useXRPlanes(semanticLabel) {
  const planes = useXR((xr) => xr.detectedPlanes);
  return (0, import_react14.useMemo)(() => semanticLabel == null ? planes : planes.filter((plane) => plane.semanticLabel === semanticLabel), [planes, semanticLabel]);
}
function useXRPlaneGeometry(plane, disposeBuffer = true) {
  const [geometry, setGeometry] = (0, import_react14.useState)(updateXRPlaneGeometry(plane, void 0));
  useFrame(() => setGeometry((geometry2) => updateXRPlaneGeometry(plane, geometry2)));
  (0, import_react14.useEffect)(() => {
    if (!disposeBuffer) {
      return;
    }
    return () => geometry.dispose();
  }, [geometry]);
  return geometry;
}

// node_modules/@react-three/xr/dist/guard/facing-camera.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
function useIsFacingCamera(ref, set, direction, angle) {
  const camera = useThree((state) => state.camera);
  useFrame(() => {
    if (ref.current == null) {
      return;
    }
    set(isFacingCamera(camera, ref.current, direction, angle));
  });
}
function ShowIfFacingCamera({ children, direction, angle = Math.PI / 2 }) {
  const ref = (0, import_react15.useRef)(null);
  useIsFacingCamera(ref, (visible) => {
    if (ref.current == null) {
      return;
    }
    ref.current.visible = visible;
  }, direction, angle);
  return (0, import_jsx_runtime11.jsx)("group", { ref, children });
}
function IfFacingCamera({ children, direction, angle = Math.PI / 2 }) {
  const ref = (0, import_react15.useRef)(null);
  const [show, setShow] = (0, import_react15.useState)(false);
  useIsFacingCamera(ref, setShow, direction, angle);
  return show ? (0, import_jsx_runtime11.jsx)(import_jsx_runtime11.Fragment, { children }) : null;
}

// node_modules/@react-three/xr/dist/guard/session-mode.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
function useIsInSessionMode(allow, deny) {
  const mode = useXR((state) => state.mode);
  if (deny != null) {
    return Array.isArray(deny) ? !deny.includes(mode) : deny != mode;
  }
  if (allow != null) {
    return Array.isArray(allow) ? allow.includes(mode) : allow === mode;
  }
  return mode !== null;
}
function ShowIfInSessionMode({ children, allow, deny }) {
  const visible = useIsInSessionMode(allow, deny);
  return (0, import_jsx_runtime12.jsx)("group", { visible, children });
}
function IfInSessionMode({ children, allow, deny }) {
  const visible = useIsInSessionMode(allow, deny);
  return visible ? (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children }) : null;
}

// node_modules/@react-three/xr/dist/guard/session-supported.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function ShowIfSessionModeSupported({ children, mode }) {
  const supported = useXRSessionModeSupported(mode);
  return (0, import_jsx_runtime13.jsx)("group", { visible: supported, children });
}
function IfSessionModeSupported({ children, mode }) {
  const supported = useXRSessionModeSupported(mode);
  if (!supported) {
    return null;
  }
  return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children });
}

// node_modules/@react-three/xr/dist/guard/focus.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function ShowIfSessionVisible({ children }) {
  const state = useXRSessionVisibilityState();
  return (0, import_jsx_runtime14.jsx)("group", { visible: state == null || state === "visible", children });
}
function IfSessionVisible({ children }) {
  const state = useXRSessionVisibilityState();
  if (state != "visible" && state != null) {
    return null;
  }
  return (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children });
}

// node_modules/@react-three/xr/dist/origin.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var XROrigin = (0, import_react16.forwardRef)(({ children, disabled, ...props }, ref) => {
  const xrCamera = useThree((s) => s.gl.xr.getCamera());
  const internalRef = (0, import_react16.useRef)(null);
  const referenceSpace = useXR((xr) => xr.originReferenceSpace);
  (0, import_react16.useImperativeHandle)(ref, () => internalRef.current, []);
  (0, import_react16.useEffect)(() => {
    const group = internalRef.current;
    if (group == null || disabled) {
      return;
    }
    group.add(xrCamera);
    return () => void group.remove(xrCamera);
  }, [disabled, xrCamera]);
  return (0, import_jsx_runtime15.jsx)("group", { ref: internalRef, ...props, children: (0, import_jsx_runtime15.jsx)(xrSpaceContext.Provider, { value: referenceSpace, children }) });
});

// node_modules/@react-three/xr/dist/hit-test.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
function useXRHitTestSource(relativeTo, trackableType) {
  const [source, setState] = (0, import_react17.useState)();
  useCreateXRHitTestSource(relativeTo, trackableType, setState);
  return source;
}
function useXRHitTest(fn, relativeTo, trackableType) {
  const sourceRef = (0, import_react17.useRef)(void 0);
  useCreateXRHitTestSource(relativeTo, trackableType, (0, import_react17.useCallback)((source) => sourceRef.current = source, []));
  useFrame((_s, _d, frame) => {
    if (fn == null || frame == null || sourceRef.current == null) {
      return;
    }
    fn(frame.getHitTestResults(sourceRef.current.source), sourceRef.current.getWorldMatrix);
  });
}
function useCreateXRHitTestSource(relativeTo, trackableType, onLoad) {
  const store = useXRStore();
  const session = useStore2(store, (s) => s.session);
  (0, import_react17.useEffect)(() => {
    if (session == null) {
      return;
    }
    let storedResult;
    let cancelled = false;
    const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === "string" ? relativeTo : relativeTo?.current;
    if (relativeToResolved == null) {
      return;
    }
    createXRHitTestSource(store, session, relativeToResolved, trackableType).then((result) => {
      if (cancelled) {
        return;
      }
      storedResult = result;
      onLoad(result);
    });
    return () => {
      onLoad(void 0);
      cancelled = true;
      storedResult?.source.cancel();
    };
  }, [session, store, relativeTo, trackableType, onLoad]);
}
function useXRRequestHitTest() {
  const store = useXRStore();
  return (0, import_react17.useCallback)((relativeTo, trackableType) => {
    const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === "string" ? relativeTo : relativeTo.current;
    if (relativeToResolved == null) {
      return;
    }
    return requestXRHitTest(store, relativeToResolved, trackableType);
  }, [store]);
}
var XRHitTest = (0, import_react17.forwardRef)(({ trackableType, onResults, space, ...rest }, ref) => {
  const internalRef = (0, import_react17.useRef)(null);
  (0, import_react17.useImperativeHandle)(ref, () => internalRef.current);
  useXRHitTest(onResults, space ?? internalRef, trackableType);
  return (0, import_jsx_runtime16.jsx)("group", { ...rest, ref: internalRef });
});

// node_modules/@react-three/xr/dist/anchor.js
var import_react18 = __toESM(require_react(), 1);
function useRequestXRAnchor() {
  const store = useXRStore();
  return (0, import_react18.useMemo)(() => requestXRAnchor.bind(null, store), [store]);
}
function useXRAnchor() {
  const [anchor, setAnchor] = (0, import_react18.useState)(void 0);
  const cleanup = (0, import_react18.useRef)(() => {
  });
  const store = useXRStore();
  const create2 = (0, import_react18.useCallback)(async (options) => {
    cleanup.current?.();
    cleanup.current = void 0;
    let cancelled = false;
    cleanup.current = () => cancelled = true;
    const anchor2 = await requestXRAnchor(store, options);
    if (cancelled) {
      anchor2?.delete();
      return void 0;
    }
    cleanup.current = () => anchor2?.delete();
    setAnchor(anchor2);
    return anchor2;
  }, [store]);
  (0, import_react18.useEffect)(() => () => void cleanup.current?.(), []);
  return [anchor, create2];
}

// node_modules/@react-three/xr/dist/dom-overlay.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);
var XRDomOverlay = (0, import_react19.forwardRef)((props, ref) => {
  const domOverlayRoot = useXR((xr) => xr.domOverlayRoot);
  const { In, Out } = (0, import_react19.useMemo)(tunnel, []);
  (0, import_react19.useEffect)(() => {
    if (domOverlayRoot == null) {
      return;
    }
    const root = (0, import_client.createRoot)(domOverlayRoot);
    root.render((0, import_jsx_runtime17.jsx)(Out, {}));
    return () => root.unmount();
  }, [domOverlayRoot, Out]);
  return (0, import_jsx_runtime17.jsx)(In, { children: (0, import_jsx_runtime17.jsx)("div", { ...props, ref }) });
});

// node_modules/@react-three/xr/dist/layer.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
import { OrthographicCamera, PerspectiveCamera, Raycaster, Scene, Vector2 as Vector23, Vector3 as Vector39, Vector4, WebGLRenderTarget as WebGLRenderTarget3 } from "three";
function XRLayer({ src, pixelWidth = 1024, pixelHeight = 1024, dpr = 1, renderPriority = 0, children, customRender, ...props }) {
  const [hasSize, setHasSize] = (0, import_react20.useState)(false);
  const ref = (0, import_react20.useRef)(null);
  const renderTargetRef = (0, import_react20.useRef)(void 0);
  const layerEntryRef = (0, import_react20.useRef)(void 0);
  (0, import_react20.useEffect)(() => {
    setHasSize(false);
    let aborted = false;
    waitForXRLayerSrcSize(src).then(() => !aborted && setHasSize(true));
    return () => void (aborted = true);
  }, [src]);
  const layersEnabled = useXRSessionFeatureEnabled("layers");
  const geometry = (0, import_react20.useMemo)(() => createXRLayerGeometry(props.shape ?? "quad", {
    centralAngle: props.centralAngle,
    centralHorizontalAngle: props.centralHorizontalAngle,
    lowerVerticalAngle: props.lowerVerticalAngle,
    upperVerticalAngle: props.upperVerticalAngle
  }), [props.centralAngle, props.centralHorizontalAngle, props.lowerVerticalAngle, props.shape, props.upperVerticalAngle]);
  const store = useLayerStore(pixelWidth, pixelHeight, dpr);
  useForwardEvents(store, ref, [hasSize, layersEnabled]);
  if (!hasSize) {
    return null;
  }
  return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [src == null && (0, import_jsx_runtime18.jsx)(ChildrenToRenderTarget, { customRender, store, renderPriority, renderTargetRef, layerEntryRef: layersEnabled ? layerEntryRef : void 0, children }), layersEnabled ? (0, import_jsx_runtime18.jsx)(XRLayerImplementation, { renderTargetRef, layerEntryRef, pixelWidth, pixelHeight, dpr, ref, ...props, src, geometry }) : (0, import_jsx_runtime18.jsx)(FallbackXRLayerImplementation, { renderTargetRef, ref, ...props, src, pixelWidth, pixelHeight, dpr, geometry })] });
}
var XRLayerImplementation = (0, import_react20.forwardRef)(({ src, shape, colorFormat, depthFormat, layout, mipLevels, renderOrder = 0, blendTextureSourceAlpha, centralAngle, centralHorizontalAngle, chromaticAberrationCorrection, lowerVerticalAngle, quality, upperVerticalAngle, invertStereo, pixelWidth, pixelHeight, dpr, renderTargetRef, layerEntryRef, ...props }, ref) => {
  const internalRef = (0, import_react20.useRef)(null);
  const renderer = useThree((state) => state.gl);
  const store = useXRStore();
  const layerProperties = {
    blendTextureSourceAlpha,
    centralAngle,
    centralHorizontalAngle,
    chromaticAberrationCorrection,
    lowerVerticalAngle,
    quality,
    upperVerticalAngle
  };
  const layerPropertiesRef = (0, import_react20.useRef)(layerProperties);
  layerPropertiesRef.current = layerProperties;
  const renderOrderRef = (0, import_react20.useRef)(renderOrder);
  renderOrderRef.current = renderOrder;
  const originReferenceSpace = useXR((s) => s.originReferenceSpace);
  (0, import_react20.useEffect)(() => {
    if (internalRef.current == null || originReferenceSpace == null) {
      return;
    }
    const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));
    const layer = createXRLayer(resolvedSrc, store.getState(), originReferenceSpace, renderer.xr, internalRef.current, {
      colorFormat,
      depthFormat,
      invertStereo,
      layout,
      mipLevels,
      shape
    }, layerPropertiesRef.current);
    if (layer == null) {
      return;
    }
    const layerEntry = layerEntryRef.current = {
      layer,
      renderOrder: renderOrderRef.current,
      object3D: internalRef.current
    };
    store.addLayerEntry(layerEntry);
    if (resolvedSrc instanceof HTMLVideoElement || resolvedSrc instanceof WebGLRenderTarget3) {
      return () => {
        store.removeLayerEntry(layerEntry);
        layer.destroy();
      };
    }
    const cleanupXRImageLayer = setupXRImageLayer(renderer, store, layer, resolvedSrc);
    return () => {
      store.removeLayerEntry(layerEntry);
      cleanupXRImageLayer();
      layer.destroy();
    };
  }, [
    originReferenceSpace,
    colorFormat,
    depthFormat,
    invertStereo,
    layerEntryRef,
    layout,
    mipLevels,
    pixelHeight,
    pixelWidth,
    dpr,
    renderTargetRef,
    renderer,
    shape,
    src,
    store
  ]);
  if (layerEntryRef.current != null) {
    layerEntryRef.current.renderOrder = renderOrder;
  }
  if (layerEntryRef.current != null) {
    updateXRLayerProperties(layerEntryRef.current.layer, layerPropertiesRef.current);
  }
  useFrame(() => {
    if (layerEntryRef.current == null || internalRef.current == null) {
      return;
    }
    updateXRLayerTransform(store.getState(), layerEntryRef.current.layer, layerPropertiesRef.current.centralAngle, internalRef.current);
  });
  (0, import_react20.useImperativeHandle)(ref, () => internalRef.current, []);
  return (0, import_jsx_runtime18.jsx)("mesh", { ...props, renderOrder: -Infinity, ref: internalRef, children: (0, import_jsx_runtime18.jsx)("meshBasicMaterial", { colorWrite: false }) });
});
var FallbackXRLayerImplementation = (0, import_react20.forwardRef)(({ src, renderTargetRef, dpr, renderOrder, pixelWidth, pixelHeight, ...props }, ref) => {
  const materialRef = (0, import_react20.useRef)(null);
  (0, import_react20.useEffect)(() => {
    if (materialRef.current == null) {
      return;
    }
    const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));
    const texture = getXRLayerSrcTexture(resolvedSrc);
    materialRef.current.map = texture;
    materialRef.current.needsUpdate = true;
    return () => {
      if (resolvedSrc instanceof WebGLRenderTarget3) {
        resolvedSrc.dispose();
        return;
      }
      texture.dispose();
    };
  }, [src, pixelWidth, pixelHeight, dpr, renderTargetRef]);
  return (0, import_jsx_runtime18.jsx)("mesh", { ref, ...props, children: (0, import_jsx_runtime18.jsx)("meshBasicMaterial", { ref: materialRef, toneMapped: false }) });
});
function useForwardEvents(store, ref, deps) {
  (0, import_react20.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    let cleanup;
    const update = (state, prevState) => {
      if (state.camera === prevState?.camera && state.scene === prevState.scene) {
        return;
      }
      cleanup?.();
      const { destroy, update: update2 } = forwardObjectEvents(current, () => state.camera, state.scene);
      const cleanupUpdate = addEffect(update2);
      cleanup = () => {
        destroy();
        cleanupUpdate();
      };
    };
    update(store.getState());
    const unsubscribe = store.subscribe(update);
    return () => {
      unsubscribe();
      cleanup?.();
    };
  }, [store, ref, ...deps]);
}
var privateKeys = [
  "set",
  "get",
  "setSize",
  "setFrameloop",
  "setDpr",
  "events",
  "invalidate",
  "advance",
  "size",
  "viewport"
];
function useLayerStore(width, height, dpr) {
  const previousRoot = useStore();
  const layerStore = (0, import_react20.useMemo)(() => {
    let previousState = previousRoot.getState();
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    camera.position.set(0, 0, 5);
    const pointer = new Vector23();
    let ownState = {
      events: { enabled: false, priority: 0 },
      size: { width: 1, height: 1, left: 0, top: 0 },
      camera,
      scene: new Scene(),
      raycaster: new Raycaster(),
      pointer,
      mouse: pointer,
      previousRoot
    };
    const store = create((innerSet, get) => {
      const merge = () => {
        const result = {};
        for (const key in previousState) {
          if (privateKeys.includes(key)) {
            continue;
          }
          result[key] = previousState[key];
        }
        return Object.assign(result, ownState, {
          events: { ...previousState.events, ...ownState.events },
          viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector39(), ownState.size))
        });
      };
      const update = () => innerSet(merge());
      return {
        ...previousState,
        // Set and get refer to this root-state
        set(newOwnState) {
          if (typeof newOwnState === "function") {
            newOwnState = newOwnState(get());
          }
          Object.assign(ownState, newOwnState);
          update();
        },
        setPreviousState(prevState) {
          previousState = prevState;
          update();
        },
        get,
        setEvents() {
        },
        ...merge()
      };
    });
    return Object.assign(store, {
      setState(state) {
        store.getState().set(state);
      }
    });
  }, [previousRoot]);
  (0, import_react20.useEffect)(() => previousRoot.subscribe(layerStore.getState().setPreviousState), [previousRoot, layerStore]);
  (0, import_react20.useEffect)(() => {
    const viewport = {
      factor: 1,
      distance: 0,
      dpr,
      initialDpr: dpr,
      left: 0,
      top: 0,
      getCurrentViewport: () => viewport,
      width,
      height,
      aspect: width / height
    };
    layerStore.setState({
      size: { width, height, top: 0, left: 0 },
      viewport
    });
  }, [width, height, dpr, layerStore, previousRoot]);
  return layerStore;
}
var v4Helper = new Vector4();
function getSize(target) {
  this.getViewport(v4Helper);
  target.x = v4Helper.z - v4Helper.x;
  target.y = v4Helper.w - v4Helper.y;
  return target;
}
var viewportHelper = new Vector4();
function ChildrenToRenderTarget({ renderPriority, children, layerEntryRef, renderTargetRef, store, customRender }) {
  (0, import_react20.useEffect)(() => {
    const update = (state, prevState) => {
      const { size, camera } = state;
      if (camera instanceof OrthographicCamera) {
        camera.left = size.width / -2;
        camera.right = size.width / 2;
        camera.top = size.height / 2;
        camera.bottom = size.height / -2;
      } else {
        camera.aspect = size.width / size.height;
      }
      if (size !== prevState?.size || camera !== prevState.camera) {
        camera.updateProjectionMatrix();
        camera.updateMatrixWorld();
      }
    };
    update(store.getState());
    return store.subscribe(update);
  }, [store]);
  let oldAutoClear;
  let oldXrEnabled;
  let oldIsPresenting;
  let oldRenderTarget;
  let oldGetDrawingBufferSize;
  let oldGetSize;
  useFrame((_, delta, frame) => {
    if (renderTargetRef.current == null || layerEntryRef != null && (layerEntryRef.current == null || frame == null)) {
      return;
    }
    const state = store.getState();
    const { gl, scene, camera } = state;
    oldAutoClear = gl.autoClear;
    oldXrEnabled = gl.xr.enabled;
    oldIsPresenting = gl.xr.isPresenting;
    oldRenderTarget = gl.getRenderTarget();
    oldGetSize = gl.getSize;
    oldGetDrawingBufferSize = gl.getDrawingBufferSize;
    gl.getViewport(viewportHelper);
    gl.autoClear = true;
    gl.xr.enabled = false;
    gl.xr.isPresenting = false;
    const renderTarget = renderTargetRef.current;
    gl.setViewport(0, 0, renderTarget.width, renderTarget.height);
    gl.getSize = getSize;
    gl.getDrawingBufferSize = getSize;
    setXRLayerRenderTarget(gl, renderTarget, layerEntryRef?.current, frame);
    if (customRender != null) {
      customRender(renderTarget, state, delta, frame);
    } else {
      gl.render(scene, camera);
    }
    gl.setRenderTarget(oldRenderTarget);
    gl.setViewport(viewportHelper);
    gl.autoClear = oldAutoClear;
    gl.xr.enabled = oldXrEnabled;
    gl.xr.isPresenting = oldIsPresenting;
    gl.getSize = oldGetSize;
    gl.getDrawingBufferSize = oldGetDrawingBufferSize;
  }, renderPriority);
  return (0, import_jsx_runtime18.jsx)(import_jsx_runtime18.Fragment, { children: reconciler.createPortal((0, import_jsx_runtime18.jsx)(context.Provider, { value: store, children }), store, null) });
}

// node_modules/@react-three/xr/dist/controller-locomotion.js
var import_react21 = __toESM(require_react(), 1);
function useXRControllerLocomotion(target, translationOptions = {}, rotationOptions = {}, translationControllerHand = "left") {
  const store = useXRStore();
  const update = (0, import_react21.useMemo)(() => createXRControllerLocomotionUpdate(), []);
  useFrame((state, delta, frame) => update(typeof target === "function" ? target : target.current, store, state.camera, delta, translationOptions, rotationOptions, translationControllerHand, delta, state, frame));
}

// node_modules/@react-three/xr/dist/events.js
var import_react22 = __toESM(require_react(), 1);
function PointerEvents({ batchEvents, clickThesholdMs, clickThresholdMs, contextMenuButton, customSort, dblClickThresholdMs, filter, forwardPointerCapture, intersectEveryFrame, pointerTypePrefix }) {
  const domElement = useThree((s) => s.gl.domElement);
  const alwaysRendering = useThree((s) => s.frameloop === "always");
  const camera = useThree((s) => s.camera);
  const scene = useThree((s) => s.scene);
  (0, import_react22.useEffect)(() => {
    const { destroy, update } = forwardHtmlEvents(domElement, () => camera, scene, {
      batchEvents: batchEvents ?? alwaysRendering,
      clickThesholdMs,
      clickThresholdMs,
      contextMenuButton,
      customSort,
      dblClickThresholdMs,
      filter,
      forwardPointerCapture,
      intersectEveryFrame,
      pointerTypePrefix
    });
    const cleanupUpdate = addEffect(update);
    return () => {
      cleanupUpdate();
      destroy();
    };
  }, [
    domElement,
    camera,
    scene,
    alwaysRendering,
    batchEvents,
    clickThresholdMs,
    clickThesholdMs,
    contextMenuButton,
    customSort,
    dblClickThresholdMs,
    filter,
    forwardPointerCapture,
    intersectEveryFrame,
    pointerTypePrefix
  ]);
  return null;
}
var noEvents = () => ({ enabled: false, priority: 0 });

// node_modules/@react-three/xr/dist/deprecated/button.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var XRButton = (0, import_react23.forwardRef)(({ store, mode, onError, children, ...props }, ref) => {
  const session = useStore2(store, (xr) => xr.session);
  const supported = useXRSessionModeSupported(mode, onError);
  return (0, import_jsx_runtime19.jsx)("button", { ref, ...props, onClick: () => session != null ? session.end() : store.enterXR(mode).catch(onError), children: typeof children === "function" ? children(supported ? session != null ? "entered" : "exited" : "unsupported") : children });
});
var ARButton = (0, import_react23.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime19.jsx)(XRButton, { ref, mode: "immersive-ar", ...props });
});
var VRButton = (0, import_react23.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime19.jsx)(XRButton, { ref, mode: "immersive-vr", ...props });
});

// node_modules/@react-three/xr/dist/deprecated/hooks.js
var import_react24 = __toESM(require_react(), 1);
var eventTranslations = {
  onBlur: "pointerleave",
  onHover: "pointerenter",
  onMove: "pointermove",
  onSelect: {
    type: "click",
    filter: (e) => e.pointerType === "ray"
  },
  onSelectEnd: {
    type: "pointerup",
    filter: (e) => e.pointerType === "ray"
  },
  onSelectStart: {
    type: "pointerdown",
    filter: (e) => e.pointerType === "ray"
  },
  onSqueeze: {
    type: "click",
    filter: (e) => e.pointerType === "grab"
  },
  onSqueezeEnd: {
    type: "pointerup",
    filter: (e) => e.pointerType === "grab"
  },
  onSqueezeStart: {
    type: "pointerdown",
    filter: (e) => e.pointerType === "grab"
  }
};
function useInteraction(ref, type, handler) {
  const handlerRef = (0, import_react24.useRef)(handler);
  handlerRef.current = handler;
  (0, import_react24.useEffect)(() => {
    const { current } = ref;
    if (current == null) {
      return;
    }
    const translation = eventTranslations[type];
    const fn = typeof translation === "string" ? (event) => handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState }) : (event) => {
      if (event instanceof PointerEvent && !translation.filter(event)) {
        return;
      }
      handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState });
    };
    const eventName = typeof translation === "string" ? translation : translation.type;
    current.addEventListener(eventName, fn);
    return () => current.removeEventListener(eventName, fn);
  }, [ref, type]);
}
function useXREvent(type, handler, { handedness } = {}) {
  const session = useXR((xr) => xr.session);
  const handlerRef = (0, import_react24.useRef)(handler);
  handlerRef.current = handler;
  (0, import_react24.useEffect)(() => {
    if (session == null) {
      return;
    }
    const fn = (e) => {
      handlerRef.current?.({
        type: e.type,
        data: e.inputSource
      });
    };
    session.addEventListener(type, fn);
    return () => session.removeEventListener(type, fn);
  }, [session, handedness, type]);
}
function useXRTransientPointerState(handedness) {
  return handedness == null ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceStateContext("transientPointer")
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceState("transientPointer", handedness)
  );
}
function useXRGazeState() {
  return useXRInputSourceStateContext("gaze");
}
function useXRScreenInputState() {
  return useXRInputSourceStateContext("screenInput");
}
function useXRHandState(handedness) {
  return handedness == null ? useXRInputSourceStateContext("hand") : useXRInputSourceState("hand", handedness);
}
function useXRControllerState(handedness) {
  return handedness == null ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceStateContext("controller")
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useXRInputSourceState("controller", handedness)
  );
}
var useXRReferenceSpace = useXRSpace;

// node_modules/@react-three/xr/dist/deprecated/interactive.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var Interactive = (0, import_react25.forwardRef)(({ onHover, onBlur, onSelectStart, onSelectEnd, onSelect, onSqueezeStart, onSqueezeEnd, onSqueeze, onMove, children }, passedRef) => {
  const ref = (0, import_react25.useRef)(null);
  (0, import_react25.useImperativeHandle)(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return (0, import_jsx_runtime20.jsx)("group", { ref, children });
});

// node_modules/@react-three/xr/dist/deprecated/ray-grab.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
import { Matrix4 as Matrix45 } from "three";
var RayGrab = (0, import_react26.forwardRef)(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = (0, import_react26.useRef)(void 0);
  const groupRef = (0, import_react26.useRef)(null);
  const previousTransform = (0, import_react26.useMemo)(() => new Matrix45(), []);
  (0, import_react26.useImperativeHandle)(forwardedRef, () => groupRef.current);
  useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!group || !controller)
      return;
    group.applyMatrix4(previousTransform);
    controller.updateWorldMatrix(true, false);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return (0, import_jsx_runtime21.jsx)(Interactive, { ref: groupRef, onSelectStart: (e) => {
    if (isXRInputSourceState(e.target) && (e.target.type === "controller" || e.target.type === "hand") && e.target.object != null) {
      grabbingController.current = e.target.object;
      e.target.object.updateWorldMatrix(true, false);
      previousTransform.copy(e.target.object.matrixWorld).invert();
      onSelectStart?.(e);
    }
  }, onSelectEnd: (e) => {
    if (e.target.controller === grabbingController.current) {
      grabbingController.current = void 0;
    }
    onSelectEnd?.(e);
  }, ...rest, children });
});
export {
  ARButton,
  CombinedPointer2 as CombinedPointer,
  DefaultXRController,
  DefaultXRControllerGrabPointer,
  DefaultXRGaze,
  DefaultXRHand,
  DefaultXRHandGrabPointer,
  DefaultXRHandTouchPointer,
  DefaultXRInputSourceRayPointer,
  DefaultXRInputSourceTeleportPointer,
  DefaultXRScreenInput,
  DefaultXRTransientPointer,
  FallbackXRLayerImplementation,
  IfFacingCamera,
  IfInSessionMode,
  IfSessionModeSupported,
  IfSessionVisible,
  Interactive,
  NotInXR,
  PointerCursorModel2 as PointerCursorModel,
  PointerEvents,
  PointerRayModel2 as PointerRayModel,
  RayGrab,
  RootCombinedPointer,
  ShowIfFacingCamera,
  ShowIfInSessionMode,
  ShowIfSessionModeSupported,
  ShowIfSessionVisible,
  TeleportPointerRayModel2 as TeleportPointerRayModel,
  TeleportTarget,
  UNSAFE_useXRStore,
  VRButton,
  XR,
  XRButton,
  XRControllerComponent,
  XRControllerModel2 as XRControllerModel,
  XRDomOverlay,
  XRHandJoint,
  XRHandModel2 as XRHandModel,
  XRHitTest,
  XRLayer,
  XRLayerImplementation,
  XRMeshModel,
  XROrigin,
  XRPlaneModel,
  XRSpace3 as XRSpace,
  createXRHitTestSource,
  createXRStore2 as createXRStore,
  defaultGrabPointerOpacity,
  defaultRayPointerOpacity,
  defaultTouchPointerOpacity,
  isAppleVisionPro,
  isXRInputSourceState,
  noEvents,
  privateKeys,
  requestXRAnchor,
  requestXRHitTest,
  useApplyXRSpaceMatrix,
  useGetXRSpaceMatrix,
  useGrabPointer,
  useHover,
  useInitRoomCapture,
  useInteraction,
  useLayerStore,
  useLinesPointer,
  useLoadXRControllerLayout,
  useLoadXRControllerModel,
  usePointerXRInputSourceEvents,
  useRayPointer,
  useRequestXRAnchor,
  useSessionFeatureEnabled,
  useSessionModeSupported,
  useTouchPointer,
  useXR,
  useXRAnchor,
  useXRControllerButtonEvent,
  useXRControllerLocomotion,
  useXRControllerState,
  useXREvent,
  useXRGazeState,
  useXRHandState,
  useXRHitTest,
  useXRHitTestSource,
  useXRInputSourceEvent,
  useXRInputSourceState,
  useXRInputSourceStateContext,
  useXRInputSourceStates,
  useXRMeshGeometry,
  useXRMeshes,
  useXRPlaneGeometry,
  useXRPlanes,
  useXRReferenceSpace,
  useXRRequestHitTest,
  useXRScreenInputState,
  useXRSessionFeatureEnabled,
  useXRSessionModeSupported,
  useXRSessionVisibilityState,
  useXRSpace,
  useXRStore,
  useXRTransientPointerState
};
//# sourceMappingURL=@react-three_xr.js.map
