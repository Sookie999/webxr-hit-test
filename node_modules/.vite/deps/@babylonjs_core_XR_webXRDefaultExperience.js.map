{
  "version": 3,
  "sources": ["../../../dev/core/src/XR/webXRLayerWrapper.ts", "../../../dev/core/src/Materials/Textures/MultiviewRenderTarget.ts", "../../../dev/core/src/XR/webXRRenderTargetTextureProvider.ts", "../../../dev/core/src/XR/webXRWebGLLayer.ts", "../../../dev/core/src/XR/webXRManagedOutputCanvas.ts", "../../../dev/core/src/XR/native/nativeXRRenderTarget.ts", "../../../dev/core/src/XR/webXRSessionManager.ts", "../../../dev/core/src/XR/webXRCamera.ts", "../../../dev/core/src/XR/webXRFeaturesManager.ts", "../../../dev/core/src/Cameras/touchCamera.ts", "../../../dev/core/src/Gamepads/gamepad.ts", "../../../dev/core/src/Gamepads/xboxGamepad.ts", "../../../dev/core/src/Gamepads/dualShockGamepad.ts", "../../../dev/core/src/Gamepads/gamepadManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraGamepadInput.ts", "../../../dev/core/src/Gamepads/gamepadSceneComponent.ts", "../../../dev/core/src/Cameras/universalCamera.ts", "../../../dev/core/src/XR/webXRExperienceHelper.ts", "../../../dev/core/src/XR/motionController/webXRControllerComponent.ts", "../../../dev/core/src/XR/motionController/webXRAbstractMotionController.ts", "../../../dev/core/src/XR/motionController/webXRGenericMotionController.ts", "../../../dev/core/src/Meshes/Builders/sphereBuilder.ts", "../../../dev/core/src/XR/motionController/webXRProfiledMotionController.ts", "../../../dev/core/src/XR/motionController/webXRMotionControllerManager.ts", "../../../dev/core/src/XR/webXRInputSource.ts", "../../../dev/core/src/XR/webXRInput.ts", "../../../dev/core/src/Meshes/Builders/cylinderBuilder.ts", "../../../dev/core/src/Meshes/Builders/torusBuilder.ts", "../../../dev/core/src/Culling/ray.core.ts", "../../../dev/core/src/Culling/ray.ts", "../../../dev/core/src/XR/features/WebXRAbstractFeature.ts", "../../../dev/core/src/Rendering/utilityLayerRenderer.ts", "../../../dev/core/src/XR/features/WebXRControllerPointerSelection.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialBlockTargets.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBuildState.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBuildStateSharedData.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBlockConnectionPoint.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBlock.ts", "../../../dev/core/src/Decorators/nodeDecorator.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialModes.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialSystemValues.ts", "../../../dev/core/src/Materials/Node/Blocks/Input/animatedInputBlockTypes.ts", "../../../dev/core/src/Materials/Node/Blocks/Input/inputBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/screenSizeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/transformBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/vertexOutputBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/currentScreenBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleTextureBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleRampGradientBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/vectorMergerBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/remapBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/baseMathBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/multiplyBlock.ts", "../../../dev/core/src/Materials/imageProcessingConfiguration.defines.ts", "../../../dev/core/src/Particles/baseParticleSystem.ts", "../../../dev/core/src/Materials/Node/Blocks/colorSplitterBlock.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts", "../../../dev/core/src/Materials/Node/Blocks/trigonometryBlock.ts", "../../../dev/core/src/Materials/Node/nodeMaterial.ts", "../../../dev/core/src/Meshes/subMesh.project.ts", "../../../dev/core/src/XR/features/WebXRNearInteraction.ts", "../../../dev/core/src/XR/webXREnterExitUI.ts", "../../../dev/core/src/Physics/v1/physicsJoint.ts", "../../../dev/core/src/Physics/v1/physicsImpostor.ts", "../../../dev/core/src/Meshes/Builders/icoSphereBuilder.ts", "../../../dev/core/src/XR/features/WebXRHandTracking.ts", "../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../dev/core/src/Meshes/groundMesh.ts", "../../../dev/core/src/Meshes/Builders/groundBuilder.ts", "../../../dev/core/src/Meshes/linesMesh.ts", "../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../dev/core/src/XR/features/WebXRControllerTeleportation.ts", "../../../dev/core/src/XR/webXRDefaultExperience.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRCompositionLayer */\r\n// TODO (rgerd): Extend for all other subclasses of XRCompositionLayer.\r\nexport type WebXRCompositionLayerType = \"XRProjectionLayer\";\r\nexport type WebXRQuadLayerType = \"XRQuadLayer\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRLayer */\r\nexport type WebXRLayerType = \"XRWebGLLayer\" | WebXRCompositionLayerType | WebXRQuadLayerType;\r\n\r\n/**\r\n * Wrapper over subclasses of XRLayer.\r\n * @internal\r\n */\r\nexport class WebXRLayerWrapper {\r\n    private _rttWrapper: Nullable<WebXRLayerRenderTargetTextureProvider> = null;\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this.layerType == \"XRWebGLLayer\" && typeof (this.layer as XRWebGLLayer).fixedFoveation == \"number\";\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        if (this.isFixedFoveationSupported) {\r\n            return (this.layer as XRWebGLLayer).fixedFoveation!;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        if (this.isFixedFoveationSupported) {\r\n            const val = Math.max(0, Math.min(1, value || 0));\r\n            (this.layer as XRWebGLLayer).fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a render target provider for the wrapped layer.\r\n     * @param xrSessionManager The XR Session Manager\r\n     * @returns A new render target texture provider for the wrapped layer.\r\n     */\r\n    public createRenderTargetTextureProvider(xrSessionManager: WebXRSessionManager): WebXRLayerRenderTargetTextureProvider {\r\n        this._rttWrapper = this._createRenderTargetTextureProvider(xrSessionManager);\r\n        return this._rttWrapper;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this._rttWrapper) {\r\n            this._rttWrapper.dispose();\r\n            this._rttWrapper = null;\r\n        }\r\n    }\r\n\r\n    protected constructor(\r\n        /** The width of the layer's framebuffer. */\r\n        public getWidth: () => number,\r\n        /** The height of the layer's framebuffer. */\r\n        public getHeight: () => number,\r\n        /** The XR layer that this WebXRLayerWrapper wraps. */\r\n        public readonly layer: XRLayer,\r\n        /** The type of XR layer that is being wrapped. */\r\n        public readonly layerType: WebXRLayerType,\r\n        /** Create a render target provider for the wrapped layer. */\r\n        private _createRenderTargetTextureProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider\r\n    ) {}\r\n}\r\n", "import { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n\r\n/**\r\n * Renders to multiple views with a single draw call\r\n * Only for WebGL backends\r\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\r\n */\r\nexport class MultiviewRenderTarget extends RenderTargetTexture {\r\n    public override set samples(value: number) {\r\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\r\n        this._samples = value;\r\n    }\r\n\r\n    public override get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Creates a multiview render target\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"multiview rtt\", size, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_BYTE, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = (this.getScene()!.getEngine() as Engine).createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n        this.samples = this._getEngine()!.getCaps().maxSamples || this.samples;\r\n        this._texture.samples = this._samples;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        (this.getScene()!.getEngine() as Engine).bindMultiviewFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public override getViewCount() {\r\n        return 2;\r\n    }\r\n}\r\n", "import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(\r\n        private readonly _scene: Scene,\r\n        public readonly layerWrapper: WebXRLayerWrapper\r\n    ) {\r\n        this._engine = _scene.getEngine() as Engine;\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        for (const rtt of this._renderTargetTextures) {\r\n            rtt.dispose();\r\n        }\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\n\r\n/**\r\n * Wraps xr webgl layers.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerWrapper extends WebXRLayerWrapper {\r\n    /**\r\n     * @param layer is the layer to be wrapped.\r\n     * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.\r\n     */\r\n    constructor(public override readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRWebGLLayer.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    // The dimensions will always be defined in this class.\r\n    protected override _framebufferDimensions: { framebufferWidth: number; framebufferHeight: number };\r\n    private _rtt: Nullable<RenderTargetTexture>;\r\n    private _framebuffer: WebGLFramebuffer;\r\n    private _layer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public override readonly layerWrapper: WebXRWebGLLayerWrapper\r\n    ) {\r\n        super(scene, layerWrapper);\r\n        this._layer = layerWrapper.layer;\r\n        this._framebufferDimensions = {\r\n            framebufferWidth: this._layer.framebufferWidth,\r\n            framebufferHeight: this._layer.framebufferHeight,\r\n        };\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const xrViewport = this._layer.getViewport(view);\r\n        if (!xrViewport) {\r\n            return false;\r\n        }\r\n        const framebufferWidth = this._framebufferDimensions.framebufferWidth;\r\n        const framebufferHeight = this._framebufferDimensions.framebufferHeight;\r\n        viewport.x = xrViewport.x / framebufferWidth;\r\n        viewport.y = xrViewport.y / framebufferHeight;\r\n        viewport.width = xrViewport.width / framebufferWidth;\r\n        viewport.height = xrViewport.height / framebufferHeight;\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const layerWidth = this._layer.framebufferWidth;\r\n        const layerHeight = this._layer.framebufferHeight;\r\n        const framebuffer = this._layer.framebuffer;\r\n\r\n        if (\r\n            !this._rtt ||\r\n            layerWidth !== this._framebufferDimensions.framebufferWidth ||\r\n            layerHeight !== this._framebufferDimensions.framebufferHeight ||\r\n            framebuffer !== this._framebuffer\r\n        ) {\r\n            this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);\r\n            this._framebufferDimensions.framebufferWidth = layerWidth;\r\n            this._framebufferDimensions.framebufferHeight = layerHeight;\r\n            this._framebuffer = framebuffer;\r\n        }\r\n\r\n        return this._rtt;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view.eye);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: AbstractEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<AbstractEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGL2RenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    private _canvasCompatiblePromise: Promise<void>;\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()\r\n    ) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n\r\n        this._makeCanvasCompatible();\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n        this.onXRLayerInitObservable.clear();\r\n    }\r\n\r\n    private _makeCanvasCompatible() {\r\n        this._canvasCompatiblePromise = new Promise<void>((resolve, reject) => {\r\n            // stay safe - make sure the context has the function\r\n            try {\r\n                if (this.canvasContext && (this.canvasContext as any).makeXRCompatible) {\r\n                    // eslint-disable-next-line github/no-then\r\n                    this.canvasContext.makeXRCompatible().then(\r\n                        () => {\r\n                            resolve();\r\n                        },\r\n                        () => {\r\n                            // fail silently\r\n                            Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                            resolve();\r\n                        }\r\n                    );\r\n                } else {\r\n                    resolve();\r\n                }\r\n            } catch (e) {\r\n                // if this fails - the exception will be caught and the promise will be rejected\r\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        return await this._canvasCompatiblePromise\r\n            // eslint-disable-next-line github/no-then\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {}\r\n            )\r\n            // eslint-disable-next-line github/no-then\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRLayerWrapper } from \"../webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { WebXRRenderTarget } from \"../webXRTypes\";\r\n\r\n/**\r\n * Wraps XRWebGLLayer's created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerWrapper extends WebXRLayerWrapper {\r\n    constructor(public override readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures for layers created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    private _nativeRTTProvider: WebXRLayerRenderTargetTextureProvider;\r\n    private _nativeLayer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        sessionManager: WebXRSessionManager,\r\n        public override readonly layerWrapper: NativeXRLayerWrapper\r\n    ) {\r\n        super(sessionManager.scene, layerWrapper);\r\n        this._nativeRTTProvider = (navigator as any).xr.getNativeRenderTargetProvider(\r\n            sessionManager.session,\r\n            this._createRenderTargetTexture.bind(this),\r\n            this._destroyRenderTargetTexture.bind(this)\r\n        );\r\n        this._nativeLayer = layerWrapper.layer;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport): boolean {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = 1;\r\n        viewport.height = 1;\r\n        return true;\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        // TODO (rgerd): Update the contract on the BabylonNative side to call this \"getRenderTargetTextureForEye\"\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(eye);\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(view.eye);\r\n    }\r\n\r\n    public override getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return {\r\n            framebufferWidth: this._nativeLayer.framebufferWidth,\r\n            framebufferHeight: this._nativeLayer.framebufferHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the xr layer that will be used as the xr session's base layer.\r\n * @internal\r\n */\r\nexport class NativeXRRenderTarget implements WebXRRenderTarget {\r\n    public canvasContext: WebGLRenderingContext;\r\n    public xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    private _nativeRenderTarget: WebXRRenderTarget;\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        this._nativeRenderTarget = (navigator as any).xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());\r\n    }\r\n\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);\r\n        this.xrLayer = this._nativeRenderTarget.xrLayer!;\r\n        return this.xrLayer;\r\n    }\r\n\r\n    dispose(): void {\r\n        /* empty */\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n\r\n    /**\r\n     * Fires when the xr reference space has been initialized\r\n     */\r\n    public onXRReferenceSpaceInitialized: Observable<XRReferenceSpace> = new Observable<XRReferenceSpace>();\r\n\r\n    /**\r\n     * Fires when the session manager is rendering the first frame\r\n     */\r\n    public onXRReady: Observable<WebXRSessionManager> = new Observable<WebXRSessionManager>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    private _worldScalingFactor: number = 1;\r\n\r\n    /**\r\n     * Observable raised when the world scale has changed\r\n     */\r\n    public onWorldScaleFactorChangedObservable: Observable<{\r\n        previousScaleFactor: number;\r\n        newScaleFactor: number;\r\n    }> = new Observable(undefined, true);\r\n\r\n    /**\r\n     * Scale factor to apply to all XR-related elements (camera, controllers)\r\n     */\r\n    public get worldScalingFactor(): number {\r\n        return this._worldScalingFactor;\r\n    }\r\n\r\n    public set worldScalingFactor(value: number) {\r\n        const oldValue = this._worldScalingFactor;\r\n        this._worldScalingFactor = value;\r\n        this.onWorldScaleFactorChangedObservable.notifyObservers({\r\n            previousScaleFactor: oldValue,\r\n            newScaleFactor: value,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine() as Engine;\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRReady.clear();\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this.onWorldScaleFactorChangedObservable.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public async exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            try {\r\n                return await this.session.end();\r\n            } catch {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public async initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            throw new Error(\"WebXR not supported on this browser.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public async initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        const session = await this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit);\r\n\r\n        this.session = session;\r\n        this._sessionMode = xrSessionMode;\r\n        this.inXRSession = true;\r\n        this.onXRSessionInit.notifyObservers(session);\r\n\r\n        // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n        this.session.addEventListener(\r\n            \"end\",\r\n            () => {\r\n                this.inXRSession = false;\r\n\r\n                // Notify frame observers\r\n                this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                if (this._engine) {\r\n                    // make sure dimensions object is restored\r\n                    this._engine.framebufferDimensionsObject = null;\r\n\r\n                    // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                    this._engine.restoreDefaultFramebuffer();\r\n\r\n                    // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                    this._engine.customAnimationFrameRequester = null;\r\n                    this._engine._renderLoop();\r\n                }\r\n\r\n                // Dispose render target textures.\r\n                // Only dispose on native because we can't destroy opaque textures on browser.\r\n                if (this.isNative) {\r\n                    this._baseLayerRTTProvider?.dispose();\r\n                }\r\n                this._baseLayerRTTProvider = null;\r\n                this._baseLayerWrapper = null;\r\n            },\r\n            { once: true }\r\n        );\r\n\r\n        return this.session;\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public async isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return await WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: (callback: FrameRequestCallback) => this.session.requestAnimationFrame(callback),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    const framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    // equality can be tested as it should be the same object\r\n                    if (this._engine.framebufferDimensionsObject !== framebufferDimensionsObject) {\r\n                        this._engine.framebufferDimensionsObject = framebufferDimensionsObject;\r\n                    }\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n        this.onXRFrameObservable.addOnce(() => {\r\n            this.onXRReady.notifyObservers(this);\r\n        });\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public async setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        let referenceSpace: XRReferenceSpace;\r\n        try {\r\n            referenceSpace = await this.session.requestReferenceSpace(referenceSpaceType);\r\n        } catch (rejectionReason) {\r\n            Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n            Logger.Error(rejectionReason);\r\n            Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n            try {\r\n                const referenceSpace = await this.session.requestReferenceSpace(\"viewer\");\r\n                const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n            } catch (rejectionReason) {\r\n                Logger.Error(rejectionReason);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n            }\r\n        }\r\n        // create viewer reference space before setting the first reference space\r\n        const viewerReferenceSpace = await this.session.requestReferenceSpace(\"viewer\");\r\n        this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n        // initialize the base and offset (currently the same)\r\n        this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n        this.onXRReferenceSpaceInitialized.notifyObservers(referenceSpace);\r\n        return this.referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated Use updateRenderState() instead.\r\n     */\r\n    public async updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return await this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static async IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return false;\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                const result = functionToUse.call((navigator as any).xr, sessionMode);\r\n                const returnValue = typeof result === \"undefined\" ? true : result;\r\n                return returnValue;\r\n            } catch (e: any) {\r\n                Logger.Warn(e);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public async updateTargetFrameRate(rate: number): Promise<void> {\r\n        return await this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n", "import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * This will be triggered after the first XR Frame initialized the camera,\r\n     * including the right number of views and their rendering parameters\r\n     */\r\n    public onXRCameraInitializedObservable = new Observable<WebXRCamera>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     * @deprecated use onBeforeCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     * @deprecated use onAfterCameraTeleport of the teleportation feature instead\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        private _xrSessionManager: WebXRSessionManager\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n        this._deferOnly = true;\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add(() => {\r\n                // only run if in session\r\n                if (!this._xrSessionManager.currentFrame) {\r\n                    return;\r\n                }\r\n                this._updateDepthNearFar();\r\n            });\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                if (this.onXRCameraInitializedObservable.hasObservers()) {\r\n                    this.onXRCameraInitializedObservable.notifyObservers(this);\r\n                    this.onXRCameraInitializedObservable.clear();\r\n                }\r\n\r\n                if (this._deferredUpdated) {\r\n                    this.position.copyFrom(this._deferredPositionUpdate);\r\n                    this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                }\r\n\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     *\r\n     * Note - this value is multiplied by the worldScalingFactor (if set), so it will be in the same units as the scene.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y * this._xrSessionManager.worldScalingFactor;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Set the target for the camera to look at.\r\n     * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras\r\n     * @param target the target to set the camera to look at\r\n     */\r\n    public override setTarget(target: Vector3): void {\r\n        // only rotate around the y axis!\r\n        const tmpVector = TmpVectors.Vector3[1];\r\n        target.subtractToRef(this.position, tmpVector);\r\n        tmpVector.y = 0;\r\n        tmpVector.normalize();\r\n        const yRotation = Math.atan2(tmpVector.x, tmpVector.z) + (this._scene.useRightHandedSystem ? Math.PI : 0);\r\n        this.rotationQuaternion.toEulerAnglesToRef(tmpVector);\r\n        Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n        this.onTrackingStateChanged.clear();\r\n    }\r\n\r\n    private _updateDepthNearFar() {\r\n        const far = (this.maxZ || 10000) * this._xrSessionManager.worldScalingFactor;\r\n        const xrRenderState: XRRenderStateInit = {\r\n            // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n            depthFar: far,\r\n            depthNear: this.minZ,\r\n        };\r\n\r\n        this._xrSessionManager.updateRenderState(xrRenderState);\r\n        this._cache.minZ = this.minZ;\r\n        this._cache.maxZ = far;\r\n    }\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        // check min/max Z and update if not the same as in cache\r\n        if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\r\n            this._updateDepthNearFar();\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        for (let i = 0; i < pose.views.length; i++) {\r\n            const view = pose.views[i];\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // add any custom render targets to this camera, if available in the scene\r\n            const customRenderTargets = this.getScene().customRenderTargets;\r\n            // use a for loop\r\n            for (let i = 0; i < customRenderTargets.length; i++) {\r\n                const rt = customRenderTargets[i];\r\n                // make sure we don't add the same render target twice\r\n                if (currentRig.customRenderTargets.indexOf(rt) === -1) {\r\n                    currentRig.customRenderTargets.push(rt);\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // fov\r\n            const fov = Math.atan2(1, view.projectionMatrix[5]) * 2;\r\n            currentRig.fov = fov;\r\n            // first camera?\r\n            if (i === 0) {\r\n                this.fov = fov;\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n\r\n            // Replicate parent rig camera behavior\r\n            currentRig.layerMask = this.layerMask;\r\n        }\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x / this._xrSessionManager.worldScalingFactor,\r\n                    y: this._referencedPosition.y / this._xrSessionManager.worldScalingFactor,\r\n                    z: this._referencedPosition.z / this._xrSessionManager.worldScalingFactor,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n", "import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Observable } from \"core/Misc/observable\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n\r\n    /**\r\n     * Triggered when the feature is attached\r\n     */\r\n    onFeatureAttachObservable: Observable<IWebXRFeature>;\r\n    /**\r\n     * Triggered when the feature is detached\r\n     */\r\n    onFeatureDetachObservable: Observable<IWebXRFeature>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n    /**\r\n     * The name of the depth sensing feature\r\n     */\r\n    public static readonly DEPTH_SENSING = \"xr-depth-sensing\";\r\n    /**\r\n     * The name of the WebXR Space Warp feature\r\n     */\r\n    public static readonly SPACE_WARP = \"xr-space-warp\";\r\n    /**\r\n     * The name of the WebXR Raw Camera Access feature\r\n     */\r\n    public static readonly RAW_CAMERA_ACCESS = \"xr-raw-camera-access\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            const features = this.getEnabledFeatures();\r\n            for (const featureName of features) {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            }\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            const features = this.getEnabledFeatures();\r\n            for (const featureName of features) {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            const attached = feature.featureImplementation.attach();\r\n            if (!attached) {\r\n                Tools.Warn(`Feature ${featureName} failed to attach`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            const detached = feature.featureImplementation.detach();\r\n            if (!detached) {\r\n                Tools.Warn(`Feature ${featureName} failed to detach`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        const features = this.getEnabledFeatures();\r\n        for (const featureName of features) {\r\n            this.disableFeature(featureName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                // eslint-disable-next-line no-await-in-loop\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\r\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera controlled by touch.\r\n * This is like a universal camera minus the Gamepad controls.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class TouchCamera extends FreeCamera {\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    public get touchAngularSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchAngularSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    public get touchMoveSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchMoveSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new touch camera.\r\n     * This represents a FPS type of camera controlled by touch.\r\n     * This is like a universal camera minus the Gamepad controls.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addTouch();\r\n\r\n        this._setupInputs();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TouchCamera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public override _setupInputs() {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            // enable touch in mouse input if touch module is not enabled\r\n            mouse.touchEnabled = !touch;\r\n        } else {\r\n            // allow mouse in touch input if mouse module is not available\r\n            touch.allowMouse = !mouse;\r\n        }\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Represents a gamepad control stick position\r\n */\r\nexport class StickValues {\r\n    /**\r\n     * Initializes the gamepad x and y control stick values\r\n     * @param x The x component of the gamepad control stick value\r\n     * @param y The y component of the gamepad control stick value\r\n     */\r\n    constructor(\r\n        /**\r\n         * The x component of the control stick\r\n         */\r\n        public x: number,\r\n        /**\r\n         * The y component of the control stick\r\n         */\r\n        public y: number\r\n    ) {}\r\n}\r\n\r\n/**\r\n * An interface which manages callbacks for gamepad button changes\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GamepadButtonChanges {\r\n    /**\r\n     * Called when a gamepad has been changed\r\n     */\r\n    changed: boolean;\r\n    /**\r\n     * Called when a gamepad press event has been triggered\r\n     */\r\n    pressChanged: boolean;\r\n    /**\r\n     * Called when a touch event has been triggered\r\n     */\r\n    touchChanged: boolean;\r\n    /**\r\n     * Called when a value has changed\r\n     */\r\n    valueChanged: boolean;\r\n}\r\n\r\n/**\r\n * Represents a gamepad\r\n */\r\nexport class Gamepad {\r\n    /**\r\n     * Specifies what type of gamepad this represents\r\n     */\r\n    public type: number;\r\n\r\n    private _leftStick: StickValues = { x: 0, y: 0 };\r\n    private _rightStick: StickValues = { x: 0, y: 0 };\r\n\r\n    /** @internal */\r\n    public _isConnected = true;\r\n\r\n    private _leftStickAxisX: number;\r\n    private _leftStickAxisY: number;\r\n    private _rightStickAxisX: number;\r\n    private _rightStickAxisY: number;\r\n\r\n    /**\r\n     * Triggered when the left control stick has been changed\r\n     */\r\n    private _onleftstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Triggered when the right control stick has been changed\r\n     */\r\n    private _onrightstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Represents a gamepad controller\r\n     */\r\n    public static GAMEPAD = 0;\r\n    /**\r\n     * Represents a generic controller\r\n     */\r\n    public static GENERIC = 1;\r\n    /**\r\n     * Represents an XBox controller\r\n     */\r\n    public static XBOX = 2;\r\n    /**\r\n     * Represents a pose-enabled controller\r\n     */\r\n    public static POSE_ENABLED = 3;\r\n    /**\r\n     * Represents an Dual Shock controller\r\n     */\r\n    public static DUALSHOCK = 4;\r\n\r\n    /**\r\n     * Specifies whether the left control stick should be Y-inverted\r\n     */\r\n    protected _invertLeftStickY: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the gamepad has been connected\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Initializes the gamepad\r\n     * @param id The id of the gamepad\r\n     * @param index The index of the gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     * @param leftStickX The x component of the left joystick\r\n     * @param leftStickY The y component of the left joystick\r\n     * @param rightStickX The x component of the right joystick\r\n     * @param rightStickY The y component of the right joystick\r\n     */\r\n    constructor(\r\n        /**\r\n         * The id of the gamepad\r\n         */\r\n        public id: string,\r\n        /**\r\n         * The index of the gamepad\r\n         */\r\n        public index: number,\r\n        /**\r\n         * The browser gamepad\r\n         */\r\n        public browserGamepad: any,\r\n        leftStickX: number = 0,\r\n        leftStickY: number = 1,\r\n        rightStickX: number = 2,\r\n        rightStickY: number = 3\r\n    ) {\r\n        this.type = Gamepad.GAMEPAD;\r\n        this._leftStickAxisX = leftStickX;\r\n        this._leftStickAxisY = leftStickY;\r\n        this._rightStickAxisX = rightStickX;\r\n        this._rightStickAxisY = rightStickY;\r\n        if (this.browserGamepad.axes.length >= 2) {\r\n            this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n        }\r\n        if (this.browserGamepad.axes.length >= 4) {\r\n            this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the left joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onleftstickchanged(callback: (values: StickValues) => void) {\r\n        this._onleftstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the right joystick has changed\r\n     * @param callback callback to trigger\r\n     */\r\n    public onrightstickchanged(callback: (values: StickValues) => void) {\r\n        this._onrightstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left joystick\r\n     */\r\n    public get leftStick(): StickValues {\r\n        return this._leftStick;\r\n    }\r\n    /**\r\n     * Sets the left joystick values\r\n     */\r\n    public set leftStick(newValues: StickValues) {\r\n        if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {\r\n            this._onleftstickchanged(newValues);\r\n        }\r\n        this._leftStick = newValues;\r\n    }\r\n    /**\r\n     * Gets the right joystick\r\n     */\r\n    public get rightStick(): StickValues {\r\n        return this._rightStick;\r\n    }\r\n    /**\r\n     * Sets the right joystick value\r\n     */\r\n    public set rightStick(newValues: StickValues) {\r\n        if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {\r\n            this._onrightstickchanged(newValues);\r\n        }\r\n        this._rightStick = newValues;\r\n    }\r\n\r\n    /**\r\n     * Updates the gamepad joystick positions\r\n     */\r\n\r\n    public update() {\r\n        if (this._leftStick) {\r\n            this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n            if (this._invertLeftStickY) {\r\n                this.leftStick.y *= -1;\r\n            }\r\n        }\r\n        if (this._rightStick) {\r\n            this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {}\r\n}\r\n\r\n/**\r\n * Represents a generic gamepad\r\n */\r\nexport class GenericPad extends Gamepad {\r\n    private _buttons: Array<number>;\r\n    private _onbuttondown: (buttonPressed: number) => void;\r\n    private _onbuttonup: (buttonReleased: number) => void;\r\n\r\n    /**\r\n     * Observable triggered when a button has been pressed\r\n     */\r\n    public onButtonDownObservable = new Observable<number>();\r\n    /**\r\n     * Observable triggered when a button has been released\r\n     */\r\n    public onButtonUpObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Callback triggered when a button has been pressed\r\n     * @param callback Called when a button has been pressed\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: number) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n    /**\r\n     * Callback triggered when a button has been released\r\n     * @param callback Called when a button has been released\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: number) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Initializes the generic gamepad\r\n     * @param id The id of the generic gamepad\r\n     * @param index The index of the generic gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     */\r\n    constructor(id: string, index: number, browserGamepad: any) {\r\n        super(id, index, browserGamepad);\r\n        this.type = Gamepad.GENERIC;\r\n        this._buttons = new Array(browserGamepad.buttons.length);\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonIndex: number): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonIndex);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonIndex);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonIndex);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonIndex);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Updates the generic gamepad\r\n     */\r\n    public override update() {\r\n        super.update();\r\n        for (let index = 0; index < this._buttons.length; index++) {\r\n            this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the generic gamepad\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"../Gamepads/gamepad\";\r\n/**\r\n * Defines supported buttons for XBox360 compatible gamepads\r\n */\r\nexport const enum Xbox360Button {\r\n    /** A */\r\n    A = 0,\r\n    /** B */\r\n    B = 1,\r\n    /** X */\r\n    X = 2,\r\n    /** Y */\r\n    Y = 3,\r\n    /** Left button */\r\n    LB = 4,\r\n    /** Right button */\r\n    RB = 5,\r\n    /** Back */\r\n    Back = 8,\r\n    /** Start */\r\n    Start = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for XBox360 DPad  */\r\nexport const enum Xbox360Dpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a XBox360 gamepad\r\n */\r\nexport class Xbox360Pad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: Xbox360Button) => void;\r\n    private _onbuttonup: (buttonReleased: Xbox360Button) => void;\r\n    private _ondpaddown: (dPadPressed: Xbox360Dpad) => void;\r\n    private _ondpadup: (dPadReleased: Xbox360Dpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<Xbox360Dpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<Xbox360Dpad>();\r\n\r\n    private _buttonA: number = 0;\r\n    private _buttonB: number = 0;\r\n    private _buttonX: number = 0;\r\n    private _buttonY: number = 0;\r\n    private _buttonBack: number = 0;\r\n    private _buttonStart: number = 0;\r\n    private _buttonLb: number = 0;\r\n    private _buttonRb: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    private _isXboxOnePad: boolean = false;\r\n\r\n    /**\r\n     * Creates a new XBox360 gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     * @param xboxOne defines if it is a XBox One gamepad\r\n     */\r\n    constructor(id: string, index: number, gamepad: any, xboxOne: boolean = false) {\r\n        super(id, index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.XBOX;\r\n        this._isXboxOnePad = xboxOne;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: Xbox360Button) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: Xbox360Button) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: Xbox360Dpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: Xbox360Button): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDpadValue(newValue: number, currentValue: number, buttonType: Xbox360Dpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `A` button\r\n     */\r\n    public get buttonA(): number {\r\n        return this._buttonA;\r\n    }\r\n    /**\r\n     * Sets the value of the `A` button\r\n     */\r\n    public set buttonA(value) {\r\n        this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `B` button\r\n     */\r\n    public get buttonB(): number {\r\n        return this._buttonB;\r\n    }\r\n    /**\r\n     * Sets the value of the `B` button\r\n     */\r\n    public set buttonB(value) {\r\n        this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `X` button\r\n     */\r\n    public get buttonX(): number {\r\n        return this._buttonX;\r\n    }\r\n    /**\r\n     * Sets the value of the `X` button\r\n     */\r\n    public set buttonX(value) {\r\n        this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Y` button\r\n     */\r\n    public get buttonY(): number {\r\n        return this._buttonY;\r\n    }\r\n    /**\r\n     * Sets the value of the `Y` button\r\n     */\r\n    public set buttonY(value) {\r\n        this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Start` button\r\n     */\r\n    public get buttonStart(): number {\r\n        return this._buttonStart;\r\n    }\r\n    /**\r\n     * Sets the value of the `Start` button\r\n     */\r\n    public set buttonStart(value) {\r\n        this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Back` button\r\n     */\r\n    public get buttonBack(): number {\r\n        return this._buttonBack;\r\n    }\r\n    /**\r\n     * Sets the value of the `Back` button\r\n     */\r\n    public set buttonBack(value) {\r\n        this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Left` button\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get buttonLB(): number {\r\n        return this._buttonLb;\r\n    }\r\n    /**\r\n     * Sets the value of the `Left` button\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set buttonLB(value) {\r\n        this._buttonLb = this._setButtonValue(value, this._buttonLb, Xbox360Button.LB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Right` button\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get buttonRB(): number {\r\n        return this._buttonRb;\r\n    }\r\n    /**\r\n     * Sets the value of the `Right` button\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set buttonRB(value) {\r\n        this._buttonRb = this._setButtonValue(value, this._buttonRb, Xbox360Button.RB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDpadValue(value, this._dPadUp, Xbox360Dpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDpadValue(value, this._dPadDown, Xbox360Dpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDpadValue(value, this._dPadLeft, Xbox360Dpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDpadValue(value, this._dPadRight, Xbox360Dpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public override update() {\r\n        super.update();\r\n        if (this._isXboxOnePad) {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        } else {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"./gamepad\";\r\n\r\n/**\r\n * Defines supported buttons for DualShock compatible gamepads\r\n */\r\nexport const enum DualShockButton {\r\n    /** Cross */\r\n    Cross = 0,\r\n    /** Circle */\r\n    Circle = 1,\r\n    /** Square */\r\n    Square = 2,\r\n    /** Triangle */\r\n    Triangle = 3,\r\n    /** L1 */\r\n    L1 = 4,\r\n    /** R1 */\r\n    R1 = 5,\r\n    /** Share */\r\n    Share = 8,\r\n    /** Options */\r\n    Options = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for DualShock DPad  */\r\nexport const enum DualShockDpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a DualShock gamepad\r\n */\r\nexport class DualShockPad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: DualShockButton) => void;\r\n    private _onbuttonup: (buttonReleased: DualShockButton) => void;\r\n    private _ondpaddown: (dPadPressed: DualShockDpad) => void;\r\n    private _ondpadup: (dPadReleased: DualShockDpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<DualShockDpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<DualShockDpad>();\r\n\r\n    private _buttonCross: number = 0;\r\n    private _buttonCircle: number = 0;\r\n    private _buttonSquare: number = 0;\r\n    private _buttonTriangle: number = 0;\r\n    private _buttonShare: number = 0;\r\n    private _buttonOptions: number = 0;\r\n    private _buttonL1: number = 0;\r\n    private _buttonR1: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    /**\r\n     * Creates a new DualShock gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     */\r\n    constructor(id: string, index: number, gamepad: any) {\r\n        super(id.replace(\"STANDARD GAMEPAD\", \"SONY PLAYSTATION DUALSHOCK\"), index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.DUALSHOCK;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: DualShockButton) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: DualShockButton) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: DualShockDpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: DualShockDpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: DualShockButton): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDpadValue(newValue: number, currentValue: number, buttonType: DualShockDpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Cross` button\r\n     */\r\n    public get buttonCross(): number {\r\n        return this._buttonCross;\r\n    }\r\n    /**\r\n     * Sets the value of the `Cross` button\r\n     */\r\n    public set buttonCross(value) {\r\n        this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Circle` button\r\n     */\r\n    public get buttonCircle(): number {\r\n        return this._buttonCircle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Circle` button\r\n     */\r\n    public set buttonCircle(value) {\r\n        this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Square` button\r\n     */\r\n    public get buttonSquare(): number {\r\n        return this._buttonSquare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Square` button\r\n     */\r\n    public set buttonSquare(value) {\r\n        this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Triangle` button\r\n     */\r\n    public get buttonTriangle(): number {\r\n        return this._buttonTriangle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Triangle` button\r\n     */\r\n    public set buttonTriangle(value) {\r\n        this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Options` button\r\n     */\r\n    public get buttonOptions(): number {\r\n        return this._buttonOptions;\r\n    }\r\n    /**\r\n     * Sets the value of the `Options` button\r\n     */\r\n    public set buttonOptions(value) {\r\n        this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Share` button\r\n     */\r\n    public get buttonShare(): number {\r\n        return this._buttonShare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Share` button\r\n     */\r\n    public set buttonShare(value) {\r\n        this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `L1` button\r\n     */\r\n    public get buttonL1(): number {\r\n        return this._buttonL1;\r\n    }\r\n    /**\r\n     * Sets the value of the `L1` button\r\n     */\r\n    public set buttonL1(value) {\r\n        this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `R1` button\r\n     */\r\n    public get buttonR1(): number {\r\n        return this._buttonR1;\r\n    }\r\n    /**\r\n     * Sets the value of the `R1` button\r\n     */\r\n    public set buttonR1(value) {\r\n        this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDpadValue(value, this._dPadUp, DualShockDpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDpadValue(value, this._dPadDown, DualShockDpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDpadValue(value, this._dPadLeft, DualShockDpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDpadValue(value, this._dPadRight, DualShockDpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public override update() {\r\n        super.update();\r\n        this.buttonCross = this.browserGamepad.buttons[0].value;\r\n        this.buttonCircle = this.browserGamepad.buttons[1].value;\r\n        this.buttonSquare = this.browserGamepad.buttons[2].value;\r\n        this.buttonTriangle = this.browserGamepad.buttons[3].value;\r\n        this.buttonL1 = this.browserGamepad.buttons[4].value;\r\n        this.buttonR1 = this.browserGamepad.buttons[5].value;\r\n        this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n        this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n        this.buttonShare = this.browserGamepad.buttons[8].value;\r\n        this.buttonOptions = this.browserGamepad.buttons[9].value;\r\n        this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n        this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n        this.dPadUp = this.browserGamepad.buttons[12].value;\r\n        this.dPadDown = this.browserGamepad.buttons[13].value;\r\n        this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n        this.dPadRight = this.browserGamepad.buttons[15].value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    if (disconnectedGamepad.dispose) {\r\n                        disconnectedGamepad.dispose();\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        for (const gamepad of this._babylonGamepads) {\r\n            gamepad.dispose();\r\n        }\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            this._checkGamepadsStatus();\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring) {\r\n            AbstractEngine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Manage the gamepad inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Define the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Define the Gamepad controlling the input\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadAngularSensibility = 200;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    /**\r\n     * Defines the minimum value at which any analog stick input is ignored.\r\n     * Note: This value should only be a value between 0 and 1.\r\n     */\r\n    public deadzoneDelta = 0.1;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    // private members\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _cameraTransform: Matrix = Matrix.Identity();\r\n    private _deltaTransform: Vector3 = Vector3.Zero();\r\n    private _vector3: Vector3 = Vector3.Zero();\r\n    private _vector2: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        // check if there are already other controllers connected\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad && this.gamepad.leftStick) {\r\n            const camera = this.camera;\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (this.gamepadMoveSensibility !== 0) {\r\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\r\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\r\n            }\r\n\r\n            let rsValues = this.gamepad.rightStick;\r\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\r\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\r\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\r\n            } else {\r\n                rsValues = { x: 0, y: 0 };\r\n            }\r\n\r\n            if (!camera.rotationQuaternion) {\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\r\n            } else {\r\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\r\n            }\r\n\r\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\r\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\r\n\r\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\r\n            camera.cameraDirection.addInPlace(this._deltaTransform);\r\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\r\n            camera.cameraRotation.addInPlace(this._vector2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n/**\r\n * Manage the gamepad inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the gamepad the input is gathering event from.\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadRotationSensibility = 80;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad) {\r\n            const camera = this.camera;\r\n            const rsValues = this.gamepad.rightStick;\r\n\r\n            if (rsValues) {\r\n                if (rsValues.x != 0) {\r\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\r\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\r\n                        camera.inertialAlphaOffset += normalizedRX;\r\n                    }\r\n                }\r\n\r\n                if (rsValues.y != 0) {\r\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\r\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\r\n                        camera.inertialBetaOffset += normalizedRY;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (lsValues && lsValues.y != 0) {\r\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\r\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\r\n                    this.camera.inertialRadiusOffset -= normalizedLY;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\r\n", "import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { GamepadManager } from \"./gamepadManager\";\r\n\r\nimport { FreeCameraInputsManager } from \"../Cameras/freeCameraInputsManager\";\r\nimport { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { ArcRotateCameraGamepadInput } from \"../Cameras/Inputs/arcRotateCameraGamepadInput\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /** @internal */\r\n        _gamepadManager: Nullable<GamepadManager>;\r\n\r\n        /**\r\n         * Gets the gamepad manager associated with the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/input/gamepads\r\n         */\r\n        gamepadManager: GamepadManager;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"gamepadManager\", {\r\n    get: function (this: Scene) {\r\n        if (!this._gamepadManager) {\r\n            this._gamepadManager = new GamepadManager(this);\r\n            let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD) as GamepadSystemSceneComponent;\r\n            if (!component) {\r\n                component = new GamepadSystemSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n\r\n        return this._gamepadManager;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Cameras/freeCameraInputsManager\" {\r\n    /**\r\n     * Interface representing a free camera inputs manager\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the FreeCameraInputsManager.\r\n         * @returns the FreeCameraInputsManager\r\n         */\r\n        addGamepad(): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the free camera inputs manager\r\n * @returns the FreeCameraInputsManager\r\n */\r\nFreeCameraInputsManager.prototype.addGamepad = function (): FreeCameraInputsManager {\r\n    this.add(new FreeCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\ndeclare module \"../Cameras/arcRotateCameraInputsManager\" {\r\n    /**\r\n     * Interface representing an arc rotate camera inputs manager\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface ArcRotateCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the ArcRotateCamera InputManager.\r\n         * @returns the camera inputs manager\r\n         */\r\n        addGamepad(): ArcRotateCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the arc rotate camera inputs manager\r\n * @returns the camera inputs manager\r\n */\r\nArcRotateCameraInputsManager.prototype.addGamepad = function (): ArcRotateCameraInputsManager {\r\n    this.add(new ArcRotateCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the gamepad scene component responsible to manage gamepads in a given scene\r\n */\r\nexport class GamepadSystemSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GAMEPAD;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        // Nothing to do for gamepads\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for gamepads\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n        if (gamepadManager) {\r\n            gamepadManager.dispose();\r\n            this.scene._gamepadManager = null;\r\n        }\r\n    }\r\n}\r\n", "import { TouchCamera } from \"./touchCamera\";\r\nimport { Node } from \"../node\";\r\nimport type { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"./camera\";\r\n\r\nimport \"../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\r\n    // Forcing to use the Universal camera\r\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n * which still works and will still be found in many Playgrounds.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class UniversalCamera extends TouchCamera {\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadAngularSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadAngularSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadMoveSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadMoveSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n     * which still works and will still be found in many Playgrounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"UniversalCamera\";\r\n    }\r\n}\r\n\r\nCamera._CreateDefaultParsedCamera = (name: string, scene: Scene) => {\r\n    return new UniversalCamera(name, Vector3.Zero(), scene);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Options for setting up XR spectator camera.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface WebXRSpectatorModeOption {\r\n    /**\r\n     * Expected refresh rate (frames per sec) for a spectator camera.\r\n     */\r\n    fps?: number;\r\n    /**\r\n     * The index of rigCameras array in a WebXR camera.\r\n     */\r\n    preferredCameraIndex?: number;\r\n}\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n    private _lastTimestamp = 0;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static async CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return await helper.sessionManager\r\n            .initializeAsync()\r\n            // eslint-disable-next-line github/no-then\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            // eslint-disable-next-line github/no-then\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.camera.maxZ || 10000,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n                this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n            }\r\n\r\n            // Vision Pro suspends the audio context when entering XR, so we resume it here if needed.\r\n            AbstractEngine.audioEngine?._resumeAudioContextOnStateChange();\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                for (const c of this.camera.rigCameras) {\r\n                    c.outputRenderTarget = null;\r\n                }\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            Logger.Log(e);\r\n            Logger.Log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public async exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return;\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return await this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\r\n     */\r\n    public enableSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        if (!this._spectatorMode) {\r\n            this._spectatorMode = true;\r\n            this._switchSpectatorMode(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable spectator mode for desktop VR experiences.\r\n     */\r\n    public disableSpecatatorMode(): void {\r\n        if (this._spectatorMode) {\r\n            this._spectatorMode = false;\r\n            this._switchSpectatorMode();\r\n        }\r\n    }\r\n\r\n    private _switchSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        const fps = options?.fps ? options.fps : 1000.0;\r\n        const refreshRate = (1.0 / fps) * 1000.0;\r\n        const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\r\n\r\n        const updateSpectatorCamera = () => {\r\n            if (this._spectatorCamera) {\r\n                const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\r\n                if (delta >= refreshRate) {\r\n                    this._lastTimestamp = this.sessionManager.currentTimestamp;\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\r\n                }\r\n            }\r\n        };\r\n        if (this._spectatorMode) {\r\n            if (cameraIndex >= this.camera.rigCameras.length) {\r\n                throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\r\n            }\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            (this._scene.getEngine() as ThinEngine).framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        } else {\r\n            this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n            this._scene.activeCameras = [this.camera];\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerComponentType } from \"./webXRAbstractMotionController\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { IDisposable } from \"../../scene\";\r\n\r\n/**\r\n * X-Y values for axes in WebXR\r\n */\r\nexport interface IWebXRMotionControllerAxesValue {\r\n    /**\r\n     * The value of the x axis\r\n     */\r\n    x: number;\r\n    /**\r\n     * The value of the y-axis\r\n     */\r\n    y: number;\r\n}\r\n\r\n/**\r\n * changed / previous values for the values of this component\r\n */\r\nexport interface IWebXRMotionControllerComponentChangesValues<T> {\r\n    /**\r\n     * current (this frame) value\r\n     */\r\n    current: T;\r\n    /**\r\n     * previous (last change) value\r\n     */\r\n    previous: T;\r\n}\r\n\r\n/**\r\n * Represents changes in the component between current frame and last values recorded\r\n */\r\nexport interface IWebXRMotionControllerComponentChanges {\r\n    /**\r\n     * will be populated with previous and current values if axes changed\r\n     */\r\n    axes?: IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue>;\r\n    /**\r\n     * will be populated with previous and current values if pressed changed\r\n     */\r\n    pressed?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if touched changed\r\n     */\r\n    touched?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if value changed\r\n     */\r\n    value?: IWebXRMotionControllerComponentChangesValues<number>;\r\n}\r\n/**\r\n * This class represents a single component (for example button or thumbstick) of a motion controller\r\n */\r\nexport class WebXRControllerComponent implements IDisposable {\r\n    private _axes: IWebXRMotionControllerAxesValue = {\r\n        x: 0,\r\n        y: 0,\r\n    };\r\n    private _changes: IWebXRMotionControllerComponentChanges = {};\r\n    private _currentValue: number = 0;\r\n    private _hasChanges: boolean = false;\r\n    private _pressed: boolean = false;\r\n    private _touched: boolean = false;\r\n\r\n    /**\r\n     * button component type\r\n     */\r\n    public static BUTTON_TYPE: MotionControllerComponentType = \"button\";\r\n    /**\r\n     * squeeze component type\r\n     */\r\n    public static SQUEEZE_TYPE: MotionControllerComponentType = \"squeeze\";\r\n    /**\r\n     * Thumbstick component type\r\n     */\r\n    public static THUMBSTICK_TYPE: MotionControllerComponentType = \"thumbstick\";\r\n    /**\r\n     * Touchpad component type\r\n     */\r\n    public static TOUCHPAD_TYPE: MotionControllerComponentType = \"touchpad\";\r\n    /**\r\n     * trigger component type\r\n     */\r\n    public static TRIGGER_TYPE: MotionControllerComponentType = \"trigger\";\r\n\r\n    /**\r\n     * If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when\r\n     * the axes data changes\r\n     */\r\n    public onAxisValueChangedObservable: Observable<{ x: number; y: number }> = new Observable();\r\n    /**\r\n     * Observers registered here will be triggered when the state of a button changes\r\n     * State change is either pressed / touched / value\r\n     */\r\n    public onButtonStateChangedObservable: Observable<WebXRControllerComponent> = new Observable();\r\n\r\n    /**\r\n     * Creates a new component for a motion controller.\r\n     * It is created by the motion controller itself\r\n     *\r\n     * @param id the id of this component\r\n     * @param type the type of the component\r\n     * @param _buttonIndex index in the buttons array of the gamepad\r\n     * @param _axesIndices indices of the values in the axes array of the gamepad\r\n     */\r\n    constructor(\r\n        /**\r\n         * the id of this component\r\n         */\r\n        public id: string,\r\n        /**\r\n         * the type of the component\r\n         */\r\n        public type: MotionControllerComponentType,\r\n        private _buttonIndex: number = -1,\r\n        private _axesIndices: number[] = []\r\n    ) {}\r\n\r\n    /**\r\n     * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }\r\n     */\r\n    public get axes(): IWebXRMotionControllerAxesValue {\r\n        return this._axes;\r\n    }\r\n\r\n    /**\r\n     * Get the changes. Elements will be populated only if they changed with their previous and current value\r\n     */\r\n    public get changes(): IWebXRMotionControllerComponentChanges {\r\n        return this._changes;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the component changed the last frame\r\n     */\r\n    public get hasChanges(): boolean {\r\n        return this._hasChanges;\r\n    }\r\n\r\n    /**\r\n     * is the button currently pressed\r\n     */\r\n    public get pressed(): boolean {\r\n        return this._pressed;\r\n    }\r\n\r\n    /**\r\n     * is the button currently touched\r\n     */\r\n    public get touched(): boolean {\r\n        return this._touched;\r\n    }\r\n\r\n    /**\r\n     * Get the current value of this component\r\n     */\r\n    public get value(): number {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Dispose this component\r\n     */\r\n    public dispose(): void {\r\n        this.onAxisValueChangedObservable.clear();\r\n        this.onButtonStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Are there axes correlating to this component\r\n     * @returns true is axes data is available\r\n     */\r\n    public isAxes(): boolean {\r\n        return this._axesIndices.length !== 0;\r\n    }\r\n\r\n    /**\r\n     * Is this component a button (hence - pressable)\r\n     * @returns true if can be pressed\r\n     */\r\n    public isButton(): boolean {\r\n        return this._buttonIndex !== -1;\r\n    }\r\n\r\n    /**\r\n     * update this component using the gamepad object it is in. Called on every frame\r\n     * @param nativeController the native gamepad controller object\r\n     */\r\n    public update(nativeController: IMinimalMotionControllerObject) {\r\n        let buttonUpdated = false;\r\n        let axesUpdate = false;\r\n        this._hasChanges = false;\r\n        this._changes = {};\r\n\r\n        if (this.isButton()) {\r\n            const button = nativeController.buttons[this._buttonIndex];\r\n            // defensive, in case a profile was forced\r\n            if (!button) {\r\n                return;\r\n            }\r\n            if (this._currentValue !== button.value) {\r\n                this.changes.value = {\r\n                    current: button.value,\r\n                    previous: this._currentValue,\r\n                };\r\n                buttonUpdated = true;\r\n                this._currentValue = button.value;\r\n            }\r\n            if (this._touched !== button.touched) {\r\n                this.changes.touched = {\r\n                    current: button.touched,\r\n                    previous: this._touched,\r\n                };\r\n                buttonUpdated = true;\r\n                this._touched = button.touched;\r\n            }\r\n            if (this._pressed !== button.pressed) {\r\n                this.changes.pressed = {\r\n                    current: button.pressed,\r\n                    previous: this._pressed,\r\n                };\r\n                buttonUpdated = true;\r\n                this._pressed = button.pressed;\r\n            }\r\n        }\r\n\r\n        if (this.isAxes()) {\r\n            if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {\r\n                this.changes.axes = {\r\n                    current: {\r\n                        x: nativeController.axes[this._axesIndices[0]],\r\n                        y: this._axes.y,\r\n                    },\r\n                    previous: {\r\n                        x: this._axes.x,\r\n                        y: this._axes.y,\r\n                    },\r\n                };\r\n                this._axes.x = nativeController.axes[this._axesIndices[0]];\r\n                axesUpdate = true;\r\n            }\r\n\r\n            if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {\r\n                if (this.changes.axes) {\r\n                    this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];\r\n                } else {\r\n                    this.changes.axes = {\r\n                        current: {\r\n                            x: this._axes.x,\r\n                            y: nativeController.axes[this._axesIndices[1]],\r\n                        },\r\n                        previous: {\r\n                            x: this._axes.x,\r\n                            y: this._axes.y,\r\n                        },\r\n                    };\r\n                }\r\n                this._axes.y = nativeController.axes[this._axesIndices[1]];\r\n                axesUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (buttonUpdated) {\r\n            this._hasChanges = true;\r\n            this.onButtonStateChangedObservable.notifyObservers(this);\r\n        }\r\n        if (axesUpdate) {\r\n            this._hasChanges = true;\r\n            this.onAxisValueChangedObservable.notifyObservers(this._axes);\r\n        }\r\n    }\r\n}\r\n", "import type { IDisposable, Scene } from \"../../scene\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\n\r\n/**\r\n * Handedness type in xrInput profiles. These can be used to define layouts in the Layout Map.\r\n */\r\nexport type MotionControllerHandedness = \"none\" | \"left\" | \"right\";\r\n/**\r\n * The type of components available in motion controllers.\r\n * This is not the name of the component.\r\n */\r\nexport type MotionControllerComponentType = \"trigger\" | \"squeeze\" | \"touchpad\" | \"thumbstick\" | \"button\";\r\n\r\n/**\r\n * The state of a controller component\r\n */\r\nexport type MotionControllerComponentStateType = \"default\" | \"touched\" | \"pressed\";\r\n\r\n/**\r\n * The schema of motion controller layout.\r\n * No object will be initialized using this interface\r\n * This is used just to define the profile.\r\n */\r\nexport interface IMotionControllerLayout {\r\n    /**\r\n     * Path to load the assets. Usually relative to the base path\r\n     */\r\n    assetPath: string;\r\n    /**\r\n     * Available components (unsorted)\r\n     */\r\n    components: {\r\n        /**\r\n         * A map of component Ids\r\n         */\r\n        [componentId: string]: {\r\n            /**\r\n             * The type of input the component outputs\r\n             */\r\n            type: MotionControllerComponentType;\r\n            /**\r\n             * The indices of this component in the gamepad object\r\n             */\r\n            gamepadIndices: {\r\n                /**\r\n                 * Index of button\r\n                 */\r\n                button?: number;\r\n                /**\r\n                 * If available, index of x-axis\r\n                 */\r\n                xAxis?: number;\r\n                /**\r\n                 * If available, index of y-axis\r\n                 */\r\n                yAxis?: number;\r\n            };\r\n            /**\r\n             * The mesh's root node name\r\n             */\r\n            rootNodeName: string;\r\n            /**\r\n             * Animation definitions for this model\r\n             */\r\n            visualResponses: {\r\n                [stateKey: string]: {\r\n                    /**\r\n                     * What property will be animated\r\n                     */\r\n                    componentProperty: \"xAxis\" | \"yAxis\" | \"button\" | \"state\";\r\n                    /**\r\n                     * What states influence this visual response\r\n                     */\r\n                    states: MotionControllerComponentStateType[];\r\n                    /**\r\n                     * Type of animation - movement or visibility\r\n                     */\r\n                    valueNodeProperty: \"transform\" | \"visibility\";\r\n                    /**\r\n                     * Base node name to move. Its position will be calculated according to the min and max nodes\r\n                     */\r\n                    valueNodeName?: string;\r\n                    /**\r\n                     * Minimum movement node\r\n                     */\r\n                    minNodeName?: string;\r\n                    /**\r\n                     * Max movement node\r\n                     */\r\n                    maxNodeName?: string;\r\n                };\r\n            };\r\n            /**\r\n             * If touch enabled, what is the name of node to display user feedback\r\n             */\r\n            touchPointNodeName?: string;\r\n        };\r\n    };\r\n    /**\r\n     * Is it xr standard mapping or not\r\n     */\r\n    gamepadMapping: \"\" | \"xr-standard\";\r\n    /**\r\n     * Base root node of this entire model\r\n     */\r\n    rootNodeName: string;\r\n    /**\r\n     * Defines the main button component id\r\n     */\r\n    selectComponentId: string;\r\n}\r\n\r\n/**\r\n * A definition for the layout map in the input profile\r\n */\r\nexport interface IMotionControllerLayoutMap {\r\n    /**\r\n     * Layouts with handedness type as a key\r\n     */\r\n    [handedness: string /* handedness */]: IMotionControllerLayout;\r\n}\r\n\r\n/**\r\n * The XR Input profile schema\r\n * Profiles can be found here:\r\n * https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles\r\n */\r\nexport interface IMotionControllerProfile {\r\n    /**\r\n     * fallback profiles for this profileId\r\n     */\r\n    fallbackProfileIds: string[];\r\n    /**\r\n     * The layout map, with handedness as key\r\n     */\r\n    layouts: IMotionControllerLayoutMap;\r\n    /**\r\n     * The id of this profile\r\n     * correlates to the profile(s) in the xrInput.profiles array\r\n     */\r\n    profileId: string;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller button animation\r\n * The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerButtonMeshMap {\r\n    /**\r\n     * the mesh that defines the pressed value mesh position.\r\n     * This is used to find the max-position of this button\r\n     */\r\n    pressedMesh: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the unpressed value mesh position.\r\n     * This is used to find the min (or initial) position of this button\r\n     */\r\n    unpressedMesh: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when value changes\r\n     */\r\n    valueMesh: AbstractMesh;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller axis animation.\r\n * This will be expanded when touchpad animations are fully supported\r\n * The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerMeshMap {\r\n    /**\r\n     * the mesh that defines the maximum value mesh position.\r\n     */\r\n    maxMesh?: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the minimum value mesh position.\r\n     */\r\n    minMesh?: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when axis value changes\r\n     */\r\n    valueMesh?: AbstractMesh;\r\n}\r\n\r\n/**\r\n * The elements needed for change-detection of the gamepad objects in motion controllers\r\n */\r\nexport interface IMinimalMotionControllerObject {\r\n    /**\r\n     * Available axes of this controller\r\n     */\r\n    axes: number[];\r\n    /**\r\n     * An array of available buttons\r\n     */\r\n    buttons: Array<{\r\n        /**\r\n         * Value of the button/trigger\r\n         */\r\n        value: number;\r\n        /**\r\n         * If the button/trigger is currently touched\r\n         */\r\n        touched: boolean;\r\n        /**\r\n         * If the button/trigger is currently pressed\r\n         */\r\n        pressed: boolean;\r\n    }>;\r\n\r\n    /**\r\n     * EXPERIMENTAL haptic support.\r\n     */\r\n    hapticActuators?: Array<{\r\n        pulse: (value: number, duration: number) => Promise<boolean>;\r\n    }>;\r\n}\r\n\r\n/**\r\n * An Abstract Motion controller\r\n * This class receives an xrInput and a profile layout and uses those to initialize the components\r\n * Each component has an observable to check for changes in value and state\r\n */\r\nexport abstract class WebXRAbstractMotionController implements IDisposable {\r\n    private _initComponent = (id: string) => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        const componentDef = this.layout.components[id];\r\n        const type = componentDef.type;\r\n        const buttonIndex = componentDef.gamepadIndices.button;\r\n        // search for axes\r\n        const axes: number[] = [];\r\n        if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\r\n            axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\r\n        }\r\n\r\n        this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\r\n    };\r\n\r\n    private _modelReady: boolean = false;\r\n\r\n    /**\r\n     * A map of components (WebXRControllerComponent) in this motion controller\r\n     * Components have a ComponentType and can also have both button and axis definitions\r\n     */\r\n    public readonly components: {\r\n        [id: string]: WebXRControllerComponent;\r\n    } = {};\r\n\r\n    /**\r\n     * Disable the model's animation. Can be set at any time.\r\n     */\r\n    public disableAnimation: boolean = false;\r\n    /**\r\n     * Observers registered here will be triggered when the model of this controller is done loading\r\n     */\r\n    public onModelLoadedObservable: Observable<WebXRAbstractMotionController> = new Observable();\r\n    /**\r\n     * The profile id of this motion controller\r\n     */\r\n    public abstract profileId: string;\r\n    /**\r\n     * The root mesh of the model. It is null if the model was not yet initialized\r\n     */\r\n    public rootMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * constructs a new abstract motion controller\r\n     * @param scene the scene to which the model of the controller will be added\r\n     * @param layout The profile layout to load\r\n     * @param gamepadObject The gamepad object correlating to this controller\r\n     * @param handedness handedness (left/right/none) of this controller\r\n     * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\r\n     * @param _controllerCache a cache holding controller models already loaded in this session\r\n     */\r\n    constructor(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected layout: IMotionControllerLayout,\r\n        /**\r\n         * The gamepad object correlating to this controller\r\n         */\r\n        public gamepadObject: IMinimalMotionControllerObject,\r\n        /**\r\n         * handedness (left/right/none) of this controller\r\n         */\r\n        public handedness: MotionControllerHandedness,\r\n        /**\r\n         * @internal\r\n         * [false]\r\n         */\r\n        public _doNotLoadControllerMesh: boolean = false,\r\n        private _controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        // initialize the components\r\n        if (layout.components) {\r\n            const keys = Object.keys(layout.components);\r\n            for (const key of keys) {\r\n                this._initComponent(key);\r\n            }\r\n        }\r\n        // Model is loaded in WebXRInput\r\n    }\r\n\r\n    /**\r\n     * Dispose this controller, the model mesh and all its components\r\n     */\r\n    public dispose(): void {\r\n        const ids = this.getComponentIds();\r\n        for (const id of ids) {\r\n            this.getComponent(id).dispose();\r\n        }\r\n        if (this.rootMesh) {\r\n            const nodes = this.rootMesh.getChildren(undefined, true);\r\n            for (const node of nodes) {\r\n                node.setEnabled(false);\r\n            }\r\n            this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);\r\n        }\r\n        this.onModelLoadedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns all components of specific type\r\n     * @param type the type to search for\r\n     * @returns an array of components with this type\r\n     */\r\n    public getAllComponentsOfType(type: MotionControllerComponentType): WebXRControllerComponent[] {\r\n        return this.getComponentIds()\r\n            .map((id) => this.components[id])\r\n            .filter((component) => component.type === type);\r\n    }\r\n\r\n    /**\r\n     * get a component based an its component id as defined in layout.components\r\n     * @param id the id of the component\r\n     * @returns the component correlates to the id or undefined if not found\r\n     */\r\n    public getComponent(id: string): WebXRControllerComponent {\r\n        return this.components[id];\r\n    }\r\n\r\n    /**\r\n     * Get the list of components available in this motion controller\r\n     * @returns an array of strings correlating to available components\r\n     */\r\n    public getComponentIds(): string[] {\r\n        return Object.keys(this.components);\r\n    }\r\n\r\n    /**\r\n     * Get the first component of specific type\r\n     * @param type type of component to find\r\n     * @returns a controller component or null if not found\r\n     */\r\n    public getComponentOfType(type: MotionControllerComponentType): Nullable<WebXRControllerComponent> {\r\n        return this.getAllComponentsOfType(type)[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Get the main (Select) component of this controller as defined in the layout\r\n     * @returns the main component of this controller\r\n     */\r\n    public getMainComponent(): WebXRControllerComponent {\r\n        return this.getComponent(this.layout.selectComponentId);\r\n    }\r\n\r\n    /**\r\n     * Loads the model correlating to this controller\r\n     * When the mesh is loaded, the onModelLoadedObservable will be triggered\r\n     * @returns A promise fulfilled with the result of the model loading\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public async loadModel(): Promise<boolean> {\r\n        const useGeneric = !this._getModelLoadingConstraints();\r\n        let loadingParams = this._getGenericFilenameAndPath();\r\n        // Checking if GLB loader is present\r\n        if (useGeneric) {\r\n            Logger.Warn(\"Falling back to generic models\");\r\n        } else {\r\n            loadingParams = this._getFilenameAndPath();\r\n        }\r\n        return await new Promise((resolve, reject) => {\r\n            const meshesLoaded = (meshes: AbstractMesh[]) => {\r\n                if (useGeneric) {\r\n                    this._getGenericParentMesh(meshes);\r\n                } else {\r\n                    this._setRootMesh(meshes);\r\n                }\r\n                this._processLoadedModel(meshes);\r\n                this._modelReady = true;\r\n                this.onModelLoadedObservable.notifyObservers(this);\r\n                resolve(true);\r\n            };\r\n            if (this._controllerCache) {\r\n                // look for it in the cache\r\n                const found = this._controllerCache.filter((c) => {\r\n                    return c.filename === loadingParams.filename && c.path === loadingParams.path;\r\n                });\r\n                if (found[0]) {\r\n                    for (const mesh of found[0].meshes) {\r\n                        mesh.setEnabled(true);\r\n                    }\r\n                    meshesLoaded(found[0].meshes);\r\n                    return;\r\n                    // found, don't continue to load\r\n                }\r\n            }\r\n            SceneLoader.ImportMesh(\r\n                \"\",\r\n                loadingParams.path,\r\n                loadingParams.filename,\r\n                this.scene,\r\n                (meshes) => {\r\n                    if (this._controllerCache) {\r\n                        this._controllerCache.push({\r\n                            ...loadingParams,\r\n                            meshes,\r\n                        });\r\n                    }\r\n                    meshesLoaded(meshes);\r\n                },\r\n                null,\r\n                (_scene: Scene, message: string) => {\r\n                    Logger.Log(message);\r\n                    Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(message);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update this model using the current XRFrame\r\n     * @param xrFrame the current xr frame to use and update the model\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame): void {\r\n        for (const id of this.getComponentIds()) {\r\n            this.getComponent(id).update(this.gamepadObject);\r\n        }\r\n        this.updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Backwards compatibility due to a deeply-integrated typo\r\n     */\r\n    public get handness() {\r\n        return this.handedness;\r\n    }\r\n\r\n    /**\r\n     * Pulse (vibrate) this controller\r\n     * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\r\n     * Consecutive calls to this function will cancel the last pulse call\r\n     *\r\n     * @param value the strength of the pulse in 0.0...1.0 range\r\n     * @param duration Duration of the pulse in milliseconds\r\n     * @param hapticActuatorIndex optional index of actuator (will usually be 0)\r\n     * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public async pulse(value: number, duration: number, hapticActuatorIndex: number = 0): Promise<boolean> {\r\n        if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\r\n            return await this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n    protected _getChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name === name, false)[0];\r\n    }\r\n\r\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n    protected _getImmediateChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name == name, true)[0];\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axisMap\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @internal\r\n     */\r\n    protected _lerpTransform(axisMap: IMotionControllerMeshMap, axisValue: number, fixValueCoordinates?: boolean): void {\r\n        if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\r\n            return;\r\n        }\r\n\r\n        if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\r\n        Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\r\n        Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\r\n    }\r\n\r\n    /**\r\n     * Update the model itself with the current frame data\r\n     * @param xrFrame the frame to use for updating the model mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected updateModel(xrFrame: XRFrame): void {\r\n        if (!this._modelReady) {\r\n            return;\r\n        }\r\n        this._updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Get the filename and path for this controller's model\r\n     * @returns a map of filename and path\r\n     */\r\n    protected abstract _getFilenameAndPath(): { filename: string; path: string };\r\n    /**\r\n     * This function is called before the mesh is loaded. It checks for loading constraints.\r\n     * For example, this function can check if the GLB loader is available\r\n     * If this function returns false, the generic controller will be loaded instead\r\n     * @returns Is the client ready to load the mesh\r\n     */\r\n    protected abstract _getModelLoadingConstraints(): boolean;\r\n    /**\r\n     * This function will be called after the model was successfully loaded and can be used\r\n     * for mesh transformations before it is available for the user\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _processLoadedModel(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * Set the root mesh for this controller. Important for the WebXR controller class\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _setRootMesh(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * A function executed each frame that updates the mesh (if needed)\r\n     * @param xrFrame the current xrFrame\r\n     */\r\n    protected abstract _updateModel(xrFrame: XRFrame): void;\r\n\r\n    private _getGenericFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    private _getGenericParentMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        for (const mesh of meshes) {\r\n            if (!mesh.parent) {\r\n                mesh.isPickable = false;\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        }\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n}\r\n", "import type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * A generic trigger-only motion controller for WebXR\r\n */\r\nexport class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {\r\n    /**\r\n     * Static version of the profile id of this controller\r\n     */\r\n    public static ProfileId = \"generic-trigger\";\r\n\r\n    public profileId = WebXRGenericTriggerMotionController.ProfileId;\r\n\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processLoadedModel(meshes: AbstractMesh[]): void {\r\n        // nothing to do\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        for (const mesh of meshes) {\r\n            mesh.isPickable = false;\r\n            if (!mesh.parent) {\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        }\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op\r\n    }\r\n}\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/master/packages/registry/profiles/generic/generic-trigger-touchpad-thumbstick.json\r\nconst GenericTriggerLayout: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, useOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n", "import type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { IMotionControllerProfile, IMotionControllerMeshMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Axis, Space } from \"../../Maths/math.axis\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\n/**\r\n * A profiled motion controller has its profile loaded from an online repository.\r\n * The class is responsible of loading the model, mapping the keys and enabling model-animations\r\n */\r\nexport class WebXRProfiledMotionController extends WebXRAbstractMotionController {\r\n    private _buttonMeshMapping: {\r\n        [buttonName: string]: {\r\n            mainMesh?: AbstractMesh;\r\n            states: {\r\n                [state: string]: IMotionControllerMeshMap;\r\n            };\r\n        };\r\n    } = {};\r\n    private _touchDots: { [visKey: string]: AbstractMesh } = {};\r\n\r\n    /**\r\n     * The profile ID of this controller. Will be populated when the controller initializes.\r\n     */\r\n    public profileId: string;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        xrInput: XRInputSource,\r\n        _profile: IMotionControllerProfile,\r\n        private _repositoryUrl: string,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        private controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        super(scene, _profile.layouts[xrInput.handedness || \"none\"], xrInput.gamepad as any, xrInput.handedness, undefined, controllerCache);\r\n        this.profileId = _profile.profileId;\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n        if (!this.controllerCache) {\r\n            const keys = Object.keys(this._touchDots);\r\n            for (const visResKey of keys) {\r\n                this._touchDots[visResKey].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: this.layout.assetPath,\r\n            path: `${this._repositoryUrl}/profiles/${this.profileId}/`,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn(\"glTF / glb loader was not registered, using generic controller instead\");\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        const ids = this.getComponentIds();\r\n\r\n        for (const type of ids) {\r\n            const componentInLayout = this.layout.components[type];\r\n            this._buttonMeshMapping[type] = {\r\n                mainMesh: this._getChildByName(this.rootMesh!, componentInLayout.rootNodeName),\r\n                states: {},\r\n            };\r\n            const keys = Object.keys(componentInLayout.visualResponses);\r\n            for (const visualResponseKey of keys) {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, visResponse.valueNodeName!),\r\n                        minMesh: this._getChildByName(this.rootMesh!, visResponse.minNodeName!),\r\n                        maxMesh: this._getChildByName(this.rootMesh!, visResponse.maxNodeName!),\r\n                    };\r\n                } else {\r\n                    // visibility, usually for touchpads\r\n                    const nameOfMesh =\r\n                        componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName\r\n                            ? componentInLayout.touchPointNodeName\r\n                            : visResponse.valueNodeName!;\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, nameOfMesh),\r\n                    };\r\n                    if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {\r\n                        const dot = CreateSphere(\r\n                            visualResponseKey + \"dot\",\r\n                            {\r\n                                diameter: 0.0015,\r\n                                segments: 8,\r\n                            },\r\n                            this.scene\r\n                        );\r\n                        dot.material = new StandardMaterial(visualResponseKey + \"mat\", this.scene);\r\n                        (<StandardMaterial>dot.material).diffuseColor = Color3.Red();\r\n                        dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;\r\n                        dot.isVisible = false;\r\n                        this._touchDots[visualResponseKey] = dot;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \"-\" + this.handedness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(_xrFrame: XRFrame): void {\r\n        if (this.disableAnimation) {\r\n            return;\r\n        }\r\n        const ids = this.getComponentIds();\r\n\r\n        for (const id of ids) {\r\n            const component = this.getComponent(id);\r\n            if (!component.hasChanges) {\r\n                continue;\r\n            }\r\n            const meshes = this._buttonMeshMapping[id];\r\n            const componentInLayout = this.layout.components[id];\r\n            const keys = Object.keys(componentInLayout.visualResponses);\r\n            for (const visualResponseKey of keys) {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                let value = component.value;\r\n                if (visResponse.componentProperty === \"xAxis\") {\r\n                    value = component.axes.x;\r\n                } else if (visResponse.componentProperty === \"yAxis\") {\r\n                    value = component.axes.y;\r\n                }\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== \"button\");\r\n                } else {\r\n                    // visibility\r\n                    const valueMesh = meshes.states[visualResponseKey].valueMesh;\r\n                    if (valueMesh) {\r\n                        valueMesh.isVisible = component.touched || component.pressed;\r\n                    }\r\n                    if (this._touchDots[visualResponseKey]) {\r\n                        this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { WebXRAbstractMotionController, IMotionControllerProfile } from \"./webXRAbstractMotionController\";\r\nimport { WebXRGenericTriggerMotionController } from \"./webXRGenericMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { WebXRProfiledMotionController } from \"./webXRProfiledMotionController\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\n\r\n/**\r\n * A construction function type to create a new controller based on an xrInput object\r\n */\r\nexport type MotionControllerConstructor = (xrInput: XRInputSource, scene: Scene) => WebXRAbstractMotionController;\r\n\r\n/**\r\n * The MotionController Manager manages all registered motion controllers and loads the right one when needed.\r\n *\r\n * When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets\r\n * it should be replaced with auto-loaded controllers.\r\n *\r\n * When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes\r\n */\r\n\r\nconst ControllerCache: Array<{\r\n    filename: string;\r\n    path: string;\r\n    meshes: AbstractMesh[];\r\n}> = [];\r\n\r\n/**\r\n * Motion controller manager is managing the different webxr profiles and makes sure the right\r\n * controller is being loaded.\r\n */\r\nexport class WebXRMotionControllerManager {\r\n    private static _AvailableControllers: { [type: string]: MotionControllerConstructor } = {};\r\n    private static _Fallbacks: { [profileId: string]: string[] } = {};\r\n    // cache for loading\r\n    private static _ProfileLoadingPromises: { [profileName: string]: Promise<IMotionControllerProfile> } = {};\r\n    private static _ProfilesList: Nullable<Promise<{ [profile: string]: string }>>;\r\n\r\n    /**\r\n     * The base URL of the online controller repository. Can be changed at any time.\r\n     */\r\n    public static BaseRepositoryUrl = \"https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist\";\r\n    /**\r\n     * Which repository gets priority - local or online\r\n     */\r\n    public static PrioritizeOnlineRepository: boolean = true;\r\n    /**\r\n     * Use the online repository, or use only locally-defined controllers\r\n     */\r\n    public static UseOnlineRepository: boolean = true;\r\n\r\n    /**\r\n     * Disable the controller cache and load the models each time a new WebXRProfileMotionController is loaded.\r\n     * Defaults to true.\r\n     */\r\n    public static DisableControllerCache: boolean = true;\r\n\r\n    /**\r\n     * Clear the cache used for profile loading and reload when requested again\r\n     */\r\n    public static ClearProfilesCache() {\r\n        this._ProfilesList = null;\r\n        this._ProfileLoadingPromises = {};\r\n    }\r\n\r\n    /**\r\n     * Register the default fallbacks.\r\n     * This function is called automatically when this file is imported.\r\n     */\r\n    public static DefaultFallbacks() {\r\n        this.RegisterFallbacksForProfileId(\"google-daydream\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive-focus\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"magicleap-one\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"windows-mixed-reality\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"microsoft-mixed-reality\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-go\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch-v2\", [\"oculus-touch\", \"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch\", [\"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-gearvr\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-odyssey\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"valve-index\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"generic-hand-select\", [\"generic-trigger\"]);\r\n    }\r\n\r\n    /**\r\n     * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.\r\n     * @param profileId the profile to which a fallback needs to be found\r\n     * @returns an array with corresponding fallback profiles\r\n     */\r\n    public static FindFallbackWithProfileId(profileId: string): string[] {\r\n        const returnArray = this._Fallbacks[profileId] || [];\r\n\r\n        returnArray.unshift(profileId);\r\n        return returnArray;\r\n    }\r\n\r\n    /**\r\n     * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.\r\n     * The order of search:\r\n     *\r\n     * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller\r\n     * 2) (If not found) search in the gamepad id and try using it (legacy versions only)\r\n     * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)\r\n     * 4) return the generic trigger controller if none were found\r\n     *\r\n     * @param xrInput the xrInput to which a new controller is initialized\r\n     * @param scene the scene to which the model will be added\r\n     * @param forceProfile force a certain profile for this controller\r\n     * @returns A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found\r\n     */\r\n    public static async GetMotionControllerWithXRInput(xrInput: XRInputSource, scene: Scene, forceProfile?: string): Promise<WebXRAbstractMotionController> {\r\n        const profileArray: string[] = [];\r\n        if (forceProfile) {\r\n            profileArray.push(forceProfile);\r\n        }\r\n        profileArray.push(...(xrInput.profiles || []));\r\n\r\n        // emulator support\r\n        if (profileArray.length && !profileArray[0]) {\r\n            // remove the first \"undefined\" that the emulator is adding\r\n            profileArray.pop();\r\n        }\r\n\r\n        // legacy support - try using the gamepad id\r\n        if (xrInput.gamepad && xrInput.gamepad.id) {\r\n            switch (xrInput.gamepad.id) {\r\n                case xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : undefined:\r\n                    // oculus in gamepad id\r\n                    profileArray.push(\"oculus-touch-v2\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // make sure microsoft/windows mixed reality works correctly\r\n        const windowsMRIdx = profileArray.indexOf(\"windows-mixed-reality\");\r\n        if (windowsMRIdx !== -1) {\r\n            profileArray.splice(windowsMRIdx, 0, \"microsoft-mixed-reality\");\r\n        }\r\n\r\n        if (!profileArray.length) {\r\n            profileArray.push(\"generic-trigger\");\r\n        }\r\n\r\n        if (this.UseOnlineRepository) {\r\n            const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepositoryAsync : this._LoadProfilesFromAvailableControllersAsync;\r\n            const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllersAsync : this._LoadProfileFromRepositoryAsync;\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {\r\n                return secondFunction.call(this, profileArray, xrInput, scene);\r\n            });\r\n        } else {\r\n            // use only available functions\r\n            return await this._LoadProfilesFromAvailableControllersAsync(profileArray, xrInput, scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new controller based on its profile. This function will be called by the controller classes themselves.\r\n     *\r\n     * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.\r\n     *\r\n     * @param type the profile type to register\r\n     * @param constructFunction the function to be called when loading this profile\r\n     */\r\n    public static RegisterController(type: string, constructFunction: MotionControllerConstructor) {\r\n        this._AvailableControllers[type] = constructFunction;\r\n    }\r\n\r\n    /**\r\n     * Register a fallback to a specific profile.\r\n     * @param profileId the profileId that will receive the fallbacks\r\n     * @param fallbacks A list of fallback profiles\r\n     */\r\n    public static RegisterFallbacksForProfileId(profileId: string, fallbacks: string[]): void {\r\n        if (this._Fallbacks[profileId]) {\r\n            this._Fallbacks[profileId].push(...fallbacks);\r\n        } else {\r\n            this._Fallbacks[profileId] = fallbacks;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will update the list of profiles available in the repository\r\n     * @returns a promise that resolves to a map of profiles available online\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static async UpdateProfilesList(): Promise<{\r\n        [profile: string]: string;\r\n    }> {\r\n        const data = await Tools.LoadFileAsync(this.BaseRepositoryUrl + \"/profiles/profilesList.json\", false);\r\n        this._ProfilesList = JSON.parse(data);\r\n        return await this._ProfilesList!;\r\n    }\r\n\r\n    /**\r\n     * Clear the controller's cache (usually happens at the end of a session)\r\n     */\r\n    public static ClearControllerCache() {\r\n        for (const cacheItem of ControllerCache) {\r\n            for (const mesh of cacheItem.meshes) {\r\n                mesh.dispose(false, true);\r\n            }\r\n        }\r\n        ControllerCache.length = 0;\r\n    }\r\n\r\n    private static async _LoadProfileFromRepositoryAsync(profileArray: string[], xrInput: XRInputSource, scene: Scene): Promise<WebXRAbstractMotionController> {\r\n        return await Promise.resolve()\r\n            // eslint-disable-next-line github/no-then\r\n            .then(async () => {\r\n                if (!this._ProfilesList) {\r\n                    return await this.UpdateProfilesList();\r\n                } else {\r\n                    return await this._ProfilesList;\r\n                }\r\n            })\r\n            // eslint-disable-next-line github/no-then\r\n            .then((profilesList: { [profile: string]: string }) => {\r\n                // load the right profile\r\n                for (let i = 0; i < profileArray.length; ++i) {\r\n                    // defensive\r\n                    if (!profileArray[i]) {\r\n                        continue;\r\n                    }\r\n                    if (profilesList[profileArray[i]]) {\r\n                        return profileArray[i];\r\n                    }\r\n                }\r\n\r\n                throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);\r\n            })\r\n            // eslint-disable-next-line github/no-then\r\n            .then(async (profileToLoad: string) => {\r\n                // load the profile\r\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n                if (!this._ProfileLoadingPromises[profileToLoad]) {\r\n                    // eslint-disable-next-line github/no-then\r\n                    this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then(\r\n                        (data) => <IMotionControllerProfile>JSON.parse(data)\r\n                    );\r\n                }\r\n                return await this._ProfileLoadingPromises[profileToLoad];\r\n            })\r\n            // eslint-disable-next-line github/no-then\r\n            .then((profile: IMotionControllerProfile) => {\r\n                return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? undefined : ControllerCache);\r\n            });\r\n    }\r\n\r\n    private static async _LoadProfilesFromAvailableControllersAsync(profileArray: string[], xrInput: XRInputSource, scene: Scene) {\r\n        // check fallbacks\r\n        for (let i = 0; i < profileArray.length; ++i) {\r\n            // defensive\r\n            if (!profileArray[i]) {\r\n                continue;\r\n            }\r\n            const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);\r\n            for (let j = 0; j < fallbacks.length; ++j) {\r\n                const constructionFunction = this._AvailableControllers[fallbacks[j]];\r\n                if (constructionFunction) {\r\n                    return constructionFunction(xrInput, scene);\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error(`no controller requested was found in the available controllers list`);\r\n    }\r\n}\r\n\r\n// register the generic profile(s) here so we will at least have them\r\nWebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRGenericTriggerMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// register fallbacks\r\nWebXRMotionControllerManager.DefaultFallbacks();\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { WebXRAbstractMotionController } from \"./motionController/webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nlet IdCount = 0;\r\n\r\n/**\r\n * Configuration options for the WebXR controller creation\r\n */\r\nexport interface IWebXRControllerOptions {\r\n    /**\r\n     * Should the controller mesh be animated when a user interacts with it\r\n     * The pressed buttons / thumbstick and touchpad animations will be disabled\r\n     */\r\n    disableMotionControllerAnimation?: boolean;\r\n    /**\r\n     * Do not load the controller mesh, in case a different mesh needs to be loaded.\r\n     */\r\n    doNotLoadControllerMesh?: boolean;\r\n    /**\r\n     * Force a specific controller type for this controller.\r\n     * This can be used when creating your own profile or when testing different controllers\r\n     */\r\n    forceControllerProfile?: string;\r\n    /**\r\n     * Defines a rendering group ID for meshes that will be loaded.\r\n     * This is for the default controllers only.\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * Represents an XR controller\r\n */\r\nexport class WebXRInputSource {\r\n    private _tmpVector = new Vector3();\r\n    private _uniqueId: string;\r\n    private _disposed = false;\r\n\r\n    /**\r\n     * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if that's the case only the pointer from the head will be available\r\n     */\r\n    public grip?: AbstractMesh;\r\n    /**\r\n     * If available, this is the gamepad object related to this controller.\r\n     * Using this object it is possible to get click events and trackpad changes of the\r\n     * webxr controller that is currently being used.\r\n     */\r\n    public motionController?: WebXRAbstractMotionController;\r\n    /**\r\n     * Event that fires when the controller is removed/disposed.\r\n     * The object provided as event data is this controller, after associated assets were disposed.\r\n     * uniqueId is still available.\r\n     */\r\n    public onDisposeObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Will be triggered when the mesh associated with the motion controller is done loading.\r\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\r\n     * A shortened version of controller -> motion controller -> on mesh loaded.\r\n     */\r\n    public onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n    /**\r\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\r\n     */\r\n    public onMotionControllerInitObservable = new Observable<WebXRAbstractMotionController>();\r\n    /**\r\n     * Pointer which can be used to select objects or attach a visible laser to\r\n     */\r\n    public pointer: AbstractMesh;\r\n\r\n    /**\r\n     * The last XRPose the was calculated on the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRPose?: XRPose;\r\n\r\n    /**\r\n     * Creates the input source object\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport\r\n     * @param _scene the scene which the controller should be associated to\r\n     * @param inputSource the underlying input source for the controller\r\n     * @param _options options for this controller creation\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        /** The underlying input source for the controller  */\r\n        public inputSource: XRInputSource,\r\n        private _options: IWebXRControllerOptions = {}\r\n    ) {\r\n        this._uniqueId = `controller-${IdCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;\r\n\r\n        this.pointer = new Mesh(`${this._uniqueId}-pointer`, _scene);\r\n        this.pointer.rotationQuaternion = new Quaternion();\r\n\r\n        if (this.inputSource.gripSpace) {\r\n            this.grip = new Mesh(`${this._uniqueId}-grip`, this._scene);\r\n            this.grip.rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n\r\n        // for now only load motion controllers if gamepad object available\r\n        if (this.inputSource.gamepad && this.inputSource.targetRayMode === \"tracked-pointer\") {\r\n            // eslint-disable-next-line github/no-then\r\n            WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(\r\n                (motionController) => {\r\n                    this.motionController = motionController;\r\n                    this.onMotionControllerInitObservable.notifyObservers(motionController);\r\n                    // should the model be loaded?\r\n                    if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        this.motionController.loadModel().then((success) => {\r\n                            if (success && this.motionController && this.motionController.rootMesh) {\r\n                                if (this._options.renderingGroupId) {\r\n                                    // anything other than 0?\r\n                                    this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;\r\n                                    const childMeshes = this.motionController.rootMesh.getChildMeshes(false);\r\n                                    for (const mesh of childMeshes) {\r\n                                        mesh.renderingGroupId = this._options.renderingGroupId!;\r\n                                    }\r\n                                }\r\n                                this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);\r\n                                this.motionController.rootMesh.parent = this.grip || this.pointer;\r\n                                this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;\r\n                            }\r\n                            // make sure to dispose is the controller is already disposed\r\n                            if (this._disposed) {\r\n                                this.motionController?.dispose();\r\n                            }\r\n                        });\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Warn(`Could not find a matching motion controller for the registered input source`);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get this controllers unique id\r\n     */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        if (this.grip) {\r\n            this.grip.dispose(true);\r\n        }\r\n        if (this.motionController) {\r\n            this.motionController.dispose();\r\n        }\r\n        this.pointer.dispose(true);\r\n        this.onMotionControllerInitObservable.clear();\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this._disposed = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a world space ray coming from the pointer or grip\r\n     * @param result the resulting ray\r\n     * @param gripIfAvailable use the grip mesh instead of the pointer, if available\r\n     */\r\n    public getWorldPointerRayToRef(result: Ray, gripIfAvailable: boolean = false) {\r\n        const object = gripIfAvailable && this.grip ? this.grip : this.pointer;\r\n        Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\r\n        result.direction.normalize();\r\n        result.origin.copyFrom(object.absolutePosition);\r\n        result.length = 1000;\r\n    }\r\n\r\n    /**\r\n     * Updates the controller pose based on the given XRFrame\r\n     * @param xrFrame xr frame to update the pose with\r\n     * @param referenceSpace reference space to use\r\n     * @param xrCamera the xr camera, used for parenting\r\n     * @param xrSessionManager the session manager used to get the world reference system\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, xrCamera: WebXRCamera, xrSessionManager: WebXRSessionManager) {\r\n        const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);\r\n        this._lastXRPose = pose;\r\n\r\n        // Update the pointer mesh\r\n        if (pose) {\r\n            const pos = pose.transform.position;\r\n            this.pointer.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n            const orientation = pose.transform.orientation;\r\n            this.pointer.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this.pointer.position.z *= -1;\r\n                this.pointer.rotationQuaternion!.z *= -1;\r\n                this.pointer.rotationQuaternion!.w *= -1;\r\n            }\r\n            this.pointer.parent = xrCamera.parent;\r\n            this.pointer.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n\r\n        // Update the grip mesh if it exists\r\n        if (this.inputSource.gripSpace && this.grip) {\r\n            const pose = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\r\n            if (pose) {\r\n                const pos = pose.transform.position;\r\n                const orientation = pose.transform.orientation;\r\n                this.grip.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\r\n                this.grip.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n                if (!this._scene.useRightHandedSystem) {\r\n                    this.grip.position.z *= -1;\r\n                    this.grip.rotationQuaternion!.z *= -1;\r\n                    this.grip.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n            this.grip.parent = xrCamera.parent;\r\n            this.grip.scaling.setAll(xrSessionManager.worldScalingFactor);\r\n        }\r\n        if (this.motionController) {\r\n            // either update buttons only or also position, if in gamepad mode\r\n            this.motionController.updateFromXRFrame(xrFrame);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IWebXRControllerOptions } from \"./webXRInputSource\";\r\nimport { WebXRInputSource } from \"./webXRInputSource\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\n\r\n/**\r\n * The schema for initialization options of the XR Input class\r\n */\r\nexport interface IWebXRInputOptions {\r\n    /**\r\n     * If set to true no model will be automatically loaded\r\n     */\r\n    doNotLoadControllerMeshes?: boolean;\r\n\r\n    /**\r\n     * If set, this profile will be used for all controllers loaded (for example \"microsoft-mixed-reality\")\r\n     * If not found, the xr input profile data will be used.\r\n     * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/\r\n     */\r\n    forceInputProfile?: string;\r\n\r\n    /**\r\n     * Do not send a request to the controller repository to load the profile.\r\n     *\r\n     * Instead, use the controllers available in babylon itself.\r\n     */\r\n    disableOnlineControllerRepository?: boolean;\r\n\r\n    /**\r\n     * A custom URL for the controllers repository\r\n     */\r\n    customControllersRepositoryURL?: string;\r\n\r\n    /**\r\n     * Should the controller model's components not move according to the user input\r\n     */\r\n    disableControllerAnimation?: boolean;\r\n\r\n    /**\r\n     * Optional options to pass to the controller. Will be overridden by the Input options where applicable\r\n     */\r\n    controllerOptions?: IWebXRControllerOptions;\r\n}\r\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\r\nexport class WebXRInput implements IDisposable {\r\n    /**\r\n     * XR controllers being tracked\r\n     */\r\n    public controllers: Array<WebXRInputSource> = [];\r\n    private _frameObserver: Nullable<Observer<any>>;\r\n    private _sessionEndedObserver: Nullable<Observer<any>>;\r\n    private _sessionInitObserver: Nullable<Observer<any>>;\r\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\r\n    public onControllerAddedObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\r\n    public onControllerRemovedObservable = new Observable<WebXRInputSource>();\r\n\r\n    /**\r\n     * Initializes the WebXRInput\r\n     * @param xrSessionManager the xr session manager for this session\r\n     * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n     * @param _options = initialization options for this xr input\r\n     */\r\n    public constructor(\r\n        /**\r\n         * the xr session manager for this session\r\n         */\r\n        public xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * the WebXR camera for this session. Mainly used for teleportation\r\n         */\r\n        public xrCamera: WebXRCamera,\r\n        private readonly _options: IWebXRInputOptions = {}\r\n    ) {\r\n        // Remove controllers when exiting XR\r\n        this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._addAndRemoveControllers(\r\n                [],\r\n                this.controllers.map((c) => {\r\n                    return c.inputSource;\r\n                })\r\n            );\r\n        });\r\n\r\n        this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {\r\n            session.addEventListener(\"inputsourceschange\", this._onInputSourcesChange);\r\n        });\r\n\r\n        this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {\r\n            // Update controller pose info\r\n            for (const controller of this.controllers) {\r\n                controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera, this.xrSessionManager);\r\n            }\r\n        });\r\n\r\n        if (this._options.customControllersRepositoryURL) {\r\n            WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;\r\n        }\r\n\r\n        WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;\r\n        if (WebXRMotionControllerManager.UseOnlineRepository) {\r\n            // pre-load the profiles list to load the controllers quicker afterwards\r\n            try {\r\n                // eslint-disable-next-line github/no-then\r\n                WebXRMotionControllerManager.UpdateProfilesList().catch(() => {\r\n                    WebXRMotionControllerManager.UseOnlineRepository = false;\r\n                });\r\n            } catch (e) {\r\n                WebXRMotionControllerManager.UseOnlineRepository = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onInputSourcesChange = (event: XRInputSourceChangeEvent) => {\r\n        this._addAndRemoveControllers(event.added, event.removed);\r\n    };\r\n\r\n    private _addAndRemoveControllers(addInputs: readonly XRInputSource[], removeInputs: readonly XRInputSource[]) {\r\n        // Add controllers if they don't already exist\r\n        const sources = this.controllers.map((c) => {\r\n            return c.inputSource;\r\n        });\r\n        for (const input of addInputs) {\r\n            if (sources.indexOf(input) === -1) {\r\n                const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {\r\n                    ...(this._options.controllerOptions || {}),\r\n                    forceControllerProfile: this._options.forceInputProfile,\r\n                    doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,\r\n                    disableMotionControllerAnimation: this._options.disableControllerAnimation,\r\n                });\r\n                this.controllers.push(controller);\r\n                this.onControllerAddedObservable.notifyObservers(controller);\r\n            }\r\n        }\r\n\r\n        // Remove and dispose of controllers to be disposed\r\n        const keepControllers: Array<WebXRInputSource> = [];\r\n        const removedControllers: Array<WebXRInputSource> = [];\r\n        for (const c of this.controllers) {\r\n            if (removeInputs.indexOf(c.inputSource) === -1) {\r\n                keepControllers.push(c);\r\n            } else {\r\n                removedControllers.push(c);\r\n            }\r\n        }\r\n        this.controllers = keepControllers;\r\n        for (const c of removedControllers) {\r\n            this.onControllerRemovedObservable.notifyObservers(c);\r\n            c.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        for (const c of this.controllers) {\r\n            c.dispose();\r\n        }\r\n        this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\r\n        this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\r\n        this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\r\n        this.onControllerAddedObservable.clear();\r\n        this.onControllerRemovedObservable.clear();\r\n\r\n        // clear the controller cache\r\n        WebXRMotionControllerManager.ClearControllerCache();\r\n    }\r\n}\r\n", "import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = (options.tessellation || 24) | 0;\r\n    const subdivisions: number = (options.subdivisions || 1) | 0;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, useOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, useOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, useOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, useOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\nMesh.CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a torus\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * diameter the diameter of the torus, optional default 1\r\n * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the torus\r\n */\r\nexport function CreateTorusVertexData(options: { diameter?: number; thickness?: number; tessellation?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }) {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const diameter = options.diameter || 1;\r\n    const thickness = options.thickness || 0.5;\r\n    const tessellation = (options.tessellation || 16) | 0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const stride = tessellation + 1;\r\n\r\n    for (let i = 0; i <= tessellation; i++) {\r\n        const u = i / tessellation;\r\n\r\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\r\n\r\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\r\n\r\n        for (let j = 0; j <= tessellation; j++) {\r\n            const v = 1 - j / tessellation;\r\n\r\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\r\n            const dx = Math.cos(innerAngle);\r\n            const dy = Math.sin(innerAngle);\r\n\r\n            // Create a vertex.\r\n            let normal = new Vector3(dx, dy, 0);\r\n            let position = normal.scale(thickness / 2);\r\n            const textureCoordinate = new Vector2(u, v);\r\n\r\n            position = Vector3.TransformCoordinates(position, transform);\r\n            normal = Vector3.TransformNormal(normal, transform);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, useOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\r\n\r\n            // And create indices for two triangles.\r\n            const nextI = (i + 1) % stride;\r\n            const nextJ = (j + 1) % stride;\r\n\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\r\n */\r\nexport function CreateTorus(\r\n    name: string,\r\n    options: { diameter?: number; thickness?: number; tessellation?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torus = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torus._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusVertexData(options);\r\n\r\n    vertexData.applyToMesh(torus, options.updatable);\r\n\r\n    return torus;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorus instead\r\n */\r\nexport const TorusBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorus,\r\n};\r\n\r\nVertexData.CreateTorus = CreateTorusVertexData;\r\n\r\nMesh.CreateTorus = (name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        diameter,\r\n        thickness,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorus(name, options, scene);\r\n};\r\n", "import { Epsilon } from \"core/Maths/math.constants\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport { BuildArray } from \"core/Misc/arrayTools\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport type { DeepImmutable, float, Nullable } from \"core/types\";\r\nimport type { Plane } from \"core/Maths/math.plane\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"core/Collisions/pickingInfo\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { _ImportHelper } from \"core/import.helper\";\r\n\r\n/**\r\n * Type used to define predicate for selecting meshes and instances (if exist)\r\n */\r\nexport type MeshPredicate = (mesh: AbstractMesh, thinInstanceIndex: number) => boolean;\r\n\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\n/**\r\n * This class allows user to customize internal picking mechanism\r\n */\r\nexport interface IPickingCustomization {\r\n    /**\r\n     * Predicate to select faces when a mesh intersection is detected\r\n     */\r\n    internalPickerForMesh?: (\r\n        pickingInfo: Nullable<PickingInfo>,\r\n        rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n        mesh: AbstractMesh,\r\n        world: Matrix,\r\n        fastCheck?: boolean,\r\n        onlyBoundingInfo?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        skipBoundingInfo?: boolean\r\n    ) => PickingInfo;\r\n}\r\n\r\n/**\r\n * Use this object to customize mesh picking behavior\r\n */\r\nexport const PickingCustomization: IPickingCustomization = {\r\n    internalPickerForMesh: undefined,\r\n};\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants)\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** [Number.MAX_VALUE] length of the ray */\r\n        public length: number = Number.MAX_VALUE,\r\n        /** [Epsilon] The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\r\n        public epsilon: number = Epsilon\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const discriminant = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = discriminant; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = discriminant; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (discriminant < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        return Ray.CreateFromToToRef(origin, end, result, world);\r\n    }\r\n\r\n    /**\r\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param result the object to store the result\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the ref ray\r\n     */\r\n    public static CreateFromToToRef(origin: Vector3, end: Vector3, result: Ray, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        result.origin.copyFrom(origin);\r\n        const direction = end.subtractToRef(origin, result.direction);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        result.length = length;\r\n        result.direction.normalize();\r\n\r\n        return Ray.TransformToRef(result, world, result);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     * @returns the updated result ray\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): Ray {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n        result.epsilon = ray.epsilon;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3.TransformCoordinatesToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3.TransformCoordinatesToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRay(scene: Scene, x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayToRef(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        return scene;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return scene;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param camera defines the camera to use for the picking\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRayInCameraSpace(scene: Scene, x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayInCameraSpaceToRef(scene: Scene, x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return scene;\r\n    }\r\n\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        throw new Error(\"Active camera not set\");\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\r\n    return scene;\r\n}\r\n\r\nfunction InternalPickForMesh(\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction InternalPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n}\r\n\r\nfunction InternalMultiPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos: PickingInfo[] = [];\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n */\r\nexport function PickWithBoundingInfo(scene: Scene, x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @param _enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns a PickingInfo\r\n */\r\nexport function Pick(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world, enableDistantPicking) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param ray The ray to use to pick meshes\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns a PickingInfo\r\n */\r\nexport function PickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param x X position on screen\r\n * @param y Y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPick(scene: Scene, x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param ray Ray to use\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRay(camera: Camera, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param refRay the ray to (re)use when setting the values\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRayToRef(camera: Camera, refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = camera.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (origin) {\r\n        refRay.origin.copyFrom(origin);\r\n    } else {\r\n        refRay.origin.copyFrom(camera.position);\r\n    }\r\n    const forward = TmpVectors.Vector3[2];\r\n    forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);\r\n    const worldForward = TmpVectors.Vector3[3];\r\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\r\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\r\n\r\n    return refRay;\r\n}\r\n\r\n/**\r\n * Initialize the minimal interdependecies between the Ray and Scene and Camera\r\n * @param sceneClass defines the scene prototype to use\r\n * @param cameraClass defines the camera prototype to use\r\n */\r\nexport function AddRayExtensions(sceneClass: typeof Scene, cameraClass: typeof Camera): void {\r\n    if (cameraClass) {\r\n        cameraClass.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n        };\r\n\r\n        cameraClass.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, refRay, length, transform, origin);\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    _ImportHelper._IsPickingAvailable = true;\r\n\r\n    sceneClass.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n        return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\n\r\nimport type { MeshPredicate, TrianglePickingPredicate, Ray } from \"./ray.core\";\r\nimport {\r\n    AddRayExtensions,\r\n    CreatePickingRayInCameraSpace,\r\n    CreatePickingRayInCameraSpaceToRef,\r\n    CreatePickingRayToRef,\r\n    MultiPick,\r\n    MultiPickWithRay,\r\n    Pick,\r\n    PickWithBoundingInfo,\r\n    PickWithRay,\r\n} from \"./ray.core\";\r\n\r\nexport * from \"./ray.core\";\r\n\r\n// Picking\r\nAddRayExtensions(Scene, Camera);\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    return CreatePickingRayInCameraSpace(this, x, y, camera);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);\r\n};\r\n\r\nScene.prototype.pickWithRay = function (ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPick = function (x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPick(this, x, y, predicate, camera, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPickWithRay(this, ray, predicate, trianglePredicate);\r\n};\r\n", "import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * This is the base class for all WebXR features.\r\n * Since most features require almost the same resources and callbacks, this class can be used to simplify the development\r\n * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class\r\n */\r\nexport abstract class WebXRAbstractFeature implements IWebXRFeature {\r\n    private _attached: boolean = false;\r\n    private _removeOnDetach: {\r\n        observer: Nullable<Observer<any>>;\r\n        observable: Observable<any>;\r\n    }[] = [];\r\n\r\n    /**\r\n     * Is this feature disposed?\r\n     */\r\n    public isDisposed: boolean = false;\r\n\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    public disableAutoAttach: boolean = false;\r\n\r\n    protected _xrNativeFeatureName: string = \"\";\r\n\r\n    /**\r\n     * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    public get xrNativeFeatureName() {\r\n        return this._xrNativeFeatureName;\r\n    }\r\n\r\n    public set xrNativeFeatureName(name: string) {\r\n        // check if feature was initialized while in session but needs to be initialized before the session starts\r\n        if (!this._xrSessionManager.isNative && name && this._xrSessionManager.inXRSession && this._xrSessionManager.enabledFeatures?.indexOf(name) === -1) {\r\n            Logger.Warn(`The feature ${name} needs to be enabled before starting the XR session. Note - It is still possible it is not supported.`);\r\n        }\r\n        this._xrNativeFeatureName = name;\r\n    }\r\n\r\n    /**\r\n     * Observers registered here will be executed when the feature is attached\r\n     */\r\n    public onFeatureAttachObservable: Observable<IWebXRFeature> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when the feature is detached\r\n     */\r\n    public onFeatureDetachObservable: Observable<IWebXRFeature> = new Observable();\r\n\r\n    /**\r\n     * The dependencies of this feature, if any\r\n     */\r\n    public dependsOn?: string[];\r\n\r\n    /**\r\n     * Construct a new (abstract) WebXR feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(protected _xrSessionManager: WebXRSessionManager) {}\r\n\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    public get attached() {\r\n        return this._attached;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful, false is failed or already attached\r\n     */\r\n    public attach(force?: boolean): boolean {\r\n        // do not attach a disposed feature\r\n        if (this.isDisposed) {\r\n            return false;\r\n        }\r\n        if (!force) {\r\n            if (this.attached) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (this.attached) {\r\n                // detach first, to be sure\r\n                this.detach();\r\n            }\r\n        }\r\n\r\n        // if this is a native WebXR feature, check if it is enabled on the session\r\n        // For now only check if not using babylon native\r\n        // vision OS doesn't support the enabledFeatures array, so just warn instead of failing\r\n        if (!this._xrSessionManager.enabledFeatures) {\r\n            Logger.Warn(\"session.enabledFeatures is not available on this device. It is possible that this feature is not supported.\");\r\n        } else if (!this._xrSessionManager.isNative && this.xrNativeFeatureName && this._xrSessionManager.enabledFeatures.indexOf(this.xrNativeFeatureName) === -1) {\r\n            return false;\r\n        }\r\n\r\n        this._attached = true;\r\n        this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));\r\n        this.onFeatureAttachObservable.notifyObservers(this);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     *\r\n     * @returns true if successful, false if failed or already detached\r\n     */\r\n    public detach(): boolean {\r\n        if (!this._attached) {\r\n            this.disableAutoAttach = true;\r\n            return false;\r\n        }\r\n        this._attached = false;\r\n        for (const toRemove of this._removeOnDetach) {\r\n            toRemove.observable.remove(toRemove.observer);\r\n        }\r\n        this.onFeatureDetachObservable.notifyObservers(this);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this.detach();\r\n        this.isDisposed = true;\r\n        this.onFeatureAttachObservable.clear();\r\n        this.onFeatureDetachObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    public isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This is used to register callbacks that will automatically be removed when detach is called.\r\n     * @param observable the observable to which the observer will be attached\r\n     * @param callback the callback to register\r\n     * @param insertFirst should the callback be executed as soon as it is registered\r\n     */\r\n    protected _addNewAttachObserver<T>(observable: Observable<T>, callback: (eventData: T, eventState: EventState) => void, insertFirst?: boolean) {\r\n        this._removeOnDetach.push({\r\n            observable,\r\n            observer: observable.add(callback, undefined, insertFirst),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code in this function will be executed on each xrFrame received from the browser.\r\n     * This function will not execute after the feature is detached.\r\n     * @param _xrFrame the current frame\r\n     */\r\n    protected abstract _onXRFrame(_xrFrame: XRFrame): void;\r\n}\r\n", "import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     * @param manualRender boolean indicating if the utility layer should render manually.\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        public readonly handleEvents: boolean = true,\r\n        manualRender = false\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                if (prePointerInfo.originalPickingInfo?.aimTransform && utilityScenePick) {\r\n                    utilityScenePick.aimTransform = prePointerInfo.originalPickingInfo.aimTransform;\r\n                    utilityScenePick.gripTransform = prePointerInfo.originalPickingInfo.gripTransform;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        if (!manualRender) {\r\n            this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n                // Only render when the render camera finishes rendering\r\n                if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                    this.render();\r\n                }\r\n            });\r\n        }\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n\r\n    /**\r\n     * Use the grip space instead of the pointer space for selection, if available.\r\n     */\r\n    forceGripIfAvailable?: boolean;\r\n\r\n    /**\r\n     * If set to true, the hand rays will be disabled and the user will be able to look and pick objects.\r\n     * This requires system support (like in the vision OS) and will not work in all systems.\r\n     * @experimental - this is an experimental feature and might change int he future\r\n     */\r\n    lookAndPickMode?: boolean;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(this._options.forceGripIfAvailable && xrController.grip ? xrController.grip : xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n            case \"transient-pointer\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRControllerPointerSelectionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n\r\n        // force look and pick mode if using WebXR on safari, assuming it is vision OS\r\n        // Only if not explicitly set. If set to false, it will not be forced\r\n        if (this._options.lookAndPickMode === undefined && (this._scene.getEngine()._badDesktopOS || this._scene.getEngine()._badOS)) {\r\n            this._options.lookAndPickMode = true;\r\n        }\r\n\r\n        // look and pick mode extra state changes\r\n        if (this._options.lookAndPickMode) {\r\n            this._options.enablePointerSelectionOnAllControllers = true;\r\n            this.displayLaserPointer = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        for (const controller of this._options.xrInput.controllers) {\r\n            this._attachController(controller);\r\n        }\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController, true);\r\n        this._addNewAttachObserver(\r\n            this._options.xrInput.onControllerRemovedObservable,\r\n            (controller) => {\r\n                // REMOVE the controller\r\n                this._detachController(controller.uniqueId);\r\n            },\r\n            true\r\n        );\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        const keys = Object.keys(this._controllers);\r\n        for (const controllerId of keys) {\r\n            this._detachController(controllerId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const keys = Object.keys(this._controllers);\r\n        for (const id of keys) {\r\n            // look and pick mode\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if (this._options.lookAndPickMode && controllerData.xrController?.inputSource.targetRayMode !== \"transient-pointer\") {\r\n                continue;\r\n            }\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                continue;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition =\r\n                    this._options.forceGripIfAvailable && controllerData.xrController.grip\r\n                        ? controllerData.xrController.grip.position\r\n                        : controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay, this._options.forceGripIfAvailable);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth() / camera.rigCameras.length, scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, camera.getTransformationMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y) &&\r\n                        this._screenCoordinatesRef.x !== Infinity &&\r\n                        this._screenCoordinatesRef.y !== Infinity\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n                controllerData.pick.originMesh = controllerData.xrController.pointer;\r\n                controllerData.tmpRay.length = controllerData.pick.distance;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                // force a pointer up if switching controllers\r\n                                // get the controller that was attached before\r\n                                const prevController = this._controllers[this._attachedController];\r\n                                if (prevController && prevController.pointerDownTriggered && !prevController.finalPointerUpTriggered) {\r\n                                    this._augmentPointerInit(pointerEventInit, prevController.id, prevController.screenCoordinates);\r\n                                    this._scene.simulatePointerUp(new PickingInfo(), {\r\n                                        pointerId: prevController.id,\r\n                                        pointerType: \"xr\",\r\n                                    });\r\n                                    prevController.finalPointerUpTriggered = true;\r\n                                }\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        controllerData.pointerDownTriggered = true;\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._xrSessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                    if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                        this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                        (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                    }\r\n                });\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            const keys = Object.keys(controllerData.eventListeners);\r\n            for (const eventName of keys) {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n", "/**\r\n * Defines the kind of connection point for node based material\r\n */\r\nexport enum NodeMaterialBlockConnectionPointTypes {\r\n    /** Float */\r\n    Float = 0x0001,\r\n    /** Int */\r\n    Int = 0x0002,\r\n    /** Vector2 */\r\n    Vector2 = 0x0004,\r\n    /** Vector3 */\r\n    Vector3 = 0x0008,\r\n    /** Vector4 */\r\n    Vector4 = 0x0010,\r\n    /** Color3 */\r\n    Color3 = 0x0020,\r\n    /** Color4 */\r\n    Color4 = 0x0040,\r\n    /** Matrix */\r\n    Matrix = 0x0080,\r\n    /** Custom object */\r\n    Object = 0x0100,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x0400,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x0800,\r\n    /** Bitmask of all types */\r\n    All = 0x0fff,\r\n}\r\n", "/**\r\n * Enum used to define the target of a block\r\n */\r\nexport enum NodeMaterialBlockTargets {\r\n    /** Vertex shader */\r\n    Vertex = 1,\r\n    /** Fragment shader */\r\n    Fragment = 2,\r\n    /** Neutral */\r\n    Neutral = 4,\r\n    /** Vertex and Fragment */\r\n    VertexAndFragment = Vertex | Fragment,\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { ShaderStore as EngineShaderStore } from \"../../Engines/shaderStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport type { _IProcessingOptions } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { WebGLShaderProcessor } from \"core/Engines/WebGL/webGLShaderProcessors\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to store node based material build state\r\n */\r\nexport class NodeMaterialBuildState {\r\n    /** Gets or sets a boolean indicating if the current state can emit uniform buffers */\r\n    public supportUniformBuffers = false;\r\n    /**\r\n     * Gets the list of emitted attributes\r\n     */\r\n    public attributes: string[] = [];\r\n    /**\r\n     * Gets the list of emitted uniforms\r\n     */\r\n    public uniforms: string[] = [];\r\n    /**\r\n     * Gets the list of emitted constants\r\n     */\r\n    public constants: string[] = [];\r\n    /**\r\n     * Gets the list of emitted samplers\r\n     */\r\n    public samplers: string[] = [];\r\n    /**\r\n     * Gets the list of emitted functions\r\n     */\r\n    public functions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted extensions\r\n     */\r\n    public extensions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted prePass outputs - if using the prepass\r\n     */\r\n    public prePassOutput: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Gets the target of the compilation state\r\n     */\r\n    public target: NodeMaterialBlockTargets;\r\n    /**\r\n     * Gets the list of emitted counters\r\n     */\r\n    public counters: { [key: string]: number } = {};\r\n\r\n    /**\r\n     * Shared data between multiple NodeMaterialBuildState instances\r\n     */\r\n    public sharedData: NodeMaterialBuildStateSharedData;\r\n\r\n    /** @internal */\r\n    public _terminalBlocks: Set<NodeMaterialBlock> = new Set();\r\n\r\n    /** @internal */\r\n    public _vertexState: NodeMaterialBuildState;\r\n\r\n    /** @internal */\r\n    public _attributeDeclaration = \"\";\r\n    /** @internal */\r\n    public _uniformDeclaration = \"\";\r\n    /** @internal */\r\n    public _constantDeclaration = \"\";\r\n    /** @internal */\r\n    public _samplerDeclaration = \"\";\r\n    /** @internal */\r\n    public _varyingTransfer = \"\";\r\n    /** @internal */\r\n    public _injectAtEnd = \"\";\r\n    /** @internal */\r\n    public _injectAtTop = \"\";\r\n    /** @internal */\r\n    public _customEntryHeader = \"\";\r\n    /** @internal */\r\n    private _repeatableContentAnchorIndex = 0;\r\n    /** @internal */\r\n    public _builtCompilationString = \"\";\r\n\r\n    /**\r\n     * Gets the emitted compilation strings\r\n     */\r\n    public compilationString = \"\";\r\n\r\n    /**\r\n     * Gets the current shader language to use\r\n     */\r\n    public get shaderLanguage() {\r\n        return this.sharedData.nodeMaterial.shaderLanguage;\r\n    }\r\n\r\n    /** Gets suffix to add behind type casting */\r\n    public get fSuffix() {\r\n        return this.shaderLanguage === ShaderLanguage.WGSL ? \"f\" : \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the processed, compiled shader code\r\n     * @param defines defines to use for the shader processing\r\n     * @returns the raw shader code used by the engine\r\n     */\r\n    public async getProcessedShaderAsync(defines: string): Promise<string> {\r\n        if (!this._builtCompilationString) {\r\n            Logger.Error(\"getProcessedShaderAsync: Shader not built yet.\");\r\n            return \"\";\r\n        }\r\n\r\n        const engine = this.sharedData.nodeMaterial.getScene().getEngine();\r\n        const options: _IProcessingOptions = {\r\n            defines: defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: this.target === NodeMaterialBlockTargets.Fragment,\r\n            shouldUseHighPrecisionShader: engine._shouldUseHighPrecisionShader,\r\n            processor: engine._getShaderProcessor(this.shaderLanguage),\r\n            supportsUniformBuffers: engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this.shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage),\r\n            version: (engine.version * 100).toString(),\r\n            platformName: engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        // Export WebGL2 shaders with WebGL1 syntax for max compatibility\r\n        if (!engine.isWebGPU && engine.version > 1.0) {\r\n            options.processor = new WebGLShaderProcessor();\r\n        }\r\n\r\n        return await new Promise((resolve) => {\r\n            Process(\r\n                this._builtCompilationString,\r\n                options,\r\n                (migratedCode, _) => {\r\n                    resolve(migratedCode);\r\n                },\r\n                engine\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Finalize the compilation strings\r\n     * @param state defines the current compilation state\r\n     */\r\n    public finalize(state: NodeMaterialBuildState) {\r\n        const emitComments = state.sharedData.emitComments;\r\n        const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;\r\n\r\n        let entryPointString = `\\n${emitComments ? \"//Entry point\\n\" : \"\"}`;\r\n        if (this._customEntryHeader) {\r\n            entryPointString += this._customEntryHeader;\r\n        } else if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            if (isFragmentMode) {\r\n                entryPointString += `@fragment\\nfn main(input: FragmentInputs) -> FragmentOutputs {\\n${this.sharedData.varyingInitializationsFragment}`;\r\n            } else {\r\n                entryPointString += `@vertex\\nfn main(input: VertexInputs) -> FragmentInputs{\\n`;\r\n            }\r\n        } else {\r\n            entryPointString += `void main(void) {\\n`;\r\n        }\r\n\r\n        this.compilationString = entryPointString + this.compilationString;\r\n\r\n        if (this._constantDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Constants\\n\" : \"\"}${this._constantDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        let functionCode = \"\";\r\n        for (const functionName in this.functions) {\r\n            functionCode += this.functions[functionName] + `\\n`;\r\n        }\r\n        this.compilationString = `\\n${functionCode}\\n${this.compilationString}`;\r\n\r\n        if (!isFragmentMode && this._varyingTransfer) {\r\n            this.compilationString = `${this.compilationString}\\n${this._varyingTransfer}`;\r\n        }\r\n\r\n        if (this._injectAtEnd) {\r\n            this.compilationString = `${this.compilationString}\\n${this._injectAtEnd}`;\r\n        }\r\n\r\n        this.compilationString = `${this.compilationString}\\n}`;\r\n\r\n        if (this.sharedData.varyingDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Varyings\\n\" : \"\"}${isFragmentMode ? this.sharedData.varyingDeclarationFragment : this.sharedData.varyingDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._samplerDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Samplers\\n\" : \"\"}${this._samplerDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._uniformDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Uniforms\\n\" : \"\"}${this._uniformDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._attributeDeclaration && !isFragmentMode) {\r\n            this.compilationString = `\\n${emitComments ? \"//Attributes\\n\" : \"\"}${this._attributeDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this.shaderLanguage !== ShaderLanguage.WGSL) {\r\n            this.compilationString = \"precision highp float;\\n\" + this.compilationString;\r\n            this.compilationString = \"#if defined(WEBGL2) || defined(WEBGPU)\\nprecision highp sampler2DArray;\\n#endif\\n\" + this.compilationString;\r\n\r\n            if (isFragmentMode) {\r\n                this.compilationString =\r\n                    \"#if defined(PREPASS)\\r\\n#extension GL_EXT_draw_buffers : require\\r\\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\\r\\nhighp vec4 gl_FragColor;\\r\\n#endif\\r\\n\" +\r\n                    this.compilationString;\r\n            }\r\n\r\n            for (const extensionName in this.extensions) {\r\n                const extension = this.extensions[extensionName];\r\n                this.compilationString = `\\n${extension}\\n${this.compilationString}`;\r\n            }\r\n        }\r\n\r\n        if (this._injectAtTop) {\r\n            this.compilationString = `${this._injectAtTop}\\n${this.compilationString}`;\r\n        }\r\n\r\n        this._builtCompilationString = this.compilationString;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _repeatableContentAnchor(): string {\r\n        return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeVariableName(prefix: string): string {\r\n        prefix = this.sharedData.formatConfig.formatVariablename(prefix);\r\n\r\n        if (this.sharedData.variableNames[prefix] === undefined) {\r\n            this.sharedData.variableNames[prefix] = 0;\r\n\r\n            // Check reserved words\r\n            if (prefix === \"output\" || prefix === \"texture\") {\r\n                return prefix + this.sharedData.variableNames[prefix];\r\n            }\r\n\r\n            return prefix;\r\n        } else {\r\n            this.sharedData.variableNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.variableNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeDefineName(prefix: string): string {\r\n        if (this.sharedData.defineNames[prefix] === undefined) {\r\n            this.sharedData.defineNames[prefix] = 0;\r\n        } else {\r\n            this.sharedData.defineNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.defineNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _excludeVariableName(name: string) {\r\n        this.sharedData.variableNames[name] = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DSampler(name: string, define = \"\", force = false, annotation?: string, unsignedSampler?: boolean, precision?: string) {\r\n        if (this.samplers.indexOf(name) < 0 || force) {\r\n            if (define) {\r\n                this._samplerDeclaration += `#if ${define}\\n`;\r\n            }\r\n\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                const unsignedSamplerPrefix = unsignedSampler ? \"u\" : \"f\";\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_2d<${unsignedSamplerPrefix}32>;\\n`;\r\n            } else {\r\n                const unsignedSamplerPrefix = unsignedSampler ? \"u\" : \"\";\r\n                const precisionDecl = precision ?? \"\";\r\n                this._samplerDeclaration += `uniform ${precisionDecl} ${unsignedSamplerPrefix}sampler2D ${name}; ${annotation ? annotation : \"\"}\\n`;\r\n            }\r\n\r\n            if (define) {\r\n                this._samplerDeclaration += `#endif\\n`;\r\n            }\r\n\r\n            if (!force) {\r\n                this.samplers.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCubeSampler(name: string, define = \"\", force = false) {\r\n        if (this.samplers.indexOf(name) < 0 || force) {\r\n            if (define) {\r\n                this._samplerDeclaration += `#if ${define}\\n`;\r\n            }\r\n\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_cube<f32>;\\n`;\r\n            } else {\r\n                this._samplerDeclaration += `uniform samplerCube ${name};\\n`;\r\n            }\r\n\r\n            if (define) {\r\n                this._samplerDeclaration += `#endif\\n`;\r\n            }\r\n\r\n            if (!force) {\r\n                this.samplers.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DArraySampler(name: string) {\r\n        if (this.samplers.indexOf(name) < 0) {\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_2d_array<f32>;\\n`;\r\n            } else {\r\n                this._samplerDeclaration += `uniform sampler2DArray ${name};\\n`;\r\n            }\r\n            this.samplers.push(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getGLType(type: NodeMaterialBlockConnectionPointTypes): string {\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderType(type: NodeMaterialBlockConnectionPointTypes) {\r\n        const isWGSL = this.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return isWGSL ? \"f32\" : \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return isWGSL ? \"i32\" : \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return isWGSL ? \"vec2f\" : \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return isWGSL ? \"vec3f\" : \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return isWGSL ? \"vec4f\" : \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return isWGSL ? \"mat4x4f\" : \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitExtension(name: string, extension: string, define: string = \"\") {\r\n        if (this.extensions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (define) {\r\n            extension = `#if ${define}\\n${extension}\\n#endif`;\r\n        }\r\n        this.extensions[name] = extension;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunction(name: string, code: string, comments: string) {\r\n        if (this.functions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        this.functions[name] = code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCodeFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n        }\r\n    ) {\r\n        const store = EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage);\r\n\r\n        if (options && options.repeatKey) {\r\n            return `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n        }\r\n\r\n        let code = store[includeName] + \"\\n\";\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        if (!options) {\r\n            return code;\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                code = code.replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunctionFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n            removeAttributes?: boolean;\r\n            removeUniforms?: boolean;\r\n            removeVaryings?: boolean;\r\n            removeIfDef?: boolean;\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n        },\r\n        storeKey: string = \"\"\r\n    ) {\r\n        const key = includeName + storeKey;\r\n        if (this.functions[key]) {\r\n            return;\r\n        }\r\n        const store = EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage);\r\n\r\n        if (!options || (!options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings)) {\r\n            if (options && options.repeatKey) {\r\n                this.functions[key] = `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n            } else {\r\n                this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? \"(\" + options?.substitutionVars + \")\" : \"\"}\\n`;\r\n            }\r\n\r\n            if (this.sharedData.emitComments) {\r\n                this.functions[key] = comments + `\\n` + this.functions[key];\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.functions[key] = store[includeName];\r\n\r\n        if (this.sharedData.emitComments) {\r\n            this.functions[key] = comments + `\\n` + this.functions[key];\r\n        }\r\n\r\n        if (options.removeIfDef) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#ifdef.+$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#endif.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#else.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#elif.*$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeAttributes) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?attribute .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeUniforms) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?uniform .*?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeVaryings) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?(varying|in) .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerTempVariable(name: string) {\r\n        if (this.sharedData.temps.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.temps.push(name);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitVaryingFromString(name: string, type: NodeMaterialBlockConnectionPointTypes, define: string = \"\", notDefine = false) {\r\n        if (this.sharedData.varyings.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.varyings.push(name);\r\n\r\n        const shaderType = this._getShaderType(type);\r\n\r\n        const emitCode = (forFragment = false) => {\r\n            let code = \"\";\r\n            if (define) {\r\n                if (define.startsWith(\"defined(\")) {\r\n                    code += `#if ${define}\\n`;\r\n                } else {\r\n                    code += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n                }\r\n            }\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                switch (shaderType) {\r\n                    case \"mat4x4f\":\r\n                        // We can't pass a matrix as a varying in WGSL, so we need to split it into 4 vectors\r\n                        code += `varying ${name}_r0: vec4f;\\n`;\r\n                        code += `varying ${name}_r1: vec4f;\\n`;\r\n                        code += `varying ${name}_r2: vec4f;\\n`;\r\n                        code += `varying ${name}_r3: vec4f;\\n`;\r\n\r\n                        if (forFragment) {\r\n                            code += `var<private> ${name}: mat4x4f;\\n`;\r\n                            this.sharedData.varyingInitializationsFragment += `${name} = mat4x4f(fragmentInputs.${name}_r0, fragmentInputs.${name}_r1, fragmentInputs.${name}_r2, fragmentInputs.${name}_r3);\\n`;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        code += `varying ${name}: ${shaderType};\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                code += `varying ${shaderType} ${name};\\n`;\r\n            }\r\n            if (define) {\r\n                code += `#endif\\n`;\r\n            }\r\n            return code;\r\n        };\r\n\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            this.sharedData.varyingDeclaration += emitCode(false);\r\n            this.sharedData.varyingDeclarationFragment += emitCode(true);\r\n        } else {\r\n            const code = emitCode();\r\n            this.sharedData.varyingDeclaration += code;\r\n            this.sharedData.varyingDeclarationFragment += code;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getVaryingName(name: string): string {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return (this.target !== NodeMaterialBlockTargets.Fragment ? \"vertexOutputs.\" : \"fragmentInputs.\") + name;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitUniformFromString(name: string, type: NodeMaterialBlockConnectionPointTypes, define: string = \"\", notDefine = false) {\r\n        if (this.uniforms.indexOf(name) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.uniforms.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this._uniformDeclaration += `#if ${define}\\n`;\r\n            } else {\r\n                this._uniformDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n            }\r\n        }\r\n        if (this.sharedData.formatConfig.getUniformAnnotation) {\r\n            this._uniformDeclaration += this.sharedData.formatConfig.getUniformAnnotation(name);\r\n        }\r\n        const shaderType = this._getShaderType(type);\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            this._uniformDeclaration += `uniform ${name}: ${shaderType};\\n`;\r\n        } else {\r\n            this._uniformDeclaration += `uniform ${shaderType} ${name};\\n`;\r\n        }\r\n        if (define) {\r\n            this._uniformDeclaration += `#endif\\n`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTernary(trueStatement: string, falseStatement: string, condition: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `select(${falseStatement}, ${trueStatement}, ${condition})`;\r\n        }\r\n\r\n        return `(${condition}) ? ${trueStatement} : ${falseStatement}`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFloat(value: number) {\r\n        if (value.toString() === value.toFixed(0)) {\r\n            return `${value}.0`;\r\n        }\r\n\r\n        return value.toString();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _declareOutput(output: NodeMaterialConnectionPoint, isConst?: boolean): string {\r\n        return this._declareLocalVar(output.associatedVariableName, output.type, isConst);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _declareLocalVar(name: string, type: NodeMaterialBlockConnectionPointTypes, isConst?: boolean): string {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${isConst ? \"const\" : \"var\"} ${name}: ${this._getShaderType(type)}`;\r\n        } else {\r\n            return `${isConst ? \"const \" : \"\"}${this._getShaderType(type)} ${name}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerCubeFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSample\";\r\n        }\r\n        return \"textureCube\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSample\";\r\n        }\r\n        return \"texture2D\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerLODFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSampleLevel\";\r\n        }\r\n        return \"texture2DLodEXT\";\r\n    }\r\n\r\n    public _toLinearSpace(output: NodeMaterialConnectionPoint) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            if (output.type === NodeMaterialBlockConnectionPointTypes.Color3 || output.type === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                return `toLinearSpaceVec3(${output.associatedVariableName})`;\r\n            }\r\n\r\n            return `toLinearSpace(${output.associatedVariableName})`;\r\n        }\r\n        return `toLinearSpace(${output.associatedVariableName})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSample(uv: string, samplerName: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv})`;\r\n        }\r\n        return `${this._samplerFunc()}(${samplerName}, ${uv})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleLOD(uv: string, samplerName: string, lod: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerLODFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv}, ${lod})`;\r\n        }\r\n        return `${this._samplerLODFunc()}(${samplerName}, ${uv}, ${lod})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleCube(uv: string, samplerName: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerCubeFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv})`;\r\n        }\r\n        return `${this._samplerCubeFunc()}(${samplerName}, ${uv})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleCubeLOD(uv: string, samplerName: string, lod: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerCubeFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv}, ${lod})`;\r\n        }\r\n        return `${this._samplerCubeFunc()}(${samplerName}, ${uv}, ${lod})`;\r\n    }\r\n\r\n    private _convertVariableDeclarationToWGSL(type: string, dest: string, source: string): string {\r\n        return source.replace(new RegExp(`(${type})\\\\s+(\\\\w+)`, \"g\"), `var $2: ${dest}`);\r\n    }\r\n\r\n    private _convertVariableConstructorsToWGSL(type: string, dest: string, source: string): string {\r\n        return source.replace(new RegExp(`(${type})\\\\(`, \"g\"), ` ${dest}(`);\r\n    }\r\n\r\n    private _convertOutParametersToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`out\\\\s+var\\\\s+(\\\\w+)\\\\s*:\\\\s*(\\\\w+)`, \"g\"), `$1: ptr<function, $2>`);\r\n    }\r\n\r\n    private _convertTernaryOperandsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`\\\\[(.*?)\\\\?(.*?):(.*)\\\\]`, \"g\"), (match, condition, trueCase, falseCase) => `select(${falseCase}, ${trueCase}, ${condition})`);\r\n    }\r\n\r\n    private _convertModOperatorsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`mod\\\\((.+?),\\\\s*(.+?)\\\\)`, \"g\"), (match, left, right) => `((${left})%(${right}))`);\r\n    }\r\n\r\n    private _convertConstToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`const var`, \"g\"), `const`);\r\n    }\r\n\r\n    private _convertInnerFunctionsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`inversesqrt`, \"g\"), `inverseSqrt`);\r\n    }\r\n\r\n    private _convertFunctionsToWGSL(source: string): string {\r\n        const regex = /var\\s+(\\w+)\\s*:\\s*(\\w+)\\((.*)\\)/g;\r\n\r\n        let match: RegExpMatchArray | null;\r\n        while ((match = regex.exec(source)) !== null) {\r\n            const funcName = match[1];\r\n            const funcType = match[2];\r\n            const params = match[3]; // All parameters as a single string\r\n\r\n            // Processing the parameters to match 'name: type' format\r\n            const formattedParams = params.replace(/var\\s/g, \"\");\r\n\r\n            // Constructing the final output string\r\n            source = source.replace(match[0], `fn ${funcName}(${formattedParams}) -> ${funcType}`);\r\n        }\r\n        return source;\r\n    }\r\n\r\n    public _babylonSLtoWGSL(code: string) {\r\n        // variable declarations\r\n        code = this._convertVariableDeclarationToWGSL(\"void\", \"voidnull\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"bool\", \"bool\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"int\", \"i32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"uint\", \"u32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"float\", \"f32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec2\", \"vec2f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec3\", \"vec3f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec4\", \"vec4f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat2\", \"mat2x2f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat3\", \"mat3x3f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat4\", \"mat4x4f\", code);\r\n\r\n        // Type constructors\r\n        code = this._convertVariableConstructorsToWGSL(\"float\", \"f32\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec2\", \"vec2f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec3\", \"vec3f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec4\", \"vec4f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat2\", \"mat2x2f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat3\", \"mat3x3f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat4\", \"mat4x4f\", code);\r\n\r\n        // Ternary operands\r\n        code = this._convertTernaryOperandsToWGSL(code);\r\n\r\n        // Mod operators\r\n        code = this._convertModOperatorsToWGSL(code);\r\n\r\n        // Const\r\n        code = this._convertConstToWGSL(code);\r\n\r\n        // Inner functions\r\n        code = this._convertInnerFunctionsToWGSL(code);\r\n\r\n        // Out paramters\r\n        code = this._convertOutParametersToWGSL(code);\r\n        code = code.replace(/\\[\\*\\]/g, \"*\");\r\n\r\n        // Functions\r\n        code = this._convertFunctionsToWGSL(code);\r\n\r\n        // Remove voidnull\r\n        code = code.replace(/\\s->\\svoidnull/g, \"\");\r\n\r\n        // Derivatives\r\n        code = code.replace(/dFdx/g, \"dpdx\");\r\n        code = code.replace(/dFdy/g, \"dpdy\");\r\n\r\n        return code;\r\n    }\r\n\r\n    private _convertTernaryOperandsToGLSL(source: string): string {\r\n        return source.replace(new RegExp(`\\\\[(.+?)\\\\?(.+?):(.+)\\\\]`, \"g\"), (match, condition, trueCase, falseCase) => `${condition} ? ${trueCase} : ${falseCase}`);\r\n    }\r\n\r\n    public _babylonSLtoGLSL(code: string) {\r\n        /** Remove BSL specifics */\r\n        code = code.replace(/\\[\\*\\]/g, \"\");\r\n        code = this._convertTernaryOperandsToGLSL(code);\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Immutable, Nullable } from \"../../types\";\r\nimport type { NodeMaterial, NodeMaterialTextureBlocks } from \"./nodeMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n     * The node material we are currently building\r\n     */\r\n    public nodeMaterial: NodeMaterial;\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public temps: string[] = [];\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings: string[] = [];\r\n\r\n    /**\r\n     * Gets the varying declaration string (for vertex shader)\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * Gets the varying declaration string (for fragment shader)\r\n     * This is potentially different from varyingDeclaration only in WebGPU\r\n     */\r\n    public varyingDeclarationFragment = \"\";\r\n\r\n    /**\r\n     * Gets the varying initialization string (for fragment shader)\r\n     * Only used in WebGPU, to reconstruct the varying values from the vertex shader if their types is mat4x4f\r\n     */\r\n    public varyingInitializationsFragment = \"\";\r\n\r\n    /**\r\n     * List of the fragment output nodes\r\n     */\r\n    public fragmentOutputNodes: Immutable<Array<NodeMaterialBlock>>;\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks: InputBlock[] = [];\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\r\n     */\r\n    public forcedBindableBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a repeatable content\r\n     */\r\n    public repeatableContentBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a dynamic list of uniforms\r\n     */\r\n    public dynamicUniformBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs: InputBlock[] = [];\r\n\r\n    /**\r\n     * Configurations used to format the generated code\r\n     */\r\n    public formatConfig = {\r\n        getUniformAnnotation: null as Nullable<(name: string) => string>,\r\n        formatVariablename: (name: string) => name.replace(/[^a-zA-Z_]+/g, \"\"),\r\n    };\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false,\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>(),\r\n        customErrors: new Array<string>(),\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Push a new error to the build state, avoiding exceptions that can break the build process\r\n     * @param message defines the error message to push\r\n     */\r\n    public raiseBuildError(message: string) {\r\n        if (this.checks.customErrors.indexOf(message) !== -1) {\r\n            this.checks.customErrors.push(message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     * @returns true if all checks pass\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.\\n\";\r\n        }\r\n        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n        for (const customError of this.checks.customErrors) {\r\n            errorMessage += customError + \"\\n\";\r\n        }\r\n\r\n        if (errorMessage) {\r\n            errorMessage = \"Node material build failed: \\n\" + errorMessage;\r\n            Logger.Error(errorMessage);\r\n            this.nodeMaterial.onBuildErrorObservable.notifyObservers(errorMessage);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport const enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport const enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isInactive: boolean = false;\r\n\r\n    /**\r\n     * Boolean used to provide visual clue to users when some ports are not active in the current block configuration\r\n     */\r\n    public get isInactive(): boolean {\r\n        return this._isInactive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preventBubbleUp = false;\r\n\r\n    /** @internal */\r\n    public readonly _ownerBlock: NodeMaterialBlock;\r\n\r\n    private _connectedPointBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _connectedPointTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    private get _connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPointBackingField;\r\n    }\r\n\r\n    private set _connectedPoint(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._connectedPointBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._connectedPointTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._connectedPointBackingField = value));\r\n        if (this._connectedPointBackingField) {\r\n            this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    private readonly _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private readonly _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @internal */\r\n    public _redirectedSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _typeConnectionSourceBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _typeConnectionSourceTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    /** @internal */\r\n    public get _typeConnectionSource(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._typeConnectionSourceBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _typeConnectionSource(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._typeConnectionSourceBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._typeConnectionSourceTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._typeConnectionSourceBackingField = value));\r\n        if (this._typeConnectionSourceBackingField) {\r\n            this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _defaultConnectionPointTypeBackingField: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @internal */\r\n    public get _defaultConnectionPointType(): Nullable<NodeMaterialBlockConnectionPointTypes> {\r\n        return this._defaultConnectionPointTypeBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _defaultConnectionPointType(value: Nullable<NodeMaterialBlockConnectionPointTypes>) {\r\n        this._updateTypeDependentState(() => (this._defaultConnectionPointTypeBackingField = value));\r\n    }\r\n\r\n    /** @internal */\r\n    public _isMainLinkSource = false;\r\n\r\n    private _linkedConnectionSourceBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _linkedConnectionSourceTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    /** @internal */\r\n    public get _linkedConnectionSource(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._linkedConnectionSourceBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _linkedConnectionSource(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._linkedConnectionSourceBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._linkedConnectionSourceTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._linkedConnectionSourceBackingField = value));\r\n        this._isMainLinkSource = false;\r\n        if (this._linkedConnectionSourceBackingField) {\r\n            this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @internal */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** @internal */\r\n    public _forPostBuild = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public readonly onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when this point is disconnected\r\n     */\r\n    public readonly onDisconnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when the type of the connection point is changed\r\n     */\r\n    public readonly onTypeChangedObservable = new Observable<NodeMaterialBlockConnectionPointTypes>();\r\n    private _isTypeChangeObservableNotifying = false;\r\n\r\n    /**\r\n     * Gets the declaration variable name in the shader\r\n     */\r\n    public get declarationVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).declarationVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.declarationVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource) {\r\n                if (this._linkedConnectionSource.isConnected) {\r\n                    if (this._linkedConnectionSource.connectedPoint!._redirectedSource && this._linkedConnectionSource.connectedPoint!._redirectedSource.isConnected) {\r\n                        return this._linkedConnectionSource.connectedPoint!._redirectedSource.type;\r\n                    }\r\n                    return this._linkedConnectionSource.type;\r\n                }\r\n                if (this._linkedConnectionSource._defaultConnectionPointType) {\r\n                    return this._linkedConnectionSource._defaultConnectionPointType;\r\n                }\r\n            }\r\n\r\n            if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._updateTypeDependentState(() => (this._type = value));\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public readonly name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @internal */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.isConnectedInFragmentShader()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `Cannot connect these two connectors. source: \"${this.ownerBlock.name}\".${this.name}, target: \"${connectionPoint.ownerBlock.name}\".${connectionPoint.name}`;\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n\r\n        this.onDisconnectionObservable.notifyObservers(endpoint);\r\n        endpoint.onDisconnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        if (this.displayName) {\r\n            serializationObject.displayName = this.displayName;\r\n        }\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n        this.onDisconnectionObservable.clear();\r\n        this.onTypeChangedObservable.clear();\r\n\r\n        this._connectedPoint = null;\r\n        this._typeConnectionSource = null;\r\n        this._linkedConnectionSource = null;\r\n    }\r\n\r\n    private _updateTypeDependentState(update: () => void) {\r\n        const previousType = this.type;\r\n        update();\r\n        if (this.type !== previousType) {\r\n            this._notifyTypeChanged();\r\n        }\r\n    }\r\n\r\n    private _notifyTypeChanged() {\r\n        // Disallow re-entrancy\r\n        if (this._isTypeChangeObservableNotifying) {\r\n            return;\r\n        }\r\n\r\n        this._isTypeChangeObservableNotifying = true;\r\n        this.onTypeChangedObservable.notifyObservers(this.type);\r\n        this._isTypeChangeObservableNotifying = false;\r\n    }\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _isLoop = false;\r\n    private _isTeleportOut = false;\r\n    private _isTeleportIn = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n    protected _codeIsReady = true;\r\n    /** @internal */\r\n    public _isFinalOutput = false;\r\n\r\n    /** @internal */\r\n    public get _isFinalOutputAndActive() {\r\n        return this._isFinalOutput;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _hasPrecedence() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the block code is ready (if the code loading is async)\r\n     */\r\n    public onCodeIsReadyObservable = new Observable<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block has is code ready to be used\r\n     */\r\n    public get codeIsReady() {\r\n        return this._codeIsReady;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a loop\r\n     */\r\n    public get isLoop(): boolean {\r\n        return this._isLoop;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isFinalOutput defines a boolean indicating that this block is generating a final output and no other block should be generated after\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isFinalOutput = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isFinalOutput = isFinalOutput;\r\n        switch (this.getClassName()) {\r\n            case \"InputBlock\":\r\n                this._isInput = true;\r\n                break;\r\n            case \"NodeMaterialTeleportOutBlock\":\r\n                this._isTeleportOut = true;\r\n                break;\r\n            case \"NodeMaterialTeleportInBlock\":\r\n                this._isTeleportIn = true;\r\n                break;\r\n            case \"LoopBlock\":\r\n                this._isLoop = true;\r\n                break;\r\n        }\r\n\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setInitialTarget(target: NodeMaterialBlockTargets): void {\r\n        this._target = target;\r\n        // marked as read only\r\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\r\n        (this._originalTargetIsNeutral as boolean) = target === NodeMaterialBlockTargets.Neutral;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader\r\n     * @returns true if connected in fragment shader\r\n     */\r\n    public isConnectedInFragmentShader() {\r\n        return this.outputs.some((o) => o.isConnectedInFragmentShader);\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (\r\n                    !forOutput ||\r\n                    forOutput.type === input.type ||\r\n                    input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect ||\r\n                    input.acceptedConnectionPointTypes.indexOf(forOutput.type) !== -1\r\n                ) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _postBuildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(fallbacks: EffectFallbacks, mesh?: AbstractMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param defines defines the material defines to update\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, defines: NodeMaterialDefines, mesh?: AbstractMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n            this._inputs[inputIndex0]._isMainLinkSource = true;\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (block.isTeleportOut && (block as NodeMaterialTeleportOutBlock).entryPoint?.isConnectedToUniform) {\r\n            // In that case, we skip the context switch as the teleport out block is connected to a uniform\r\n            return;\r\n        }\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.declarationVariableName, connectedPoint.type)) {\r\n                    const prefix = state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\";\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL && connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Matrix) {\r\n                        // We can't pass a matrix as a varying in WGSL, so we need to split it into 4 vectors\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r0 = ${connectedPoint.associatedVariableName}[0];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r1 = ${connectedPoint.associatedVariableName}[1];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r2 = ${connectedPoint.associatedVariableName}[2];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r3 = ${connectedPoint.associatedVariableName}[3];\\n`;\r\n                    } else {\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName} = ${connectedPoint.associatedVariableName};\\n`;\r\n                    }\r\n                }\r\n                const prefix = state.shaderLanguage === ShaderLanguage.WGSL && connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Matrix ? \"fragmentInputs.\" : \"\";\r\n                input.associatedVariableName = prefix + \"v_\" + connectedPoint.declarationVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"postprocess_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state, activeBlocks);\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\n//${this.name}\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if (output._forPostBuild) {\r\n                continue;\r\n            }\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block) {\r\n                    if (((block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) || state._terminalBlocks.has(block)) {\r\n                        this._processBuild(block, state, endpoint, activeBlocks);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._postBuildBlock(state);\r\n\r\n        // Compile post build connected blocks\r\n        for (const output of this._outputs) {\r\n            if (!output._forPostBuild) {\r\n                continue;\r\n            }\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string, urlRewriter?: (url: string) => string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            for (let i = 0; i < serializedInputs.length; i++) {\r\n                const port = serializedInputs[i];\r\n\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            }\r\n        }\r\n        if (serializedOutputs) {\r\n            for (let i = 0; i < serializedOutputs.length; i++) {\r\n                const port = serializedOutputs[i];\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onCodeIsReadyObservable.clear();\r\n\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Enum defining the type of properties that can be edited in the property pages in the node editor\r\n */\r\nexport const enum PropertyTypeForEdition {\r\n    /** property is a boolean */\r\n    Boolean,\r\n    /** property is a float */\r\n    Float,\r\n    /** property is a int */\r\n    Int,\r\n    /** property is a Vector2 */\r\n    Vector2,\r\n    /** property is a list of values */\r\n    List,\r\n    /** property is a Color4 */\r\n    Color4,\r\n    /** property (int) should be edited as a combo box with a list of sampling modes */\r\n    SamplingMode,\r\n    /** property (int) should be edited as a combo box with a list of texture formats */\r\n    TextureFormat,\r\n    /** property (int) should be edited as a combo box with a list of texture types */\r\n    TextureType,\r\n}\r\n\r\n/**\r\n * Interface that defines an option in a variable of type list\r\n */\r\nexport interface IEditablePropertyListOption {\r\n    /** label of the option */\r\n    label: string;\r\n    /** value of the option */\r\n    value: number;\r\n}\r\n\r\n/**\r\n * Interface that defines the options available for an editable property\r\n */\r\nexport interface IEditablePropertyOption {\r\n    /**\r\n     * Define if the property is displayed inside the source block or in a separate property tab\r\n     */\r\n    embedded?: boolean;\r\n    /** min value */\r\n    min?: number;\r\n    /** max value */\r\n    max?: number;\r\n    /** notifiers: indicates which actions to take when the property is changed */\r\n    notifiers?: {\r\n        /** the entity should be rebuilt */\r\n        rebuild?: boolean;\r\n        /** the preview should be updated */\r\n        update?: boolean;\r\n        /** the onPreviewCommandActivated observer of the preview manager should be triggered */\r\n        activatePreviewCommand?: boolean;\r\n        /** a callback to trigger */\r\n        callback?: (scene: Nullable<Scene>, block: any) => boolean | undefined | void;\r\n        /** a callback to validate the property. Returns true if the property is ok, else false. If false, the rebuild/update/callback events won't be called */\r\n        onValidation?: (block: any, propertyName: string) => boolean;\r\n    };\r\n    /** list of the options for a variable of type list */\r\n    options?: IEditablePropertyListOption[];\r\n}\r\n\r\n/**\r\n * Interface that describes an editable property\r\n */\r\nexport interface IPropertyDescriptionForEdition {\r\n    /** name of the property */\r\n    propertyName: string;\r\n    /** display name of the property */\r\n    displayName: string;\r\n    /** type of the property */\r\n    type: PropertyTypeForEdition;\r\n    /** group of the property - all properties with the same group value will be displayed in a specific section */\r\n    groupName: string;\r\n    /** options for the property */\r\n    options: IEditablePropertyOption;\r\n    /** name of the class that contains the property */\r\n    className: string;\r\n}\r\n\r\n/**\r\n * Decorator that flags a property in a node block as being editable\r\n * @param displayName the display name of the property\r\n * @param propertyType the type of the property\r\n * @param groupName the group name of the property\r\n * @param options the options of the property\r\n * @returns the decorator\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function editableInPropertyPage(\r\n    displayName: string,\r\n    propertyType: PropertyTypeForEdition = PropertyTypeForEdition.Boolean,\r\n    groupName: string = \"PROPERTIES\",\r\n    options?: IEditablePropertyOption\r\n) {\r\n    return (target: any, propertyKey: string) => {\r\n        let propStore: IPropertyDescriptionForEdition[] = target._propStore;\r\n        if (!propStore) {\r\n            propStore = [];\r\n            target._propStore = propStore;\r\n        }\r\n        propStore.push({\r\n            propertyName: propertyKey,\r\n            displayName: displayName,\r\n            type: propertyType,\r\n            groupName: groupName,\r\n            options: options ?? {},\r\n            className: target.getClassName(),\r\n        });\r\n    };\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { BindLogDepth } from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Color spaces supported by the fragment output block\r\n */\r\nexport enum FragmentOutputBlockColorSpace {\r\n    /** Unspecified */\r\n    NoColorSpace,\r\n    /** Gamma */\r\n    Gamma,\r\n    /** Linear */\r\n    Linear,\r\n}\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _additionalColorDefineName: string;\r\n    protected _outputString: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"glow\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true })\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets or sets the color space used for the block\r\n     */\r\n    @editableInPropertyPage(\"Color space\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"No color space\", value: FragmentOutputBlockColorSpace.NoColorSpace },\r\n            { label: \"Gamma\", value: FragmentOutputBlockColorSpace.Gamma },\r\n            { label: \"Linear\", value: FragmentOutputBlockColorSpace.Linear },\r\n        ],\r\n    })\r\n    public get colorSpace() {\r\n        if (this.convertToGammaSpace) {\r\n            return FragmentOutputBlockColorSpace.Gamma;\r\n        }\r\n        if (this.convertToLinearSpace) {\r\n            return FragmentOutputBlockColorSpace.Linear;\r\n        }\r\n        return FragmentOutputBlockColorSpace.NoColorSpace;\r\n    }\r\n\r\n    public set colorSpace(value: FragmentOutputBlockColorSpace) {\r\n        this.convertToGammaSpace = value === FragmentOutputBlockColorSpace.Gamma;\r\n        this.convertToLinearSpace = value === FragmentOutputBlockColorSpace.Linear;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the additionalColor input component (named glow in the UI for now)\r\n     */\r\n    public get additionalColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    protected _getOutputString(state: NodeMaterialBuildState): string {\r\n        return state.shaderLanguage === ShaderLanguage.WGSL ? \"fragmentOutputsColor\" : \"gl_FragColor\";\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._additionalColorDefineName, this.additionalColor.connectedPoint && nodeMaterial._useAdditionalColor, true);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {\r\n            BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n        const additionalColor = this.additionalColor;\r\n\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state._emitVaryingFromString(\"vFragmentDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            state._excludeVariableName(\"useAdditionalColor\");\r\n            state._emitUniformFromString(\"useAdditionalColor\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            this._additionalColorDefineName = state._getFreeDefineName(\"USEADDITIONALCOLOR\");\r\n        }\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        const outputString = this._getOutputString(state);\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `var ${outputString} : vec4<f32>;\\r\\n`;\r\n        }\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n            state.compilationString += `#ifdef ${this._additionalColorDefineName}\\n`;\r\n            if (additionalColor.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n            state.compilationString += `#else\\n`;\r\n        }\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `${outputString} = ${vec4}(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${rgba.associatedVariableName};\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            state.compilationString += `#endif\\n`;\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${outputString}  = toLinearSpace(${outputString});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${outputString}  = toGammaSpace(${outputString});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `#if !defined(PREPASS)\\r\\n`;\r\n            state.compilationString += `fragmentOutputs.color = ${outputString};\\r\\n`;\r\n            state.compilationString += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\r\n            const fragDepth = isWebGPU ? \"input.vFragmentDepth\" : \"vFragmentDepth\";\r\n            const uniformP = isWebGPU ? \"uniforms.\" : \"\";\r\n            const output = isWebGPU ? \"fragmentOutputs.fragDepth\" : \"gl_FragDepthEXT\";\r\n\r\n            state.compilationString += `${output} = log2(${fragDepth}) * ${uniformP}logarithmicDepthConstant * 0.5;\\n`;\r\n        }\r\n\r\n        state.compilationString += `#if defined(PREPASS)\\r\\n`;\r\n        state.compilationString += `${isWebGPU ? \"fragmentOutputs.fragData0\" : \"gl_FragData[0]\"} = ${outputString};\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n", "/**\r\n * Enum used to define the material modes\r\n */\r\nexport enum NodeMaterialModes {\r\n    /** Regular material */\r\n    Material = 0,\r\n    /** For post process */\r\n    PostProcess = 1,\r\n    /** For particle system */\r\n    Particle = 2,\r\n    /** For procedural texture */\r\n    ProceduralTexture = 3,\r\n    /** For gaussian splatting */\r\n    GaussianSplatting = 4,\r\n    /** For SFE */\r\n    SFE = 5,\r\n}\r\n", "/**\r\n * Enum used to define system values e.g. values automatically provided by the system\r\n */\r\nexport enum NodeMaterialSystemValues {\r\n    /** World */\r\n    World = 1,\r\n    /** View */\r\n    View = 2,\r\n    /** Projection */\r\n    Projection = 3,\r\n    /** ViewProjection */\r\n    ViewProjection = 4,\r\n    /** WorldView */\r\n    WorldView = 5,\r\n    /** WorldViewProjection */\r\n    WorldViewProjection = 6,\r\n    /** CameraPosition */\r\n    CameraPosition = 7,\r\n    /** Fog Color */\r\n    FogColor = 8,\r\n    /** Delta time */\r\n    DeltaTime = 9,\r\n    /** Camera parameters */\r\n    CameraParameters = 10,\r\n    /** Material alpha */\r\n    MaterialAlpha = 11,\r\n    /** Projection */\r\n    ProjectionInverse = 12,\r\n}\r\n", "/**\r\n * Enum defining the type of animations supported by InputBlock\r\n */\r\nexport enum AnimatedInputBlockTypes {\r\n    /** No animation */\r\n    None,\r\n    /** Time based animation (is incremented by 0.6 each second). Will only work for floats */\r\n    Time,\r\n    /** Time elapsed (in seconds) since the engine was initialized. Will only work for floats */\r\n    RealTime,\r\n    MouseInfo,\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Effect } from \"../../../../Materials/effect\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Color3, Color4, TmpColors, TmpVectors } from \"../../../../Maths/math\";\r\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes\";\r\nimport { Observable } from \"../../../../Misc/observable\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { PrecisionDate } from \"../../../../Misc/precisionDate\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\nconst remapAttributeName: { [name: string]: string } = {\r\n    position2d: \"position\",\r\n    // From particle.vertex:\r\n    particle_uv: \"vUV\",\r\n    particle_color: \"vColor\",\r\n    particle_texturemask: \"textureMask\",\r\n    particle_positionw: \"vPositionW\",\r\n    // From postprocess.vertex:\r\n    postprocess_uv: \"vUV\",\r\n};\r\n\r\nconst attributeInFragmentOnly: { [name: string]: boolean } = {\r\n    particle_uv: true,\r\n    particle_color: true,\r\n    particle_texturemask: true,\r\n    particle_positionw: true,\r\n    postprocess_uv: true,\r\n};\r\n\r\nconst attributeAsUniform: { [name: string]: boolean } = {\r\n    particle_texturemask: true,\r\n};\r\n\r\nconst attributeDefine: { [name: string]: string } = {\r\n    normal: \"NORMAL\",\r\n    tangent: \"TANGENT\",\r\n    uv: \"UV1\",\r\n    uv2: \"UV2\",\r\n    uv3: \"UV3\",\r\n    uv4: \"UV4\",\r\n    uv5: \"UV5\",\r\n    uv6: \"UV6\",\r\n    uv7: \"UV7\",\r\n    uv8: \"UV8\",\r\n};\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class InputBlock extends NodeMaterialBlock {\r\n    private _mode = NodeMaterialBlockConnectionPointMode.Undefined;\r\n    private _associatedVariableName: string;\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeMaterialBlockConnectionPointTypes;\r\n    private _animationType = AnimatedInputBlockTypes.None;\r\n    private _prefix = \"\";\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\r\n    public isBoolean: boolean = false;\r\n\r\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\r\n    public matrixMode: number = 0;\r\n\r\n    /** @internal */\r\n    public _systemValue: Nullable<NodeMaterialSystemValues> = null;\r\n\r\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\r\n    public isConstant = false;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<InputBlock>();\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.isUniform && this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Color3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case \"Color4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isAttribute) {\r\n                switch (this.name) {\r\n                    case \"splatIndex\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case \"position\":\r\n                    case \"normal\":\r\n                    case \"particle_positionw\":\r\n                    case \"splatPosition\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"uv\":\r\n                    case \"uv2\":\r\n                    case \"uv3\":\r\n                    case \"uv4\":\r\n                    case \"uv5\":\r\n                    case \"uv6\":\r\n                    case \"position2d\":\r\n                    case \"particle_uv\":\r\n                    case \"splatScale\":\r\n                    case \"postprocess_uv\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"matricesIndices\":\r\n                    case \"matricesWeights\":\r\n                    case \"matricesIndicesExtra\":\r\n                    case \"matricesWeightsExtra\":\r\n                    case \"world0\":\r\n                    case \"world1\":\r\n                    case \"world2\":\r\n                    case \"world3\":\r\n                    case \"tangent\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"color\":\r\n                    case \"instanceColor\":\r\n                    case \"particle_color\":\r\n                    case \"particle_texturemask\":\r\n                    case \"splatColor\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isSystemValue) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.World:\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                    case NodeMaterialSystemValues.View:\r\n                    case NodeMaterialSystemValues.ViewProjection:\r\n                    case NodeMaterialSystemValues.Projection:\r\n                    case NodeMaterialSystemValues.ProjectionInverse:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraPosition:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.FogColor:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.DeltaTime:\r\n                    case NodeMaterialSystemValues.MaterialAlpha:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraParameters:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, type: NodeMaterialBlockConnectionPointTypes = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n        super(name, target, false);\r\n\r\n        this._type = type;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Validates if a name is a reserve word.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public override validateBlockName(newName: string) {\r\n        if (!this.isAttribute) {\r\n            return super.validateBlockName(newName);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a vertex attribute\r\n     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\r\n     * @returns the current connection point\r\n     */\r\n    public setAsAttribute(attributeName?: string): InputBlock {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\r\n        if (attributeName) {\r\n            this.name = attributeName;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a system value\r\n     * @param value define the system value to use (world, view, etc...) or null to switch to manual value\r\n     * @returns the current connection point\r\n     */\r\n    public setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock {\r\n        this.systemValue = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n            if (this.isBoolean) {\r\n                value = value ? 1 : 0;\r\n            } else if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    /**\r\n     * Gets the declaration variable name in the shader\r\n     */\r\n    public get declarationVariableName(): string {\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._prefix + this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Gets or sets the type of animation applied to the input */\r\n    public get animationType() {\r\n        return this._animationType;\r\n    }\r\n\r\n    public set animationType(value: AnimatedInputBlockTypes) {\r\n        this._animationType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this connection point not defined yet\r\n     */\r\n    public get isUndefined(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\r\n     * In this case the connection point name must be the name of the uniform to use.\r\n     * Can only be set on inputs\r\n     */\r\n    public get isUniform(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    public set isUniform(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\r\n     * In this case the connection point name must be the name of the attribute to use\r\n     * Can only be set on inputs\r\n     */\r\n    public get isAttribute(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\r\n    }\r\n\r\n    public set isAttribute(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\r\n     * Can only be set on exit points\r\n     */\r\n    public get isVarying(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\r\n    }\r\n\r\n    public set isVarying(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a system value\r\n     */\r\n    public get isSystemValue(): boolean {\r\n        return this._systemValue != null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current well known value or null if not defined as a system value\r\n     */\r\n    public get systemValue(): Nullable<NodeMaterialSystemValues> {\r\n        return this._systemValue;\r\n    }\r\n\r\n    public set systemValue(value: Nullable<NodeMaterialSystemValues>) {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n        this.associatedVariableName = \"\";\r\n        this._systemValue = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"InputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Animate the input if animationType !== None\r\n     * @param scene defines the rendering scene\r\n     */\r\n    public animate(scene: Scene) {\r\n        switch (this._animationType) {\r\n            case AnimatedInputBlockTypes.Time: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value += scene.getAnimationRatio() * 0.01;\r\n                }\r\n                break;\r\n            }\r\n            case AnimatedInputBlockTypes.RealTime: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1000;\r\n                }\r\n                break;\r\n            }\r\n            case AnimatedInputBlockTypes.MouseInfo: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    const event = scene._inputManager._originMouseEvent;\r\n                    if (event) {\r\n                        const x = event.offsetX;\r\n                        const y = event.offsetY;\r\n                        const z = (event.buttons & 1) != 0 ? 1 : 0;\r\n                        const w = (event.buttons & 2) != 0 ? 1 : 0;\r\n                        this.value = new Vector4(x, y, z, w);\r\n                    } else {\r\n                        this.value = new Vector4(0, 0, 0, 0);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _emitDefine(define: string, notDefine = false): string {\r\n        return `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n    }\r\n\r\n    public override initialize() {\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                this.value = Color3.White();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                this.value = new Color4(1, 1, 1, 1);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _emitConstant(state: NodeMaterialBuildState) {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return `${state._emitFloat(this.value)}`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return `vec2(${this.value.x}, ${this.value.y})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _noContextSwitch(): boolean {\r\n        return attributeInFragmentOnly[this.name];\r\n    }\r\n\r\n    private _emit(state: NodeMaterialBuildState) {\r\n        // Uniforms\r\n        if (this.isUniform) {\r\n            if (!this._associatedVariableName) {\r\n                this._associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\r\n            }\r\n\r\n            if (this.isConstant) {\r\n                if (state.constants.indexOf(this.associatedVariableName) !== -1) {\r\n                    return;\r\n                }\r\n                state.constants.push(this.associatedVariableName);\r\n                state._constantDeclaration += state._declareOutput(this.output, true) + ` = ${this._emitConstant(state)};\\n`;\r\n                return;\r\n            }\r\n\r\n            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state._emitUniformFromString(this._associatedVariableName, this.type);\r\n\r\n            if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._prefix = \"uniforms.\";\r\n            }\r\n\r\n            // well known\r\n            const hints = state.sharedData.hints;\r\n            if (this._systemValue !== null && this._systemValue !== undefined) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                        hints.needWorldViewMatrix = true;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                        hints.needWorldViewProjectionMatrix = true;\r\n                        break;\r\n                }\r\n            } else {\r\n                if (this._animationType !== AnimatedInputBlockTypes.None) {\r\n                    state.sharedData.animatedInputs.push(this);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Attribute\r\n        if (this.isAttribute) {\r\n            this.associatedVariableName = remapAttributeName[this.name] ?? this.name;\r\n\r\n            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\r\n                // Attribute for fragment need to be carried over by varyings\r\n                if (attributeInFragmentOnly[this.name]) {\r\n                    if (attributeAsUniform[this.name]) {\r\n                        state._emitUniformFromString(this.declarationVariableName, this.type);\r\n                        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            this._prefix = `vertexInputs.`;\r\n                        }\r\n                    } else {\r\n                        state._emitVaryingFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                } else {\r\n                    this._emit(state._vertexState);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const alreadyDeclared = state.attributes.indexOf(this.declarationVariableName) !== -1;\r\n\r\n            if (!alreadyDeclared) {\r\n                state.attributes.push(this.declarationVariableName);\r\n            }\r\n\r\n            if (attributeInFragmentOnly[this.name]) {\r\n                if (attributeAsUniform[this.name]) {\r\n                    if (!alreadyDeclared) {\r\n                        state._emitUniformFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                        this._prefix = `uniforms.`;\r\n                    }\r\n                } else {\r\n                    if (!alreadyDeclared) {\r\n                        state._emitVaryingFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                        this._prefix = `fragmentInputs.`;\r\n                    }\r\n                }\r\n            } else {\r\n                if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                    if (!alreadyDeclared) {\r\n                        const defineName = attributeDefine[this.name];\r\n                        if (defineName) {\r\n                            state._attributeDeclaration += this._emitDefine(defineName);\r\n                            state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};\\n`;\r\n                            state._attributeDeclaration += `#else\\n`;\r\n                            state._attributeDeclaration += `var<private> ${this.declarationVariableName}: ${state._getShaderType(this.type)} = ${state._getShaderType(this.type)}(0.);\\n`;\r\n                            state._attributeDeclaration += `#endif\\n`;\r\n                        } else {\r\n                            state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};\\n`;\r\n                        }\r\n                    }\r\n                    this._prefix = `vertexInputs.`;\r\n                } else {\r\n                    if (!alreadyDeclared) {\r\n                        const defineName = attributeDefine[this.name];\r\n                        if (defineName) {\r\n                            state._attributeDeclaration += this._emitDefine(defineName);\r\n                            state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};\\n`;\r\n                            state._attributeDeclaration += `#else\\n`;\r\n                            state._attributeDeclaration += `${state._getShaderType(this.type)} ${this.declarationVariableName} = ${state._getShaderType(this.type)}(0.);\\n`;\r\n                            state._attributeDeclaration += `#endif\\n`;\r\n                        } else {\r\n                            state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};\\n`;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix) {\r\n        if (!this._systemValue) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this._associatedVariableName;\r\n        switch (this._systemValue) {\r\n            case NodeMaterialSystemValues.World:\r\n                effect.setMatrix(variableName, world);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldView:\r\n                effect.setMatrix(variableName, worldView);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldViewProjection:\r\n                effect.setMatrix(variableName, worldViewProjection);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmit(effect: Effect, scene: Scene, material: NodeMaterial) {\r\n        if (this.isAttribute) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this._associatedVariableName;\r\n        if (this._systemValue) {\r\n            switch (this._systemValue) {\r\n                case NodeMaterialSystemValues.World:\r\n                case NodeMaterialSystemValues.WorldView:\r\n                case NodeMaterialSystemValues.WorldViewProjection:\r\n                    return;\r\n                case NodeMaterialSystemValues.View:\r\n                    effect.setMatrix(variableName, scene.getViewMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.Projection:\r\n                    effect.setMatrix(variableName, scene.getProjectionMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.ProjectionInverse: {\r\n                    const projectionMatrix = scene.getProjectionMatrix();\r\n                    projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n                    effect.setMatrix(variableName, TmpVectors.Matrix[0]);\r\n                    break;\r\n                }\r\n                case NodeMaterialSystemValues.ViewProjection:\r\n                    effect.setMatrix(variableName, scene.getTransformMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraPosition:\r\n                    scene.bindEyePosition(effect, variableName, true);\r\n                    break;\r\n                case NodeMaterialSystemValues.FogColor:\r\n                    effect.setColor3(variableName, scene.fogColor);\r\n                    break;\r\n                case NodeMaterialSystemValues.DeltaTime:\r\n                    effect.setFloat(variableName, scene.deltaTime / 1000.0);\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraParameters:\r\n                    if (scene.activeCamera) {\r\n                        effect.setFloat4(\r\n                            variableName,\r\n                            scene.getEngine().hasOriginBottomLeft ? -1 : 1,\r\n                            scene.activeCamera.minZ,\r\n                            scene.activeCamera.maxZ,\r\n                            1 / scene.activeCamera.maxZ\r\n                        );\r\n                    }\r\n                    break;\r\n                case NodeMaterialSystemValues.MaterialAlpha:\r\n                    effect.setFloat(variableName, material.alpha);\r\n                    break;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const value = this._valueCallback ? this._valueCallback() : this._storedValue;\r\n\r\n        if (value === null) {\r\n            return;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                effect.setFloat(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                effect.setInt(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setColor3(variableName, TmpColors.Color3[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setDirectColor4(variableName, TmpColors.Color4[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                effect.setVector2(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                effect.setVector3(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                effect.setVector4(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                effect.setMatrix(variableName, value);\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isUniform || this.isSystemValue) {\r\n            state.sharedData.inputBlocks.push(this);\r\n        }\r\n\r\n        this._emit(state);\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isAttribute) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\n`;\r\n        }\r\n        if (this.isSystemValue) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue!]});\\n`;\r\n        }\r\n        if (this.isUniform) {\r\n            const codes: string[] = [];\r\n\r\n            let valueString = \"\";\r\n\r\n            switch (this.type) {\r\n                case NodeMaterialBlockConnectionPointTypes.Float:\r\n                    valueString = `${this.value}`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                    valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                    valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                    valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                    valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                    valueString = `BABYLON.Matrix.FromArray([${(this.value as Matrix).m.join(\", \")}])`;\r\n                    break;\r\n            }\r\n\r\n            // Common Property \"Value\"\r\n            codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n            // Float-Value-Specific Properties\r\n            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                codes.push(\r\n                    `${variableName}.min = ${this.min}`,\r\n                    `${variableName}.max = ${this.max}`,\r\n                    `${variableName}.isBoolean = ${this.isBoolean}`,\r\n                    `${variableName}.matrixMode = ${this.matrixMode}`,\r\n                    `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`\r\n                );\r\n            }\r\n\r\n            // Common Property \"Type\"\r\n            codes.push(`${variableName}.isConstant = ${this.isConstant}`);\r\n\r\n            codes.push(\"\");\r\n\r\n            return super._dumpPropertiesCode() + codes.join(\";\\n\");\r\n        }\r\n        return super._dumpPropertiesCode();\r\n    }\r\n\r\n    public override dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.mode = this._mode;\r\n        serializationObject.systemValue = this._systemValue;\r\n        serializationObject.animationType = this._animationType;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.isBoolean = this.isBoolean;\r\n        serializationObject.matrixMode = this.matrixMode;\r\n        serializationObject.isConstant = this.isConstant;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n\r\n        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this._mode = serializationObject.mode;\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\r\n        this._animationType = serializationObject.animationType;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.isBoolean = !!serializationObject.isBoolean;\r\n        this.matrixMode = serializationObject.matrixMode || 0;\r\n        this.isConstant = !!serializationObject.isConstant;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        // Tangents back compat\r\n        if (\r\n            serializationObject.name === \"tangent\" &&\r\n            serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute &&\r\n            serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3\r\n        ) {\r\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n        }\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to get the screen sizes\r\n */\r\nexport class ScreenSizeBlock extends NodeMaterialBlock {\r\n    private _varName: string;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Name of the variable in the shader that holds the screen size\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._varName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ScreenSizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ScreenSizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                code += `${state._declareOutput(output)} = ${varName}.${output.name};\\n`;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            state.sharedData.raiseBuildError(\"ScreenSizeBlock must only be used in a fragment shader\");\r\n            return this;\r\n        }\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._varName = state._getFreeVariableName(\"screenSize\");\r\n        state._emitUniformFromString(this._varName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        const prefix = state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\";\r\n        state.compilationString += this.writeOutputs(state, prefix + this._varName);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSizeBlock\", ScreenSizeBlock);\r\n", "import { FragmentOutputBlock } from \"./fragmentOutputBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { ScreenSizeBlock } from \"../Fragment/screenSizeBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport const SfeModeDefine = \"USE_SFE_FRAMEWORK\";\r\n\r\n/**\r\n * Block used to output the final color with Smart Filters structural support.\r\n */\r\nexport class SmartFilterFragmentOutputBlock extends FragmentOutputBlock {\r\n    /**\r\n     * Create a new SmartFilterFragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SmartFilterFragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        super.initialize(state);\r\n\r\n        if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {\r\n            state.sharedData.raiseBuildError(\"SmartFilterFragmentOutputBlock should not be used outside of SFE mode.\");\r\n        }\r\n\r\n        if (state.sharedData.nodeMaterial.shaderLanguage !== ShaderLanguage.GLSL) {\r\n            state.sharedData.raiseBuildError(\"WebGPU is not supported in SmartFilters mode.\");\r\n        }\r\n\r\n        // Annotate uniforms of InputBlocks and bindable blocks with their current values\r\n        if (!state.sharedData.formatConfig.getUniformAnnotation) {\r\n            state.sharedData.formatConfig.getUniformAnnotation = (name: string) => {\r\n                for (const block of state.sharedData.nodeMaterial.attachedBlocks) {\r\n                    if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name) {\r\n                        return this._generateInputBlockAnnotation(block);\r\n                    }\r\n                    if (block instanceof ScreenSizeBlock && block.associatedVariableName === name) {\r\n                        return this._generateScreenSizeBlockAnnotation();\r\n                    }\r\n                }\r\n                return \"\";\r\n            };\r\n        }\r\n\r\n        // Do our best to clean up variable names, as they will be used as display names.\r\n        state.sharedData.formatConfig.formatVariablename = (n: string) => {\r\n            let name = n;\r\n\r\n            const hasUnderscoredPrefix = name.length > 1 && name[1] === \"_\";\r\n            if (hasUnderscoredPrefix) {\r\n                name = name.substring(2);\r\n            }\r\n\r\n            return name.replace(/[^a-zA-Z]+/g, \"\");\r\n        };\r\n    }\r\n\r\n    private _generateInputBlockAnnotation(inputBlock: InputBlock): string {\r\n        const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;\r\n        return `// { \"default\": ${JSON.stringify(value)} }\\n`;\r\n    }\r\n\r\n    private _generateScreenSizeBlockAnnotation(): string {\r\n        return `// { \"autoBind\": \"outputResolution\" }\\n`;\r\n    }\r\n\r\n    private _getMainUvName(state: NodeMaterialBuildState): string {\r\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\r\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\r\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\r\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\r\n            return \"\";\r\n        }\r\n        return screenUv.associatedVariableName;\r\n    }\r\n\r\n    protected override _getOutputString(): string {\r\n        return \"outColor\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const outputString = this._getOutputString();\r\n\r\n        state._injectAtTop = `// { \"smartFilterBlockType\": \"${state.sharedData.nodeMaterial.name}\", \"namespace\": \"Babylon.NME.Exports\" }`;\r\n\r\n        state._customEntryHeader += `#ifdef ${SfeModeDefine}\\n`;\r\n        state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main\\n`;\r\n        state._customEntryHeader += `#else\\n`;\r\n        state._customEntryHeader += `void main(void) {\\n`;\r\n        state._customEntryHeader += `#endif\\n`;\r\n        state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);\\n`;\r\n\r\n        state.compilationString += `\\n#ifndef ${SfeModeDefine}\\n`;\r\n        state.compilationString += `gl_FragColor = ${outputString};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `return ${outputString};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SmartFilterFragmentOutputBlock\", SmartFilterFragmentOutputBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { InputBlock } from \"./Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\r\n */\r\nexport class TransformBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Defines the value to use to complement W value to transform it to a Vector4\r\n     */\r\n    public complementW = 1;\r\n\r\n    /**\r\n     * Defines the value to use to complement z value to transform it to a Vector4\r\n     */\r\n    public complementZ = 0;\r\n\r\n    /**\r\n     * Boolean indicating if the transformation is made for a direction vector and not a position vector\r\n     * If set to true the complementW value will be set to 0 else it will be set to 1\r\n     */\r\n    @editableInPropertyPage(\"Transform as direction\", PropertyTypeForEdition.Boolean, undefined, { embedded: true })\r\n    public get transformAsDirection() {\r\n        return this.complementW === 0;\r\n    }\r\n\r\n    public set transformAsDirection(value: boolean) {\r\n        this.complementW = value ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a new TransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.target = NodeMaterialBlockTargets.Vertex;\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (other.ownerBlock.isInput) {\r\n                const otherAsInput = other.ownerBlock as InputBlock;\r\n\r\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\r\n                    this.complementW = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz output component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix transform input\r\n     */\r\n    public get transform(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const transform = this.transform;\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        if (vector.connectedPoint) {\r\n            // None uniform scaling case.\r\n            if (this.complementW === 0 || this.transformAsDirection) {\r\n                const comments = `//${this.name}`;\r\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n                state.sharedData.blocksWithDefines.push(this);\r\n\r\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\r\n                if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                    state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);\\n`;\r\n                } else {\r\n                    state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\r\n                }\r\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\r\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\r\n                state.compilationString += `#endif\\n`;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) +\r\n                            ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                const transformName = transform.associatedVariableName;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) +\r\n                            ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (this.xyz.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (mesh && mesh.nonUniformScaling) {\r\n            defines.setValue(\"NONUNIFORMSCALING\", true);\r\n        }\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.complementZ = this.complementZ;\r\n        serializationObject.complementW = this.complementW;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\r\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Immutable } from \"../../../../types\";\r\n\r\nimport type { FragmentOutputBlock } from \"../Fragment/fragmentOutputBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to output the vertex position\r\n */\r\nexport class VertexOutputBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VertexOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex, true);\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VertexOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input component\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    private _isLogarithmicDepthEnabled(nodeList: Immutable<NodeMaterialBlock[]>, useLogarithmicDepth: boolean): boolean {\r\n        if (useLogarithmicDepth) {\r\n            return true;\r\n        }\r\n\r\n        for (const node of nodeList) {\r\n            if ((node as FragmentOutputBlock).useLogarithmicDepth) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.vector;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `vertexOutputs.position = ${input.associatedVariableName};\\n`;\r\n        } else {\r\n            state.compilationString += `gl_Position = ${input.associatedVariableName};\\n`;\r\n        }\r\n\r\n        // TODOWGSL\r\n        if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state._emitVaryingFromString(\"vFragmentDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n            const fragDepth = isWebGPU ? \"vertexOutputs.vFragmentDepth\" : \"vFragmentDepth\";\r\n            const uniformP = isWebGPU ? \"uniforms.\" : \"\";\r\n            const position = isWebGPU ? \"vertexOutputs.position\" : \"gl_Position\";\r\n\r\n            state.compilationString += `${fragDepth} = 1.0 + ${position}.w;\\n`;\r\n            state.compilationString += `${position}.z = log2(max(0.000001, ${fragDepth})) * ${uniformP}logarithmicDepthConstant;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VertexOutputBlock\", VertexOutputBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\n/**\r\n * Base block used as input for post process\r\n */\r\nexport class CurrentScreenBlock extends NodeMaterialBlock {\r\n    protected _samplerName = \"textureSampler\";\r\n    protected _linearDefineName: string;\r\n    protected _gammaDefineName: string;\r\n    protected _mainUVName: string;\r\n    protected _tempTextureRead: string;\r\n\r\n    /**\r\n     * The name of the sampler to read the screen texture from.\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new CurrentScreenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CurrentScreenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(this._samplerName);\r\n    }\r\n\r\n    public override get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _getMainUvName(state: NodeMaterialBuildState): string {\r\n        return \"vMain\" + this.uv.associatedVariableName;\r\n    }\r\n\r\n    protected _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n            }\r\n        }\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n            const textureReadFunc =\r\n                state.shaderLanguage === ShaderLanguage.GLSL\r\n                    ? `texture2D(${this._samplerName},`\r\n                    : `textureSampleLevel(${this._samplerName}, ${this._samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n            const complement = state.shaderLanguage === ShaderLanguage.GLSL ? \"\" : \", 0\";\r\n\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName}${complement});\\n`;\r\n            return;\r\n        }\r\n\r\n        const textureReadFunc =\r\n            state.shaderLanguage === ShaderLanguage.GLSL\r\n                ? `texture2D(${this._samplerName},`\r\n                : `textureSample(${this._samplerName}, ${this._samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    protected _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected _emitUvAndSampler(state: NodeMaterialBuildState) {\r\n        state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        state._emit2DSampler(this._samplerName);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\r\n            state.sharedData.blockingBlocks.push(this);\r\n        }\r\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\r\n            state.sharedData.textureBlocks.push(this);\r\n        }\r\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n        this._mainUVName = this._getMainUvName(state);\r\n\r\n        this._emitUvAndSampler(state);\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(this.uv.associatedVariableName, this._samplerName)};\\n`;\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used for the particle ramp gradient section\r\n */\r\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleRampGradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleRampGradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rampColor output component\r\n     */\r\n    public get rampColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"remapRanges\");\r\n        state._excludeVariableName(\"rampSampler\");\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"alpha\");\r\n        state._excludeVariableName(\"remappedColorIndex\");\r\n        state._excludeVariableName(\"rampColor\");\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(\"rampSampler\", \"RAMPGRADIENT\");\r\n        state._emitVaryingFromString(\"remapRanges\", NodeMaterialBlockConnectionPointTypes.Vector4, \"RAMPGRADIENT\");\r\n\r\n        const varyingString = state.shaderLanguage === ShaderLanguage.GLSL ? \"\" : \"fragmentInputs.\";\r\n\r\n        state.compilationString += `\r\n            #ifdef RAMPGRADIENT\r\n                ${state._declareLocalVar(\"baseColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.color.associatedVariableName};\r\n                ${state._declareLocalVar(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.color.associatedVariableName}.a;\r\n\r\n                ${state._declareLocalVar(\"remappedColorIndex\", NodeMaterialBlockConnectionPointTypes.Float)} = clamp((alpha - ${varyingString}remapRanges.x) / ${varyingString}remapRanges.y, 0.0, 1.0);\r\n\r\n                ${state._declareLocalVar(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(\"vec2(1.0 - remappedColorIndex, 0.)\", \"rampSampler\")};\r\n\r\n                // Remapped alpha\r\n                ${state._declareOutput(this.rampColor)} = vec4${state.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${varyingString}remapRanges.z) / ${varyingString}remapRanges.w, 0.0, 1.0));\r\n            #else\r\n                ${state._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle blend multiply section\r\n */\r\nexport class ParticleBlendMultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleBlendMultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaTexture\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaColor\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"blendColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleBlendMultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaTexture input component\r\n     */\r\n    public get alphaTexture(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaColor input component\r\n     */\r\n    public get alphaColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the blendColor output component\r\n     */\r\n    public get blendColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sourceAlpha\");\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `\r\n            #ifdef BLENDMULTIPLYMODE\r\n                ${state._declareOutput(this.blendColor)};\r\n                ${state._declareLocalVar(\"sourceAlpha\", NodeMaterialBlockConnectionPointTypes.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};\r\n                ${this.blendColor.associatedVariableName} = vec4${state.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);\r\n            #else\r\n                ${state._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleBlendMultiplyBlock\", ParticleBlendMultiplyBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Block used to create a Vector2/3/4 out of individual inputs (one for each component)\r\n */\r\nexport class VectorMergerBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the swizzle for x (meaning which component to affect to the output.x)\r\n     */\r\n    public xSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"x\";\r\n    /**\r\n     * Gets or sets the swizzle for y (meaning which component to affect to the output.y)\r\n     */\r\n    public ySwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"y\";\r\n    /**\r\n     * Gets or sets the swizzle for z (meaning which component to affect to the output.z)\r\n     */\r\n    public zSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"z\";\r\n    /**\r\n     * Gets or sets the swizzle for w (meaning which component to affect to the output.w)\r\n     */\r\n    public wSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"w\";\r\n\r\n    /**\r\n     * Create a new VectorMergerBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"xyzw \", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"zw \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VectorMergerBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (input)\r\n     */\r\n    public get zwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (input)\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (input)\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (input)\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (input)\r\n     */\r\n    public get w(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (output)\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zwOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     * @deprecated Please use xyOut instead.\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this.xyOut;\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     * @deprecated Please use xyzOut instead.\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this.xyzOut;\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"xyzw \") {\r\n            return \"xyzwIn\";\r\n        }\r\n        if (name === \"xyz \") {\r\n            return \"xyzIn\";\r\n        }\r\n        if (name === \"xy \") {\r\n            return \"xyIn\";\r\n        }\r\n        if (name === \"zw \") {\r\n            return \"zwIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private _buildSwizzle(len: number) {\r\n        const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;\r\n\r\n        return \".\" + swizzle.substring(0, len);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const xInput = this.x;\r\n        const yInput = this.y;\r\n        const zInput = this.z;\r\n        const wInput = this.w;\r\n        const xyInput = this.xyIn;\r\n        const zwInput = this.zwIn;\r\n        const xyzInput = this.xyzIn;\r\n        const xyzwInput = this.xyzwIn;\r\n\r\n        const v4Output = this._outputs[0];\r\n        const v3Output = this._outputs[1];\r\n        const v2Output = this._outputs[2];\r\n        const v2CompOutput = this._outputs[3];\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        if (xyzwInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v4Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v3Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyzInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v4Output) +\r\n                    ` = ${vec4}(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v3Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${\r\n                            wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v3Output) +\r\n                    ` = ${vec3}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"})${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v2CompOutput) +\r\n                        ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        } else {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zwInput.associatedVariableName\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                        }, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v3Output) +\r\n                    ` = ${vec3}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                        zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                    })${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v2Output) +\r\n                    ` = ${vec2}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"})${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v2CompOutput) +\r\n                        ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.xSwizzle = this.xSwizzle;\r\n        serializationObject.ySwizzle = this.ySwizzle;\r\n        serializationObject.zSwizzle = this.zSwizzle;\r\n        serializationObject.wSwizzle = this.wSwizzle;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.xSwizzle = serializationObject.xSwizzle ?? \"x\";\r\n        this.ySwizzle = serializationObject.ySwizzle ?? \"y\";\r\n        this.zSwizzle = serializationObject.zSwizzle ?? \"z\";\r\n        this.wSwizzle = serializationObject.wSwizzle ?? \"w\";\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.xSwizzle = \"${this.xSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.ySwizzle = \"${this.ySwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.zSwizzle = \"${this.zSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.wSwizzle = \"${this.wSwizzle}\";\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorMergerBlock\", VectorMergerBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\n/**\r\n * Block used to remap a float from a range to a new one\r\n */\r\nexport class RemapBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the source range\r\n     */\r\n    @editableInPropertyPage(\"From\", PropertyTypeForEdition.Vector2)\r\n    public sourceRange = new Vector2(-1, 1);\r\n\r\n    /**\r\n     * Gets or sets the target range\r\n     */\r\n    @editableInPropertyPage(\"To\", PropertyTypeForEdition.Vector2)\r\n    public targetRange = new Vector2(0, 1);\r\n\r\n    /**\r\n     * Creates a new RemapBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"sourceMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"sourceMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"RemapBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source min input component\r\n     */\r\n    public get sourceMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the source max input component\r\n     */\r\n    public get sourceMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the target min input component\r\n     */\r\n    public get targetMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the target max input component\r\n     */\r\n    public get targetMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);\r\n        const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);\r\n\r\n        const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);\r\n        const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.sourceRange = this.sourceRange.asArray();\r\n        serializationObject.targetRange = this.targetRange.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);\r\n        this.targetRange = Vector2.FromArray(serializationObject.targetRange);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RemapBlock\", RemapBlock);\r\n", "import type { Observer } from \"core/Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\n\r\n/**\r\n * Block used to perform a mathematical operation on 2 values\r\n */\r\nexport class BaseMathBlock extends NodeMaterialBlock {\r\n    private readonly _connectionObservers: Observer<NodeMaterialBlockConnectionPointTypes>[];\r\n\r\n    protected constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this.output._typeConnectionSource = this.left;\r\n        this._linkConnectionTypes(0, 1, true);\r\n\r\n        this.left.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.right.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._connectionObservers = [\r\n            this.left.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),\r\n            this.right.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _updateInputOutputTypes() {\r\n        // First update the output type with the initial assumption that we'll base it on the left input.\r\n        this.output._typeConnectionSource = this.left;\r\n\r\n        if (this.left.isConnected && this.right.isConnected) {\r\n            // Both inputs are connected, so we need to determine the output type based on the input types.\r\n            if (\r\n                this.left.type === NodeMaterialBlockConnectionPointTypes.Int ||\r\n                (this.left.type === NodeMaterialBlockConnectionPointTypes.Float && this.right.type !== NodeMaterialBlockConnectionPointTypes.Int)\r\n            ) {\r\n                this.output._typeConnectionSource = this.right;\r\n            }\r\n        } else if (this.left.isConnected !== this.right.isConnected) {\r\n            // Only one input is connected, so we need to determine the output type based on the connected input.\r\n            this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;\r\n        }\r\n\r\n        // Next update the accepted connection point types for the inputs based on the current input connection state.\r\n        if (this.left.isConnected || this.right.isConnected) {\r\n            for (const [first, second] of [\r\n                [this.left, this.right],\r\n                [this.right, this.left],\r\n            ]) {\r\n                // Always allow Ints and Floats.\r\n                first.acceptedConnectionPointTypes = [NodeMaterialBlockConnectionPointTypes.Int, NodeMaterialBlockConnectionPointTypes.Float];\r\n\r\n                if (second.isConnected) {\r\n                    // The same types as the connected input are always allowed.\r\n                    first.acceptedConnectionPointTypes.push(second.type);\r\n\r\n                    // If the other input is a scalar, then we also allow Vector/Color/Matrix types.\r\n                    if (second.type === NodeMaterialBlockConnectionPointTypes.Int || second.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                        first.acceptedConnectionPointTypes.push(\r\n                            NodeMaterialBlockConnectionPointTypes.Vector2,\r\n                            NodeMaterialBlockConnectionPointTypes.Vector3,\r\n                            NodeMaterialBlockConnectionPointTypes.Vector4,\r\n                            NodeMaterialBlockConnectionPointTypes.Color3,\r\n                            NodeMaterialBlockConnectionPointTypes.Color4,\r\n                            NodeMaterialBlockConnectionPointTypes.Matrix\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        for (const observer of this._connectionObservers) {\r\n            observer.remove();\r\n        }\r\n        this._connectionObservers.length = 0;\r\n    }\r\n}\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { BaseMathBlock } from \"./baseMathBlock\";\r\n\r\n/**\r\n * Block used to multiply 2 values\r\n */\r\nexport class MultiplyBlock extends BaseMathBlock {\r\n    /**\r\n     * Creates a new MultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MultiplyBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiplyBlock\", MultiplyBlock);\r\n", "import { MaterialDefines } from \"./materialDefines\";\r\n/**\r\n * Interface to follow in your material defines to integrate easily the\r\n * Image processing functions.\r\n * @internal\r\n */\r\nexport interface IImageProcessingConfigurationDefines {\r\n    IMAGEPROCESSING: boolean;\r\n    VIGNETTE: boolean;\r\n    VIGNETTEBLENDMODEMULTIPLY: boolean;\r\n    VIGNETTEBLENDMODEOPAQUE: boolean;\r\n    TONEMAPPING: number;\r\n    CONTRAST: boolean;\r\n    EXPOSURE: boolean;\r\n    COLORCURVES: boolean;\r\n    COLORGRADING: boolean;\r\n    COLORGRADING3D: boolean;\r\n    SAMPLER3DGREENDEPTH: boolean;\r\n    SAMPLER3DBGRMAP: boolean;\r\n    DITHER: boolean;\r\n    IMAGEPROCESSINGPOSTPROCESS: boolean;\r\n    SKIPFINALCOLORCLAMP: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ImageProcessingConfigurationDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = 0;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public EXPOSURE = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration.defines\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport type { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { IParticleEmitterType } from \"./EmitterTypes/IParticleEmitterType\";\r\nimport type { PointParticleEmitter } from \"./EmitterTypes/pointParticleEmitter\";\r\nimport type { HemisphericParticleEmitter } from \"./EmitterTypes/hemisphericParticleEmitter\";\r\nimport type { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"./EmitterTypes/sphereParticleEmitter\";\r\nimport type { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"./EmitterTypes/cylinderParticleEmitter\";\r\nimport type { ConeDirectedParticleEmitter, ConeParticleEmitter } from \"./EmitterTypes/coneParticleEmitter\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * This represents the base class for particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class BaseParticleSystem implements IClipPlanesHolder {\r\n    /**\r\n     * Source color is added to the destination color without alpha affecting the result. Great for additive glow effects (fire, magic, lasers)\r\n     */\r\n    public static BLENDMODE_ONEONE = 0;\r\n    /**\r\n     * Blend current color and particle color using particle’s alpha. Same as Constants.ALPHA_COMBINE, the go-to for transparency. 100% alpha means source, 0% alpha means background. Glass, UI fade, smoke\r\n     */\r\n    public static BLENDMODE_STANDARD = 1;\r\n    /**\r\n     * Add current color and particle color multiplied by particle’s alpha\r\n     */\r\n    public static BLENDMODE_ADD = 2;\r\n    /**\r\n     * Multiply current color with particle color\r\n     */\r\n    public static BLENDMODE_MULTIPLY = 3;\r\n    /**\r\n     * Multiply current color with particle color then add current color and particle color multiplied by particle’s alpha\r\n     */\r\n    public static BLENDMODE_MULTIPLYADD = 4;\r\n    /**\r\n     * Subtracts source (particle) from destination (current color), leading to darker results\r\n     * - NOTE: Init as -1 so we can properly map all modes to Engine Const's (otherwise ALPHA_SUBTRACT will conflict with BLENDMODE_MULTIPLY since both use 3)\r\n     */\r\n    public static BLENDMODE_SUBTRACT = -1;\r\n\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets the unique id of the particle system\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * The friendly name of the Particle system.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Snippet ID if the particle system was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    public renderingGroupId = 0;\r\n\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    public emitter: Nullable<AbstractMesh | Vector3> = Vector3.Zero();\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame\r\n     */\r\n    public emitRate = 10;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    public manualEmitCount = -1;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    public updateSpeed = 0.01;\r\n\r\n    /** @internal */\r\n    public _targetStopDuration = 0;\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    public get targetStopDuration() {\r\n        return this._targetStopDuration;\r\n    }\r\n\r\n    public set targetStopDuration(value: number) {\r\n        if (this._targetStopDuration === value) {\r\n            return;\r\n        }\r\n\r\n        this._targetStopDuration = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    public disposeOnStop = false;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    public minEmitPower = 1;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    public maxEmitPower = 1;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    public minLifeTime = 1;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    public maxLifeTime = 1;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    public minSize = 1;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    public maxSize = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    public minScaleX = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    public maxScaleX = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    public minScaleY = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    public maxScaleY = 1;\r\n\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    public minInitialRotation = 0;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    public maxInitialRotation = 0;\r\n\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public minAngularSpeed = 0;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public maxAngularSpeed = 0;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    public particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * This can help using your own shader to render the particle system.\r\n     * The according effect will be created\r\n     */\r\n    public customShader: any = null;\r\n\r\n    /**\r\n     * By default particle system starts as soon as they are created. This prevents the\r\n     * automatic start to happen and let you decide when to start emitting particles.\r\n     */\r\n    public preventAutoStart: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this particle system will allow fog to be rendered on it (false by default)\r\n     */\r\n    public applyFog = false;\r\n\r\n    /** @internal */\r\n    _wasDispatched = false;\r\n\r\n    protected _rootUrl = \"\";\r\n    protected _noiseTexture: Nullable<ProceduralTexture>;\r\n\r\n    /**\r\n     * Returns true if the particle system was generated by a node particle system set\r\n     */\r\n    public get isNodeGenerated(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    public get noiseTexture(): Nullable<ProceduralTexture> {\r\n        return this._noiseTexture;\r\n    }\r\n\r\n    public set noiseTexture(value: Nullable<ProceduralTexture>) {\r\n        if (this._noiseTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._noiseTexture = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    public noiseStrength = new Vector3(10, 10, 10);\r\n\r\n    /**\r\n     * Callback triggered when the particle animation is ending.\r\n     */\r\n    public onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Blend mode use to render the particle\r\n     * For original blend modes which are exposed from ParticleSystem (OneOne, Standard, Add, Multiply, MultiplyAdd, and Subtract), use ParticleSystem.BLENDMODE_FOO\r\n     * For all other blend modes, use Engine Constants.ALPHA_FOO blend modes\r\n     */\r\n    public blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\r\n    public preWarmCycles = 0;\r\n\r\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\r\n    public preWarmStepOffset = 1;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    public spriteCellChangeSpeed = 1;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public startSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public endSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    public spriteCellWidth = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    public spriteCellHeight = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\r\n     */\r\n    public spriteCellLoop = true;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    public spriteRandomStartCell = false;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    public translationPivot = new Vector2(0, 0);\r\n\r\n    protected _animationSheetEnabled = false;\r\n    /** @internal */\r\n    public get _isAnimationSheetEnabled() {\r\n        return this._animationSheetEnabled;\r\n    }\r\n\r\n    public set _isAnimationSheetEnabled(value: boolean) {\r\n        if (this._animationSheetEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._animationSheetEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    public beginAnimationOnStart = false;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationFrom = 0;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationTo = 60;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationLoop = false;\r\n\r\n    /**\r\n     * Gets or sets a world offset applied to all particles\r\n     */\r\n    public worldOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\r\n     */\r\n    public get isAnimationSheetEnabled(): boolean {\r\n        return this._isAnimationSheetEnabled;\r\n    }\r\n\r\n    public set isAnimationSheetEnabled(value: boolean) {\r\n        if (this._isAnimationSheetEnabled == value) {\r\n            return;\r\n        }\r\n\r\n        this._isAnimationSheetEnabled = value;\r\n\r\n        this._reset();\r\n    }\r\n\r\n    private _useLogarithmicDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene()!.getEngine().getCaps().fragmentDepthSupported;\r\n    }\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    public gravity = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _colorGradients: Nullable<Array<ColorGradient>> = null;\r\n    /** @internal */\r\n    public _sizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _lifeTimeGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _angularSpeedGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _velocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _limitVelocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _dragGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _emitRateGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _startSizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _rampGradients: Nullable<Array<Color3Gradient>> = null;\r\n    /** @internal */\r\n    public _colorRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _alphaRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n\r\n    protected _hasTargetStopDurationDependantGradient() {\r\n        return (\r\n            (this._startSizeGradients && this._startSizeGradients.length > 0) ||\r\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\r\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0)\r\n        );\r\n    }\r\n\r\n    protected _setEngineBasedOnBlendMode(blendMode: number): void {\r\n        switch (blendMode) {\r\n            case BaseParticleSystem.BLENDMODE_MULTIPLYADD:\r\n                // Don't want to update engine since there is no equivalent engine alpha mode, instead it gets handled within particleSystem\r\n                return;\r\n            case BaseParticleSystem.BLENDMODE_ADD:\r\n                blendMode = Constants.ALPHA_ADD;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_ONEONE:\r\n                blendMode = Constants.ALPHA_ONEONE;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_STANDARD:\r\n                blendMode = Constants.ALPHA_COMBINE;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_MULTIPLY:\r\n                blendMode = Constants.ALPHA_MULTIPLY;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_SUBTRACT:\r\n                blendMode = Constants.ALPHA_SUBTRACT;\r\n                break;\r\n            default:\r\n                // For all other blend modes that were added after the initial particleSystem implementation,\r\n                // the ParticleSystem.BLENDMODE_FOO are already mapped to the underlying Constants.ALPHA_FOO\r\n                break;\r\n        }\r\n        this._engine.setAlphaMode(blendMode);\r\n    }\r\n\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    public startDelay = 0;\r\n\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    public getDragGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._dragGradients;\r\n    }\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    public limitVelocityDamping = 0.4;\r\n\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    public getLimitVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._limitVelocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    public getColorGradients(): Nullable<Array<ColorGradient>> {\r\n        return this._colorGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    public getSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._sizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    public getColorRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._colorRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    public getAlphaRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._alphaRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    public getLifeTimeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._lifeTimeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    public getAngularSpeedGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._angularSpeedGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    public getVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._velocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    public getStartSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._startSizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    public getEmitRateGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._emitRateGradients;\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction1(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction1;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction1(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction1 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction2(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction2;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction2(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction2 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get minEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).minEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set minEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).minEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get maxEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set maxEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Color the particle will have at the end of its lifetime\r\n     */\r\n    public colorDead = new Color4(0, 0, 0, 1.0);\r\n\r\n    /**\r\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\r\n     */\r\n    public textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    public particleEmitterType: IParticleEmitterType;\r\n\r\n    /** @internal */\r\n    public _isSubEmitter = false;\r\n\r\n    /** @internal */\r\n    public _billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    public get billboardMode(): number {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._billboardMode = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isBillboardBased = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    public get isBillboardBased(): boolean {\r\n        return this._isBillboardBased;\r\n    }\r\n\r\n    public set isBillboardBased(value: boolean) {\r\n        if (this._isBillboardBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isBillboardBased = value;\r\n        this._reset();\r\n    }\r\n\r\n    /**\r\n     * The scene the particle system belongs to.\r\n     */\r\n    protected _scene: Nullable<Scene>;\r\n\r\n    /**\r\n     * The engine the particle system belongs to.\r\n     */\r\n    protected _engine: AbstractEngine;\r\n\r\n    /**\r\n     * Local cache of defines for image processing.\r\n     */\r\n    protected _imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration && this._scene) {\r\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _reset() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem {\r\n        if (!gradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const valueGradient of gradients) {\r\n            if (valueGradient.gradient === gradient) {\r\n                gradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        if (texture) {\r\n            texture.dispose();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     */\r\n    public constructor(name: string) {\r\n        this.id = name;\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     */\r\n    public createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     */\r\n    public createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     */\r\n    public createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     */\r\n    public createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     */\r\n    public createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     */\r\n    public createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     */\r\n    public createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    public createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): ConeDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     */\r\n    public createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.BaseParticleSystem\", BaseParticleSystem);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to expand a Color3/4 into 4 outputs (one for each component)\r\n */\r\nexport class ColorSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ColorSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputsAreExclusive = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ColorSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component (input)\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component (output)\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component (output)\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n    /**\r\n     * Gets the b component (output)\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n    /**\r\n     * Gets the a component (output)\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.rgba.isConnected ? this.rgba : this.rgbIn;\r\n\r\n        if (!input.isConnected) {\r\n            return;\r\n        }\r\n\r\n        const rgbOutput = this._outputs[0];\r\n        const rOutput = this._outputs[1];\r\n        const gOutput = this._outputs[2];\r\n        const bOutput = this._outputs[3];\r\n        const aOutput = this._outputs[4];\r\n\r\n        if (rgbOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(rgbOutput) + ` = ${input.associatedVariableName}.rgb;\\n`;\r\n        }\r\n        if (rOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(rOutput) + ` = ${input.associatedVariableName}.r;\\n`;\r\n        }\r\n        if (gOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(gOutput) + ` = ${input.associatedVariableName}.g;\\n`;\r\n        }\r\n        if (bOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(bOutput) + ` = ${input.associatedVariableName}.b;\\n`;\r\n        }\r\n        if (aOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(aOutput) + ` = ${input.associatedVariableName}.a;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorSplitterBlock\", ColorSplitterBlock);\r\n", "import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector4, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { RenderTargetTextureOptions } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\n\r\n/**\r\n * Options to create a procedural texture\r\n */\r\nexport interface IProceduralTextureCreationOptions extends RenderTargetTextureOptions {\r\n    /**\r\n     * Defines a fallback texture in case there were issues to create the custom texture\r\n     */\r\n    fallbackTexture?: Nullable<Texture>;\r\n    /**\r\n     * The shader language of the shader. (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Define the list of custom preprocessor defines used in the shader\r\n     */\r\n    public defines: string = \"\";\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: ThinTexture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _vectors4: { [key: string]: Vector4 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: AbstractEngine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n    private _options: IProceduralTextureCreationOptions;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> | IProceduralTextureCreationOptions = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\r\n            this._options = fallbackTexture;\r\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\r\n        } else {\r\n            this._options = {};\r\n            this._fallbackTexture = fallbackTexture;\r\n        }\r\n\r\n        this._shaderLanguage = this._options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            if (this._rtWrapper.is3D) {\r\n                this.setFloat(\"layer\", 0);\r\n                this.setInt(\"layerNum\", 0);\r\n            }\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return this.defines;\r\n    }\r\n\r\n    /**\r\n     * Executes a function when the texture will be ready to be drawn.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenReady(func: (texture: ProceduralTexture) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        const effect = this.getEffect();\r\n        if (effect) {\r\n            effect.executeWhenCompiled(() => {\r\n                func(this);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public override isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                shaders,\r\n                [VertexBuffer.PositionKind],\r\n                this._uniforms,\r\n                this._samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    this._rtWrapper?.dispose();\r\n                    this._rtWrapper = this._texture = null;\r\n\r\n                    if (this._fallbackTexture) {\r\n                        this._texture = this._fallbackTexture._texture;\r\n\r\n                        if (this._texture) {\r\n                            this._texture.incrementReferences();\r\n                        }\r\n                    }\r\n\r\n                    this._fallbackTextureUsed = true;\r\n                },\r\n                undefined,\r\n                this._shaderLanguage,\r\n                async () => {\r\n                    if (this._options.extraInitializationsAsync) {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        }\r\n                    } else {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await import(\"../../../ShadersWGSL/procedural.vertex\");\r\n                        } else {\r\n                            await import(\"../../../Shaders/procedural.vertex\");\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: ThinTexture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (const name in this._vectors4) {\r\n                this._drawWrapper.effect!.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, true);\r\n            }\r\n        } else {\r\n            let numLayers = 1;\r\n            if (this._rtWrapper.is3D) {\r\n                numLayers = this._rtWrapper.depth;\r\n            } else if (this._rtWrapper.is2DArray) {\r\n                numLayers = this._rtWrapper.layers;\r\n            }\r\n            for (let layer = 0; layer < numLayers; layer++) {\r\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\r\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\r\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\r\n                    for (const name in this._textures) {\r\n                        this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n                    }\r\n                }\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\r\n            }\r\n        }\r\n\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Trigonometry block\r\n */\r\nexport enum TrigonometryBlockOperations {\r\n    /** Cos */\r\n    Cos,\r\n    /** Sin */\r\n    Sin,\r\n    /** Abs */\r\n    Abs,\r\n    /** Exp */\r\n    Exp,\r\n    /** Exp2 */\r\n    Exp2,\r\n    /** Round */\r\n    Round,\r\n    /** Floor */\r\n    Floor,\r\n    /** Ceiling */\r\n    Ceiling,\r\n    /** Square root */\r\n    Sqrt,\r\n    /** Log */\r\n    Log,\r\n    /** Tangent */\r\n    Tan,\r\n    /** Arc tangent */\r\n    ArcTan,\r\n    /** Arc cosinus */\r\n    ArcCos,\r\n    /** Arc sinus */\r\n    ArcSin,\r\n    /** Fraction */\r\n    Fract,\r\n    /** Sign */\r\n    Sign,\r\n    /** To radians (from degrees) */\r\n    Radians,\r\n    /** To degrees (from radians) */\r\n    Degrees,\r\n    /** To Set a = b */\r\n    Set,\r\n}\r\n\r\n/**\r\n * Block used to apply trigonometry operation to floats\r\n */\r\nexport class TrigonometryBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"Cos\", value: TrigonometryBlockOperations.Cos },\r\n            { label: \"Sin\", value: TrigonometryBlockOperations.Sin },\r\n            { label: \"Abs\", value: TrigonometryBlockOperations.Abs },\r\n            { label: \"Exp\", value: TrigonometryBlockOperations.Exp },\r\n            { label: \"Exp2\", value: TrigonometryBlockOperations.Exp2 },\r\n            { label: \"Round\", value: TrigonometryBlockOperations.Round },\r\n            { label: \"Floor\", value: TrigonometryBlockOperations.Floor },\r\n            { label: \"Ceiling\", value: TrigonometryBlockOperations.Ceiling },\r\n            { label: \"Sqrt\", value: TrigonometryBlockOperations.Sqrt },\r\n            { label: \"Log\", value: TrigonometryBlockOperations.Log },\r\n            { label: \"Tan\", value: TrigonometryBlockOperations.Tan },\r\n            { label: \"ArcTan\", value: TrigonometryBlockOperations.ArcTan },\r\n            { label: \"ArcCos\", value: TrigonometryBlockOperations.ArcCos },\r\n            { label: \"ArcSin\", value: TrigonometryBlockOperations.ArcSin },\r\n            { label: \"Fract\", value: TrigonometryBlockOperations.Fract },\r\n            { label: \"Sign\", value: TrigonometryBlockOperations.Sign },\r\n            { label: \"Radians\", value: TrigonometryBlockOperations.Radians },\r\n            { label: \"Degrees\", value: TrigonometryBlockOperations.Degrees },\r\n            { label: \"Set\", value: TrigonometryBlockOperations.Set },\r\n        ],\r\n    })\r\n    public operation = TrigonometryBlockOperations.Cos;\r\n\r\n    /**\r\n     * Creates a new TrigonometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TrigonometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        let operation = \"\";\r\n\r\n        switch (this.operation) {\r\n            case TrigonometryBlockOperations.Cos: {\r\n                operation = \"cos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sin: {\r\n                operation = \"sin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Abs: {\r\n                operation = \"abs\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp: {\r\n                operation = \"exp\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp2: {\r\n                operation = \"exp2\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Round: {\r\n                operation = \"round\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Floor: {\r\n                operation = \"floor\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Ceiling: {\r\n                operation = \"ceil\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sqrt: {\r\n                operation = \"sqrt\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Log: {\r\n                operation = \"log\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Tan: {\r\n                operation = \"tan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcTan: {\r\n                operation = \"atan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcCos: {\r\n                operation = \"acos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcSin: {\r\n                operation = \"asin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Fract: {\r\n                operation = \"fract\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sign: {\r\n                operation = \"sign\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Radians: {\r\n                operation = \"radians\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Degrees: {\r\n                operation = \"degrees\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Set: {\r\n                operation = \"\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${operation}(${this.input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TrigonometryBlock\", TrigonometryBlock);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { ImageProcessingConfiguration } from \"../imageProcessingConfiguration\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { SfeModeDefine } from \"./Blocks/Fragment/smartFilterFragmentOutputBlock\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Material } from \"../material\";\r\nimport type { TriPlanarBlock } from \"./Blocks/triPlanarBlock\";\r\nimport type { BiPlanarBlock } from \"./Blocks/biPlanarBlock\";\r\nimport type { PrePassRenderer } from \"../../Rendering/prePassRenderer\";\r\nimport type { PrePassTextureBlock } from \"./Blocks/Input/prePassTextureBlock\";\r\nimport type { PrePassOutputBlock } from \"./Blocks/Fragment/prePassOutputBlock\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\nimport type { NodeMaterialTeleportInBlock } from \"./Blocks/Teleport/teleportInBlock\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { PrepareDefinesForCamera, PrepareDefinesForPrePass } from \"../materialHelper.functions\";\r\nimport type { IImageProcessingConfigurationDefines } from \"../imageProcessingConfiguration.defines\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { LoopBlock } from \"./Blocks/loopBlock\";\r\nimport { MaterialHelperGeometryRendering } from \"../materialHelper.geometryrendering\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the NME */\r\n    nodeEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n    };\r\n}\r\n\r\n/** @internal */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    /** Normal */\r\n    public NORMAL = false;\r\n    /** Tangent */\r\n    public TANGENT = false;\r\n    /** Vertex color */\r\n    public VERTEXCOLOR_NME = false;\r\n    /**  Uv1 **/\r\n    public UV1 = false;\r\n    /** Uv2 **/\r\n    public UV2 = false;\r\n    /** Uv3 **/\r\n    public UV3 = false;\r\n    /** Uv4 **/\r\n    public UV4 = false;\r\n    /** Uv5 **/\r\n    public UV5 = false;\r\n    /** Uv6 **/\r\n    public UV6 = false;\r\n\r\n    /** Prepass **/\r\n    public PREPASS = false;\r\n    /** Prepass normal */\r\n    public PREPASS_NORMAL = false;\r\n    /** Prepass normal index */\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    /** Prepass world normal */\r\n    public PREPASS_WORLD_NORMAL = false;\r\n    /** Prepass world normal index */\r\n    public PREPASS_WORLD_NORMAL_INDEX = -1;\r\n    /** Prepass position */\r\n    public PREPASS_POSITION = false;\r\n    /** Prepass position index */\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    /** Prepass local position */\r\n    public PREPASS_LOCAL_POSITION = false;\r\n    /** Prepass local position index */\r\n    public PREPASS_LOCAL_POSITION_INDEX = -1;\r\n    /** Prepass depth */\r\n    public PREPASS_DEPTH = false;\r\n    /** Prepass depth index */\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    /** Clip-space depth */\r\n    public PREPASS_SCREENSPACE_DEPTH = false;\r\n    /** Clip-space depth index */\r\n    public PREPASS_SCREENSPACE_DEPTH_INDEX = -1;\r\n    /** Scene MRT count */\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    /** Bones per mesh */\r\n    public BonesPerMesh = 0;\r\n    /** Using texture for bone storage */\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    /** Morph target position */\r\n    public MORPHTARGETS_POSITION = false;\r\n    /** Morph target normal */\r\n    public MORPHTARGETS_NORMAL = false;\r\n    /** Morph target tangent */\r\n    public MORPHTARGETS_TANGENT = false;\r\n    /** Morph target uv */\r\n    public MORPHTARGETS_UV = false;\r\n    /** Morph target uv2 */\r\n    public MORPHTARGETS_UV2 = false;\r\n    public MORPHTARGETS_COLOR = false;\r\n    /** Morph target support positions */\r\n    public MORPHTARGETTEXTURE_HASPOSITIONS = false;\r\n    /** Morph target support normals */\r\n    public MORPHTARGETTEXTURE_HASNORMALS = false;\r\n    /** Morph target support tangents */\r\n    public MORPHTARGETTEXTURE_HASTANGENTS = false;\r\n    /** Morph target support uvs */\r\n    public MORPHTARGETTEXTURE_HASUVS = false;\r\n    /** Morph target support uv2s */\r\n    public MORPHTARGETTEXTURE_HASUV2S = false;\r\n    public MORPHTARGETTEXTURE_HASCOLORS = false;\r\n    /** Number of morph influencers */\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    /** Using a texture to store morph target data */\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    /** Vignette */\r\n    public VIGNETTE = false;\r\n    /** Multiply blend mode for vignette */\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    /** Opaque blend mode for vignette */\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    /** Tone mapping */\r\n    public TONEMAPPING = 0;\r\n    /** Contrast */\r\n    public CONTRAST = false;\r\n    /** Exposure */\r\n    public EXPOSURE = false;\r\n    /** Color curves */\r\n    public COLORCURVES = false;\r\n    /** Color grading */\r\n    public COLORGRADING = false;\r\n    /** 3D color grading */\r\n    public COLORGRADING3D = false;\r\n    /** Sampler green depth */\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    /** Sampler for BGR map */\r\n    public SAMPLER3DBGRMAP = false;\r\n    /** Dithering */\r\n    public DITHER = false;\r\n    /** Using post process for image processing */\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    /** Skip color clamp */\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n    /** Camera is orthographic */\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    /** Camera is perspective */\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    public AREALIGHTSUPPORTED = true;\r\n\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialDefines\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Set the value of a specific key\r\n     * @param name defines the name of the key to set\r\n     * @param value defines the value to set\r\n     * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing\r\n     */\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n    /** Defines shader language to use (default to GLSL) */\r\n    shaderLanguage: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Blocks that manage a texture\r\n */\r\nexport type NodeMaterialTextureBlocks =\r\n    | TextureBlock\r\n    | ReflectionTextureBaseBlock\r\n    | RefractionBlock\r\n    | CurrentScreenBlock\r\n    | ParticleTextureBlock\r\n    | ImageSourceBlock\r\n    | TriPlanarBlock\r\n    | BiPlanarBlock\r\n    | PrePassTextureBlock;\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n    private _buildIsInProgress = false;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeEditor/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    /** Gets or sets a boolean indicating that render target textures can be serialized */\r\n    public static AllowSerializationOfRenderTargetTextures = false;\r\n\r\n    /** Defines default shader language when no option is defined */\r\n    public static DefaultShaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /** If true, the node material will use GLSL if the engine is WebGL and WGSL if it's WebGPU. It takes priority over DefaultShaderLanguage if it's true */\r\n    public static UseNativeShaderLanguageOfEngine = false;\r\n\r\n    /**\r\n     * Checks if a block is a texture block\r\n     * @param block The block to check\r\n     * @returns True if the block is a texture block\r\n     */\r\n    public static _BlockIsTextureBlock(block: NodeMaterialBlock): block is NodeMaterialTextureBlocks {\r\n        return (\r\n            block.getClassName() === \"TextureBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBaseBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBlock\" ||\r\n            block.getClassName() === \"ReflectionBlock\" ||\r\n            block.getClassName() === \"RefractionBlock\" ||\r\n            block.getClassName() === \"CurrentScreenBlock\" ||\r\n            block.getClassName() === \"SmartFilterTextureBlock\" ||\r\n            block.getClassName() === \"ParticleTextureBlock\" ||\r\n            block.getClassName() === \"ImageSourceBlock\" ||\r\n            block.getClassName() === \"TriPlanarBlock\" ||\r\n            block.getClassName() === \"BiPlanarBlock\" ||\r\n            block.getClassName() === \"PrePassTextureBlock\"\r\n        );\r\n    }\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** @internal */\r\n    public _useAdditionalColor = false;\r\n\r\n    public override set _glowModeEnabled(value: boolean) {\r\n        this._useAdditionalColor = value;\r\n    }\r\n\r\n    /** Get the inspector from bundle or global\r\n     * @returns the global NME\r\n     */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /** Gets or sets the active shader language */\r\n    public override get shaderLanguage(): ShaderLanguage {\r\n        return this._options?.shaderLanguage || NodeMaterial.DefaultShaderLanguage;\r\n    }\r\n\r\n    public override set shaderLanguage(value: ShaderLanguage) {\r\n        this._options.shaderLanguage = value;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Observable raised when an error is detected\r\n     */\r\n    public onBuildErrorObservable = new Observable<string>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @internal\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        if (!NodeMaterial.UseNativeShaderLanguageOfEngine && options && options.shaderLanguage === ShaderLanguage.WGSL && !this.getScene().getEngine().isWebGPU) {\r\n            throw new Error(\"WebGPU shader language is only supported with WebGPU engine\");\r\n        }\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            shaderLanguage: NodeMaterial.DefaultShaderLanguage,\r\n            ...options,\r\n        };\r\n\r\n        if (NodeMaterial.UseNativeShaderLanguageOfEngine) {\r\n            this._options.shaderLanguage = this.getScene().getEngine().isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    public override get _supportGlowLayer() {\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.some((f) => (f as FragmentOutputBlock).additionalColor && (f as FragmentOutputBlock).additionalColor.isConnected)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _processInitializeOnLink(block: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        }\r\n        this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n    }\r\n\r\n    private _attachBlock(node: NodeMaterialBlock) {\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        this._sharedData.raiseBuildError(`Cannot have multiple blocks of type ${className} in the same NodeMaterial`);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        this._attachBlock(node);\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint && !connectedPoint._preventBubbleUp) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Loop\r\n        if (node.isLoop) {\r\n            // We need to keep the storage write block in the active blocks\r\n            const loopBlock = node as LoopBlock;\r\n            if (loopBlock.loopID.hasEndpoints) {\r\n                for (const endpoint of loopBlock.loopID.endpoints) {\r\n                    const block = endpoint.ownerBlock;\r\n                    if (block.outputs.length !== 0) {\r\n                        continue;\r\n                    }\r\n                    state._terminalBlocks.add(block); // Attach the storage write only\r\n                    this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        } else if (node.isTeleportOut) {\r\n            // Teleportation\r\n            const teleport = node as NodeMaterialTeleportOutBlock;\r\n            if (teleport.entryPoint) {\r\n                this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint && !connectedPoint._preventBubbleUp) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If this is a teleport out, we need to reset the connected block\r\n        if (node.isTeleportOut) {\r\n            const teleportOut = node as NodeMaterialTeleportOutBlock;\r\n            if (teleportOut.entryPoint) {\r\n                this._resetDualBlocks(teleportOut.entryPoint, id);\r\n            }\r\n        } else if (node.isLoop) {\r\n            // Loop\r\n            const loopBlock = node as LoopBlock;\r\n            if (loopBlock.loopID.hasEndpoints) {\r\n                for (const endpoint of loopBlock.loopID.endpoints) {\r\n                    const block = endpoint.ownerBlock;\r\n                    if (block.outputs.length !== 0) {\r\n                        continue;\r\n                    }\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = false) {\r\n        if (this._buildIsInProgress) {\r\n            Logger.Warn(\"Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.\");\r\n            return;\r\n        }\r\n        this._buildIsInProgress = true;\r\n        // First time?\r\n        if (!this._vertexCompilationState && !autoConfigure) {\r\n            autoConfigure = true;\r\n        }\r\n\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle || this._mode === NodeMaterialModes.SFE;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            this.onBuildErrorObservable.notifyObservers(\"You must define at least one vertexOutputNode\");\r\n            this._buildIsInProgress = false;\r\n            return;\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            this.onBuildErrorObservable.notifyObservers(\"You must define at least one fragmentOutputNode\");\r\n            this._buildIsInProgress = false;\r\n            return;\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        const needToPurgeList = this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive).length > 1;\r\n        let fragmentOutputNodes = this._fragmentOutputNodes;\r\n\r\n        if (needToPurgeList) {\r\n            // Get all but the final output nodes\r\n            fragmentOutputNodes = this._fragmentOutputNodes.filter((n) => !n._isFinalOutputAndActive);\r\n\r\n            // Get the first with precedence on\r\n            fragmentOutputNodes.push(this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive && n._hasPrecedence)[0]);\r\n        }\r\n\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.nodeMaterial = this;\r\n        this._sharedData.fragmentOutputNodes = fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Are blocks code ready?\r\n        let waitingNodeCount = 0;\r\n        for (const node of this.attachedBlocks) {\r\n            if (!node.codeIsReady) {\r\n                waitingNodeCount++;\r\n                node.onCodeIsReadyObservable.addOnce(() => {\r\n                    waitingNodeCount--;\r\n                    if (waitingNodeCount === 0) {\r\n                        this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (waitingNodeCount !== 0) {\r\n            return;\r\n        }\r\n\r\n        this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);\r\n    }\r\n\r\n    private _finishBuildProcess(verbose: boolean = false, updateBuildId = true, vertexNodes: NodeMaterialBlock[], fragmentNodes: NodeMaterialBlock[]) {\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        if (verbose) {\r\n            Logger.Log(\"Vertex shader:\");\r\n            Logger.Log(this._vertexCompilationState.compilationString);\r\n            Logger.Log(\"Fragment shader:\");\r\n            Logger.Log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        // Errors\r\n        const noError = this._sharedData.emitErrors();\r\n\r\n        this._buildIsInProgress = false;\r\n        if (noError) {\r\n            this._buildWasSuccessful = true;\r\n            this.onBuildObservable.notifyObservers(this);\r\n        }\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n\r\n        if (this.prePassTextureInputs.length) {\r\n            this.getScene().enablePrePassRenderer();\r\n        }\r\n        const prePassRenderer = this.getScene().prePassRenderer;\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an optimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n        const oldColor = defines[\"VERTEXCOLOR_NME\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n        defines[\"VERTEXCOLOR_NME\"] = hasVertexColors;\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(this.getScene(), defines, !oit);\r\n\r\n        MaterialHelperGeometryRendering.PrepareDefines(this.getScene().getEngine().currentRenderPassId, mesh, defines);\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldColor !== defines[\"VERTEXCOLOR_NME\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public override get isPrePassCapable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Outputs written to the prepass\r\n     */\r\n    public get prePassTextureOutputs(): number[] {\r\n        const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === \"PrePassOutputBlock\") as PrePassOutputBlock;\r\n        const result = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\r\n        if (!prePassOutputBlock) {\r\n            return result;\r\n        }\r\n        // Cannot write to prepass if we alread read from prepass\r\n        if (this.prePassTextureInputs.length) {\r\n            return result;\r\n        }\r\n\r\n        if (prePassOutputBlock.viewDepth.isConnected) {\r\n            result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.screenDepth.isConnected) {\r\n            result.push(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.viewNormal.isConnected) {\r\n            result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.worldNormal.isConnected) {\r\n            result.push(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.worldPosition.isConnected) {\r\n            result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.localPosition.isConnected) {\r\n            result.push(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.reflectivity.isConnected) {\r\n            result.push(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.velocity.isConnected) {\r\n            result.push(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.velocityLinear.isConnected) {\r\n            result.push(Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of prepass texture required\r\n     */\r\n    public get prePassTextureInputs(): number[] {\r\n        const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === \"PrePassTextureBlock\") as PrePassTextureBlock[];\r\n        const result = [] as number[];\r\n\r\n        for (const block of prePassTextureBlocks) {\r\n            if (block.position.isConnected && !result.includes(Constants.PREPASS_POSITION_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n            }\r\n            if (block.localPosition.isConnected && !result.includes(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE);\r\n            }\r\n            if (block.depth.isConnected && !result.includes(Constants.PREPASS_DEPTH_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            }\r\n            if (block.screenDepth.isConnected && !result.includes(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE);\r\n            }\r\n            if (block.normal.isConnected && !result.includes(Constants.PREPASS_NORMAL_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n            }\r\n            if (block.worldNormal.isConnected && !result.includes(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to set\r\n     * @returns true if the pre pass is needed\r\n     */\r\n    public override setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);\r\n\r\n        if (prePassRenderer && prePassTexturesRequired.length > 1) {\r\n            let cfg = prePassRenderer.getEffectConfiguration(\"nodeMaterial\");\r\n            if (!cfg) {\r\n                cfg = prePassRenderer.addEffectConfiguration({\r\n                    enabled: true,\r\n                    needsImageProcessing: false,\r\n                    name: \"nodeMaterial\",\r\n                    texturesRequired: [],\r\n                });\r\n            }\r\n            for (const prePassTexture of prePassTexturesRequired) {\r\n                if (!cfg.texturesRequired.includes(prePassTexture)) {\r\n                    cfg.texturesRequired.push(prePassTexture);\r\n                }\r\n            }\r\n            cfg.enabled = true;\r\n        }\r\n\r\n        // COLOR_TEXTURE is always required for prepass, length > 1 means\r\n        // we actually need to write to special prepass textures\r\n        return prePassTexturesRequired.length > 1;\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess && this.mode !== NodeMaterialModes.SFE) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(defines);\r\n\r\n        // If no vertex shader emitted, fallback to default postprocess vertex shader\r\n        const vertexCode = this._sharedData.checks.emitVertex ? this._vertexCompilationState._builtCompilationString : undefined;\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, vertexCode, this.shaderLanguage);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                vertexCode ? tempName : \"postprocess\",\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat,\r\n                this.shaderLanguage\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this.shaderLanguage\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        const refreshEffect = () => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        };\r\n\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            refreshEffect();\r\n        });\r\n\r\n        // This is needed if the procedural texture is not set to refresh automatically\r\n        this.onBuildObservable.add(() => {\r\n            refreshEffect();\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, undefined, this.shaderLanguage);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode, false);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem,\r\n                    this.shaderLanguage\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode, false);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, undefined, this.shaderLanguage);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * Use this material as the shadow depth wrapper of a target material\r\n     * @param targetMaterial defines the target material\r\n     */\r\n    public createAsShadowDepthWrapper(targetMaterial: Material) {\r\n        if (this.mode !== NodeMaterialModes.Material) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\r\n    }\r\n\r\n    private _processDefines(\r\n        defines: NodeMaterialDefines,\r\n        mesh?: AbstractMesh,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Global defines\r\n        const scene = this.getScene();\r\n        if (PrepareDefinesForCamera(scene, defines)) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Shared defines\r\n        for (const b of this._sharedData.blocksWithDefines) {\r\n            b.initializeDefines(defines);\r\n        }\r\n\r\n        for (const b of this._sharedData.blocksWithDefines) {\r\n            b.prepareDefines(defines, this, mesh, useInstances, subMesh);\r\n        }\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            for (const b of this._sharedData.repeatableContentBlocks) {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, defines, mesh);\r\n            }\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            for (const b of this._sharedData.dynamicUniformBlocks) {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            }\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            for (const u of this._fragmentCompilationState.uniforms) {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            for (const s of this._fragmentCompilationState.samplers) {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            }\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            for (const b of this._sharedData.blocksWithFallbacks) {\r\n                b.provideFallbacks(fallbacks, mesh);\r\n            }\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines || typeof subMesh.materialDefines === \"string\") {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(defines, mesh, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    multiTarget: defines.PREPASS,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                    shaderLanguage: this.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n        return `// Vertex shader\\n${this._vertexCompilationState.compilationString}\\n\\n// Fragment shader\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the fragment shader used by the engine for the current node graph\r\n     * @internal\r\n     */\r\n    public async _getProcessedFragmentAsync(): Promise<string> {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        this._processDefines(defines);\r\n\r\n        let processingDefines = defines.toString();\r\n        if (this.mode === NodeMaterialModes.SFE) {\r\n            processingDefines += `#define ${SfeModeDefine}\\n`;\r\n        }\r\n\r\n        return await this._fragmentCompilationState.getProcessedShaderAsync(processingDefines);\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public override bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all texture blocks\r\n     * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\r\n     * @returns\r\n     */\r\n    public getAllTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        const textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            if (NodeMaterial._BlockIsTextureBlock(block)) {\r\n                textureBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        return textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n        this.onBuildErrorObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window.\r\n     * @param additionalConfig Define the configuration of the editor\r\n     */\r\n    private _createNodeEditor(additionalConfig?: any) {\r\n        const nodeEditorConfig: any = {\r\n            nodeMaterial: this,\r\n            ...additionalConfig,\r\n        };\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public async edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return await new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadBabylonScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor(config?.nodeEditorConfig);\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor(config?.nodeEditorConfig);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes.length = 0;\r\n        this._fragmentOutputNodes.length = 0;\r\n        this.attachedBlocks.length = 0;\r\n        this._buildIsInProgress = false;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n        const textureUrl = Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png\");\r\n        currentScreen.texture = new Texture(textureUrl, this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public async loadAsync(url: string, rootUrl: string = \"\") {\r\n        return await NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (rootNode.isTeleportOut) {\r\n            const block = rootNode as NodeMaterialTeleportOutBlock;\r\n            if (block.entryPoint) {\r\n                this._gatherBlocks(block.entryPoint, list);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\n`;\r\n        codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\n// Connections\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\n// Output nodes\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks defines an optional list of blocks to serialize\r\n     * @returns the serialized material object\r\n     */\r\n    public override serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n        serializationObject.alphaMode = this._alphaMode;\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     */\r\n    public parseSerializedObject(source: any, rootUrl: string = \"\", merge = false, urlRewriter?: (url: string) => string) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl, urlRewriter);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Reconnect teleportation\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isTeleportOut) {\r\n                const teleportOut = block as NodeMaterialTeleportOutBlock;\r\n                const id = teleportOut._tempEntryPointUniqueId;\r\n                if (id) {\r\n                    const source = map[id] as NodeMaterialTeleportInBlock;\r\n                    source.attachToEndpoint(teleportOut);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n                isCollapsed: boolean;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (source.forceAlphaBlending !== undefined) {\r\n            this.forceAlphaBlending = source.forceAlphaBlending;\r\n        }\r\n\r\n        if (source.alphaMode !== undefined) {\r\n            this.alphaMode = source.alphaMode;\r\n        }\r\n\r\n        if (!Array.isArray(source.alphaMode)) {\r\n            this._alphaMode = [source.alphaMode ?? Constants.ALPHA_COMBINE];\r\n        } else {\r\n            this._alphaMode = source.alphaMode;\r\n        }\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @deprecated Please use the parseSerializedObject method instead\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        this.parseSerializedObject(source, rootUrl, merge);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     * @returns the cloned material\r\n     */\r\n    public override clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Awaits for all the material textures to be ready before resolving the returned promise.\r\n     * @returns A promise that resolves when the textures are ready.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public whenTexturesReadyAsync(): Promise<void[]> {\r\n        // Ensures all textures are ready to render.\r\n        const textureReadyPromises: Promise<void>[] = [];\r\n        const activeTextures = this.getActiveTextures();\r\n        for (const texture of activeTextures) {\r\n            const internalTexture = texture.getInternalTexture();\r\n            if (internalTexture && !internalTexture.isReady) {\r\n                textureReadyPromises.push(\r\n                    new Promise((textureResolve, textureReject) => {\r\n                        internalTexture.onLoadedObservable.addOnce(() => {\r\n                            textureResolve();\r\n                        });\r\n                        internalTexture.onErrorObservable.addOnce((e) => {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            textureReject(e);\r\n                        });\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        return Promise.all(textureReadyPromises);\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param shaderLanguage defines the language to use (GLSL by default)\r\n     * @returns a new node material\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string = \"\", shaderLanguage = ShaderLanguage.GLSL): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene, { shaderLanguage: shaderLanguage }), source, scene, rootUrl);\r\n\r\n        nodeMaterial.parseSerializedObject(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param targetMaterial defines a material to use instead of creating a new one\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     * @param options defines options to be used with the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        name: string,\r\n        url: string,\r\n        scene: Scene,\r\n        rootUrl: string = \"\",\r\n        skipBuild: boolean = false,\r\n        targetMaterial?: NodeMaterial,\r\n        urlRewriter?: (url: string) => string,\r\n        options?: Partial<INodeMaterialOptions>\r\n    ): Promise<NodeMaterial> {\r\n        const material = targetMaterial ?? new NodeMaterial(name, scene, options);\r\n\r\n        const data = await scene._loadFileAsync(url);\r\n        const serializationObject = JSON.parse(data);\r\n        material.parseSerializedObject(serializationObject, rootUrl, undefined, urlRewriter);\r\n        if (!skipBuild) {\r\n            material.build();\r\n        }\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     * @param options defines options to be used with the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public static ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scene: Scene = EngineStore.LastCreatedScene!,\r\n        rootUrl: string = \"\",\r\n        nodeMaterial?: NodeMaterial,\r\n        skipBuild: boolean = false,\r\n        waitForTextureReadyness: boolean = false,\r\n        urlRewriter?: (url: string) => string,\r\n        options?: Partial<INodeMaterialOptions>\r\n    ): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene, options), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.parseSerializedObject(serializationObject, undefined, undefined, urlRewriter);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        // We reset sideOrientation to default value\r\n                        nodeMaterial.sideOrientation = null;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeMaterial.build();\r\n                            }\r\n                        } catch (err) {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(err);\r\n                        }\r\n\r\n                        if (waitForTextureReadyness) {\r\n                            nodeMaterial\r\n                                .whenTexturesReadyAsync()\r\n                                // eslint-disable-next-line github/no-then\r\n                                .then(() => {\r\n                                    resolve(nodeMaterial!);\r\n                                })\r\n                                // eslint-disable-next-line github/no-then\r\n                                .catch((err) => {\r\n                                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                    reject(err);\r\n                                });\r\n                        } else {\r\n                            resolve(nodeMaterial);\r\n                        }\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface SubMesh {\r\n        /** @internal */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @internal */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n", "import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRControllerPointerSelection } from \"./WebXRControllerPointerSelection\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { IndicesArray, Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { BoundingSphere } from \"../../Culling/boundingSphere\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing\";\r\n// side effects\r\nimport \"../../Meshes/subMesh.project\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ntype ControllerData = {\r\n    xrController?: WebXRInputSource;\r\n    squeezeComponent?: WebXRControllerComponent;\r\n    selectionComponent?: WebXRControllerComponent;\r\n    onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onSqueezeButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n    onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n    meshUnderPointer: Nullable<AbstractMesh>;\r\n    nearInteractionTargetMesh: Nullable<AbstractMesh>;\r\n    pick: Nullable<PickingInfo>;\r\n    stalePick: Nullable<PickingInfo>;\r\n    id: number;\r\n    touchCollisionMesh: AbstractMesh;\r\n    touchCollisionMeshFunction: (isTouch: boolean) => void;\r\n    hydrateCollisionMeshFunction: (isHydration: boolean) => void;\r\n    currentAnimationState: ControllerOrbAnimationState;\r\n    grabRay: Ray;\r\n    nearInteraction: boolean;\r\n    hoverInteraction: boolean;\r\n    grabInteraction: boolean;\r\n    downTriggered: boolean;\r\n    // event support\r\n    eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n    pickedPointVisualCue: AbstractMesh;\r\n    _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>>;\r\n};\r\n\r\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\r\nenum ControllerOrbAnimationState {\r\n    /**\r\n     * Orb is invisible\r\n     */\r\n    DEHYDRATED,\r\n    /**\r\n     * Orb is visible and inside the hover range\r\n     */\r\n    HOVER,\r\n    /**\r\n     * Orb is visible and touching a near interaction target\r\n     */\r\n    TOUCH,\r\n}\r\n\r\n/**\r\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\r\n */\r\nexport const enum WebXRNearControllerMode {\r\n    /**\r\n     * Motion controllers will not support near interaction\r\n     */\r\n    DISABLED = 0,\r\n    /**\r\n     * The interaction point for motion controllers will be inside of them\r\n     */\r\n    CENTERED_ON_CONTROLLER = 1,\r\n    /**\r\n     * The interaction point for motion controllers will be in front of the controller\r\n     */\r\n    CENTERED_IN_FRONT = 2,\r\n}\r\n\r\n/**\r\n * Options interface for the near interaction module\r\n */\r\nexport interface IWebXRNearInteractionOptions {\r\n    /**\r\n     * If provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * The xr input to use with this near interaction\r\n     */\r\n    xrInput: WebXRInput;\r\n    /**\r\n     * Enable near interaction on all controllers instead of switching between them\r\n     */\r\n    enableNearInteractionOnAllControllers?: boolean;\r\n    /**\r\n     * The preferred hand to give the near interaction to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n    /**\r\n     * Disable switching the near interaction from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * Far interaction feature to toggle when near interaction takes precedence\r\n     */\r\n    farInteractionFeature?: WebXRControllerPointerSelection;\r\n\r\n    /**\r\n     * Near interaction mode for motion controllers\r\n     */\r\n    nearInteractionControllerMode?: WebXRNearControllerMode;\r\n\r\n    /**\r\n     * Optional material for the motion controller orb, if enabled\r\n     */\r\n    motionControllerOrbMaterial?: Material;\r\n\r\n    /**\r\n     * If provided, this URL will be used by Node Material to generate the material for the motion controller orb\r\n     * If not provided, a snippet will be downloaded from the Babylon.js snippet server CDN.\r\n     * The NME JSON file can be found here - https://github.com/BabylonJS/Assets/blob/master/nme/nearInteractionTouchMaterial.json\r\n     */\r\n    motionControllerTouchMaterialSnippetUrl?: string;\r\n}\r\n\r\nconst LocalTempVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n\r\n/**\r\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\r\n */\r\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _tmpRay: Ray = new Ray(new Vector3(), new Vector3());\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        // get two new meshes\r\n        const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n        const selectionMesh = this._generateVisualCue();\r\n\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            meshUnderPointer: null,\r\n            nearInteractionTargetMesh: null,\r\n            pick: null,\r\n            stalePick: null,\r\n            touchCollisionMesh,\r\n            touchCollisionMeshFunction: touchCollisionMeshFunction,\r\n            hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\r\n            currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\r\n            grabRay: new Ray(new Vector3(), new Vector3()),\r\n            hoverInteraction: false,\r\n            nearInteraction: false,\r\n            grabInteraction: false,\r\n            downTriggered: false,\r\n            id: WebXRNearInteraction._IdCounter++,\r\n            pickedPointVisualCue: selectionMesh,\r\n        };\r\n\r\n        this._controllers[xrController.uniqueId]._worldScaleObserver =\r\n            this._controllers[xrController.uniqueId]._worldScaleObserver ||\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n                if (values.newScaleFactor !== values.previousScaleFactor) {\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh.dispose();\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue.dispose();\r\n\r\n                    const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();\r\n                    this._controllers[xrController.uniqueId].touchCollisionMesh = touchCollisionMesh;\r\n                    this._controllers[xrController.uniqueId].touchCollisionMeshFunction = touchCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].hydrateCollisionMeshFunction = hydrateCollisionMeshFunction;\r\n                    this._controllers[xrController.uniqueId].pickedPointVisualCue = this._generateVisualCue();\r\n                }\r\n            });\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enableNearInteractionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enableNearInteractionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachNearInteractionMode(xrController);\r\n            case \"gaze\":\r\n                return null;\r\n            case \"screen\":\r\n                return null;\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: ControllerData;\r\n    } = {};\r\n    private _scene: Scene;\r\n\r\n    private _attachedController: string;\r\n\r\n    private _farInteractionFeature: Nullable<WebXRControllerPointerSelection> = null;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.NEAR_INTERACTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * If set to true, the selection mesh will always be hidden. Otherwise it will be shown only when needed\r\n     */\r\n    public alwaysHideSelectionMesh: boolean = false;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private readonly _options: IWebXRNearInteractionOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n        if (this._options.nearInteractionControllerMode === undefined) {\r\n            this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\r\n        }\r\n\r\n        if (this._options.farInteractionFeature) {\r\n            this._farInteractionFeature = this._options.farInteractionFeature;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        for (const controller of this._options.xrInput.controllers) {\r\n            this._attachController(controller);\r\n        }\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        const keys = Object.keys(this._controllers);\r\n        for (const controllerId of keys) {\r\n            this._detachController(controllerId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function sets webXRControllerPointerSelection feature that will be disabled when\r\n     * the hover range is reached for a mesh and will be reattached when not in hover range.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\r\n     */\r\n    public setFarInteractionFeature(farInteractionFeature: Nullable<WebXRControllerPointerSelection>) {\r\n        this._farInteractionFeature = farInteractionFeature;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction pick and hover\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearPickPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for near interaction grab\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearGrabPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\r\n    }\r\n\r\n    /**\r\n     * Filter used for any near interaction\r\n     * @param mesh the mesh candidate to be pick-filtered\r\n     * @returns if the mesh should be included in the list of candidate meshes for near interaction\r\n     */\r\n    private _nearInteractionPredicate(mesh: AbstractMesh): boolean {\r\n        return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\r\n    }\r\n\r\n    private _controllerAvailablePredicate(mesh: AbstractMesh, controllerId: string): boolean {\r\n        let parent: TransformNode = mesh;\r\n\r\n        while (parent) {\r\n            if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\r\n                return false;\r\n            }\r\n            parent = parent.parent as TransformNode;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _handleTransitionAnimation(controllerData: ControllerData, newState: ControllerOrbAnimationState) {\r\n        if (\r\n            controllerData.currentAnimationState === newState ||\r\n            this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT ||\r\n            !!controllerData.xrController?.inputSource.hand\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\r\n        if (newState > controllerData.currentAnimationState) {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.DEHYDRATED: {\r\n                    controllerData.hydrateCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.touchCollisionMeshFunction(true);\r\n                    if (newState === ControllerOrbAnimationState.TOUCH) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            switch (controllerData.currentAnimationState) {\r\n                case ControllerOrbAnimationState.TOUCH: {\r\n                    controllerData.touchCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.HOVER) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                case ControllerOrbAnimationState.HOVER: {\r\n                    controllerData.hydrateCollisionMeshFunction(false);\r\n                    if (newState === ControllerOrbAnimationState.DEHYDRATED) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        controllerData.currentAnimationState = newState;\r\n    }\r\n\r\n    private readonly _hoverRadius = 0.1;\r\n    private readonly _pickRadius = 0.02;\r\n    private readonly _controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\r\n    private readonly _nearGrabLengthScale = 5;\r\n\r\n    private _processTouchPoint(id: string, position: Vector3, orientation: Quaternion) {\r\n        const controllerData = this._controllers[id];\r\n\r\n        // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\r\n        controllerData.grabRay.origin.copyFrom(position);\r\n        orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n        controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\r\n\r\n        if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\r\n            // offset the touch point in the direction the transform is facing\r\n            controllerData.xrController!.getWorldPointerRayToRef(this._tmpRay);\r\n            controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\r\n        }\r\n\r\n        controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius * this._xrSessionManager.worldScalingFactor;\r\n        controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor);\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const keys = Object.keys(this._controllers);\r\n        for (const id of keys) {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            const handData = controllerData.xrController?.inputSource.hand;\r\n            // If near interaction is not enabled/available for this controller, return early\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n            controllerData.hoverInteraction = false;\r\n            controllerData.nearInteraction = false;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                if (handData) {\r\n                    const xrIndexTip = handData.get(\"index-finger-tip\");\r\n                    if (xrIndexTip) {\r\n                        const indexTipPose = _xrFrame.getJointPose!(xrIndexTip, this._xrSessionManager.referenceSpace);\r\n                        if (indexTipPose && indexTipPose.transform) {\r\n                            const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\r\n                            TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\r\n                            TmpVectors.Quaternion[0].set(\r\n                                indexTipPose.transform.orientation.x,\r\n                                indexTipPose.transform.orientation.y,\r\n                                indexTipPose.transform.orientation.z * axisRHSMultiplier,\r\n                                indexTipPose.transform.orientation.w * axisRHSMultiplier\r\n                            );\r\n\r\n                            this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\r\n                        }\r\n                    }\r\n                } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\r\n                    let controllerPose = controllerData.xrController.pointer;\r\n                    if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\r\n                        controllerPose = controllerData.xrController.grip;\r\n                    }\r\n\r\n                    this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion!);\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const accuratePickInfo = (originalScenePick: Nullable<PickingInfo>, utilityScenePick: Nullable<PickingInfo>): Nullable<PickingInfo> => {\r\n                let pick = null;\r\n                if (!utilityScenePick || !utilityScenePick.hit) {\r\n                    // No hit in utility scene\r\n                    pick = originalScenePick;\r\n                } else if (!originalScenePick || !originalScenePick.hit) {\r\n                    // No hit in original scene\r\n                    pick = utilityScenePick;\r\n                } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                    // Hit is closer in utility scene\r\n                    pick = utilityScenePick;\r\n                } else {\r\n                    // Hit is closer in original scene\r\n                    pick = originalScenePick;\r\n                }\r\n                return pick;\r\n            };\r\n            const populateNearInteractionInfo = (nearInteractionInfo: Nullable<PickingInfo>): PickingInfo => {\r\n                let result = new PickingInfo();\r\n\r\n                let nearInteractionAtOrigin = false;\r\n                const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\r\n                if (nearInteractionInfo?.pickedPoint) {\r\n                    nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\r\n                }\r\n                if (nearInteraction && !nearInteractionAtOrigin) {\r\n                    result = nearInteractionInfo!;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\r\n            // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\r\n            // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\r\n            if (!controllerData.grabInteraction) {\r\n                let pick = null;\r\n\r\n                // near interaction hover\r\n                let utilitySceneHoverPick = null;\r\n                if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                    utilitySceneHoverPick = this._pickWithSphere(\r\n                        controllerData,\r\n                        this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                        this._utilityLayerScene,\r\n                        (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                    );\r\n                }\r\n                const originalSceneHoverPick = this._pickWithSphere(\r\n                    controllerData,\r\n                    this._hoverRadius * this._xrSessionManager.worldScalingFactor,\r\n                    this._scene,\r\n                    (mesh: AbstractMesh) => this._nearInteractionPredicate(mesh)\r\n                );\r\n\r\n                const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\r\n                if (hoverPickInfo && hoverPickInfo.hit) {\r\n                    pick = populateNearInteractionInfo(hoverPickInfo);\r\n                    if (pick.hit) {\r\n                        controllerData.hoverInteraction = true;\r\n                    }\r\n                }\r\n\r\n                // near interaction pick\r\n                if (controllerData.hoverInteraction) {\r\n                    let utilitySceneNearPick = null;\r\n                    const radius = (handData ? this._pickRadius : this._controllerPickRadius) * this._xrSessionManager.worldScalingFactor;\r\n                    if (this._options.useUtilityLayer && this._utilityLayerScene) {\r\n                        utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    }\r\n                    const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh: AbstractMesh) => this._nearPickPredicate(mesh));\r\n                    const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\r\n                    const nearPick = populateNearInteractionInfo(pickInfo);\r\n                    if (nearPick.hit) {\r\n                        // Near pick takes precedence over hover interaction\r\n                        pick = nearPick;\r\n                        controllerData.nearInteraction = true;\r\n                    }\r\n                }\r\n\r\n                controllerData.stalePick = controllerData.pick;\r\n                controllerData.pick = pick;\r\n\r\n                // Update mesh under pointer\r\n                if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\r\n                    controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\r\n                    controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\r\n                    controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\r\n                    }\r\n                } else {\r\n                    controllerData.meshUnderPointer = null;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n\r\n                    if (this._farInteractionFeature && this._farInteractionFeature.attached) {\r\n                        this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the interaction animation. Only updates if the visible touch mesh is active\r\n            let state = ControllerOrbAnimationState.DEHYDRATED;\r\n            if (controllerData.grabInteraction || controllerData.nearInteraction) {\r\n                state = ControllerOrbAnimationState.TOUCH;\r\n            } else if (controllerData.hoverInteraction) {\r\n                state = ControllerOrbAnimationState.HOVER;\r\n            }\r\n            this._handleTransitionAnimation(controllerData, state);\r\n        }\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _generateVisualCue() {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const selectionMesh = CreateSphere(\r\n            \"nearInteraction\",\r\n            {\r\n                diameter: 0.0035 * 3 * this._xrSessionManager.worldScalingFactor,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        selectionMesh.rotationQuaternion = Quaternion.Identity();\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        return selectionMesh;\r\n    }\r\n\r\n    private _isControllerReadyForNearInteraction(id: number) {\r\n        if (this._farInteractionFeature) {\r\n            return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _attachNearInteractionMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr-near\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (\r\n                (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController) ||\r\n                !controllerData.xrController ||\r\n                (!controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad))\r\n            ) {\r\n                return;\r\n            }\r\n            if (controllerData.pick) {\r\n                controllerData.pick.ray = controllerData.grabRay;\r\n            }\r\n\r\n            if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n\r\n            // Near pick pointer event\r\n            if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\r\n                if (!controllerData.nearInteractionTargetMesh) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\r\n                this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\r\n                controllerData.downTriggered = false;\r\n                controllerData.nearInteractionTargetMesh = null;\r\n            }\r\n        });\r\n\r\n        const grabCheck = (pressed: boolean) => {\r\n            if (\r\n                this._options.enableNearInteractionOnAllControllers ||\r\n                (xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id))\r\n            ) {\r\n                if (controllerData.pick) {\r\n                    controllerData.pick.ray = controllerData.grabRay;\r\n                }\r\n                if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = false;\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;\r\n                }\r\n            } else {\r\n                if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                    this._attachedController = xrController.uniqueId;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\r\n                if (controllerData.squeezeComponent) {\r\n                    controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                } else {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                    controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                        if (component.changes.pressed) {\r\n                            const pressed = component.changes.pressed.current;\r\n                            grabCheck(pressed);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id) &&\r\n                    controllerData.meshUnderPointer &&\r\n                    this._nearGrabPredicate(controllerData.meshUnderPointer)\r\n                ) {\r\n                    controllerData.grabInteraction = true;\r\n                    controllerData.pickedPointVisualCue.isVisible = false;\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.downTriggered = true;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (\r\n                    controllerData.xrController &&\r\n                    event.inputSource === controllerData.xrController.inputSource &&\r\n                    controllerData.pick &&\r\n                    this._isControllerReadyForNearInteraction(controllerData.id)\r\n                ) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.grabInteraction = false;\r\n                    controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;\r\n                    controllerData.downTriggered = false;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.squeezeComponent) {\r\n            if (controllerData.onSqueezeButtonChangedObserver) {\r\n                controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            const keys = Object.keys(controllerData.eventListeners);\r\n            for (const eventName of keys) {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            }\r\n        }\r\n        controllerData.touchCollisionMesh.dispose();\r\n        controllerData.pickedPointVisualCue.dispose();\r\n\r\n        this._xrSessionManager.runInXRFrame(() => {\r\n            if (!controllerData.downTriggered) {\r\n                return;\r\n            }\r\n            // Fire a pointerup in case controller was detached before a pointerup event was fired\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr-near\",\r\n            };\r\n            this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\r\n        });\r\n\r\n        // remove world scale observer\r\n        if (controllerData._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(controllerData._worldScaleObserver);\r\n        }\r\n\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewTouchPointMesh() {\r\n        const worldScale = this._xrSessionManager.worldScalingFactor;\r\n        // populate information for near hover, pick and pinch\r\n        const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n\r\n        const touchCollisionMesh = CreateSphere(\"PickSphere\", { diameter: 1 * worldScale }, meshCreationScene);\r\n        touchCollisionMesh.isVisible = false;\r\n\r\n        // Generate the material for the touch mesh visuals\r\n        if (this._options.motionControllerOrbMaterial) {\r\n            touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\r\n        } else {\r\n            let parsePromise: Promise<NodeMaterial>;\r\n            if (this._options.motionControllerTouchMaterialSnippetUrl) {\r\n                parsePromise = NodeMaterial.ParseFromFileAsync(\"motionControllerTouchMaterial\", this._options.motionControllerTouchMaterialSnippetUrl, meshCreationScene);\r\n            } else {\r\n                parsePromise = NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene);\r\n            }\r\n            parsePromise\r\n                // eslint-disable-next-line github/no-then\r\n                .then((mat) => {\r\n                    touchCollisionMesh.material = mat;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((err) => {\r\n                    Logger.Warn(`Error creating touch material in WebXRNearInteraction: ${err}`);\r\n                });\r\n        }\r\n\r\n        const easingFunction = new QuadraticEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n\r\n        // Adjust the visual size based off of the size of the touch collision orb.\r\n        // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\r\n        // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\r\n        const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius).scaleInPlace(worldScale);\r\n        const touchSize = this._controllerPickRadius * (4 / 3);\r\n        const touchSizeVec = new Vector3(touchSize, touchSize, touchSize).scaleInPlace(worldScale);\r\n        const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\r\n        const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize).scaleInPlace(worldScale);\r\n        const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\r\n        const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize).scaleInPlace(worldScale);\r\n        const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\r\n        const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize).scaleInPlace(worldScale);\r\n\r\n        const touchKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: hoverTouchTransitionSizeVec },\r\n            { frame: 18, value: touchSizeVec },\r\n        ];\r\n        const releaseKeys = [\r\n            { frame: 0, value: touchSizeVec },\r\n            { frame: 10, value: touchHoverTransitionSizeVec },\r\n            { frame: 18, value: hoverSizeVec },\r\n        ];\r\n        const hydrateKeys = [\r\n            { frame: 0, value: Vector3.ZeroReadOnly },\r\n            { frame: 12, value: hydrateTransitionSizeVec },\r\n            { frame: 15, value: hoverSizeVec },\r\n        ];\r\n        const dehydrateKeys = [\r\n            { frame: 0, value: hoverSizeVec },\r\n            { frame: 10, value: Vector3.ZeroReadOnly },\r\n            { frame: 15, value: Vector3.ZeroReadOnly },\r\n        ];\r\n\r\n        const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        touchAction.setEasingFunction(easingFunction);\r\n        releaseAction.setEasingFunction(easingFunction);\r\n        hydrateAction.setEasingFunction(easingFunction);\r\n        dehydrateAction.setEasingFunction(easingFunction);\r\n\r\n        touchAction.setKeys(touchKeys);\r\n        releaseAction.setKeys(releaseKeys);\r\n        hydrateAction.setKeys(hydrateKeys);\r\n        dehydrateAction.setKeys(dehydrateKeys);\r\n\r\n        const touchCollisionMeshFunction = (isTouch: boolean) => {\r\n            const action = isTouch ? touchAction : releaseAction;\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\r\n        };\r\n\r\n        const hydrateCollisionMeshFunction = (isHydration: boolean) => {\r\n            const action = isHydration ? hydrateAction : dehydrateAction;\r\n            if (isHydration) {\r\n                touchCollisionMesh.isVisible = true;\r\n            }\r\n            meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\r\n                if (!isHydration) {\r\n                    touchCollisionMesh.isVisible = false;\r\n                }\r\n            });\r\n        };\r\n\r\n        return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };\r\n    }\r\n\r\n    private _pickWithSphere(controllerData: ControllerData, radius: number, sceneToUse: Scene, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo> {\r\n        const pickingInfo = new PickingInfo();\r\n        pickingInfo.distance = +Infinity;\r\n\r\n        if (controllerData.touchCollisionMesh && controllerData.xrController) {\r\n            const position = controllerData.touchCollisionMesh.position;\r\n            const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\r\n\r\n            for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\r\n                const mesh = sceneToUse.meshes[meshIndex];\r\n                if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\r\n                    continue;\r\n                }\r\n                const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\r\n\r\n                if (result && result.hit && result.distance < pickingInfo.distance) {\r\n                    pickingInfo.hit = result.hit;\r\n                    pickingInfo.pickedMesh = mesh;\r\n                    pickingInfo.pickedPoint = result.pickedPoint;\r\n                    pickingInfo.aimTransform = controllerData.xrController.pointer;\r\n                    pickingInfo.gripTransform = controllerData.xrController.grip || null;\r\n                    pickingInfo.originMesh = controllerData.touchCollisionMesh;\r\n                    pickingInfo.distance = result.distance;\r\n                    pickingInfo.bu = result.bu;\r\n                    pickingInfo.bv = result.bv;\r\n                    pickingInfo.faceId = result.faceId;\r\n                    pickingInfo.subMeshId = result.subMeshId;\r\n                }\r\n            }\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Picks a mesh with a sphere\r\n     * @param mesh the mesh to pick\r\n     * @param sphere picking sphere in world coordinates\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public static PickMeshWithSphere(mesh: AbstractMesh, sphere: BoundingSphere, skipBoundingInfo = false): PickingInfo {\r\n        const subMeshes = mesh.subMeshes;\r\n        const pi = new PickingInfo();\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (!mesh._generatePointsArray()) {\r\n            return pi;\r\n        }\r\n\r\n        if (!mesh.subMeshes || !boundingInfo) {\r\n            return pi;\r\n        }\r\n\r\n        if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\r\n            return pi;\r\n        }\r\n\r\n        const result = LocalTempVectors[0];\r\n        const tmpVec = LocalTempVectors[1];\r\n        LocalTempVectors[2].setAll(0);\r\n        LocalTempVectors[3].setAll(0);\r\n\r\n        const tmpRay = new Ray(LocalTempVectors[2], LocalTempVectors[3], 1);\r\n\r\n        let distance = +Infinity;\r\n        let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter, intersectionInfo;\r\n        const center = TmpVectors.Vector3[2];\r\n        const worldToMesh = TmpVectors.Matrix[0];\r\n        worldToMesh.copyFrom(mesh.getWorldMatrix());\r\n        worldToMesh.invert();\r\n        Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\r\n\r\n        for (let index = 0; index < subMeshes.length; index++) {\r\n            const subMesh = subMeshes[index];\r\n\r\n            subMesh.projectToRef(center, <Vector3[]>mesh._positions, <IndicesArray>mesh.getIndices(), tmpVec);\r\n\r\n            Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\r\n            tmp = Vector3.Distance(tmpVec, sphere.center);\r\n\r\n            // Check for finger inside of mesh\r\n            tmpDistanceSurfaceToCenter = Vector3.DistanceSquared(tmpVec, mesh.getAbsolutePosition());\r\n            tmpDistanceSphereToCenter = Vector3.DistanceSquared(sphere.center, mesh.getAbsolutePosition());\r\n            if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\r\n                tmp = 0;\r\n                tmpVec.copyFrom(sphere.center);\r\n            }\r\n\r\n            if (tmp !== -1 && tmp < distance) {\r\n                distance = tmp;\r\n\r\n                // ray between the sphere center and the point on the mesh\r\n                Ray.CreateFromToToRef(sphere.center, tmpVec, tmpRay);\r\n                tmpRay.length = distance * 2;\r\n                intersectionInfo = tmpRay.intersectsMesh(mesh);\r\n\r\n                result.copyFrom(tmpVec);\r\n            }\r\n        }\r\n\r\n        if (distance < sphere.radius) {\r\n            pi.hit = true;\r\n            pi.distance = distance;\r\n            pi.pickedMesh = mesh;\r\n            pi.pickedPoint = result.clone();\r\n            if (intersectionInfo && intersectionInfo.bu !== null && intersectionInfo.bv !== null) {\r\n                pi.faceId = intersectionInfo.faceId;\r\n                pi.subMeshId = intersectionInfo.subMeshId;\r\n                pi.bu = intersectionInfo.bu;\r\n                pi.bv = intersectionInfo.bv;\r\n            }\r\n        }\r\n\r\n        return pi;\r\n    }\r\n}\r\n\r\n//Register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRNearInteraction.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRNearInteraction(xrSessionManager, options);\r\n    },\r\n    WebXRNearInteraction.Version,\r\n    true\r\n);\r\n", "import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Button which can be used to enter a different mode of XR\r\n */\r\nexport class WebXREnterExitUIButton {\r\n    /**\r\n     * Creates a WebXREnterExitUIButton\r\n     * @param element button element\r\n     * @param sessionMode XR initialization session mode\r\n     * @param referenceSpaceType the type of reference space to be used\r\n     */\r\n    constructor(\r\n        /** button element */\r\n        public element: HTMLElement,\r\n        /** XR initialization options for the button */\r\n        public sessionMode: XRSessionMode,\r\n        /** Reference space type */\r\n        public referenceSpaceType: XRReferenceSpaceType\r\n    ) {}\r\n\r\n    /**\r\n     * Extendable function which can be used to update the button's visuals when the state changes\r\n     * @param activeButton the current active button in the UI\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public update(activeButton: Nullable<WebXREnterExitUIButton>) {}\r\n}\r\n\r\n/**\r\n * Options to create the webXR UI\r\n */\r\nexport class WebXREnterExitUIOptions {\r\n    /**\r\n     * User provided buttons to enable/disable WebXR. The system will provide default if not set\r\n     */\r\n    customButtons?: Array<WebXREnterExitUIButton>;\r\n    /**\r\n     * A reference space type to use when creating the default button.\r\n     * Default is local-floor\r\n     */\r\n    referenceSpaceType?: XRReferenceSpaceType;\r\n    /**\r\n     * Context to enter xr with\r\n     */\r\n    renderTarget?: Nullable<WebXRRenderTarget>;\r\n    /**\r\n     * A session mode to use when creating the default button.\r\n     * Default is immersive-vr\r\n     */\r\n    sessionMode?: XRSessionMode;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    optionalFeatures?: string[];\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     */\r\n    requiredFeatures?: string[];\r\n\r\n    /**\r\n     * If set, the `sessiongranted` event will not be registered. `sessiongranted` is used to move seamlessly between WebXR experiences.\r\n     * If set to true the user will be forced to press the \"enter XR\" button even if sessiongranted event was triggered.\r\n     * If not set and a sessiongranted event was triggered, the XR session will start automatically.\r\n     */\r\n    ignoreSessionGrantedEvent?: boolean;\r\n\r\n    /**\r\n     * If defined, this function will be executed if the UI encounters an error when entering XR\r\n     */\r\n    onError?: (error: any) => void;\r\n}\r\n/**\r\n * UI to allow the user to enter/exit XR mode\r\n */\r\nexport class WebXREnterExitUI implements IDisposable {\r\n    private _activeButton: Nullable<WebXREnterExitUIButton> = null;\r\n    private _buttons: Array<WebXREnterExitUIButton> = [];\r\n    private _helper: WebXRExperienceHelper;\r\n    private _renderTarget?: WebXRRenderTarget;\r\n    /**\r\n     * The HTML Div Element to which buttons are added.\r\n     */\r\n    public readonly overlay: HTMLDivElement;\r\n\r\n    /**\r\n     * Fired every time the active button is changed.\r\n     *\r\n     * When xr is entered via a button that launches xr that button will be the callback parameter\r\n     *\r\n     * When exiting xr the callback parameter will be null)\r\n     */\r\n    public activeButtonChangedObservable = new Observable<Nullable<WebXREnterExitUIButton>>();\r\n\r\n    /**\r\n     * Construct a new EnterExit UI class\r\n     *\r\n     * @param _scene babylon scene object to use\r\n     * @param options (read-only) version of the options passed to this UI\r\n     */\r\n    public constructor(\r\n        private _scene: Scene,\r\n        /** version of the options passed to this UI */\r\n        public options: WebXREnterExitUIOptions\r\n    ) {\r\n        this.overlay = document.createElement(\"div\");\r\n        this.overlay.classList.add(\"xr-button-overlay\");\r\n\r\n        // prepare for session granted event\r\n        if (!options.ignoreSessionGrantedEvent && (navigator as any).xr) {\r\n            (navigator as any).xr.addEventListener(\"sessiongranted\", this._onSessionGranted);\r\n        }\r\n\r\n        // if served over HTTP, warn people.\r\n        // Hopefully the browsers will catch up\r\n        if (typeof window !== \"undefined\") {\r\n            if (window.location && window.location.protocol === \"http:\" && window.location.hostname !== \"localhost\") {\r\n                Tools.Warn(\"WebXR can only be served over HTTPS\");\r\n                throw new Error(\"WebXR can only be served over HTTPS\");\r\n            }\r\n        }\r\n\r\n        if (options.customButtons) {\r\n            this._buttons = options.customButtons;\r\n        } else {\r\n            this.overlay.style.cssText = \"z-index:11;position: absolute; right: 20px;bottom: 50px;\";\r\n            const sessionMode = options.sessionMode || \"immersive-vr\";\r\n            const referenceSpaceType = options.referenceSpaceType || \"local-floor\";\r\n            const url =\r\n                typeof SVGSVGElement === \"undefined\"\r\n                    ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\r\n                    : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\r\n            let css =\r\n                \".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n                url +\r\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\r\n            css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: \"EXIT\"} .xr-error::after { content: \"ERROR\"}';\r\n\r\n            const style = document.createElement(\"style\");\r\n            style.appendChild(document.createTextNode(css));\r\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n            const hmdBtn = document.createElement(\"button\");\r\n            hmdBtn.className = \"babylonVRicon\";\r\n            hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;\r\n            this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));\r\n            this._buttons[this._buttons.length - 1].update = function (activeButton: WebXREnterExitUIButton) {\r\n                this.element.style.display = activeButton === null || activeButton === this ? \"\" : \"none\";\r\n                hmdBtn.className = \"babylonVRicon\" + (activeButton === this ? \" vrdisplaypresenting\" : \"\");\r\n            };\r\n            this._updateButtons(null);\r\n        }\r\n\r\n        const renderCanvas = _scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode) {\r\n            renderCanvas.parentNode.appendChild(this.overlay);\r\n            _scene.onDisposeObservable.addOnce(() => {\r\n                this.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the helper to be used with this UI component.\r\n     * The UI is bound to an experience helper. If not provided the UI can still be used but the events should be registered by the developer.\r\n     *\r\n     * @param helper the experience helper to attach\r\n     * @param renderTarget an optional render target (in case it is created outside of the helper scope)\r\n     * @returns a promise that resolves when the ui is ready\r\n     */\r\n    public async setHelperAsync(helper: WebXRExperienceHelper, renderTarget?: WebXRRenderTarget): Promise<void> {\r\n        this._helper = helper;\r\n        this._renderTarget = renderTarget;\r\n        const supportedPromises = this._buttons.map(async (btn) => {\r\n            return await helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);\r\n        });\r\n        helper.onStateChangedObservable.add((state) => {\r\n            if (state == WebXRState.NOT_IN_XR) {\r\n                this._updateButtons(null);\r\n            }\r\n        });\r\n        const results = await Promise.all(supportedPromises);\r\n        for (let i = 0; i < results.length; i++) {\r\n            const supported = results[i];\r\n            if (supported) {\r\n                this.overlay.appendChild(this._buttons[i].element);\r\n                this._buttons[i].element.onclick = this._enterXRWithButtonIndexAsync.bind(this, i);\r\n            } else {\r\n                Tools.Warn(`Session mode \"${this._buttons[i].sessionMode}\" not supported in browser`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates UI to allow the user to enter/exit XR mode\r\n     * @param scene the scene to add the ui to\r\n     * @param helper the xr experience helper to enter/exit xr with\r\n     * @param options options to configure the UI\r\n     * @returns the created ui\r\n     */\r\n    public static async CreateAsync(scene: Scene, helper: WebXRExperienceHelper, options: WebXREnterExitUIOptions): Promise<WebXREnterExitUI> {\r\n        const ui = new WebXREnterExitUI(scene, options);\r\n        await ui.setHelperAsync(helper, options.renderTarget || undefined);\r\n        return ui;\r\n    }\r\n\r\n    private async _enterXRWithButtonIndexAsync(idx: number = 0) {\r\n        if (this._helper.state == WebXRState.IN_XR) {\r\n            await this._helper.exitXRAsync();\r\n            this._updateButtons(null);\r\n        } else if (this._helper.state == WebXRState.NOT_IN_XR) {\r\n            try {\r\n                await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {\r\n                    optionalFeatures: this.options.optionalFeatures,\r\n                    requiredFeatures: this.options.requiredFeatures,\r\n                });\r\n                this._updateButtons(this._buttons[idx]);\r\n            } catch (e) {\r\n                // make sure button is visible\r\n                this._updateButtons(null);\r\n                const element = this._buttons[idx].element;\r\n                const prevTitle = element.title;\r\n                element.title = \"Error entering XR session : \" + prevTitle;\r\n                element.classList.add(\"xr-error\");\r\n                if (this.options.onError) {\r\n                    this.options.onError(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the XR UI component\r\n     */\r\n    public dispose() {\r\n        const renderCanvas = this._scene.getEngine().getInputElement();\r\n        if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {\r\n            renderCanvas.parentNode.removeChild(this.overlay);\r\n        }\r\n        this.activeButtonChangedObservable.clear();\r\n        (navigator as any).xr.removeEventListener(\"sessiongranted\", this._onSessionGranted);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _onSessionGranted = (evt: { session: XRSession }) => {\r\n        // This section is for future reference.\r\n        // As per specs, evt.session.mode should have the supported session mode, but no browser supports it for now.\r\n\r\n        // // check if the session granted is the same as the one requested\r\n        // const grantedMode = (evt.session as any).mode;\r\n        // if (grantedMode) {\r\n        //     this._buttons.some((btn, idx) => {\r\n        //         if (btn.sessionMode === grantedMode) {\r\n        //             this._enterXRWithButtonIndex(idx);\r\n        //             return true;\r\n        //         }\r\n        //         return false;\r\n        //     });\r\n        // } else\r\n\r\n        if (this._helper) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._enterXRWithButtonIndexAsync(0);\r\n        }\r\n    };\r\n\r\n    private _updateButtons(activeButton: Nullable<WebXREnterExitUIButton>) {\r\n        this._activeButton = activeButton;\r\n        for (const b of this._buttons) {\r\n            b.update(this._activeButton);\r\n        }\r\n        this.activeButtonChangedObservable.notifyObservers(this._activeButton);\r\n    }\r\n}\r\n", "import type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin } from \"./IPhysicsEnginePlugin\";\r\n/**\r\n * Interface for Physics-Joint data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface PhysicsJointData {\r\n    //Important for some engines, optional!\r\n    /**\r\n     * The main pivot of the joint\r\n     */\r\n    mainPivot?: Vector3;\r\n    /**\r\n     * The connected pivot of the joint\r\n     */\r\n    connectedPivot?: Vector3;\r\n    /**\r\n     * The main axis of the joint\r\n     */\r\n    mainAxis?: Vector3;\r\n    /**\r\n     * The connected axis of the joint\r\n     */\r\n    connectedAxis?: Vector3;\r\n    /**\r\n     * The collision of the joint\r\n     */\r\n    collision?: boolean;\r\n    /**\r\n     * Native Oimo/Cannon/Energy data\r\n     */\r\n    nativeParams?: any;\r\n}\r\n\r\n/**\r\n * This is a holder class for the physics joint created by the physics plugin\r\n * It holds a set of functions to control the underlying joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsJoint {\r\n    private _physicsJoint: any;\r\n    protected _physicsPlugin: IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Initializes the physics joint\r\n     * @param type The type of the physics joint\r\n     * @param jointData The data for the physics joint\r\n     */\r\n    constructor(\r\n        /**\r\n         * The type of the physics joint\r\n         */\r\n        public type: number,\r\n        /**\r\n         * The data for the physics joint\r\n         */\r\n        public jointData: PhysicsJointData\r\n    ) {\r\n        jointData.nativeParams = jointData.nativeParams || {};\r\n    }\r\n\r\n    /**\r\n     * Gets the physics joint\r\n     */\r\n    public get physicsJoint(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return this._physicsJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics joint\r\n     */\r\n    public set physicsJoint(newJoint: any) {\r\n        this._physicsJoint = newJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics plugin\r\n     */\r\n    public set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin) {\r\n        this._physicsPlugin = physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Execute a function that is physics-plugin specific.\r\n     * @param {Function} func the function that will be executed.\r\n     *                        It accepts two parameters: the physics world and the physics joint\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsJoint: any) => void) {\r\n        func(this._physicsPlugin.world, this._physicsJoint);\r\n    }\r\n\r\n    //TODO check if the native joints are the same\r\n\r\n    //Joint Types\r\n    /**\r\n     * Distance-Joint type\r\n     */\r\n    public static DistanceJoint = 0;\r\n    /**\r\n     * Hinge-Joint type\r\n     */\r\n    public static HingeJoint = 1;\r\n    /**\r\n     * Ball-and-Socket joint type\r\n     */\r\n    public static BallAndSocketJoint = 2;\r\n    /**\r\n     * Wheel-Joint type\r\n     */\r\n    public static WheelJoint = 3;\r\n    /**\r\n     * Slider-Joint type\r\n     */\r\n    public static SliderJoint = 4;\r\n    //OIMO\r\n    /**\r\n     * Prismatic-Joint type\r\n     */\r\n    public static PrismaticJoint = 5;\r\n    //\r\n    /**\r\n     * Universal-Joint type\r\n     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\r\n     */\r\n    public static UniversalJoint = 6;\r\n    /**\r\n     * Hinge-Joint 2 type\r\n     */\r\n    public static Hinge2Joint = PhysicsJoint.WheelJoint;\r\n    //Cannon\r\n    /**\r\n     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters\r\n     */\r\n    public static PointToPointJoint = 8;\r\n    //Cannon only at the moment\r\n    /**\r\n     * Spring-Joint type\r\n     */\r\n    public static SpringJoint = 9;\r\n    /**\r\n     * Lock-Joint type\r\n     */\r\n    public static LockJoint = 10;\r\n}\r\n\r\n/**\r\n * A class representing a physics distance joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class DistanceJoint extends PhysicsJoint {\r\n    /**\r\n     *\r\n     * @param jointData The data for the Distance-Joint\r\n     */\r\n    constructor(jointData: DistanceJointData) {\r\n        super(PhysicsJoint.DistanceJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Update the predefined distance.\r\n     * @param maxDistance The maximum preferred distance\r\n     * @param minDistance The minimum preferred distance\r\n     */\r\n    public updateDistance(maxDistance: number, minDistance?: number) {\r\n        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Motor-Enabled Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {\r\n    /**\r\n     * Initializes the Motor-Enabled Joint\r\n     * @param type The type of the joint\r\n     * @param jointData The physical joint data for the joint\r\n     */\r\n    constructor(type: number, jointData: PhysicsJointData) {\r\n        super(type, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param force the force to apply\r\n     * @param maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a single physics Hinge-Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class HingeJoint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge-Joint\r\n     * @param jointData The joint data for the Hinge-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.HingeJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} force the force to apply\r\n     * @param {number} maxForce max force for this motor.\r\n     */\r\n    public override setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public override setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a dual hinge physics joint (same as wheel joint)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class Hinge2Joint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge2-Joint\r\n     * @param jointData The joint data for the Hinge2-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.Hinge2Joint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param targetSpeed the speed the motor is to reach\r\n     * @param maxForce max force for this motor.\r\n     * @param motorIndex motor's index, 0 or 1.\r\n     */\r\n    public override setMotor(targetSpeed?: number, maxForce?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the motor limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit the upper limit\r\n     * @param lowerLimit lower limit\r\n     * @param motorIndex the motor's index, 0 or 1.\r\n     */\r\n    public override setLimit(upperLimit: number, lowerLimit?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a motor enabled joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface IMotorEnabledJoint {\r\n    /**\r\n     * Physics joint\r\n     */\r\n    physicsJoint: any;\r\n    /**\r\n     * Sets the motor of the motor-enabled joint\r\n     * @param force The force of the motor\r\n     * @param maxForce The maximum force of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setMotor(force?: number, maxForce?: number, motorIndex?: number): void;\r\n    /**\r\n     * Sets the limit of the motor\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n}\r\n\r\n/**\r\n * Joint data for a Distance-Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface DistanceJointData extends PhysicsJointData {\r\n    /**\r\n     * Max distance the 2 joint objects can be apart\r\n     */\r\n    maxDistance: number;\r\n    //Oimo - minDistance\r\n    //Cannon - maxForce\r\n}\r\n\r\n/**\r\n * Joint data from a spring joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface SpringJointData extends PhysicsJointData {\r\n    /**\r\n     * Length of the spring\r\n     */\r\n    length: number;\r\n    /**\r\n     * Stiffness of the spring\r\n     */\r\n    stiffness: number;\r\n    /**\r\n     * Damping of the spring\r\n     */\r\n    damping: number;\r\n    /** this callback will be called when applying the force to the impostors. */\r\n    forceApplicationCallback: () => void;\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unsafe-return */\r\nimport type { Nullable, IndicesArray } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { BuildArray } from \"../../Misc/arrayTools\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Bone } from \"../../Bones/bone\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { PhysicsEngine as PhysicsEngineV1 } from \"./physicsEngine\";\r\n\r\nimport type { PhysicsJointData } from \"./physicsJoint\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function (scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(\r\n        physicObject,\r\n        jsonObject.physicsImpostor,\r\n        {\r\n            mass: jsonObject.physicsMass,\r\n            friction: jsonObject.physicsFriction,\r\n            restitution: jsonObject.physicsRestitution,\r\n        },\r\n        scene\r\n    );\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsImpostor {\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @internal */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<PhysicsEngineV1>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @internal */\r\n    public _onPhysicsCollideCallbacks: Array<{\r\n        callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>, distance: number, impulse: number, normal: Nullable<Vector3>) => void;\r\n        otherImpostors: Array<PhysicsImpostor>;\r\n    }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @internal */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _TmpVecs: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    private static _TmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint;\r\n        otherImpostor: PhysicsImpostor;\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter. Types are available as static members of this class.\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number,\r\n        private _options: PhysicsImpostorParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as any;\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n            }\r\n            //default options params\r\n            this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n            this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n            this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\r\n                this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\r\n                this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\r\n                this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\r\n                this._options.path = _options.path === void 0 ? null : _options.path;\r\n                this._options.shape = _options.shape === void 0 ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completely initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @internal\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            const parentMesh: AbstractMesh = this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && (!this._parent || !!this._options.ignoreParent));\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use with caution - This will remove all previously-instantiated joints.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const q = this.object.rotationQuaternion;\r\n            const scaling = this.object.scaling.clone();\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            if (this.object.computeWorldMatrix) {\r\n                this.object.computeWorldMatrix(true);\r\n            }\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter's collision callback\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\r\n        let index = -1;\r\n        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                const sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        if (this._deltaRotationConjugated && this.object.rotationQuaternion) {\r\n            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        }\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            if (this.object.rotationQuaternion) {\r\n                this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n            }\r\n        }\r\n\r\n        for (const func of this._onBeforePhysicsStepCallbacks) {\r\n            func(this);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        for (const func of this._onAfterPhysicsStepCallbacks) {\r\n            func(this);\r\n        }\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        if (this._deltaRotation) {\r\n            if (this.object.rotationQuaternion) {\r\n                this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n            }\r\n            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\r\n            this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\r\n        } else {\r\n            this.object.translate(this._deltaPosition, 1);\r\n        }\r\n        this.object.computeWorldMatrix(true);\r\n    };\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     *  define an onCollide function to call when this impostor collides against a different body\r\n     * @param e collide event data\r\n     */\r\n    public onCollide = (e: { body: any; point: Nullable<Vector3>; distance: number; impulse: number; normal: Nullable<Vector3> }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            const callbacks = this._onPhysicsCollideCallbacks.filter((obj) => {\r\n                return obj.otherImpostors.indexOf(<PhysicsImpostor>otherImpostor) !== -1;\r\n            });\r\n\r\n            for (const obj of callbacks) {\r\n                obj.callback(this, <PhysicsImpostor>otherImpostor, e.point, e.distance, e.impulse, e.normal);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        const joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint,\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) {\r\n            return null;\r\n        }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        for (const j of this._joints) {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        }\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n        const tempVec = PhysicsImpostor._TmpVecs[0];\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = PhysicsImpostor._TmpVecs[0];\r\n        const boneDir = PhysicsImpostor._TmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._TmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type (Only available to objects with vertices data)\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the IcoSphere\r\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n * * radius the radius of the IcoSphere, optional default 1\r\n * * radiusX allows stretching in the x direction, optional, default radius\r\n * * radiusY allows stretching in the y direction, optional, default radius\r\n * * radiusZ allows stretching in the z direction, optional, default radius\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the IcoSphere\r\n */\r\nexport function CreateIcoSphereVertexData(options: {\r\n    radius?: number;\r\n    radiusX?: number;\r\n    radiusY?: number;\r\n    radiusZ?: number;\r\n    flat?: boolean;\r\n    subdivisions?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const radius = options.radius || 1;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const subdivisions = (options.subdivisions || 4) | 0;\r\n    const radiusX = options.radiusX || radius;\r\n    const radiusY = options.radiusY || radius;\r\n    const radiusZ = options.radiusZ || radius;\r\n\r\n    const t = (1 + Math.sqrt(5)) / 2;\r\n\r\n    // 12 vertex x,y,z\r\n    const icoVertices = [\r\n        -1,\r\n        t,\r\n        -0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0, // v0-3\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1,\r\n        t,\r\n        0,\r\n        1,\r\n        t, // v4-7\r\n        t,\r\n        0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1, // v8-11\r\n    ];\r\n\r\n    // index of 3 vertex makes a face of icopshere\r\n    const icoIndices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\r\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    const verticesUnaliasId = [\r\n        0,\r\n        1,\r\n        2,\r\n        3,\r\n        4,\r\n        5,\r\n        6,\r\n        7,\r\n        8,\r\n        9,\r\n        10,\r\n        11,\r\n        // vertex alias\r\n        0, // 12: 0 + 12\r\n        2, // 13: 2 + 11\r\n        3, // 14: 3 + 11\r\n        3, // 15: 3 + 12\r\n        3, // 16: 3 + 13\r\n        4, // 17: 4 + 13\r\n        7, // 18: 7 + 11\r\n        8, // 19: 8 + 11\r\n        9, // 20: 9 + 11\r\n        9, // 21: 9 + 12\r\n        10, // 22: A + 12\r\n        11, // 23: B + 12\r\n    ];\r\n\r\n    // uv as integer step (not pixels !)\r\n    const icoVertexuv = [\r\n        5,\r\n        1,\r\n        3,\r\n        1,\r\n        6,\r\n        4,\r\n        0,\r\n        0, // v0-3\r\n        5,\r\n        3,\r\n        4,\r\n        2,\r\n        2,\r\n        2,\r\n        4,\r\n        0, // v4-7\r\n        2,\r\n        0,\r\n        1,\r\n        1,\r\n        6,\r\n        0,\r\n        6,\r\n        2, // v8-11\r\n        // vertex alias (for same vertex on different faces)\r\n        0,\r\n        4, // 12: 0 + 12\r\n        3,\r\n        3, // 13: 2 + 11\r\n        4,\r\n        4, // 14: 3 + 11\r\n        3,\r\n        1, // 15: 3 + 12\r\n        4,\r\n        2, // 16: 3 + 13\r\n        4,\r\n        4, // 17: 4 + 13\r\n        0,\r\n        2, // 18: 7 + 11\r\n        1,\r\n        1, // 19: 8 + 11\r\n        2,\r\n        2, // 20: 9 + 11\r\n        3,\r\n        3, // 21: 9 + 12\r\n        1,\r\n        3, // 22: A + 12\r\n        2,\r\n        4, // 23: B + 12\r\n    ];\r\n\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    const ustep = 138 / 1024;\r\n    const vstep = 239 / 1024;\r\n    const uoffset = 60 / 1024;\r\n    const voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    const islandUoffset = -40 / 1024;\r\n    const islandVoffset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    const island = [\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1, //  0 - 4\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  5 - 9\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  10 - 14\r\n        0,\r\n        1,\r\n        1,\r\n        1,\r\n        0, //  15 - 19\r\n    ];\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    let currentIndice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    const faceVertexPos = new Array(3);\r\n    const faceVertexUv = new Array(3);\r\n    let v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        faceVertexPos[v012] = Vector3.Zero();\r\n        faceVertexUv[v012] = Vector2.Zero();\r\n    }\r\n    // create all with normals\r\n    for (let face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            const vId = icoIndices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            faceVertexPos[v012].copyFromFloats(icoVertices[3 * verticesUnaliasId[vId]], icoVertices[3 * verticesUnaliasId[vId] + 1], icoVertices[3 * verticesUnaliasId[vId] + 2]);\r\n            // Normalize to get normal\r\n            faceVertexPos[v012].normalize();\r\n\r\n            // uv Coordinates from vertex ID\r\n            faceVertexUv[v012].copyFromFloats(\r\n                icoVertexuv[2 * vId] * ustep + uoffset + island[face] * islandUoffset,\r\n                icoVertexuv[2 * vId + 1] * vstep + voffset + island[face] * islandVoffset\r\n            );\r\n        }\r\n\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n\r\n        const interpVertex = (i1: number, i2: number, c1: number, c2: number) => {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            const posX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], i2 / subdivisions);\r\n            const posX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], i2 / subdivisions);\r\n            const posInterp = subdivisions === i2 ? faceVertexPos[2] : Vector3.Lerp(posX0, posX1, i1 / (subdivisions - i2));\r\n            posInterp.normalize();\r\n\r\n            let vertexNormal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                const centroidX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], c2 / subdivisions);\r\n                const centroidX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], c2 / subdivisions);\r\n                vertexNormal = Vector3.Lerp(centroidX0, centroidX1, c1 / (subdivisions - c2));\r\n            } else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertexNormal = new Vector3(posInterp.x, posInterp.y, posInterp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertexNormal.x /= radiusX;\r\n            vertexNormal.y /= radiusY;\r\n            vertexNormal.z /= radiusZ;\r\n            vertexNormal.normalize();\r\n\r\n            const uvX0 = Vector2.Lerp(faceVertexUv[0], faceVertexUv[2], i2 / subdivisions);\r\n            const uvX1 = Vector2.Lerp(faceVertexUv[1], faceVertexUv[2], i2 / subdivisions);\r\n            const uvInterp = subdivisions === i2 ? faceVertexUv[2] : Vector2.Lerp(uvX0, uvX1, i1 / (subdivisions - i2));\r\n            positions.push(posInterp.x * radiusX, posInterp.y * radiusY, posInterp.z * radiusZ);\r\n            normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);\r\n            uvs.push(uvInterp.x, useOpenGLOrientationForUV ? 1.0 - uvInterp.y : uvInterp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(currentIndice);\r\n            currentIndice++;\r\n        };\r\n\r\n        for (let i2 = 0; i2 < subdivisions; i2++) {\r\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interpVertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interpVertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interpVertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interpVertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interpVertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interpVertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the icosahedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\r\n */\r\nexport function CreateIcoSphere(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateIcoSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const IcoSphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateIcoSphere,\r\n};\r\n\r\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\r\n\r\nMesh.CreateIcoSphere = (name: string, options: { radius?: number; flat?: boolean; subdivisions?: number; sideOrientation?: number; updatable?: boolean }, scene: Scene): Mesh => {\r\n    return CreateIcoSphere(name, options, scene);\r\n};\r\n", "import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\n\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport type { ISceneLoaderAsyncResult } from \"../../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { WebXRCompositionLayerWrapper } from \"./Layers/WebXRCompositionLayer\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes.\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false).\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to an icosphere with two subdivisions and smooth lighting.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius.\r\n         */\r\n        sourceMesh?: Mesh;\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed.\r\n         * @param meshInstance An instance of the original joint mesh being used for the joint.\r\n         * @param jointId The joint's index, see https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section for more info.\r\n         * @param hand Which hand (\"left\", \"right\") the joint will be on.\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, hand: XRHandedness) => AbstractMesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible (defaults to false).\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Scale factor for all joint meshes (defaults to 1)\r\n         */\r\n        scaleFactor?: number;\r\n    };\r\n\r\n    /**\r\n     * Configuration object for the hand meshes.\r\n     */\r\n    handMeshes?: {\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultMeshes?: boolean;\r\n        /**\r\n         * Rigged hand meshes that will be tracked to the user's hands. This will override the default hand mesh.\r\n         */\r\n        customMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * Are the meshes prepared for a left-handed system. Default hand meshes are right-handed.\r\n         */\r\n        meshesUseLeftHandedCoordinates?: boolean;\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        customRigMappings?: {\r\n            right: XRHandMeshRigMapping;\r\n            left: XRHandMeshRigMapping;\r\n        };\r\n\r\n        /**\r\n         * Override the colors of the hand meshes.\r\n         */\r\n        customColors?: {\r\n            base?: Color3;\r\n            fresnel?: Color3;\r\n            fingerColor?: Color3;\r\n            tipFresnel?: Color3;\r\n        };\r\n\r\n        /**\r\n         * Define whether or not the hand meshes should be disposed on just invisible when the session ends.\r\n         * Not setting, or setting to false, will maintain the hand meshes in the scene after the session ends, which will allow q quicker re-entry into XR.\r\n         */\r\n        disposeOnSessionEnd?: boolean;\r\n\r\n        /**\r\n         * Setting this will allow the developer to avoid loading the NME material and use the standard material instead.\r\n         */\r\n        disableHandShader?: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport const enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The thumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Joints of the hand as defined by the WebXR specification.\r\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\r\n */\r\nexport const enum WebXRHandJoint {\r\n    /** Wrist */\r\n    WRIST = \"wrist\",\r\n\r\n    /** Thumb near wrist */\r\n    THUMB_METACARPAL = \"thumb-metacarpal\",\r\n    /** Thumb first knuckle */\r\n    THUMB_PHALANX_PROXIMAL = \"thumb-phalanx-proximal\",\r\n    /** Thumb second knuckle */\r\n    THUMB_PHALANX_DISTAL = \"thumb-phalanx-distal\",\r\n    /** Thumb tip */\r\n    THUMB_TIP = \"thumb-tip\",\r\n\r\n    /** Index finger near wrist */\r\n    INDEX_FINGER_METACARPAL = \"index-finger-metacarpal\",\r\n    /** Index finger first knuckle */\r\n    INDEX_FINGER_PHALANX_PROXIMAL = \"index-finger-phalanx-proximal\",\r\n    /** Index finger second knuckle */\r\n    INDEX_FINGER_PHALANX_INTERMEDIATE = \"index-finger-phalanx-intermediate\",\r\n    /** Index finger third knuckle */\r\n    INDEX_FINGER_PHALANX_DISTAL = \"index-finger-phalanx-distal\",\r\n    /** Index finger tip */\r\n    INDEX_FINGER_TIP = \"index-finger-tip\",\r\n\r\n    /** Middle finger near wrist */\r\n    MIDDLE_FINGER_METACARPAL = \"middle-finger-metacarpal\",\r\n    /** Middle finger first knuckle */\r\n    MIDDLE_FINGER_PHALANX_PROXIMAL = \"middle-finger-phalanx-proximal\",\r\n    /** Middle finger second knuckle */\r\n    MIDDLE_FINGER_PHALANX_INTERMEDIATE = \"middle-finger-phalanx-intermediate\",\r\n    /** Middle finger third knuckle */\r\n    MIDDLE_FINGER_PHALANX_DISTAL = \"middle-finger-phalanx-distal\",\r\n    /** Middle finger tip */\r\n    MIDDLE_FINGER_TIP = \"middle-finger-tip\",\r\n\r\n    /** Ring finger near wrist */\r\n    RING_FINGER_METACARPAL = \"ring-finger-metacarpal\",\r\n    /** Ring finger first knuckle */\r\n    RING_FINGER_PHALANX_PROXIMAL = \"ring-finger-phalanx-proximal\",\r\n    /** Ring finger second knuckle */\r\n    RING_FINGER_PHALANX_INTERMEDIATE = \"ring-finger-phalanx-intermediate\",\r\n    /** Ring finger third knuckle */\r\n    RING_FINGER_PHALANX_DISTAL = \"ring-finger-phalanx-distal\",\r\n    /** Ring finger tip */\r\n    RING_FINGER_TIP = \"ring-finger-tip\",\r\n\r\n    /** Pinky finger near wrist */\r\n    PINKY_FINGER_METACARPAL = \"pinky-finger-metacarpal\",\r\n    /** Pinky finger first knuckle */\r\n    PINKY_FINGER_PHALANX_PROXIMAL = \"pinky-finger-phalanx-proximal\",\r\n    /** Pinky finger second knuckle */\r\n    PINKY_FINGER_PHALANX_INTERMEDIATE = \"pinky-finger-phalanx-intermediate\",\r\n    /** Pinky finger third knuckle */\r\n    PINKY_FINGER_PHALANX_DISTAL = \"pinky-finger-phalanx-distal\",\r\n    /** Pinky finger tip */\r\n    PINKY_FINGER_TIP = \"pinky-finger-tip\",\r\n}\r\n\r\n/** A type encapsulating a dictionary mapping WebXR joints to bone names in a rigged hand mesh.  */\r\nexport type XRHandMeshRigMapping = { [webXRJointName in WebXRHandJoint]: string };\r\n\r\nconst HandJointReferenceArray: WebXRHandJoint[] = [\r\n    WebXRHandJoint.WRIST,\r\n    WebXRHandJoint.THUMB_METACARPAL,\r\n    WebXRHandJoint.THUMB_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.THUMB_PHALANX_DISTAL,\r\n    WebXRHandJoint.THUMB_TIP,\r\n    WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.INDEX_FINGER_TIP,\r\n    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    WebXRHandJoint.RING_FINGER_METACARPAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.RING_FINGER_TIP,\r\n    WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.PINKY_FINGER_TIP,\r\n];\r\n\r\nconst HandPartsDefinition: { [key in HandPart]: WebXRHandJoint[] } = {\r\n    [HandPart.WRIST]: [WebXRHandJoint.WRIST],\r\n    [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\r\n    [HandPart.INDEX]: [\r\n        WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.INDEX_FINGER_TIP,\r\n    ],\r\n    [HandPart.MIDDLE]: [\r\n        WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    ],\r\n    [HandPart.RING]: [\r\n        WebXRHandJoint.RING_FINGER_METACARPAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.RING_FINGER_TIP,\r\n    ],\r\n    [HandPart.LITTLE]: [\r\n        WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.PINKY_FINGER_TIP,\r\n    ],\r\n};\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    /**\r\n     * This observable will notify registered observers when the hand object has been set with a new mesh.\r\n     * you can get the hand mesh using `webxrHand.handMesh`\r\n     */\r\n    public onHandMeshSetObservable = new Observable<WebXRHand>();\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\r\n     */\r\n    private _jointTransforms = new Array<TransformNode>(HandJointReferenceArray.length);\r\n\r\n    /**\r\n     * The float array that will directly receive the transform matrix data from WebXR.\r\n     */\r\n    private _jointTransformMatrices = new Float32Array(HandJointReferenceArray.length * 16);\r\n\r\n    private _tempJointMatrix = new Matrix();\r\n\r\n    /**\r\n     * The float array that will directly receive the joint radii from WebXR.\r\n     */\r\n    private _jointRadii = new Float32Array(HandJointReferenceArray.length);\r\n\r\n    /**\r\n     * The hand mesh's top-most parent, if any.\r\n     */\r\n    private _handMeshRoot: Nullable<Node> = null;\r\n\r\n    /**\r\n     * Get the hand mesh.\r\n     */\r\n    public get handMesh(): Nullable<AbstractMesh> {\r\n        return this._handMesh;\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand.\r\n     * @param part The part of hand to get.\r\n     * @returns An array of meshes that correlate to the hand part requested.\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return HandPartsDefinition[part].map((name) => this._jointMeshes[HandJointReferenceArray.indexOf(name)]);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a mesh linked to a named joint in the hand.\r\n     * @param jointName The name of the joint.\r\n     * @returns An AbstractMesh whose position corresponds with the joint position.\r\n     */\r\n    public getJointMesh(jointName: WebXRHandJoint): AbstractMesh {\r\n        return this._jointMeshes[HandJointReferenceArray.indexOf(jointName)];\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController The controller to which the hand correlates.\r\n     * @param _jointMeshes The meshes to be used to track the hand joints.\r\n     * @param _handMesh An optional hand mesh.\r\n     * @param rigMapping An optional rig mapping for the hand mesh.\r\n     *                   If not provided (but a hand mesh is provided),\r\n     *                   it will be assumed that the hand mesh's bones are named\r\n     *                   directly after the WebXR bone names.\r\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\r\n     * @param _jointsInvisible Are the tracked joint meshes visible\r\n     * @param _jointScaleFactor Scale factor for all joint meshes\r\n     */\r\n    constructor(\r\n        /** The controller to which the hand correlates. */\r\n        public readonly xrController: WebXRInputSource,\r\n        private readonly _jointMeshes: AbstractMesh[],\r\n        private _handMesh: Nullable<AbstractMesh>,\r\n        /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\r\n         * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\r\n        readonly rigMapping: Nullable<XRHandMeshRigMapping>,\r\n        private readonly _leftHandedMeshes: boolean = false,\r\n        private readonly _jointsInvisible: boolean = false,\r\n        private readonly _jointScaleFactor: number = 1\r\n    ) {\r\n        this._scene = _jointMeshes[0].getScene();\r\n\r\n        // Initialize the joint transform quaternions and link the transforms to the bones.\r\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\r\n            this._jointTransforms[jointIdx] = new TransformNode(HandJointReferenceArray[jointIdx], this._scene);\r\n            this._jointTransforms[jointIdx].rotationQuaternion = new Quaternion();\r\n\r\n            // Set the rotation quaternion so we can use it later for tracking.\r\n            if (_jointMeshes[jointIdx].rotationQuaternion) {\r\n                _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\r\n            } else {\r\n                _jointMeshes[jointIdx].rotationQuaternion?.set(0, 0, 0, 1);\r\n            }\r\n        }\r\n\r\n        if (_handMesh) {\r\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\r\n            this.setHandMesh(_handMesh, rigMapping);\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.dispose(false, true);\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController._doNotLoadControllerMesh = true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current hand mesh to render for the WebXRHand.\r\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\r\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\r\n     * @param _xrSessionManager The XRSessionManager used to initialize the hand mesh.\r\n     */\r\n    public setHandMesh(handMesh: AbstractMesh, rigMapping: Nullable<XRHandMeshRigMapping>, _xrSessionManager?: WebXRSessionManager) {\r\n        this._handMesh = handMesh;\r\n\r\n        this._handMeshRoot = this._handMesh;\r\n        while (this._handMeshRoot.parent) {\r\n            this._handMeshRoot = this._handMeshRoot.parent;\r\n        }\r\n\r\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\r\n        handMesh.alwaysSelectAsActiveMesh = true;\r\n        const children = handMesh.getChildMeshes();\r\n        for (const mesh of children) {\r\n            mesh.alwaysSelectAsActiveMesh = true;\r\n        }\r\n\r\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\r\n        if (this._handMesh.skeleton) {\r\n            const handMeshSkeleton = this._handMesh.skeleton;\r\n            for (let jointIdx = 0; jointIdx < HandJointReferenceArray.length; jointIdx++) {\r\n                const jointName = HandJointReferenceArray[jointIdx];\r\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\r\n                if (jointBoneIdx !== -1) {\r\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onHandMeshSetObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame.\r\n     * @param xrFrame The latest frame received from WebXR.\r\n     * @param referenceSpace The current viewer reference space.\r\n     * @param xrCamera the xr camera, used for parenting\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, xrCamera: WebXRCamera) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n\r\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\r\n        const anyHand: any = hand;\r\n        const jointSpaces: XRJointSpace[] = HandJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\r\n        let trackingSuccessful = false;\r\n\r\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\r\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\r\n        } else if (xrFrame.getJointPose) {\r\n            trackingSuccessful = true;\r\n            // Warning: This codepath is slow by comparison, only here for compat.\r\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\r\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\r\n                if (jointPose) {\r\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\r\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\r\n                } else {\r\n                    trackingSuccessful = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!trackingSuccessful) {\r\n            return;\r\n        }\r\n\r\n        for (let jointIdx = 0; jointIdx < HandJointReferenceArray.length; jointIdx++) {\r\n            const jointTransform = this._jointTransforms[jointIdx];\r\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\r\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion!, jointTransform.position);\r\n\r\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\r\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\r\n\r\n            const jointMesh = this._jointMeshes[jointIdx];\r\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\r\n            jointMesh.position.copyFrom(jointTransform.position);\r\n            jointMesh.rotationQuaternion!.copyFrom(jointTransform.rotationQuaternion!);\r\n            jointMesh.scaling.setAll(scaledJointRadius);\r\n            jointMesh.parent = xrCamera.parent;\r\n\r\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\r\n            if (!this._scene.useRightHandedSystem) {\r\n                jointMesh.position.z *= -1;\r\n                jointMesh.rotationQuaternion!.z *= -1;\r\n                jointMesh.rotationQuaternion!.w *= -1;\r\n\r\n                if (this._leftHandedMeshes && this._handMesh) {\r\n                    jointTransform.position.z *= -1;\r\n                    jointTransform.rotationQuaternion!.z *= -1;\r\n                    jointTransform.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = true;\r\n\r\n            if (this._handMeshRoot) {\r\n                this._handMeshRoot.parent = xrCamera.parent;\r\n            }\r\n        }\r\n\r\n        this.xrController.pointer.parent = xrCamera.parent;\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     * @param disposeMeshes Should the meshes be disposed as well\r\n     */\r\n    public dispose(disposeMeshes = false) {\r\n        if (this._handMesh) {\r\n            if (disposeMeshes) {\r\n                this._handMesh.skeleton?.dispose();\r\n                this._handMesh.dispose(false, true);\r\n            } else {\r\n                this._handMesh.isVisible = false;\r\n            }\r\n        }\r\n        for (const transform of this._jointTransforms) {\r\n            transform.dispose();\r\n        }\r\n        this._jointTransforms.length = 0;\r\n        this.onHandMeshSetObservable.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /** The base URL for the default hand model. */\r\n    public static DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/core/HandMeshes/\";\r\n    /** The filename to use for the default right hand model. */\r\n    public static DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\r\n    /** The filename to use for the default left hand model. */\r\n    public static DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\r\n    /** The URL pointing to the default hand model NodeMaterial shader. */\r\n    public static DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/core/HandMeshes/handsShader.json\";\r\n\r\n    // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\r\n    private static readonly _ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\r\n\r\n    private static _RightHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n    private static _LeftHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n\r\n    private static _GenerateTrackedJointMeshes(\r\n        featureOptions: IWebXRHandTrackingOptions,\r\n        originalMesh: Mesh = CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS)\r\n    ): { left: AbstractMesh[]; right: AbstractMesh[] } {\r\n        const meshes: { [handedness: string]: AbstractMesh[] } = {};\r\n        [\"left\" as XRHandedness, \"right\" as XRHandedness].map((handedness) => {\r\n            const trackedMeshes = [];\r\n            originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\r\n            for (let i = 0; i < HandJointReferenceArray.length; ++i) {\r\n                let newInstance: AbstractMesh = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\r\n                if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\r\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, handedness);\r\n                    if (returnedMesh) {\r\n                        if (returnedMesh !== newInstance) {\r\n                            newInstance.dispose();\r\n                            newInstance = returnedMesh;\r\n                        }\r\n                    }\r\n                }\r\n                newInstance.isPickable = false;\r\n                if (featureOptions.jointMeshes?.enablePhysics) {\r\n                    const props = featureOptions.jointMeshes?.physicsProps || {};\r\n                    // downscale the instances so that physics will be initialized correctly\r\n                    newInstance.scaling.setAll(0.02);\r\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n                }\r\n                newInstance.rotationQuaternion = new Quaternion();\r\n                newInstance.isVisible = false;\r\n                trackedMeshes.push(newInstance);\r\n            }\r\n\r\n            meshes[handedness] = trackedMeshes;\r\n        });\r\n        return { left: meshes.left, right: meshes.right };\r\n    }\r\n\r\n    private static async _GenerateDefaultHandMeshesAsync(\r\n        scene: Scene,\r\n        xrSessionManager: WebXRSessionManager,\r\n        options?: IWebXRHandTrackingOptions\r\n    ): Promise<{ left: AbstractMesh; right: AbstractMesh }> {\r\n        // eslint-disable-next-line no-async-promise-executor, @typescript-eslint/no-misused-promises\r\n        return await new Promise(async (resolve) => {\r\n            const riggedMeshes: { [handedness: string]: AbstractMesh } = {};\r\n            // check the cache, defensive\r\n            if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._RightHandGLB = null;\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._LeftHandGLB = null;\r\n            }\r\n\r\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\r\n            // load them in parallel\r\n            const defaulrHandGLBUrl = Tools.GetAssetUrl(WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL);\r\n            const handGLBs = await Promise.all([\r\n                WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync(\"\", defaulrHandGLBUrl, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\r\n                WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync(\"\", defaulrHandGLBUrl, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\r\n            ]);\r\n            // eslint-disable-next-line require-atomic-updates\r\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\r\n            // eslint-disable-next-line require-atomic-updates\r\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\r\n            const shaderUrl = Tools.GetAssetUrl(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\r\n            const handShader = await NodeMaterial.ParseFromFileAsync(\"handShader\", shaderUrl, scene, undefined, true);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n                ...options?.handMeshes?.customColors,\r\n            };\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n            const isMultiview = (xrSessionManager._getBaseLayerWrapper() as WebXRCompositionLayerWrapper)?.isMultiview;\r\n            const hd = [\"left\", \"right\"];\r\n            for (const handedness of hd) {\r\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\r\n                if (!handGLB) {\r\n                    // this should never happen!\r\n                    throw new Error(\"Could not load hand model\");\r\n                }\r\n                const handMesh = handGLB.meshes[1];\r\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\r\n                // if in multiview do not use the material\r\n                if (!isMultiview && !options?.handMeshes?.disableHandShader) {\r\n                    handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\r\n                }\r\n                handMesh.isVisible = false;\r\n\r\n                riggedMeshes[handedness] = handMesh;\r\n\r\n                // single change for left handed systems\r\n                if (!handsDefined && !scene.useRightHandedSystem) {\r\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\r\n                }\r\n            }\r\n\r\n            handShader.dispose();\r\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\r\n     * @param handedness The handedness being mapped for.\r\n     * @returns A mapping from XRHandJoint to bone name.\r\n     */\r\n    private static _GenerateDefaultHandMeshRigMapping(handedness: XRHandedness): XRHandMeshRigMapping {\r\n        const h = handedness == \"right\" ? \"R\" : \"L\";\r\n        return {\r\n            [WebXRHandJoint.WRIST]: `wrist_${h}`,\r\n            [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${h}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${h}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${h}`,\r\n            [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${h}`,\r\n            [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${h}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${h}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${h}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${h}`,\r\n            [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${h}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${h}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${h}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${h}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${h}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${h}`,\r\n            [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${h}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${h}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${h}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${h}`,\r\n            [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${h}`,\r\n            [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${h}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${h}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${h}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${h}`,\r\n            [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${h}`,\r\n        };\r\n    }\r\n\r\n    private _attachedHands: {\r\n        [uniqueId: string]: WebXRHand;\r\n    } = {};\r\n\r\n    private _trackingHands: {\r\n        left: Nullable<WebXRHand>;\r\n        right: Nullable<WebXRHand>;\r\n    } = { left: null, right: null };\r\n\r\n    private _handResources: {\r\n        jointMeshes: Nullable<{ left: AbstractMesh[]; right: AbstractMesh[] }>;\r\n        handMeshes: Nullable<{ left: AbstractMesh; right: AbstractMesh }>;\r\n        rigMappings: Nullable<{ left: XRHandMeshRigMapping; right: XRHandMeshRigMapping }>;\r\n    } = { jointMeshes: null, handMeshes: null, rigMappings: null };\r\n\r\n    private _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>> = null;\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    private _originalMesh?: Mesh;\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     * @returns true if the needed objects for this feature are defined\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._attachedHands[controllerId];\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        if (handedness == \"none\") {\r\n            return null;\r\n        }\r\n        return this._trackingHands[handedness];\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the XR hand tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     * @param options Options to use when constructing this feature.\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /** Options to use when constructing this feature. */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n\r\n        // Support legacy versions of the options object by copying over joint mesh properties\r\n        const anyOptions = options as any;\r\n        const anyJointMeshOptions = anyOptions.jointMeshes;\r\n        if (anyJointMeshOptions) {\r\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\r\n            }\r\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                const leftRigMapping = {};\r\n                const rightRigMapping = {};\r\n                const rigMappingTuples = [\r\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\r\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\r\n                ];\r\n\r\n                for (const rigMappingTuple of rigMappingTuples) {\r\n                    const legacyRigMapping = rigMappingTuple[0] as string[];\r\n                    const rigMapping = rigMappingTuple[1] as XRHandMeshRigMapping;\r\n                    for (let index = 0; index < legacyRigMapping.length; index++) {\r\n                        const modelJointName = legacyRigMapping[index];\r\n                        rigMapping[HandJointReferenceArray[index]] = modelJointName;\r\n                    }\r\n                }\r\n                options.handMeshes.customRigMappings = {\r\n                    left: leftRigMapping as XRHandMeshRigMapping,\r\n                    right: rightRigMapping as XRHandMeshRigMapping,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._handResources.jointMeshes) {\r\n            this._originalMesh = this._originalMesh || this.options.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\r\n            this._originalMesh.isVisible = false;\r\n\r\n            this._handResources.jointMeshes = WebXRHandTracking._GenerateTrackedJointMeshes(this.options, this._originalMesh);\r\n        }\r\n        this._handResources.handMeshes = this.options.handMeshes?.customMeshes || null;\r\n        this._handResources.rigMappings = this.options.handMeshes?.customRigMappings || null;\r\n        // If they didn't supply custom meshes and are not disabling the default meshes...\r\n        if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene!, this._xrSessionManager, this.options).then((defaultHandMeshes) => {\r\n                this._handResources.handMeshes = defaultHandMeshes;\r\n                this._handResources.rigMappings = {\r\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\r\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\r\n                };\r\n\r\n                // Apply meshes to existing hands if already tracking.\r\n                this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left, this._xrSessionManager);\r\n                this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right, this._xrSessionManager);\r\n                this._handResources.handMeshes.left.scaling.setAll(this._xrSessionManager.worldScalingFactor);\r\n                this._handResources.handMeshes.right.scaling.setAll(this._xrSessionManager.worldScalingFactor);\r\n            });\r\n            this._worldScaleObserver = this._xrSessionManager.onWorldScaleFactorChangedObservable.add((scalingFactors) => {\r\n                if (this._handResources.handMeshes) {\r\n                    this._handResources.handMeshes.left.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);\r\n                    this._handResources.handMeshes.right.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);\r\n                }\r\n            });\r\n        }\r\n\r\n        for (const controller of this.options.xrInput.controllers) {\r\n            this._attachHand(controller);\r\n        }\r\n\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace, this.options.xrInput.xrCamera);\r\n        this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace, this.options.xrInput.xrCamera);\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\r\n            return;\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness;\r\n        const webxrHand = new WebXRHand(\r\n            xrController,\r\n            this._handResources.jointMeshes[handedness],\r\n            this._handResources.handMeshes && this._handResources.handMeshes[handedness],\r\n            this._handResources.rigMappings && this._handResources.rigMappings[handedness],\r\n            this.options.handMeshes?.meshesUseLeftHandedCoordinates,\r\n            this.options.jointMeshes?.invisible,\r\n            this.options.jointMeshes?.scaleFactor\r\n        );\r\n\r\n        this._attachedHands[xrController.uniqueId] = webxrHand;\r\n        this._trackingHands[handedness] = webxrHand;\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHandById(controllerId: string, disposeMesh?: boolean) {\r\n        const hand = this.getHandByControllerId(controllerId);\r\n        if (hand) {\r\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\r\n            if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\r\n                this._trackingHands[handedness] = null;\r\n            }\r\n            this.onHandRemovedObservable.notifyObservers(hand);\r\n            hand.dispose(disposeMesh);\r\n            delete this._attachedHands[controllerId];\r\n        }\r\n    }\r\n\r\n    private _detachHand = (xrController: WebXRInputSource) => {\r\n        this._detachHandById(xrController.uniqueId);\r\n    };\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public override detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        const keys = Object.keys(this._attachedHands);\r\n        for (const uniqueId of keys) {\r\n            this._detachHandById(uniqueId, this.options.handMeshes?.disposeOnSessionEnd);\r\n        }\r\n\r\n        if (this.options.handMeshes?.disposeOnSessionEnd) {\r\n            if (this._handResources.jointMeshes) {\r\n                for (const trackedMesh of this._handResources.jointMeshes.left) {\r\n                    trackedMesh.dispose();\r\n                }\r\n                for (const trackedMesh of this._handResources.jointMeshes.right) {\r\n                    trackedMesh.dispose();\r\n                }\r\n                this._handResources.jointMeshes = null;\r\n            }\r\n            if (this._handResources.handMeshes) {\r\n                this._handResources.handMeshes.left.dispose();\r\n                this._handResources.handMeshes.right.dispose();\r\n                this._handResources.handMeshes = null;\r\n            }\r\n\r\n            if (WebXRHandTracking._RightHandGLB) {\r\n                for (const mesh of WebXRHandTracking._RightHandGLB.meshes) {\r\n                    mesh.dispose();\r\n                }\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB) {\r\n                for (const mesh of WebXRHandTracking._LeftHandGLB.meshes) {\r\n                    mesh.dispose();\r\n                }\r\n            }\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n            this._originalMesh?.dispose();\r\n            this._originalMesh = undefined;\r\n        }\r\n\r\n        // remove world scale observer\r\n        if (this._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n        this.onHandRemovedObservable.clear();\r\n\r\n        if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\r\n            // this will dispose the cached meshes\r\n            this._handResources.handMeshes.left.dispose();\r\n            this._handResources.handMeshes.right.dispose();\r\n            // remove the cached meshes\r\n\r\n            if (WebXRHandTracking._RightHandGLB) {\r\n                for (const mesh of WebXRHandTracking._RightHandGLB.meshes) {\r\n                    mesh.dispose();\r\n                }\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB) {\r\n                for (const mesh of WebXRHandTracking._LeftHandGLB.meshes) {\r\n                    mesh.dispose();\r\n                }\r\n            }\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n        }\r\n\r\n        if (this._handResources.jointMeshes) {\r\n            for (const trackedMesh of this._handResources.jointMeshes.left) {\r\n                trackedMesh.dispose();\r\n            }\r\n            for (const trackedMesh of this._handResources.jointMeshes.right) {\r\n                trackedMesh.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n", "import { GetExponentOfTwo } from \"core/Misc/tools.functions\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    if (format) {\r\n        texture.format = format;\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport type { ITextureCreationOptions } from \"../../Materials/Textures/texture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\n/**\r\n * Interface defining options used to create a dynamic texture\r\n */\r\nexport interface IDynamicTextureOptions extends ITextureCreationOptions {\r\n    /** defines the width of the texture (default: 0) */\r\n    width?: number;\r\n    /** defines the height of the texture (default: 0) */\r\n    height?: number;\r\n    /** defines the hosting scene (default: null) */\r\n    scene?: Nullable<Scene>;\r\n}\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _ownCanvas: boolean;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param canvasOrSize provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param options The options to be used when constructing the dynamic texture\r\n     */\r\n    constructor(name: string, canvasOrSize: ICanvas | { width: number; height: number } | number, options?: IDynamicTextureOptions);\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: ICanvas | { width: number; height: number } | number,\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        const isScene = !sceneOrOptions || (sceneOrOptions as Scene)._isScene;\r\n        const scene = isScene ? (sceneOrOptions as Scene) : (sceneOrOptions as IDynamicTextureOptions)?.scene;\r\n        const noMipmap = isScene ? !generateMipMaps : (sceneOrOptions as IDynamicTextureOptions);\r\n\r\n        super(null, scene, noMipmap, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if ((canvasOrSize as ICanvas).getContext) {\r\n            this._canvas = canvasOrSize as ICanvas;\r\n            this._ownCanvas = false;\r\n            this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n            this._ownCanvas = true;\r\n\r\n            const optionsAsSize = canvasOrSize as ISize;\r\n            if (optionsAsSize.width || optionsAsSize.width === 0) {\r\n                this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(canvasOrSize as number, canvasOrSize as number, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public override get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public override scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        // When disposed, this._texture will be null.\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the dynamic texture.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._ownCanvas) {\r\n            this._canvas?.remove?.();\r\n        }\r\n        (this._canvas as any) = null;\r\n        (this._context as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public override clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public override serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @internal */\r\n    public _subdivisionsX: number;\r\n    /** @internal */\r\n    public _subdivisionsY: number;\r\n    /** @internal */\r\n    public _width: number;\r\n    /** @internal */\r\n    public _height: number;\r\n    /** @internal */\r\n    public _minX: number;\r\n    /** @internal */\r\n    public _maxX: number;\r\n    /** @internal */\r\n    public _minZ: number;\r\n    /** @internal */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\r\n     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\r\n     * to get performance improvements when using an octree.\r\n     * @param chunksCount the number of submeshes the mesh will be divided into\r\n     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = [];\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * @param options.width the width (x direction) of the ground, optional, default 1\r\n * @param options.height the height (z direction) of the ground, optional, default 1\r\n * @param options.subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.subdivisionsX the number of subdivisions in the x direction, overrides options.subdivisions, optional, default undefined\r\n * @param options.subdivisionsY the number of subdivisions in the y direction, overrides options.subdivisions, optional, default undefined\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    subdivisions?: number;\r\n    subdivisionsX?: number;\r\n    subdivisionsY?: number;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const subdivisionsX: number = (options.subdivisionsX || options.subdivisions || 1) | 0;\r\n    const subdivisionsY: number = (options.subdivisionsY || options.subdivisions || 1) | 0;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground\r\n * @param options.xmin ground minimum X coordinate, default -1\r\n * @param options.zmin ground minimum Z coordinate, default -1\r\n * @param options.xmax ground maximum X coordinate, default 1\r\n * @param options.zmax ground maximum Z coordinate, default 1\r\n * @param options.subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * @param options.width the width (x direction) of the ground\r\n * @param options.height the height (z direction) of the ground\r\n * @param options.subdivisions the number of subdivisions per side\r\n * @param options.minHeight the minimum altitude on the ground, optional, default 0\r\n * @param options.maxHeight the maximum altitude on the ground, optional default 1\r\n * @param options.colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * @param options.buffer the array holding the image color data\r\n * @param options.bufferWidth the width of image\r\n * @param options.bufferHeight the height of image\r\n * @param options.alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.heightBuffer a array of floats where the height data can be saved, if its length is greater than zero.\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n    heightBuffer?: Float32Array;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n            if (options.heightBuffer) {\r\n                // set the height buffer information in row major order.\r\n                options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width set the width size (float, default 1)\r\n * @param options.height set the height size (float, default 1)\r\n * @param options.subdivisions sets the number of subdivision per side (default 1)\r\n * @param options.subdivisionsX sets the number of subdivision on the X axis (overrides subdivisions)\r\n * @param options.subdivisionsY sets the number of subdivision on the Y axis (overrides subdivisions)\r\n * @param options.updatable defines if the mesh must be flagged as updatable (default false)\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): GroundMesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin ground minimum X coordinate (float, default -1)\r\n * @param options.zmin ground minimum Z coordinate (float, default -1)\r\n * @param options.xmax ground maximum X coordinate (float, default 1)\r\n * @param options.zmax ground maximum Z coordinate (float, default 1)\r\n * @param options.subdivisions a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @param options.updatable boolean, default false, true if the mesh must be flagged as updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map. The height map download can take some frames,\r\n * so the mesh is not immediately ready. To wait for the mesh to be completely built,\r\n * you should use the `onReady` callback option.\r\n * @param name defines the name of the mesh\r\n * @param url sets the URL of the height map image resource.\r\n * @param options defines the options used to create the mesh\r\n * @param options.width sets the ground width size (positive float, default 10)\r\n * @param options.height sets the ground height size (positive float, default 10)\r\n * @param options.subdivisions sets the number of subdivision per side (positive integer, default 1)\r\n * @param options.minHeight is the minimum altitude on the ground (float, default 0)\r\n * @param options.maxHeight is the maximum altitude on the ground (float, default 1)\r\n * @param options.colorFilter is the filter to apply to the image pixel colors to compute the height (optional Color3, default (0.3, 0.59, 0.11) )\r\n * @param options.alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.updatable defines if the mesh must be flagged as updatable\r\n * @param options.onReady is a javascript callback function that will be called once the mesh is just built (the height map download can last some time)\r\n * @param options.onError is a javascript callback function that will be called if there is an error\r\n * @param options.passHeightBufferInCallback a boolean that indicates if the calculated height data will be passed in the onReady callback. Useful if you need the height data for physics, for example.\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string | { data: Uint8Array; width: number; height: number },\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh, heightBuffer?: Float32Array) => void;\r\n        onError?: (message?: string, exception?: any) => void;\r\n        passHeightBufferInCallback?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    let heightBuffer: Float32Array;\r\n    if (options.passHeightBufferInCallback) {\r\n        heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));\r\n    }\r\n\r\n    const onBufferLoaded = (buffer: Uint8Array, bufferWidth: number, bufferHeight: number) => {\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n            heightBuffer,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground, heightBuffer);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    if (typeof url === \"string\") {\r\n        const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            const bufferWidth = img.width;\r\n            const bufferHeight = img.height;\r\n\r\n            if (scene.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            const buffer = scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n            onBufferLoaded(buffer, bufferWidth, bufferHeight);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, options.onError ? options.onError : () => {}, scene.offlineProvider);\r\n    } else {\r\n        onBufferLoaded(url.data, url.width, url.height);\r\n    }\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { IShaderMaterialOptions } from \"../Materials/shaderMaterial\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { MeshCreationOptions } from \"./mesh\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Force all the LineMeshes to compile their default color material to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _isShaderMaterial(shader: Nullable<Material>): shader is ShaderMaterial {\r\n        if (!shader) {\r\n            return false;\r\n        }\r\n\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options: Partial<IShaderMaterialOptions> = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n            shaderLanguage: ShaderLanguage.GLSL,\r\n        };\r\n\r\n        if (!this.useVertexAlpha) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!this.useVertexColor) {\r\n            options.uniforms!.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXCOLOR\");\r\n            options.attributes!.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            const engine = this.getScene().getEngine();\r\n\r\n            if (engine.isWebGPU && !LinesMesh.ForceGLSL) {\r\n                this._shaderLanguage = ShaderLanguage.WGSL;\r\n            }\r\n\r\n            options.shaderLanguage = this._shaderLanguage;\r\n            options.extraInitializationsAsync = async () => {\r\n                if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                    await Promise.all([import(\"../ShadersWGSL/color.vertex\"), import(\"../ShadersWGSL/color.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../Shaders/color.vertex\"), import(\"../Shaders/color.fragment\")]);\r\n                }\r\n            };\r\n\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material as Material;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override set material(value: Nullable<Material>) {\r\n        this._setMaterial(value);\r\n        if (this.material) {\r\n            this.material.fillMode = Material.LineListDrawMode;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this.material)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this.material.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this.material?.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> | MeshCreationOptions = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        if (newParent && (newParent as Node)._addToSceneRootNodes === undefined) {\r\n            const createOptions = newParent as MeshCreationOptions;\r\n            createOptions.source = this;\r\n\r\n            return new LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source as Nullable<LinesMesh>, createOptions.doNotCloneChildren);\r\n        }\r\n\r\n        return new LinesMesh(name, this.getScene(), newParent as Nullable<Node>, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public override createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        instance.refreshBoundingInfo();\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance._creationDataStorage!.dashSize;\r\n            const gapSize = instance._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long in milliseconds should the \"long press\" take before teleport. Defaults to 3 seconds\r\n     */\r\n    timeToTeleport?: number;\r\n\r\n    /**\r\n     * If the main component is used, how long in milliseconds should the \"long press\" take before teleport starts. Defaults to 0\r\n     */\r\n    timeToTeleportStart?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * define an optional predicate to select which meshes should block the teleportation ray\r\n     */\r\n    blockerMeshesPredicate?: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Should the teleportation ray be blocked by all of the scene's pickable meshes?\r\n     * Defaults to false\r\n     */\r\n    blockAllPickableMeshes?: boolean;\r\n\r\n    /**\r\n     * Color of the teleportation ray when it is blocked by a mesh in the pickBlockerMeshes array\r\n     * Defaults to red.\r\n     */\r\n    blockedRayColor?: Color4;\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n                blocked: boolean;\r\n                initialHit: boolean;\r\n                mainComponentUsed: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _blockedRayColor: Color4;\r\n    private _cachedColor4White = new Color4(1, 1, 1, 1);\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _worldScaleObserver?: Nullable<Observer<{ previousScaleFactor: number; newScaleFactor: number }>> = null;\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Observable raised before camera rotation\r\n     */\r\n    public onBeforeCameraTeleportRotation = new Observable<number>();\r\n\r\n    /**\r\n     *  Observable raised after camera rotation\r\n     */\r\n    public onAfterCameraTeleportRotation = new Observable<Quaternion>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport: Observable<Vector3>;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: IWebXRTeleportationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n        this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\r\n\r\n        this._setTargetMeshVisibility(false);\r\n\r\n        // set the observables\r\n        this.onBeforeCameraTeleport = _options.xrInput.xrCamera.onBeforeCameraTeleport;\r\n        this.onAfterCameraTeleport = _options.xrInput.xrCamera.onAfterCameraTeleport;\r\n\r\n        this.parabolicCheckRadius *= this._xrSessionManager.worldScalingFactor;\r\n        this._worldScaleObserver = _xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {\r\n            this.parabolicCheckRadius = (this.parabolicCheckRadius / values.previousScaleFactor) * values.newScaleFactor;\r\n            this._options.teleportationTargetMesh?.scaling.scaleInPlace(values.newScaleFactor / values.previousScaleFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public override attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        for (const controller of this._options.xrInput.controllers) {\r\n            this._attachController(controller);\r\n        }\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public override detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (const controllerId of keys) {\r\n            this._detachController(controllerId);\r\n        }\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n        if (this._worldScaleObserver) {\r\n            this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\r\n        }\r\n        this.onTargetMeshPositionUpdatedObservable.clear();\r\n        this.onTargetMeshPositionUpdatedObservable.clear();\r\n        this.onBeforeCameraTeleportRotation.clear();\r\n        this.onAfterCameraTeleportRotation.clear();\r\n        this.onBeforeCameraTeleport.clear();\r\n        this.onAfterCameraTeleport.clear();\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                const controlSelectionFeature = controllerData.xrController.inputSource.targetRayMode !== \"transient-pointer\";\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\r\n                            return true;\r\n                        }\r\n                        if (this._options.blockAllPickableMeshes && o.isPickable) {\r\n                            return true;\r\n                        }\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\r\n                    if (pick && pick.pickedMesh && !floorMeshPicked) {\r\n                        if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\r\n                            controllerData.teleportationState.forward = false;\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.initialHit = true;\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true, false, controlSelectionFeature);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible, false, controlSelectionFeature);\r\n            } else {\r\n                this._setTargetMeshVisibility(false, false, true);\r\n            }\r\n        } else {\r\n            this._disposeBezierCurve();\r\n            this._setTargetMeshVisibility(false, false, true);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n                blocked: false,\r\n                initialHit: false,\r\n                mainComponentUsed: false,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationState.mainComponentUsed = true;\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n\r\n                            const teleportLocal = () => {\r\n                                // simulate \"forward\" thumbstick push\r\n                                controllerData.teleportationState.forward = true;\r\n                                controllerData.teleportationState.initialHit = false;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                controllerData.teleportationState.currentRotation = 0;\r\n                                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                setAndStartTimer({\r\n                                    timeout: timeToSelect,\r\n                                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                    breakCondition: () => !mainComponent.pressed,\r\n                                    onEnded: () => {\r\n                                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                            this._teleportForward(xrController.uniqueId);\r\n                                        }\r\n                                    },\r\n                                });\r\n                            };\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // delay if the start time is defined\r\n                                    if (this._options.timeToTeleportStart) {\r\n                                        setAndStartTimer({\r\n                                            timeout: this._options.timeToTeleportStart,\r\n                                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                            onEnded: () => {\r\n                                                // check if still pressed\r\n                                                if (mainComponent.pressed) {\r\n                                                    teleportLocal();\r\n                                                }\r\n                                            },\r\n                                        });\r\n                                    } else {\r\n                                        teleportLocal();\r\n                                    }\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        this.onBeforeCameraTeleportRotation.notifyObservers(rotation);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                        this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion);\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.blocked) {\r\n                                    controllerData.teleportationState.blocked = false;\r\n                                    this._setTargetMeshVisibility(false);\r\n                                }\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            controllerData.teleportationState.mainComponentUsed = true;\r\n            let breakObserver = false;\r\n            const teleportLocal = () => {\r\n                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                controllerData.teleportationState.forward = true;\r\n                controllerData.teleportationState.initialHit = false;\r\n                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                controllerData.teleportationState.currentRotation = 0;\r\n                const timeToSelect = this._options.timeToTeleport || 3000;\r\n                setAndStartTimer({\r\n                    timeout: timeToSelect,\r\n                    contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                    onEnded: () => {\r\n                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                            this._teleportForward(xrController.uniqueId);\r\n                        }\r\n                    },\r\n                });\r\n            };\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    breakObserver = false;\r\n                    // check if start time is defined\r\n                    if (this._options.timeToTeleportStart) {\r\n                        setAndStartTimer({\r\n                            timeout: this._options.timeToTeleportStart,\r\n                            contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                            onEnded: () => {\r\n                                // make sure pointer up was not triggered during this time\r\n                                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                    teleportLocal();\r\n                                }\r\n                            },\r\n                            breakCondition: () => {\r\n                                if (breakObserver) {\r\n                                    breakObserver = false;\r\n                                    return true;\r\n                                }\r\n                                return false;\r\n                            },\r\n                        });\r\n                    } else {\r\n                        teleportLocal();\r\n                    }\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    breakObserver = true;\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys: { frame: number; value: number }[] = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor);\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            for (const position of this._snapToPositions) {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            }\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean, force?: boolean, controlSelectionFeature?: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        const children = this._options.teleportationTargetMesh.getChildren(undefined, false);\r\n        for (const m of children) {\r\n            (<any>m).isVisible = visible;\r\n        }\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature && controlSelectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeBezierCurve() {\r\n        if (this._quadraticBezierCurve) {\r\n            this._quadraticBezierCurve.dispose();\r\n            this._quadraticBezierCurve = null;\r\n        }\r\n    }\r\n\r\n    private _colorArray: Color4[] = Array(24).fill(this._cachedColor4White);\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\r\n        const colorsArray = this._colorArray.fill(color || this._cachedColor4White);\r\n        // take out the first 2 points, to not start directly from the controller\r\n        const points = quadraticBezierVectors.getPoints();\r\n        points.shift();\r\n        points.shift();\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: points, instance: this._quadraticBezierCurve as LinesMesh, updatable: true, colors: colorsArray },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n", "import { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IWebXRInputOptions } from \"./webXRInput\";\r\nimport { WebXRInput } from \"./webXRInput\";\r\nimport type { IWebXRControllerPointerSelectionOptions } from \"./features/WebXRControllerPointerSelection\";\r\nimport { WebXRControllerPointerSelection } from \"./features/WebXRControllerPointerSelection\";\r\nimport type { IWebXRNearInteractionOptions } from \"./features/WebXRNearInteraction\";\r\nimport { WebXRNearInteraction } from \"./features/WebXRNearInteraction\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXREnterExitUIOptions } from \"./webXREnterExitUI\";\r\nimport { WebXREnterExitUI } from \"./webXREnterExitUI\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { IWebXRTeleportationOptions } from \"./features/WebXRControllerTeleportation\";\r\nimport { WebXRHandTracking, type IWebXRHandTrackingOptions } from \"./features/WebXRHandTracking\";\r\nimport { WebXRMotionControllerTeleportation } from \"./features/WebXRControllerTeleportation\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Options for the default xr helper\r\n */\r\nexport class WebXRDefaultExperienceOptions {\r\n    /**\r\n     * Enable or disable default UI to enter XR\r\n     */\r\n    public disableDefaultUI?: boolean;\r\n    /**\r\n     * Should pointer selection not initialize.\r\n     * Note that disabling pointer selection also disables teleportation.\r\n     * Defaults to false.\r\n     */\r\n    public disablePointerSelection?: boolean;\r\n    /**\r\n     * Should teleportation not initialize. Defaults to false.\r\n     */\r\n    public disableTeleportation?: boolean;\r\n    /**\r\n     * Should nearInteraction not initialize. Defaults to false.\r\n     */\r\n    public disableNearInteraction?: boolean;\r\n\r\n    /**\r\n     * Should hand tracking be disabled. Defaults to false.\r\n     */\r\n    public disableHandTracking?: boolean;\r\n    /**\r\n     * Floor meshes that will be used for teleport\r\n     */\r\n    public floorMeshes?: Array<AbstractMesh>;\r\n    /**\r\n     * If set to true, the first frame will not be used to reset position\r\n     * The first frame is mainly used when copying transformation from the old camera\r\n     * Mainly used in AR\r\n     */\r\n    public ignoreNativeCameraTransformation?: boolean;\r\n    /**\r\n     * Optional configuration for the XR input object\r\n     */\r\n    public inputOptions?: Partial<IWebXRInputOptions>;\r\n    /**\r\n     * optional configuration for pointer selection\r\n     */\r\n    public pointerSelectionOptions?: Partial<IWebXRControllerPointerSelectionOptions>;\r\n    /**\r\n     * optional configuration for near interaction\r\n     */\r\n    public nearInteractionOptions?: Partial<IWebXRNearInteractionOptions>;\r\n\r\n    /**\r\n     * optional configuration for hand tracking\r\n     */\r\n    public handSupportOptions?: Partial<IWebXRHandTrackingOptions>;\r\n    /**\r\n     * optional configuration for teleportation\r\n     */\r\n    public teleportationOptions?: Partial<IWebXRTeleportationOptions>;\r\n    /**\r\n     * optional configuration for the output canvas\r\n     */\r\n    public outputCanvasOptions?: WebXRManagedOutputCanvasOptions;\r\n    /**\r\n     * optional UI options. This can be used among other to change session mode and reference space type\r\n     */\r\n    public uiOptions?: Partial<WebXREnterExitUIOptions>;\r\n    /**\r\n     * When loading teleportation and pointer select, use stable versions instead of latest.\r\n     */\r\n    public useStablePlugins?: boolean;\r\n\r\n    /**\r\n     * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes\r\n     */\r\n    public renderingGroupId?: number;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     * If set to true, all features we support will be added\r\n     */\r\n    public optionalFeatures?: boolean | string[];\r\n}\r\n\r\n/**\r\n * Default experience for webxr\r\n */\r\nexport class WebXRDefaultExperience {\r\n    /**\r\n     * Base experience\r\n     */\r\n    public baseExperience: WebXRExperienceHelper;\r\n    /**\r\n     * Enables ui for entering/exiting xr\r\n     */\r\n    public enterExitUI: WebXREnterExitUI;\r\n    /**\r\n     * Input experience extension\r\n     */\r\n    public input: WebXRInput;\r\n    /**\r\n     * Enables laser pointer and selection\r\n     */\r\n    public pointerSelection: WebXRControllerPointerSelection;\r\n    /**\r\n     * Default target xr should render to\r\n     */\r\n    public renderTarget: WebXRRenderTarget;\r\n    /**\r\n     * Enables teleportation\r\n     */\r\n    public teleportation: WebXRMotionControllerTeleportation;\r\n\r\n    /**\r\n     * Enables near interaction for hands/controllers\r\n     */\r\n    public nearInteraction: WebXRNearInteraction;\r\n\r\n    private constructor() {}\r\n\r\n    /**\r\n     * Creates the default xr experience\r\n     * @param scene scene\r\n     * @param options options for basic configuration\r\n     * @returns resulting WebXRDefaultExperience\r\n     */\r\n    public static async CreateAsync(scene: Scene, options: WebXRDefaultExperienceOptions = {}) {\r\n        const result = new WebXRDefaultExperience();\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            result.dispose();\r\n        });\r\n        // init the UI right after construction\r\n        if (!options.disableDefaultUI) {\r\n            const uiOptions: WebXREnterExitUIOptions = {\r\n                renderTarget: result.renderTarget,\r\n                ...(options.uiOptions || {}),\r\n            };\r\n            if (options.optionalFeatures) {\r\n                if (typeof options.optionalFeatures === \"boolean\") {\r\n                    uiOptions.optionalFeatures = [\"hit-test\", \"anchors\", \"plane-detection\", \"hand-tracking\"];\r\n                } else {\r\n                    uiOptions.optionalFeatures = options.optionalFeatures;\r\n                }\r\n            }\r\n            result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);\r\n        }\r\n\r\n        try {\r\n            // Create base experience\r\n            const xrHelper = await WebXRExperienceHelper.CreateAsync(scene);\r\n            // eslint-disable-next-line require-atomic-updates\r\n            result.baseExperience = xrHelper;\r\n\r\n            if (options.ignoreNativeCameraTransformation) {\r\n                // eslint-disable-next-line require-atomic-updates\r\n                result.baseExperience.camera.compensateOnFirstFrame = false;\r\n            }\r\n\r\n            // Add controller support\r\n            // eslint-disable-next-line require-atomic-updates\r\n            result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {\r\n                controllerOptions: {\r\n                    renderingGroupId: options.renderingGroupId,\r\n                },\r\n                ...(options.inputOptions || {}),\r\n            });\r\n\r\n            if (!options.disablePointerSelection) {\r\n                // Add default pointer selection\r\n                const pointerSelectionOptions = {\r\n                    ...options.pointerSelectionOptions,\r\n                    xrInput: result.input,\r\n                    renderingGroupId: options.renderingGroupId,\r\n                };\r\n\r\n                result.pointerSelection = <WebXRControllerPointerSelection>(\r\n                    result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRControllerPointerSelection.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRControllerPointerSelectionOptions>pointerSelectionOptions\r\n                    )\r\n                );\r\n\r\n                if (!options.disableTeleportation) {\r\n                    // Add default teleportation, including rotation\r\n                    result.teleportation = <WebXRMotionControllerTeleportation>result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRMotionControllerTeleportation.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRTeleportationOptions>{\r\n                            floorMeshes: options.floorMeshes,\r\n                            xrInput: result.input,\r\n                            renderingGroupId: options.renderingGroupId,\r\n                            ...options.teleportationOptions,\r\n                        }\r\n                    );\r\n                    result.teleportation.setSelectionFeature(result.pointerSelection);\r\n                }\r\n            }\r\n\r\n            if (!options.disableNearInteraction) {\r\n                // Add default pointer selection\r\n                result.nearInteraction = <WebXRNearInteraction>result.baseExperience.featuresManager.enableFeature(\r\n                    WebXRNearInteraction.Name,\r\n                    options.useStablePlugins ? \"stable\" : \"latest\",\r\n                    <IWebXRNearInteractionOptions>{\r\n                        xrInput: result.input,\r\n                        farInteractionFeature: result.pointerSelection,\r\n                        renderingGroupId: options.renderingGroupId,\r\n                        useUtilityLayer: true,\r\n                        enableNearInteractionOnAllControllers: true,\r\n                        ...options.nearInteractionOptions,\r\n                    }\r\n                );\r\n            }\r\n\r\n            if (!options.disableHandTracking) {\r\n                // Add default hand tracking\r\n                result.baseExperience.featuresManager.enableFeature(\r\n                    WebXRHandTracking.Name,\r\n                    options.useStablePlugins ? \"stable\" : \"latest\",\r\n                    <IWebXRHandTrackingOptions>{\r\n                        xrInput: result.input,\r\n                        ...options.handSupportOptions,\r\n                    },\r\n                    undefined,\r\n                    false\r\n                );\r\n            }\r\n\r\n            // Create the WebXR output target\r\n            result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);\r\n\r\n            if (!options.disableDefaultUI) {\r\n                // Create ui for entering/exiting xr\r\n                await result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);\r\n            }\r\n            return result;\r\n        } catch (error) {\r\n            Logger.Error(\"Error initializing XR\");\r\n            Logger.Error(error);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.baseExperience) {\r\n            this.baseExperience.dispose();\r\n        }\r\n        if (this.input) {\r\n            this.input.dispose();\r\n        }\r\n        if (this.enterExitUI) {\r\n            this.enterExitUI.dispose();\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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A;IACA,CAAC;IACD;IACA;IACA,CAAC;IACD;IACA;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;IACA;IACA,CAAC;IACD;IACA;IACA,CAAC;IACD;IACA;;;AAIJ,QAAM,aAAa;IACf;IAAG;IAAI;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAI;IAAI;IAAI;IAAI;IAAG;IAAG;IAAI;IAAG;IAAI;IAAG;IAAI;IAAI;IAAI;IAAI;IAAI;IAAG;IAAG;IAAG;IAAG;IAAI;IAAI;IAAG;IAAI;IAAG;IAAG;IAAI;IAAI;IAAG;IAAI;IAAG;IAAI;IAAG;IAAG;IAAG;IAAG;IAAI;IAAG;IAAI;IACxK;IAAI;IAAG;IAAI;IAAI;IAAI;IAAG;IAAI;IAAG;IAAG;;AAGpC,QAAM,oBAAoB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;;AAIJ,QAAM,cAAc;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IAEA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;;AA0CJ,QAAM,QAAQ,MAAM;AACpB,QAAM,QAAQ,MAAM;AACpB,QAAM,UAAU,KAAK;AACrB,QAAM,UAAU,KAAK;AAGrB,QAAM,gBAAgB,MAAM;AAC5B,QAAM,gBAAgB,KAAM;AAG5B,QAAM,SAAS;IACX;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;;IACA;IACA;IACA;IACA;IACA;;;AAGJ,QAAM,UAAoB,CAAA;AAC1B,QAAM,YAAsB,CAAA;AAC5B,QAAM,UAAoB,CAAA;AAC1B,QAAM,MAAgB,CAAA;AAEtB,MAAI,gBAAgB;AAEpB,QAAM,gBAAgB,IAAI,MAAM,CAAC;AACjC,QAAM,eAAe,IAAI,MAAM,CAAC;AAChC,MAAI;AACJ,OAAK,OAAO,GAAG,OAAO,GAAG,QAAQ;AAC7B,kBAAc,IAAI,IAAI,QAAQ,KAAI;AAClC,iBAAa,IAAI,IAAI,QAAQ,KAAI;EACrC;AAEA,WAAS,OAAO,GAAG,OAAO,IAAI,QAAQ;AAElC,SAAK,OAAO,GAAG,OAAO,GAAG,QAAQ;AAE7B,YAAM,MAAM,WAAW,IAAI,OAAO,IAAI;AAEtC,oBAAc,IAAI,EAAE,eAAe,YAAY,IAAI,kBAAkB,GAAG,CAAC,GAAG,YAAY,IAAI,kBAAkB,GAAG,IAAI,CAAC,GAAG,YAAY,IAAI,kBAAkB,GAAG,IAAI,CAAC,CAAC;AAEpK,oBAAc,IAAI,EAAE,UAAS;AAG7B,mBAAa,IAAI,EAAE,eACf,YAAY,IAAI,GAAG,IAAI,QAAQ,UAAU,OAAO,IAAI,IAAI,eACxD,YAAY,IAAI,MAAM,CAAC,IAAI,QAAQ,UAAU,OAAO,IAAI,IAAI,aAAa;IAEjF;AAuCA,UAAM,eAAe,CAAC,IAAY,IAAY,IAAY,OAAc;AAIpE,YAAM,QAAQ,QAAQ,KAAK,cAAc,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,YAAY;AAChF,YAAM,QAAQ,QAAQ,KAAK,cAAc,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,YAAY;AAChF,YAAM,YAAY,iBAAiB,KAAK,cAAc,CAAC,IAAI,QAAQ,KAAK,OAAO,OAAO,MAAM,eAAe,GAAG;AAC9G,gBAAU,UAAS;AAEnB,UAAI;AACJ,UAAI,MAAM;AAEN,cAAM,aAAa,QAAQ,KAAK,cAAc,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,YAAY;AACrF,cAAM,aAAa,QAAQ,KAAK,cAAc,CAAC,GAAG,cAAc,CAAC,GAAG,KAAK,YAAY;AACrF,uBAAe,QAAQ,KAAK,YAAY,YAAY,MAAM,eAAe,GAAG;MAChF,OAAO;AAEH,uBAAe,IAAI,QAAQ,UAAU,GAAG,UAAU,GAAG,UAAU,CAAC;MACpE;AAEA,mBAAa,KAAK;AAClB,mBAAa,KAAK;AAClB,mBAAa,KAAK;AAClB,mBAAa,UAAS;AAEtB,YAAM,OAAO,QAAQ,KAAK,aAAa,CAAC,GAAG,aAAa,CAAC,GAAG,KAAK,YAAY;AAC7E,YAAM,OAAO,QAAQ,KAAK,aAAa,CAAC,GAAG,aAAa,CAAC,GAAG,KAAK,YAAY;AAC7E,YAAM,WAAW,iBAAiB,KAAK,aAAa,CAAC,IAAI,QAAQ,KAAK,MAAM,MAAM,MAAM,eAAe,GAAG;AAC1G,gBAAU,KAAK,UAAU,IAAI,SAAS,UAAU,IAAI,SAAS,UAAU,IAAI,OAAO;AAClF,cAAQ,KAAK,aAAa,GAAG,aAAa,GAAG,aAAa,CAAC;AAC3D,UAAI,KAAK,SAAS,GAAG,4BAA4B,IAAM,SAAS,IAAI,SAAS,CAAC;AAG9E,cAAQ,KAAK,aAAa;AAC1B;IACJ;AAEA,aAAS,KAAK,GAAG,KAAK,cAAc,MAAM;AACtC,eAAS,KAAK,GAAG,KAAK,KAAK,cAAc,MAAM;AAG3C,qBAAa,IAAI,IAAI,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;AAC/C,qBAAa,KAAK,GAAG,IAAI,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;AACnD,qBAAa,IAAI,KAAK,GAAG,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;AACnD,YAAI,KAAK,KAAK,IAAI,cAAc;AAG5B,uBAAa,KAAK,GAAG,IAAI,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;AACnD,uBAAa,KAAK,GAAG,KAAK,GAAG,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;AACvD,uBAAa,IAAI,KAAK,GAAG,KAAK,IAAM,GAAG,KAAK,IAAM,CAAC;QACvD;MACJ;IACJ;EACJ;AAGA,aAAW,cAAc,iBAAiB,WAAW,SAAS,SAAS,KAAK,QAAQ,UAAU,QAAQ,OAAO;AAG7G,QAAM,aAAa,IAAI,WAAU;AACjC,aAAW,UAAU;AACrB,aAAW,YAAY;AACvB,aAAW,UAAU;AACrB,aAAW,MAAM;AACjB,SAAO;AACX;AAiBM,SAAU,gBACZ,MACA,UAWI,CAAA,GACJ,QAAyB,MAAI;AAE7B,QAAM,SAAS,IAAI,KAAK,MAAM,KAAK;AAEnC,UAAQ,kBAAkB,KAAK,2BAA2B,QAAQ,eAAe;AACjF,SAAO,kCAAkC,QAAQ;AAEjD,QAAM,aAAa,0BAA0B,OAAO;AAEpD,aAAW,YAAY,QAAQ,QAAQ,SAAS;AAEhD,SAAO;AACX;AAUA,WAAW,kBAAkB;AAE7B,KAAK,kBAAkB,CAAC,MAAc,SAAoH,UAAsB;AAC5K,SAAO,gBAAgB,MAAM,SAAS,KAAK;AAC/C;;;ACzSA,IAAkB;CAAlB,SAAkBC,WAAQ;AAItB,EAAAA,UAAA,OAAA,IAAA;AAIA,EAAAA,UAAA,OAAA,IAAA;AAIA,EAAAA,UAAA,OAAA,IAAA;AAIA,EAAAA,UAAA,QAAA,IAAA;AAIA,EAAAA,UAAA,MAAA,IAAA;AAIA,EAAAA,UAAA,QAAA,IAAA;AACJ,GAzBkB,aAAA,WAAQ,CAAA,EAAA;AA+B1B,IAAkB;CAAlB,SAAkBC,iBAAc;AAE5B,EAAAA,gBAAA,OAAA,IAAA;AAGA,EAAAA,gBAAA,kBAAA,IAAA;AAEA,EAAAA,gBAAA,wBAAA,IAAA;AAEA,EAAAA,gBAAA,sBAAA,IAAA;AAEA,EAAAA,gBAAA,WAAA,IAAA;AAGA,EAAAA,gBAAA,yBAAA,IAAA;AAEA,EAAAA,gBAAA,+BAAA,IAAA;AAEA,EAAAA,gBAAA,mCAAA,IAAA;AAEA,EAAAA,gBAAA,6BAAA,IAAA;AAEA,EAAAA,gBAAA,kBAAA,IAAA;AAGA,EAAAA,gBAAA,0BAAA,IAAA;AAEA,EAAAA,gBAAA,gCAAA,IAAA;AAEA,EAAAA,gBAAA,oCAAA,IAAA;AAEA,EAAAA,gBAAA,8BAAA,IAAA;AAEA,EAAAA,gBAAA,mBAAA,IAAA;AAGA,EAAAA,gBAAA,wBAAA,IAAA;AAEA,EAAAA,gBAAA,8BAAA,IAAA;AAEA,EAAAA,gBAAA,kCAAA,IAAA;AAEA,EAAAA,gBAAA,4BAAA,IAAA;AAEA,EAAAA,gBAAA,iBAAA,IAAA;AAGA,EAAAA,gBAAA,yBAAA,IAAA;AAEA,EAAAA,gBAAA,+BAAA,IAAA;AAEA,EAAAA,gBAAA,mCAAA,IAAA;AAEA,EAAAA,gBAAA,6BAAA,IAAA;AAEA,EAAAA,gBAAA,kBAAA,IAAA;AACJ,GAxDkB,mBAAA,iBAAc,CAAA,EAAA;AA6DhC,IAAM,0BAA4C;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BlD,IAAM,sBAA+D;EACjE;IAAA;;EAAA,GAAkB;IAAA;;EAAA;EAClB;IAAA;;EAAA,GAAkB;IAAA;IAAA;IAAA;IAAA;;EAAA;EAClB;IAAA;;EAAA,GAAkB;;;;;;;EAOlB;IAAA;;EAAA,GAAmB;;;;;;;EAOnB;IAAA;;EAAA,GAAiB;;;;;;;EAOjB;IAAA;;EAAA,GAAmB;;;;;;;;AAYjB,IAAO,YAAP,MAAgB;;;;EAkClB,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;;;;;;EAOO,kBAAkB,MAAc;AACnC,WAAO,oBAAoB,IAAI,EAAE,IAAI,CAAC,SAAS,KAAK,aAAa,wBAAwB,QAAQ,IAAI,CAAC,CAAC;EAC3G;;;;;;EAOO,aAAa,WAAyB;AACzC,WAAO,KAAK,aAAa,wBAAwB,QAAQ,SAAS,CAAC;EACvE;;;;;;;;;;;;;;EAeA,YAEoB,cACC,cACT,WAGC,YACQ,oBAA6B,OAC7B,mBAA4B,OAC5B,oBAA4B,GAAC;AAR9B,SAAA,eAAA;AACC,SAAA,eAAA;AACT,SAAA,YAAA;AAGC,SAAA,aAAA;AACQ,SAAA,oBAAA;AACA,SAAA,mBAAA;AACA,SAAA,oBAAA;AA1Ed,SAAA,0BAA0B,IAAI,WAAU;AAOvC,SAAA,mBAAmB,IAAI,MAAqB,wBAAwB,MAAM;AAK1E,SAAA,0BAA0B,IAAI,aAAa,wBAAwB,SAAS,EAAE;AAE9E,SAAA,mBAAmB,IAAI,OAAM;AAK7B,SAAA,cAAc,IAAI,aAAa,wBAAwB,MAAM;AAK7D,SAAA,gBAAgC;AAoDpC,SAAK,SAAS,aAAa,CAAC,EAAE,SAAQ;AAGtC,aAAS,WAAW,GAAG,WAAW,KAAK,iBAAiB,QAAQ,YAAY;AACxE,WAAK,iBAAiB,QAAQ,IAAI,IAAI,cAAc,wBAAwB,QAAQ,GAAG,KAAK,MAAM;AAClG,WAAK,iBAAiB,QAAQ,EAAE,qBAAqB,IAAI,WAAU;AAGnE,UAAI,aAAa,QAAQ,EAAE,oBAAoB;AAC3C,qBAAa,QAAQ,EAAE,qBAAqB,IAAI,WAAU;MAC9D,OAAO;AACH,qBAAa,QAAQ,EAAE,oBAAoB,IAAI,GAAG,GAAG,GAAG,CAAC;MAC7D;IACJ;AAEA,QAAI,WAAW;AAEX,WAAK,YAAY,WAAW,UAAU;IAC1C;AAGA,QAAI,KAAK,aAAa,kBAAkB;AACpC,UAAI,KAAK,aAAa,iBAAiB,UAAU;AAC7C,aAAK,aAAa,iBAAiB,SAAS,QAAQ,OAAO,IAAI;MACnE;IACJ;AAEA,SAAK,aAAa,iCAAiC,IAAI,CAAC,qBAAoB;AACxE,uBAAiB,2BAA2B;IAChD,CAAC;EACL;;;;;;;EAQO,YAAY,UAAwB,YAA4C,mBAAuC;AAC1H,SAAK,YAAY;AAEjB,SAAK,gBAAgB,KAAK;AAC1B,WAAO,KAAK,cAAc,QAAQ;AAC9B,WAAK,gBAAgB,KAAK,cAAc;IAC5C;AAGA,aAAS,2BAA2B;AACpC,UAAM,WAAW,SAAS,eAAc;AACxC,eAAW,QAAQ,UAAU;AACzB,WAAK,2BAA2B;IACpC;AAGA,QAAI,KAAK,UAAU,UAAU;AACzB,YAAM,mBAAmB,KAAK,UAAU;AACxC,eAAS,WAAW,GAAG,WAAW,wBAAwB,QAAQ,YAAY;AAC1E,cAAM,YAAY,wBAAwB,QAAQ;AAClD,cAAM,eAAe,iBAAiB,mBAAmB,aAAa,WAAW,SAAS,IAAI,SAAS;AACvG,YAAI,iBAAiB,IAAI;AACrB,2BAAiB,MAAM,YAAY,EAAE,kBAAkB,KAAK,iBAAiB,QAAQ,CAAC;QAC1F;MACJ;IACJ;AAEA,SAAK,wBAAwB,gBAAgB,IAAI;EACrD;;;;;;;EAQO,kBAAkB,SAAkB,gBAAkC,UAAqB;AAC9F,UAAM,OAAO,KAAK,aAAa,YAAY;AAC3C,QAAI,CAAC,MAAM;AACP;IACJ;AAGA,UAAM,UAAe;AACrB,UAAM,cAA8B,wBAAwB,IAAI,CAAC,cAAc,QAAQ,SAAS,KAAK,KAAK,IAAI,SAAS,CAAC;AACxH,QAAI,qBAAqB;AAEzB,QAAI,QAAQ,aAAa,QAAQ,gBAAgB;AAC7C,2BAAqB,QAAQ,UAAU,aAAa,gBAAgB,KAAK,uBAAuB,KAAK,QAAQ,eAAe,aAAa,KAAK,WAAW;IAC7J,WAAW,QAAQ,cAAc;AAC7B,2BAAqB;AAErB,eAAS,WAAW,GAAG,WAAW,YAAY,QAAQ,YAAY;AAC9D,cAAM,YAAY,QAAQ,aAAa,YAAY,QAAQ,GAAG,cAAc;AAC5E,YAAI,WAAW;AACX,eAAK,wBAAwB,IAAI,UAAU,UAAU,QAAQ,WAAW,EAAE;AAC1E,eAAK,YAAY,QAAQ,IAAI,UAAU,UAAU;QACrD,OAAO;AACH,+BAAqB;AACrB;QACJ;MACJ;IACJ;AAEA,QAAI,CAAC,oBAAoB;AACrB;IACJ;AAEA,aAAS,WAAW,GAAG,WAAW,wBAAwB,QAAQ,YAAY;AAC1E,YAAM,iBAAiB,KAAK,iBAAiB,QAAQ;AACrD,aAAO,eAAe,KAAK,yBAAyB,WAAW,IAAI,KAAK,gBAAgB;AACxF,WAAK,iBAAiB,UAAU,QAAW,eAAe,oBAAqB,eAAe,QAAQ;AAGtG,YAAM,oBAAoB,KAAK,YAAY,QAAQ,IAAI,KAAK;AAE5D,YAAM,YAAY,KAAK,aAAa,QAAQ;AAC5C,gBAAU,YAAY,CAAC,KAAK,aAAa,CAAC,KAAK;AAC/C,gBAAU,SAAS,SAAS,eAAe,QAAQ;AACnD,gBAAU,mBAAoB,SAAS,eAAe,kBAAmB;AACzE,gBAAU,QAAQ,OAAO,iBAAiB;AAC1C,gBAAU,SAAS,SAAS;AAG5B,UAAI,CAAC,KAAK,OAAO,sBAAsB;AACnC,kBAAU,SAAS,KAAK;AACxB,kBAAU,mBAAoB,KAAK;AACnC,kBAAU,mBAAoB,KAAK;AAEnC,YAAI,KAAK,qBAAqB,KAAK,WAAW;AAC1C,yBAAe,SAAS,KAAK;AAC7B,yBAAe,mBAAoB,KAAK;AACxC,yBAAe,mBAAoB,KAAK;QAC5C;MACJ;IACJ;AAEA,QAAI,KAAK,WAAW;AAChB,WAAK,UAAU,YAAY;AAE3B,UAAI,KAAK,eAAe;AACpB,aAAK,cAAc,SAAS,SAAS;MACzC;IACJ;AAEA,SAAK,aAAa,QAAQ,SAAS,SAAS;EAChD;;;;;EAMO,QAAQ,gBAAgB,OAAK;AAChC,QAAI,KAAK,WAAW;AAChB,UAAI,eAAe;AACf,aAAK,UAAU,UAAU,QAAO;AAChC,aAAK,UAAU,QAAQ,OAAO,IAAI;MACtC,OAAO;AACH,aAAK,UAAU,YAAY;MAC/B;IACJ;AACA,eAAW,aAAa,KAAK,kBAAkB;AAC3C,gBAAU,QAAO;IACrB;AACA,SAAK,iBAAiB,SAAS;AAC/B,SAAK,wBAAwB,MAAK;EACtC;;AAME,IAAO,oBAAP,MAAO,2BAA0B,qBAAoB;EA2B/C,OAAO,4BACX,gBACA,eAAqB,gBAAgB,eAAe,mBAAkB,iBAAiB,GAAC;AAExF,UAAM,SAAmD,CAAA;AACzD,KAAC,QAAwB,OAAuB,EAAE,IAAI,CAAC,eAAc;AACjE,YAAM,gBAAgB,CAAA;AACtB,mBAAa,YAAY,CAAC,CAAC,eAAe,aAAa;AACvD,eAAS,IAAI,GAAG,IAAI,wBAAwB,QAAQ,EAAE,GAAG;AACrD,YAAI,cAA4B,aAAa,eAAe,GAAG,UAAU,cAAc,CAAC,EAAE;AAC1F,YAAI,eAAe,aAAa,0BAA0B;AACtD,gBAAM,eAAe,eAAe,YAAY,yBAAyB,aAA8B,GAAG,UAAU;AACpH,cAAI,cAAc;AACd,gBAAI,iBAAiB,aAAa;AAC9B,0BAAY,QAAO;AACnB,4BAAc;YAClB;UACJ;QACJ;AACA,oBAAY,aAAa;AACzB,YAAI,eAAe,aAAa,eAAe;AAC3C,gBAAM,QAAQ,eAAe,aAAa,gBAAgB,CAAA;AAE1D,sBAAY,QAAQ,OAAO,IAAI;AAC/B,gBAAM,OAAO,MAAM,iBAAiB,SAAY,MAAM,eAAe,gBAAgB;AACrF,sBAAY,kBAAkB,IAAI,gBAAgB,aAAa,MAAM,EAAE,MAAM,GAAG,GAAG,MAAK,CAAE;QAC9F;AACA,oBAAY,qBAAqB,IAAI,WAAU;AAC/C,oBAAY,YAAY;AACxB,sBAAc,KAAK,WAAW;MAClC;AAEA,aAAO,UAAU,IAAI;IACzB,CAAC;AACD,WAAO,EAAE,MAAM,OAAO,MAAM,OAAO,OAAO,MAAK;EACnD;EAEQ,aAAa,gCACjB,OACA,kBACA,SAAmC;AAGnC,WAAO,MAAM,IAAI,QAAQ,OAAO,YAAW;AACvC,YAAM,eAAuD,CAAA;AAE7D,UAAI,mBAAkB,eAAe,OAAO,CAAC,GAAG,WAAU,GAAI;AAC1D,2BAAkB,gBAAgB;MACtC;AACA,UAAI,mBAAkB,cAAc,OAAO,CAAC,GAAG,WAAU,GAAI;AACzD,2BAAkB,eAAe;MACrC;AAEA,YAAM,eAAe,CAAC,EAAE,mBAAkB,iBAAiB,mBAAkB;AAE7E,YAAM,oBAAoB,MAAM,YAAY,mBAAkB,2BAA2B;AACzF,YAAM,WAAW,MAAM,QAAQ,IAAI;QAC/B,mBAAkB,iBAAiB,YAAY,gBAAgB,IAAI,mBAAmB,mBAAkB,mCAAmC,KAAK;QAChJ,mBAAkB,gBAAgB,YAAY,gBAAgB,IAAI,mBAAmB,mBAAkB,kCAAkC,KAAK;OACjJ;AAED,yBAAkB,gBAAgB,SAAS,CAAC;AAE5C,yBAAkB,eAAe,SAAS,CAAC;AAC3C,YAAM,YAAY,MAAM,YAAY,mBAAkB,6BAA6B;AACnF,YAAM,aAAa,MAAM,aAAa,mBAAmB,cAAc,WAAW,OAAO,QAAW,IAAI;AAGxG,iBAAW,mBAAmB;AAC9B,iBAAW,mBAAmB,SAAS;AACvC,iBAAW,YAAY;AAGvB,iBAAW,MAAM,KAAK;AAGtB,YAAM,aAAa;QACf,MAAM,OAAO,SAAS,KAAK,IAAI,GAAG;QAClC,SAAS,OAAO,SAAS,KAAK,KAAK,GAAG;QACtC,aAAa,OAAO,SAAS,KAAK,KAAK,GAAG;QAC1C,YAAY,OAAO,SAAS,KAAK,KAAK,GAAG;QACzC,GAAG,SAAS,YAAY;;AAG5B,YAAM,YAAY;QACd,MAAM,WAAW,eAAe,WAAW;QAC3C,SAAS,WAAW,eAAe,cAAc;QACjD,aAAa,WAAW,eAAe,aAAa;QACpD,YAAY,WAAW,eAAe,iBAAiB;;AAG3D,gBAAU,KAAK,QAAQ,WAAW;AAClC,gBAAU,QAAQ,QAAQ,WAAW;AACrC,gBAAU,YAAY,QAAQ,WAAW;AACzC,gBAAU,WAAW,QAAQ,WAAW;AACxC,YAAM,cAAe,iBAAiB,qBAAoB,GAAqC;AAC/F,YAAM,KAAK,CAAC,QAAQ,OAAO;AAC3B,iBAAW,cAAc,IAAI;AACzB,cAAM,UAAU,cAAc,SAAS,mBAAkB,eAAe,mBAAkB;AAC1F,YAAI,CAAC,SAAS;AAEV,gBAAM,IAAI,MAAM,2BAA2B;QAC/C;AACA,cAAM,WAAW,QAAQ,OAAO,CAAC;AACjC,iBAAS,8BAA8B,4BAA4B;AAEnE,YAAI,CAAC,eAAe,CAAC,SAAS,YAAY,mBAAmB;AACzD,mBAAS,WAAW,WAAW,MAAM,GAAG,UAAU,mBAAmB,IAAI;QAC7E;AACA,iBAAS,YAAY;AAErB,qBAAa,UAAU,IAAI;AAG3B,YAAI,CAAC,gBAAgB,CAAC,MAAM,sBAAsB;AAC9C,kBAAQ,OAAO,CAAC,EAAE,OAAO,KAAK,GAAG,KAAK,EAAE;QAC5C;MACJ;AAEA,iBAAW,QAAO;AAClB,cAAQ,EAAE,MAAM,aAAa,MAAM,OAAO,aAAa,MAAK,CAAE;IAClE,CAAC;EACL;;;;;;EAOQ,OAAO,mCAAmC,YAAwB;AACtE,UAAM,IAAI,cAAc,UAAU,MAAM;AACxC,WAAO;MACH;QAAA;;MAAA,GAAwB,SAAS,CAAC;MAClC;QAAA;;MAAA,GAAmC,oBAAoB,CAAC;MACxD;QAAA;;MAAA,GAAyC,qBAAqB,CAAC;MAC/D;QAAA;;MAAA,GAAuC,qBAAqB,CAAC;MAC7D;QAAA;;MAAA,GAA4B,aAAa,CAAC;MAC1C;QAAA;;MAAA,GAA0C,oBAAoB,CAAC;MAC/D;QAAA;;MAAA,GAAgD,qBAAqB,CAAC;MACtE;QAAA;;MAAA,GAAoD,oBAAoB,CAAC;MACzE;QAAA;;MAAA,GAA8C,qBAAqB,CAAC;MACpE;QAAA;;MAAA,GAAmC,aAAa,CAAC;MACjD;QAAA;;MAAA,GAA2C,qBAAqB,CAAC;MACjE;QAAA;;MAAA,GAAiD,sBAAsB,CAAC;MACxE;QAAA;;MAAA,GAAqD,qBAAqB,CAAC;MAC3E;QAAA;;MAAA,GAA+C,sBAAsB,CAAC;MACtE;QAAA;;MAAA,GAAoC,cAAc,CAAC;MACnD;QAAA;;MAAA,GAAyC,mBAAmB,CAAC;MAC7D;QAAA;;MAAA,GAA+C,oBAAoB,CAAC;MACpE;QAAA;;MAAA,GAAmD,mBAAmB,CAAC;MACvE;QAAA;;MAAA,GAA6C,oBAAoB,CAAC;MAClE;QAAA;;MAAA,GAAkC,YAAY,CAAC;MAC/C;QAAA;;MAAA,GAA0C,qBAAqB,CAAC;MAChE;QAAA;;MAAA,GAAgD,sBAAsB,CAAC;MACvE;QAAA;;MAAA,GAAoD,qBAAqB,CAAC;MAC1E;QAAA;;MAAA,GAA8C,sBAAsB,CAAC;MACrE;QAAA;;MAAA,GAAmC,cAAc,CAAC;;EAE1D;;;;;;EAmCgB,eAAY;AACxB,WAAO,OAAO,WAAW;EAC7B;;;;;;EAOO,sBAAsB,cAAoB;AAC7C,WAAO,KAAK,eAAe,YAAY;EAC3C;;;;;;EAOO,oBAAoB,YAAwB;AAC/C,QAAI,cAAc,QAAQ;AACtB,aAAO;IACX;AACA,WAAO,KAAK,eAAe,UAAU;EACzC;;;;;;EAOA,YACI,mBAEgB,SAAkC;AAElD,UAAM,iBAAiB;AAFP,SAAA,UAAA;AAlEZ,SAAA,iBAEJ,CAAA;AAEI,SAAA,iBAGJ,EAAE,MAAM,MAAM,OAAO,KAAI;AAErB,SAAA,iBAIJ,EAAE,aAAa,MAAM,YAAY,MAAM,aAAa,KAAI;AAEpD,SAAA,sBAAoG;AAKrG,SAAA,wBAA+C,IAAI,WAAU;AAI7D,SAAA,0BAAiD,IAAI,WAAU;AAkJ9D,SAAA,cAAc,CAAC,iBAAkC;AACrD,UAAI,CAAC,aAAa,YAAY,QAAQ,aAAa,YAAY,cAAc,UAAU,CAAC,KAAK,eAAe,aAAa;AACrH;MACJ;AAEA,YAAM,aAAa,aAAa,YAAY;AAC5C,YAAM,YAAY,IAAI,UAClB,cACA,KAAK,eAAe,YAAY,UAAU,GAC1C,KAAK,eAAe,cAAc,KAAK,eAAe,WAAW,UAAU,GAC3E,KAAK,eAAe,eAAe,KAAK,eAAe,YAAY,UAAU,GAC7E,KAAK,QAAQ,YAAY,gCACzB,KAAK,QAAQ,aAAa,WAC1B,KAAK,QAAQ,aAAa,WAAW;AAGzC,WAAK,eAAe,aAAa,QAAQ,IAAI;AAC7C,WAAK,eAAe,UAAU,IAAI;AAElC,WAAK,sBAAsB,gBAAgB,SAAS;IACxD;AAeQ,SAAA,cAAc,CAAC,iBAAkC;AACrD,WAAK,gBAAgB,aAAa,QAAQ;IAC9C;AA1II,SAAK,sBAAsB;AAG3B,UAAM,aAAa;AACnB,UAAM,sBAAsB,WAAW;AACvC,QAAI,qBAAqB;AACrB,UAAI,OAAO,oBAAoB,2BAA2B,aAAa;AACnE,gBAAQ,aAAa,QAAQ,cAAc,CAAA;AAC3C,gBAAQ,WAAW,uBAAuB,oBAAoB;MAClE;AACA,UAAI,OAAO,oBAAoB,eAAe,aAAa;AACvD,gBAAQ,aAAa,QAAQ,cAAc,CAAA;AAC3C,gBAAQ,WAAW,eAAe,oBAAoB;MAC1D;AACA,UAAI,OAAO,oBAAoB,2BAA2B,aAAa;AACnE,gBAAQ,aAAa,QAAQ,cAAc,CAAA;AAC3C,gBAAQ,WAAW,iCAAiC,oBAAoB;MAC5E;AACA,UAAI,OAAO,oBAAoB,eAAe,aAAa;AACvD,gBAAQ,aAAa,QAAQ,cAAc,CAAA;AAC3C,cAAM,iBAAiB,CAAA;AACvB,cAAM,kBAAkB,CAAA;AACxB,cAAM,mBAAmB;UACrB,CAAC,oBAAoB,WAAW,MAAM,cAAc;UACpD,CAAC,oBAAoB,WAAW,OAAO,eAAe;;AAG1D,mBAAW,mBAAmB,kBAAkB;AAC5C,gBAAM,mBAAmB,gBAAgB,CAAC;AAC1C,gBAAM,aAAa,gBAAgB,CAAC;AACpC,mBAAS,QAAQ,GAAG,QAAQ,iBAAiB,QAAQ,SAAS;AAC1D,kBAAM,iBAAiB,iBAAiB,KAAK;AAC7C,uBAAW,wBAAwB,KAAK,CAAC,IAAI;UACjD;QACJ;AACA,gBAAQ,WAAW,oBAAoB;UACnC,MAAM;UACN,OAAO;;MAEf;IACJ;EACJ;;;;;;;EAQgB,SAAM;AAClB,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,eAAe,aAAa;AAClC,WAAK,gBAAgB,KAAK,iBAAiB,KAAK,QAAQ,aAAa,cAAc,gBAAgB,eAAe,mBAAkB,iBAAiB;AACrJ,WAAK,cAAc,YAAY;AAE/B,WAAK,eAAe,cAAc,mBAAkB,4BAA4B,KAAK,SAAS,KAAK,aAAa;IACpH;AACA,SAAK,eAAe,aAAa,KAAK,QAAQ,YAAY,gBAAgB;AAC1E,SAAK,eAAe,cAAc,KAAK,QAAQ,YAAY,qBAAqB;AAEhF,QAAI,CAAC,KAAK,QAAQ,YAAY,gBAAgB,CAAC,KAAK,QAAQ,YAAY,sBAAsB;AAE1F,yBAAkB,gCAAgC,YAAY,kBAAmB,KAAK,mBAAmB,KAAK,OAAO,EAAE,KAAK,CAAC,sBAAqB;AAC9I,aAAK,eAAe,aAAa;AACjC,aAAK,eAAe,cAAc;UAC9B,MAAM,mBAAkB,mCAAmC,MAAM;UACjE,OAAO,mBAAkB,mCAAmC,OAAO;;AAIvE,aAAK,eAAe,MAAM,YAAY,KAAK,eAAe,WAAW,MAAM,KAAK,eAAe,YAAY,MAAM,KAAK,iBAAiB;AACvI,aAAK,eAAe,OAAO,YAAY,KAAK,eAAe,WAAW,OAAO,KAAK,eAAe,YAAY,OAAO,KAAK,iBAAiB;AAC1I,aAAK,eAAe,WAAW,KAAK,QAAQ,OAAO,KAAK,kBAAkB,kBAAkB;AAC5F,aAAK,eAAe,WAAW,MAAM,QAAQ,OAAO,KAAK,kBAAkB,kBAAkB;MACjG,CAAC;AACD,WAAK,sBAAsB,KAAK,kBAAkB,oCAAoC,IAAI,CAAC,mBAAkB;AACzG,YAAI,KAAK,eAAe,YAAY;AAChC,eAAK,eAAe,WAAW,KAAK,QAAQ,aAAa,eAAe,iBAAiB,eAAe,mBAAmB;AAC3H,eAAK,eAAe,WAAW,MAAM,QAAQ,aAAa,eAAe,iBAAiB,eAAe,mBAAmB;QAChI;MACJ,CAAC;IACL;AAEA,eAAW,cAAc,KAAK,QAAQ,QAAQ,aAAa;AACvD,WAAK,YAAY,UAAU;IAC/B;AAEA,SAAK,sBAAsB,KAAK,QAAQ,QAAQ,6BAA6B,KAAK,WAAW;AAC7F,SAAK,sBAAsB,KAAK,QAAQ,QAAQ,+BAA+B,KAAK,WAAW;AAE/F,WAAO;EACX;EAEU,WAAW,UAAiB;AAClC,SAAK,eAAe,MAAM,kBAAkB,UAAU,KAAK,kBAAkB,gBAAgB,KAAK,QAAQ,QAAQ,QAAQ;AAC1H,SAAK,eAAe,OAAO,kBAAkB,UAAU,KAAK,kBAAkB,gBAAgB,KAAK,QAAQ,QAAQ,QAAQ;EAC/H;EAwBQ,gBAAgB,cAAsB,aAAqB;AAC/D,UAAM,OAAO,KAAK,sBAAsB,YAAY;AACpD,QAAI,MAAM;AACN,YAAM,aAAa,KAAK,aAAa,YAAY,cAAc,SAAS,SAAS;AACjF,UAAI,KAAK,eAAe,UAAU,GAAG,aAAa,aAAa,cAAc;AACzE,aAAK,eAAe,UAAU,IAAI;MACtC;AACA,WAAK,wBAAwB,gBAAgB,IAAI;AACjD,WAAK,QAAQ,WAAW;AACxB,aAAO,KAAK,eAAe,YAAY;IAC3C;EACJ;;;;;;;EAYgB,SAAM;AAClB,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;IACX;AAEA,UAAM,OAAO,OAAO,KAAK,KAAK,cAAc;AAC5C,eAAW,YAAY,MAAM;AACzB,WAAK,gBAAgB,UAAU,KAAK,QAAQ,YAAY,mBAAmB;IAC/E;AAEA,QAAI,KAAK,QAAQ,YAAY,qBAAqB;AAC9C,UAAI,KAAK,eAAe,aAAa;AACjC,mBAAW,eAAe,KAAK,eAAe,YAAY,MAAM;AAC5D,sBAAY,QAAO;QACvB;AACA,mBAAW,eAAe,KAAK,eAAe,YAAY,OAAO;AAC7D,sBAAY,QAAO;QACvB;AACA,aAAK,eAAe,cAAc;MACtC;AACA,UAAI,KAAK,eAAe,YAAY;AAChC,aAAK,eAAe,WAAW,KAAK,QAAO;AAC3C,aAAK,eAAe,WAAW,MAAM,QAAO;AAC5C,aAAK,eAAe,aAAa;MACrC;AAEA,UAAI,mBAAkB,eAAe;AACjC,mBAAW,QAAQ,mBAAkB,cAAc,QAAQ;AACvD,eAAK,QAAO;QAChB;MACJ;AACA,UAAI,mBAAkB,cAAc;AAChC,mBAAW,QAAQ,mBAAkB,aAAa,QAAQ;AACtD,eAAK,QAAO;QAChB;MACJ;AACA,yBAAkB,gBAAgB;AAClC,yBAAkB,eAAe;AACjC,WAAK,eAAe,QAAO;AAC3B,WAAK,gBAAgB;IACzB;AAGA,QAAI,KAAK,qBAAqB;AAC1B,WAAK,kBAAkB,oCAAoC,OAAO,KAAK,mBAAmB;IAC9F;AAEA,WAAO;EACX;;;;EAKgB,UAAO;AACnB,UAAM,QAAO;AACb,SAAK,sBAAsB,MAAK;AAChC,SAAK,wBAAwB,MAAK;AAElC,QAAI,KAAK,eAAe,cAAc,CAAC,KAAK,QAAQ,YAAY,cAAc;AAE1E,WAAK,eAAe,WAAW,KAAK,QAAO;AAC3C,WAAK,eAAe,WAAW,MAAM,QAAO;AAG5C,UAAI,mBAAkB,eAAe;AACjC,mBAAW,QAAQ,mBAAkB,cAAc,QAAQ;AACvD,eAAK,QAAO;QAChB;MACJ;AACA,UAAI,mBAAkB,cAAc;AAChC,mBAAW,QAAQ,mBAAkB,aAAa,QAAQ;AACtD,eAAK,QAAO;QAChB;MACJ;AACA,yBAAkB,gBAAgB;AAClC,yBAAkB,eAAe;IACrC;AAEA,QAAI,KAAK,eAAe,aAAa;AACjC,iBAAW,eAAe,KAAK,eAAe,YAAY,MAAM;AAC5D,oBAAY,QAAO;MACvB;AACA,iBAAW,eAAe,KAAK,eAAe,YAAY,OAAO;AAC7D,oBAAY,QAAO;MACvB;IACJ;EACJ;;AApeuB,kBAAA,OAAO,iBAAiB;AAMxB,kBAAA,UAAU;AAGnB,kBAAA,8BAA8B;AAE9B,kBAAA,oCAAoC;AAEpC,kBAAA,mCAAmC;AAEnC,kBAAA,gCAAgC;AAGtB,kBAAA,oBAAoB,EAAE,QAAQ,KAAK,MAAM,OAAO,cAAc,EAAC;AAExE,kBAAA,gBAAmD;AACnD,kBAAA,eAAkD;AAmdrE,qBAAqB,gBACjB,kBAAkB,MAClB,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,kBAAkB,kBAAkB,OAAO;AAChE,GACA,kBAAkB,SAClB,KAAK;;;ACx+BT,WAAW,UAAU,uBAAuB,SAAU,OAAe,QAAgB,iBAA0B,cAAoB;AAC/H,QAAM,UAAU,IAAI;IAAgB;IAAI;;EAAA;AACxC,UAAQ,YAAY;AACpB,UAAQ,aAAa;AAErB,MAAI,iBAAiB;AACjB,YAAQ,KAAK,kBAAkB,iBAAiB,OAAO,KAAK,MAAM,cAAc,IAAI;AACpF,aAAS,KAAK,kBAAkB,iBAAiB,QAAQ,KAAK,MAAM,cAAc,IAAI;EAC1F;AAGA,UAAQ,QAAQ;AAChB,UAAQ,SAAS;AACjB,UAAQ,UAAU;AAClB,UAAQ,kBAAkB;AAC1B,UAAQ,eAAe;AAEvB,OAAK,0BAA0B,cAAc,OAAO;AAEpD,OAAK,uBAAuB,KAAK,OAAO;AAExC,SAAO;AACX;AAEA,WAAW,UAAU,uBAAuB,SACxC,SACA,QACA,SACA,cAAuB,OACvB,QACA,mBAA4B,OAE5B,uBAAgC,OAAK;AAErC,MAAI,CAAC,SAAS;AACV;EACJ;AAEA,QAAM,KAAK,KAAK;AAChB,QAAM,SAAS,GAAG;AAElB,QAAM,qBAAqB,KAAK,qBAAqB,QAAQ,SAAS,MAAM,gBAAgB;AAE5F,OAAK,aAAa,YAAY,SAAY,QAAQ,UAAU,OAAO;AAEnE,MAAI,aAAa;AACb,OAAG,YAAY,GAAG,gCAAgC,CAAC;EACvD;AAEA,QAAM,cAAc,KAAK,qBAAqB,QAAQ,IAAI;AAC1D,QAAM,WAAW,KAAK,mBAAmB,SAAS,SAAS,QAAQ,MAAM;AACzE,QAAM,iBAAiB,KAAK,kCAAkC,QAAQ,MAAM,QAAQ;AAEpF,KAAG,WAAW,QAAQ,GAAG,gBAAgB,UAAU,aAAa,MAAwB;AAExF,MAAI,QAAQ,iBAAiB;AACzB,OAAG,eAAe,MAAM;EAC5B;AAEA,MAAI,CAAC,oBAAoB;AACrB,SAAK,qBAAqB,QAAQ,IAAI;EAC1C;AAEA,MAAI,aAAa;AACb,OAAG,YAAY,GAAG,gCAAgC,CAAC;EACvD;AAEA,MAAI,QAAQ;AACR,YAAQ,SAAS;EACrB;AAEA,UAAQ,wBAAwB;AAChC,UAAQ,eAAe;AACvB,UAAQ,UAAU,WAAW;AAC7B,UAAQ,UAAU;AACtB;;;ACzFM,IAAO,iBAAP,MAAO,wBAAuB,QAAO;;EA8CvC,YACI,MACA,cACA,gBACA,kBAA2B,OAC3B,eAAuB,GAAA,SAAU,GAAA,SAAA;AAIjC,UAAM,UAAU,CAAC,kBAAmB,eAAyB;AAC7D,UAAM,QAAQ,UAAW,iBAA4B,gBAA2C;AAChG,UAAM,WAAW,UAAU,CAAC,kBAAmB;AAE/C,UAAM,MAAM,OAAO,UAAU,SAAS,cAAc,QAAW,QAAW,QAAW,QAAW,MAAM;AAEtG,SAAK,OAAO;AACZ,SAAK,QAAQ,QAAQ;AACrB,SAAK,QAAQ,QAAQ;AAErB,SAAK,mBAAmB;AAExB,UAAM,SAAS,KAAK,WAAU;AAC9B,QAAI,CAAC,QAAQ;AACT;IACJ;AAEA,QAAK,aAAyB,YAAY;AACtC,WAAK,UAAU;AACf,WAAK,aAAa;AAClB,WAAK,WAAW,OAAO,qBAAqB,KAAK,QAAQ,OAAO,KAAK,QAAQ,QAAQ,iBAAiB,YAAY;IACtH,OAAO;AACH,WAAK,UAAU,OAAO,aAAa,GAAG,CAAC;AACvC,WAAK,aAAa;AAElB,YAAM,gBAAgB;AACtB,UAAI,cAAc,SAAS,cAAc,UAAU,GAAG;AAClD,aAAK,WAAW,OAAO,qBAAqB,cAAc,OAAO,cAAc,QAAQ,iBAAiB,YAAY;MACxH,OAAO;AACH,aAAK,WAAW,OAAO,qBAAqB,cAAwB,cAAwB,iBAAiB,YAAY;MAC7H;IACJ;AAEA,UAAM,cAAc,KAAK,QAAO;AAEhC,QAAI,KAAK,QAAQ,UAAU,YAAY,OAAO;AAC1C,WAAK,QAAQ,QAAQ,YAAY;IACrC;AACA,QAAI,KAAK,QAAQ,WAAW,YAAY,QAAQ;AAC5C,WAAK,QAAQ,SAAS,YAAY;IACtC;AACA,SAAK,WAAW,KAAK,QAAQ,WAAW,IAAI;EAChD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAoB,aAAU;AAC1B,WAAO;EACX;EAEQ,UAAU,aAAkB;AAChC,SAAK,QAAQ,QAAQ,YAAY;AACjC,SAAK,QAAQ,SAAS,YAAY;AAElC,SAAK,uBAAsB;AAE3B,SAAK,WAAW,KAAK,WAAU,EAAI,qBAAqB,YAAY,OAAO,YAAY,QAAQ,KAAK,kBAAkB,KAAK,YAAY;EAC3I;;;;;EAMgB,MAAM,OAAa;AAC/B,UAAM,cAAc,KAAK,QAAO;AAEhC,gBAAY,SAAS;AACrB,gBAAY,UAAU;AAEtB,SAAK,UAAU,WAAW;EAC9B;;;;;;EAOO,QAAQ,OAAe,QAAc;AACxC,UAAM,cAAc,KAAK,QAAO;AAEhC,gBAAY,QAAQ;AACpB,gBAAY,SAAS;AAErB,SAAK,UAAU,WAAW;EAC9B;;;;;EAMO,aAAU;AACb,WAAO,KAAK;EAChB;;;;;EAMO,MAAM,YAAmB;AAC5B,UAAM,OAAO,KAAK,QAAO;AACzB,QAAI,YAAY;AACZ,WAAK,SAAS,YAAY;IAC9B;AACA,SAAK,SAAS,UAAU,GAAG,GAAG,KAAK,OAAO,KAAK,MAAM;EACzD;;;;;;;EAQO,OAAO,SAAmB,cAAc,OAAO,uBAAuB,OAAK;AAE9E,QAAI,CAAC,KAAK,UAAU;AAChB;IACJ;AAEA,SAAK,WAAU,EAAI,qBACf,KAAK,UACL,KAAK,SACL,YAAY,SAAY,OAAO,SAC/B,aACA,KAAK,WAAW,QAChB,QACA,oBAAoB;EAE5B;;;;;;;;;;;;EAaO,SACH,MACA,GACA,GACA,MACA,OACA,WACA,SACA,SAAS,MAAI;AAEb,UAAM,OAAO,KAAK,QAAO;AACzB,QAAI,WAAW;AACX,WAAK,SAAS,YAAY;AAC1B,WAAK,SAAS,SAAS,GAAG,GAAG,KAAK,OAAO,KAAK,MAAM;IACxD;AAEA,SAAK,SAAS,OAAO;AACrB,QAAI,MAAM,QAAQ,MAAM,QAAW;AAC/B,YAAM,WAAW,KAAK,SAAS,YAAY,IAAI;AAC/C,WAAK,KAAK,QAAQ,SAAS,SAAS;IACxC;AACA,QAAI,MAAM,QAAQ,MAAM,QAAW;AAC/B,YAAM,WAAW,SAAS,KAAK,QAAQ,OAAO,EAAE,CAAC;AACjD,UAAI,KAAK,SAAS,IAAI,WAAW;IACrC;AAEA,SAAK,SAAS,YAAY,SAAS;AACnC,SAAK,SAAS,SAAS,MAAM,GAAG,CAAC;AAEjC,QAAI,QAAQ;AACR,WAAK,OAAO,OAAO;IACvB;EACJ;;;;EAKgB,UAAO;AACnB,UAAM,QAAO;AAEb,QAAI,KAAK,YAAY;AACjB,WAAK,SAAS,SAAQ;IAC1B;AACC,SAAK,UAAkB;AACvB,SAAK,WAAmB;EAC7B;;;;;EAMgB,QAAK;AACjB,UAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAI,CAAC,OAAO;AACR,aAAO;IACX;AAEA,UAAM,cAAc,KAAK,QAAO;AAChC,UAAM,aAAa,IAAI,gBAAe,KAAK,MAAM,aAAa,OAAO,KAAK,gBAAgB;AAG1F,eAAW,WAAW,KAAK;AAC3B,eAAW,QAAQ,KAAK;AAGxB,eAAW,QAAQ,KAAK;AACxB,eAAW,QAAQ,KAAK;AAExB,WAAO;EACX;;;;;EAMgB,YAAS;AACrB,UAAM,QAAQ,KAAK,SAAQ;AAC3B,QAAI,SAAS,CAAC,MAAM,QAAO,GAAI;AAC3B,aAAO,KAAK,gEAAgE;IAChF;AAEA,UAAM,sBAAsB,MAAM,UAAS;AAC3C,QAAI,gBAAe,iBAAiB,KAAK,OAAO,GAAG;AAC/C,0BAAoB,eAAe,KAAK,QAAQ,UAAS;IAC7D;AAEA,wBAAoB,UAAU,KAAK;AACnC,wBAAoB,eAAe,KAAK;AAExC,WAAO;EACX;EAEQ,OAAO,iBAAiB,QAAqD;AACjF,WAAQ,OAA6B,cAAc;EACvD;;EAGgB,WAAQ;AACpB,SAAK,OAAM;EACf;;;;ACtUJ,KAAK,oBAAoB,CAAC,YAAiB,UAAsB;AAC7D,SAAO,WAAW,MAAM,YAAY,KAAK;AAC7C;AAKM,IAAO,aAAP,MAAO,oBAAmB,KAAI;EAuBhC,YAAY,MAAc,OAAa;AACnC,UAAM,MAAM,KAAK;AAtBd,SAAA,iBAAiB;EAuBxB;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,IAAI,KAAK,gBAAgB,KAAK,cAAc;EAC5D;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK;EAChB;;;;;;;;EASO,SAAS,aAAqB,mBAAmB,IAAE;AACtD,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AACtB,SAAK,UAAU,WAAW;AAG1B,UAAM,YAAY;AAClB,QAAI,UAAU,+BAA+B;AACzC,gBAAU,8BAA8B,gBAAgB;IAC5D;EACJ;;;;;;;;EASO,uBAAuB,GAAW,GAAS;AAC9C,UAAM,QAAQ,KAAK,eAAc;AACjC,UAAM,SAAS,WAAW,OAAO,CAAC;AAClC,UAAM,YAAY,MAAM;AACxB,UAAM,UAAU,WAAW,QAAQ,CAAC;AACpC,YAAQ,oCAAoC,GAAG,GAAK,GAAG,QAAQ,OAAO;AACtE,QAAI,QAAQ;AACZ,QAAI,QAAQ;AACZ,QAAI,IAAI,KAAK,SAAS,KAAK,KAAK,SAAS,KAAK,KAAK,SAAS,IAAI,KAAK,OAAO;AACxE,aAAO,KAAK,SAAS;IACzB;AACA,QAAI,CAAC,KAAK,gBAAgB,KAAK,aAAa,UAAU,GAAG;AACrD,WAAK,iBAAgB;AACrB,WAAK,oBAAmB;IAC5B;AACA,UAAM,QAAQ,KAAK,YAAY,GAAG,CAAC;AACnC,UAAM,IAAI,EAAE,MAAM,IAAI,IAAI,MAAM,IAAI,IAAI,MAAM,KAAK,MAAM;AAEzD,YAAQ,oCAAoC,GAAK,GAAG,GAAK,OAAO,OAAO;AACvE,WAAO,QAAQ;EACnB;;;;;;;;EASO,uBAAuB,GAAW,GAAS;AAC9C,UAAM,SAAS,IAAI,QAAQ,GAAK,GAAK,CAAG;AACxC,SAAK,4BAA4B,GAAG,GAAG,MAAM;AAC7C,WAAO;EACX;;;;;;;;;;EAWO,4BAA4B,GAAW,GAAW,KAAY;AACjE,UAAM,QAAQ,KAAK,eAAc;AACjC,UAAM,SAAS,WAAW,OAAO,CAAC;AAClC,UAAM,YAAY,MAAM;AACxB,UAAM,UAAU,WAAW,QAAQ,CAAC;AACpC,YAAQ,oCAAoC,GAAG,GAAK,GAAG,QAAQ,OAAO;AACtE,QAAI,QAAQ;AACZ,QAAI,QAAQ;AACZ,QAAI,IAAI,KAAK,SAAS,IAAI,KAAK,SAAS,IAAI,KAAK,SAAS,IAAI,KAAK,OAAO;AACtE,aAAO;IACX;AACA,QAAI,CAAC,KAAK,gBAAgB,KAAK,aAAa,UAAU,GAAG;AACrD,WAAK,iBAAgB;AACrB,WAAK,oBAAmB;IAC5B;AACA,UAAM,QAAQ,KAAK,YAAY,GAAG,CAAC;AACnC,YAAQ,+BAA+B,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG;AAC5E,WAAO;EACX;;;;;;;EAQO,0BAAuB;AAC1B,QAAI,CAAC,KAAK,gBAAgB,KAAK,aAAa,UAAU,GAAG;AACrD,WAAK,iBAAgB;IACzB;AACA,SAAK,oBAAmB;AACxB,WAAO;EACX;;EAGQ,YAAY,GAAW,GAAS;AAEpC,UAAM,MAAM,KAAK,OAAQ,IAAI,KAAK,SAAS,KAAK,iBAAkB,KAAK,MAAM;AAC7E,UAAM,MAAM,KAAK,MAAO,EAAE,IAAI,KAAK,SAAS,KAAK,iBAAkB,KAAK,UAAU,KAAK,cAAc;AACrG,UAAM,OAAO,KAAK,aAAa,MAAM,KAAK,iBAAiB,GAAG;AAC9D,QAAI;AACJ,QAAI,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,GAAG;AACrC,cAAQ,KAAK;IACjB,OAAO;AACH,cAAQ,KAAK;IACjB;AACA,WAAO;EACX;;;;;;;EAQQ,mBAAgB;AACpB,UAAM,gBAAgB,KAAK;AAC3B,UAAM,gBAAgB,KAAK;AAC3B,SAAK,eAAe,CAAA;AACpB,aAAS,MAAM,GAAG,MAAM,eAAe,OAAO;AAC1C,eAAS,MAAM,GAAG,MAAM,eAAe,OAAO;AAC1C,cAAM,OAAO,EAAE,OAAO,QAAQ,KAAI,GAAI,QAAQ,IAAI,QAAQ,GAAK,GAAK,GAAK,CAAG,GAAG,QAAQ,IAAI,QAAQ,GAAK,GAAK,GAAK,CAAG,EAAC;AACtH,aAAK,aAAa,MAAM,gBAAgB,GAAG,IAAI;MACnD;IACJ;AACA,WAAO;EACX;;;;;;EAOQ,sBAAmB;AACvB,UAAM,YAAY,KAAK,gBAAgB,aAAa,YAAY;AAEhE,QAAI,CAAC,WAAW;AACZ,aAAO;IACX;AAEA,UAAM,KAAK,WAAW,QAAQ,CAAC;AAC/B,UAAM,KAAK,WAAW,QAAQ,CAAC;AAC/B,UAAM,KAAK,WAAW,QAAQ,CAAC;AAC/B,UAAM,KAAK,WAAW,QAAQ,CAAC;AAC/B,UAAM,OAAO,WAAW,QAAQ,CAAC;AACjC,UAAM,OAAO,WAAW,QAAQ,CAAC;AACjC,UAAM,OAAO,WAAW,QAAQ,CAAC;AACjC,UAAM,QAAQ,WAAW,QAAQ,CAAC;AAClC,UAAM,QAAQ,WAAW,QAAQ,CAAC;AAClC,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,KAAK;AACT,QAAI,IAAI;AACR,QAAI,KAAK;AACT,QAAI,KAAK;AAET,UAAM,gBAAgB,KAAK;AAC3B,UAAM,gBAAgB,KAAK;AAE3B,aAAS,MAAM,GAAG,MAAM,eAAe,OAAO;AAC1C,eAAS,MAAM,GAAG,MAAM,eAAe,OAAO;AAC1C,YAAI,MAAM;AACV,YAAI,OAAO,gBAAgB,KAAK;AAChC,aAAK,MAAM,MAAM,gBAAgB,KAAK;AACtC,WAAG,IAAI,UAAU,IAAI,CAAC;AACtB,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,CAAC;AACtB,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAC1B,WAAG,IAAI,UAAU,IAAI,IAAI,CAAC;AAG1B,cAAM,GAAG,IAAI,GAAG,MAAM,GAAG,IAAI,GAAG;AAChC,YAAI,GAAG,IAAI,KAAK,GAAG;AAOnB,WAAG,cAAc,IAAI,IAAI;AACzB,WAAG,cAAc,IAAI,IAAI;AACzB,WAAG,cAAc,IAAI,IAAI;AACzB,gBAAQ,WAAW,MAAM,MAAM,KAAK;AACpC,gBAAQ,WAAW,MAAM,MAAM,KAAK;AACpC,cAAM,UAAS;AACf,cAAM,UAAS;AACf,aAAK,EAAE,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG;AACtD,aAAK,EAAE,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG,IAAI,MAAM,IAAI,GAAG;AAEtD,cAAM,OAAO,KAAK,aAAa,MAAM,gBAAgB,GAAG;AACxD,aAAK,MAAM,eAAe,IAAI,CAAC;AAC/B,aAAK,OAAO,eAAe,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,EAAE;AACxD,aAAK,OAAO,eAAe,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,EAAE;MAC5D;IACJ;AACA,WAAO;EACX;;;;;EAMgB,UAAU,qBAAwB;AAC9C,UAAM,UAAU,mBAAmB;AACnC,wBAAoB,gBAAgB,KAAK;AACzC,wBAAoB,gBAAgB,KAAK;AAEzC,wBAAoB,OAAO,KAAK;AAChC,wBAAoB,OAAO,KAAK;AAEhC,wBAAoB,OAAO,KAAK;AAChC,wBAAoB,OAAO,KAAK;AAEhC,wBAAoB,QAAQ,KAAK;AACjC,wBAAoB,SAAS,KAAK;EACtC;;;;;;;EAQO,OAAgB,MAAM,YAAiB,OAAY;AACtD,UAAM,SAAS,IAAI,YAAW,WAAW,MAAM,KAAK;AAEpD,WAAO,iBAAiB,WAAW,iBAAiB;AACpD,WAAO,iBAAiB,WAAW,iBAAiB;AAEpD,WAAO,QAAQ,WAAW;AAC1B,WAAO,QAAQ,WAAW;AAE1B,WAAO,QAAQ,WAAW;AAC1B,WAAO,QAAQ,WAAW;AAE1B,WAAO,SAAS,WAAW;AAC3B,WAAO,UAAU,WAAW;AAE5B,WAAO;EACX;;;;AC/SE,SAAU,uBAAuB,SAOtC;AACG,QAAM,UAAU,CAAA;AAChB,QAAM,YAAY,CAAA;AAClB,QAAM,UAAU,CAAA;AAChB,QAAM,MAAM,CAAA;AACZ,MAAI,KAAa;AAEjB,QAAM,QAAgB,QAAQ,SAAS,QAAQ,QAAQ;AACvD,QAAM,SAAiB,QAAQ,UAAU,QAAQ,QAAQ;AACzD,QAAM,iBAAyB,QAAQ,iBAAiB,QAAQ,gBAAgB,KAAK;AACrF,QAAM,iBAAyB,QAAQ,iBAAiB,QAAQ,gBAAgB,KAAK;AAErF,OAAK,MAAM,GAAG,OAAO,eAAe,OAAO;AACvC,SAAK,MAAM,GAAG,OAAO,eAAe,OAAO;AACvC,YAAM,WAAW,IAAI,QAAS,MAAM,QAAS,gBAAgB,QAAQ,GAAK,IAAK,gBAAgB,OAAO,SAAU,gBAAgB,SAAS,CAAG;AAC5I,YAAM,SAAS,IAAI,QAAQ,GAAG,GAAK,CAAC;AAEpC,gBAAU,KAAK,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AACjD,cAAQ,KAAK,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC;AACzC,UAAI,KAAK,MAAM,eAAe,4BAA4B,MAAM,gBAAgB,IAAM,MAAM,aAAa;IAC7G;EACJ;AAEA,OAAK,MAAM,GAAG,MAAM,eAAe,OAAO;AACtC,SAAK,MAAM,GAAG,MAAM,eAAe,OAAO;AACtC,cAAQ,KAAK,MAAM,KAAK,MAAM,MAAM,gBAAgB,EAAE;AACtD,cAAQ,KAAK,MAAM,IAAI,OAAO,gBAAgB,EAAE;AAChD,cAAQ,KAAK,MAAM,OAAO,gBAAgB,EAAE;AAE5C,cAAQ,KAAK,OAAO,MAAM,MAAM,gBAAgB,EAAE;AAClD,cAAQ,KAAK,MAAM,KAAK,MAAM,MAAM,gBAAgB,EAAE;AACtD,cAAQ,KAAK,MAAM,OAAO,gBAAgB,EAAE;IAChD;EACJ;AAGA,QAAM,aAAa,IAAI,WAAU;AAEjC,aAAW,UAAU;AACrB,aAAW,YAAY;AACvB,aAAW,UAAU;AACrB,aAAW,MAAM;AAEjB,SAAO;AACX;AAiBM,SAAU,4BAA4B,SAO3C;AACG,QAAM,OAAO,QAAQ,SAAS,UAAa,QAAQ,SAAS,OAAO,QAAQ,OAAO;AAClF,QAAM,OAAO,QAAQ,SAAS,UAAa,QAAQ,SAAS,OAAO,QAAQ,OAAO;AAClF,QAAM,OAAO,QAAQ,SAAS,UAAa,QAAQ,SAAS,OAAO,QAAQ,OAAO;AAClF,QAAM,OAAO,QAAQ,SAAS,UAAa,QAAQ,SAAS,OAAO,QAAQ,OAAO;AAClF,QAAM,eAAe,QAAQ,gBAAgB,EAAE,GAAG,GAAG,GAAG,EAAC;AACzD,QAAM,YAAY,QAAQ,aAAa,EAAE,GAAG,GAAG,GAAG,EAAC;AAEnD,QAAM,UAAoB,CAAA;AAC1B,QAAM,YAAsB,CAAA;AAC5B,QAAM,UAAoB,CAAA;AAC1B,QAAM,MAAgB,CAAA;AACtB,MAAI,KAAa,KAAa,SAAiB;AAE/C,eAAa,IAAI,aAAa,IAAI,IAAI,IAAI,aAAa;AACvD,eAAa,IAAI,aAAa,IAAI,IAAI,IAAI,aAAa;AACvD,YAAU,IAAI,UAAU,IAAI,IAAI,IAAI,UAAU;AAC9C,YAAU,IAAI,UAAU,IAAI,IAAI,IAAI,UAAU;AAE9C,QAAM,WAAW;IACb,IAAI,OAAO,QAAQ,aAAa;IAChC,IAAI,OAAO,QAAQ,aAAa;;AAGpC,WAAS,UAAU,UAAkB,UAAkB,UAAkB,UAAgB;AAErF,UAAM,OAAO,UAAU,SAAS;AAChC,UAAM,YAAY,UAAU,IAAI;AAChC,SAAK,MAAM,GAAG,MAAM,UAAU,GAAG,OAAO;AACpC,WAAK,MAAM,GAAG,MAAM,UAAU,GAAG,OAAO;AACpC,cAAM,SAAS,CAAC,OAAO,MAAM,MAAM,WAAW,QAAQ,MAAM,KAAK,MAAM,WAAW,QAAQ,MAAM,MAAM,MAAM,KAAK,WAAW,OAAO,OAAO,MAAM,KAAK,SAAS;AAE9J,gBAAQ,KAAK,OAAO,CAAC,CAAC;AACtB,gBAAQ,KAAK,OAAO,CAAC,CAAC;AACtB,gBAAQ,KAAK,OAAO,CAAC,CAAC;AACtB,gBAAQ,KAAK,OAAO,CAAC,CAAC;AACtB,gBAAQ,KAAK,OAAO,CAAC,CAAC;AACtB,gBAAQ,KAAK,OAAO,CAAC,CAAC;MAC1B;IACJ;AAGA,UAAM,WAAW,QAAQ,KAAI;AAC7B,UAAM,SAAS,IAAI,QAAQ,GAAG,GAAK,CAAC;AACpC,SAAK,MAAM,GAAG,OAAO,UAAU,GAAG,OAAO;AACrC,eAAS,IAAK,OAAO,WAAW,YAAa,UAAU,IAAI;AAC3D,WAAK,MAAM,GAAG,OAAO,UAAU,GAAG,OAAO;AACrC,iBAAS,IAAK,OAAO,WAAW,YAAa,UAAU,IAAI;AAC3D,iBAAS,IAAI;AAEb,kBAAU,KAAK,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AACjD,gBAAQ,KAAK,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC;AACzC,YAAI,KAAK,MAAM,UAAU,GAAG,MAAM,UAAU,CAAC;MACjD;IACJ;EACJ;AAEA,OAAK,UAAU,GAAG,UAAU,aAAa,GAAG,WAAW;AACnD,SAAK,UAAU,GAAG,UAAU,aAAa,GAAG,WAAW;AACnD,gBAAU,OAAO,UAAU,SAAS,GAAG,OAAO,UAAU,SAAS,GAAG,QAAQ,UAAU,KAAK,SAAS,GAAG,QAAQ,UAAU,KAAK,SAAS,CAAC;IAC5I;EACJ;AAGA,QAAM,aAAa,IAAI,WAAU;AAEjC,aAAW,UAAU;AACrB,aAAW,YAAY;AACvB,aAAW,UAAU;AACrB,aAAW,MAAM;AAEjB,SAAO;AACX;AAkBM,SAAU,oCAAoC,SAYnD;AACG,QAAM,UAAU,CAAA;AAChB,QAAM,YAAY,CAAA;AAClB,QAAM,UAAU,CAAA;AAChB,QAAM,MAAM,CAAA;AACZ,MAAI,KAAK;AACT,QAAM,SAAS,QAAQ,eAAe,IAAI,OAAO,KAAK,MAAM,IAAI;AAChE,QAAM,cAAc,QAAQ,eAAe;AAC3C,MAAI,SAAS;AAEb,MAAI,QAAQ,YAAY,QAAQ,WAAW;AACvC,aAAS;AACT,UAAM,OAAO,QAAQ;AACrB,YAAQ,YAAY,QAAQ;AAC5B,YAAQ,YAAY;EACxB;AAGA,OAAK,MAAM,GAAG,OAAO,QAAQ,cAAc,OAAO;AAC9C,SAAK,MAAM,GAAG,OAAO,QAAQ,cAAc,OAAO;AAC9C,YAAM,WAAW,IAAI,QAChB,MAAM,QAAQ,QAAS,QAAQ,eAAe,QAAQ,QAAQ,GAC/D,IACE,QAAQ,eAAe,OAAO,QAAQ,SAAU,QAAQ,eAAe,QAAQ,SAAS,CAAG;AAIjG,YAAM,cAAgB,SAAS,IAAI,QAAQ,QAAQ,KAAK,QAAQ,SAAU,QAAQ,cAAc,KAAM;AACtG,YAAM,cAAe,KAAO,SAAS,IAAI,QAAQ,SAAS,KAAK,QAAQ,WAAW,QAAQ,eAAe,KAAM;AAC/G,YAAM,OAAO,aAAa,aAAa,QAAQ,eAAe;AAC9D,UAAI,IAAI,QAAQ,OAAO,GAAG,IAAI;AAC9B,UAAI,IAAI,QAAQ,OAAO,MAAM,CAAC,IAAI;AAClC,UAAI,IAAI,QAAQ,OAAO,MAAM,CAAC,IAAI;AAClC,YAAM,IAAI,QAAQ,OAAO,MAAM,CAAC,IAAI;AAEpC,UAAI,QAAQ;AACR,YAAI,IAAM;AACV,YAAI,IAAM;AACV,YAAI,IAAM;MACd;AAEA,YAAM,WAAW,IAAI,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,OAAO;AAI1D,UAAI,KAAK,aAAa;AAClB,iBAAS,IAAI,QAAQ,aAAa,QAAQ,YAAY,QAAQ,aAAa;MAC/E,OAAO;AACH,iBAAS,IAAI,QAAQ,YAAY;MACrC;AACA,UAAI,QAAQ,cAAc;AAEtB,gBAAQ,aAAa,OAAO,QAAQ,eAAe,KAAK,GAAG,IAAI,SAAS;MAC5E;AAGA,gBAAU,KAAK,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AACjD,cAAQ,KAAK,GAAG,GAAG,CAAC;AACpB,UAAI,KAAK,MAAM,QAAQ,cAAc,IAAM,MAAM,QAAQ,YAAY;IACzE;EACJ;AAGA,OAAK,MAAM,GAAG,MAAM,QAAQ,cAAc,OAAO;AAC7C,SAAK,MAAM,GAAG,MAAM,QAAQ,cAAc,OAAO;AAE7C,YAAM,OAAO,MAAM,KAAK,MAAM,MAAM,QAAQ,eAAe;AAC3D,YAAM,OAAO,MAAM,IAAI,OAAO,QAAQ,eAAe;AACrD,YAAM,OAAO,MAAM,OAAO,QAAQ,eAAe;AACjD,YAAM,OAAO,OAAO,MAAM,MAAM,QAAQ,eAAe;AAKvD,YAAM,gBAAgB,UAAU,OAAO,IAAI,CAAC,KAAK,QAAQ;AACzD,YAAM,gBAAgB,UAAU,OAAO,IAAI,CAAC,KAAK,QAAQ;AACzD,YAAM,gBAAgB,UAAU,OAAO,IAAI,CAAC,KAAK,QAAQ;AACzD,UAAI,iBAAiB,iBAAiB,eAAe;AACjD,gBAAQ,KAAK,IAAI;AACjB,gBAAQ,KAAK,IAAI;AACjB,gBAAQ,KAAK,IAAI;MACrB;AAEA,YAAM,gBAAgB,UAAU,OAAO,IAAI,CAAC,KAAK,QAAQ;AACzD,UAAI,iBAAiB,iBAAiB,eAAe;AACjD,gBAAQ,KAAK,IAAI;AACjB,gBAAQ,KAAK,IAAI;AACjB,gBAAQ,KAAK,IAAI;MACrB;IACJ;EACJ;AAGA,aAAW,eAAe,WAAW,SAAS,OAAO;AAGrD,QAAM,aAAa,IAAI,WAAU;AAEjC,aAAW,UAAU;AACrB,aAAW,YAAY;AACvB,aAAW,UAAU;AACrB,aAAW,MAAM;AAEjB,SAAO;AACX;AAgBM,SAAU,aACZ,MACA,UAA2I,CAAA,GAC3I,OAAa;AAEb,QAAM,SAAS,IAAI,WAAW,MAAM,KAAK;AACzC,SAAO,UAAU,KAAK;AACtB,SAAO,iBAAiB,QAAQ,iBAAiB,QAAQ,gBAAgB;AACzE,SAAO,iBAAiB,QAAQ,iBAAiB,QAAQ,gBAAgB;AACzE,SAAO,SAAS,QAAQ,SAAS;AACjC,SAAO,UAAU,QAAQ,UAAU;AACnC,SAAO,QAAQ,OAAO,SAAS;AAC/B,SAAO,QAAQ,OAAO,UAAU;AAChC,SAAO,QAAQ,CAAC,OAAO;AACvB,SAAO,QAAQ,CAAC,OAAO;AAEvB,QAAM,aAAa,uBAAuB,OAAO;AAEjD,aAAW,YAAY,QAAQ,QAAQ,SAAS;AAEhD,SAAO,UAAU,IAAI;AAErB,SAAO;AACX;AAqBM,SAAU,kBACZ,MACA,SACA,QAAyB,MAAI;AAE7B,QAAM,cAAc,IAAI,KAAK,MAAM,KAAK;AAExC,QAAM,aAAa,4BAA4B,OAAO;AAEtD,aAAW,YAAY,aAAa,QAAQ,SAAS;AAErD,SAAO;AACX;AAyBM,SAAU,0BACZ,MACA,KACA,UAYI,CAAA,GACJ,QAAyB,MAAI;AAE7B,QAAM,QAAQ,QAAQ,SAAS;AAC/B,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,eAAe,QAAQ,gBAAgB,IAAI;AACjD,QAAM,YAAY,QAAQ,aAAa;AACvC,QAAM,YAAY,QAAQ,aAAa;AACvC,QAAM,SAAS,QAAQ,eAAe,IAAI,OAAO,KAAK,MAAM,IAAI;AAChE,QAAM,cAAc,QAAQ,eAAe;AAC3C,QAAM,YAAY,QAAQ;AAC1B,QAAM,UAAU,QAAQ;AAExB,UAAQ,SAAS,YAAY;AAE7B,QAAM,SAAS,IAAI,WAAW,MAAM,KAAK;AACzC,SAAO,iBAAiB;AACxB,SAAO,iBAAiB;AACxB,SAAO,SAAS;AAChB,SAAO,UAAU;AACjB,SAAO,QAAQ,OAAO,SAAS;AAC/B,SAAO,QAAQ,OAAO,UAAU;AAChC,SAAO,QAAQ,CAAC,OAAO;AACvB,SAAO,QAAQ,CAAC,OAAO;AAEvB,SAAO,UAAU,KAAK;AAEtB,MAAI;AACJ,MAAI,QAAQ,4BAA4B;AACpC,mBAAe,IAAI,cAAc,eAAe,MAAM,eAAe,EAAE;EAC3E;AAEA,QAAM,iBAAiB,CAAC,QAAoB,aAAqB,iBAAwB;AACrF,UAAM,aAAa,oCAAoC;MACnD;MACA;MACA;MACA;MACA;MACA,aAAa;MACb;MACA;MACA;MACA;MACA;KACH;AAED,eAAW,YAAY,QAAQ,SAAS;AAGxC,QAAI,SAAS;AACT,cAAQ,QAAQ,YAAY;IAChC;AAEA,WAAO,UAAU,IAAI;EACzB;AAEA,MAAI,OAAO,QAAQ,UAAU;AACzB,UAAM,SAAS,CAAC,QAAuC;AACnD,YAAM,cAAc,IAAI;AACxB,YAAM,eAAe,IAAI;AAEzB,UAAI,MAAM,YAAY;AAClB;MACJ;AAEA,YAAM,SAAS,OAAO,UAAS,EAAG,kBAAkB,KAAK,aAAa,YAAY;AAElF,qBAAe,QAAQ,aAAa,YAAY;IACpD;AAEA,UAAM,UAAU,KAAK,QAAQ,QAAQ,UAAU,QAAQ,UAAU,MAAK;IAAE,GAAG,MAAM,eAAe;EACpG,OAAO;AACH,mBAAe,IAAI,MAAM,IAAI,OAAO,IAAI,MAAM;EAClD;AAEA,SAAO;AACX;AAcA,WAAW,eAAe;AAC1B,WAAW,oBAAoB;AAC/B,WAAW,4BAA4B;AAEvC,KAAK,eAAe,CAAC,MAAc,OAAe,QAAgB,cAAsB,OAAe,cAA6B;AAChI,QAAM,UAAU;IACZ;IACA;IACA;IACA;;AAGJ,SAAO,aAAa,MAAM,SAAS,KAAK;AAC5C;AAEA,KAAK,oBAAoB,CACrB,MACA,MACA,MACA,MACA,MACA,cACA,WACA,OACA,cACM;AACN,QAAM,UAAU;IACZ;IACA;IACA;IACA;IACA;IACA;IACA;;AAGJ,SAAO,kBAAkB,MAAM,SAAS,KAAK;AACjD;AAEA,KAAK,4BAA4B,CAC7B,MACA,KACA,OACA,QACA,cACA,WACA,WACA,OACA,WACA,SACA,gBACY;AACZ,QAAM,UAAU;IACZ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;AAGJ,SAAO,0BAA0B,MAAM,KAAK,SAAS,KAAK;AAC9D;;;AC3iBA,KAAK,mBAAmB,CAAC,YAAiB,UAAsB;AAC5D,SAAO,UAAU,MAAM,YAAY,KAAK;AAC5C;AAMM,IAAO,YAAP,MAAO,mBAAkB,KAAI;EAwBvB,kBAAkB,QAA0B;AAChD,QAAI,CAAC,QAAQ;AACT,aAAO;IACX;AAEA,WAAO,OAAO,aAAY,MAAO;EACrC;;;;;;;;;;;;;;EAoBA,YACI,MACA,QAAyB,MACzB,SAAyB,MACzB,SAA8B,MAC9B,oBAIgB,gBAIA,gBAChB,UAAmB;AAEnB,UAAM,MAAM,OAAO,QAAQ,QAAQ,kBAAkB;AAPrC,SAAA,iBAAA;AAIA,SAAA,iBAAA;AArDb,SAAA,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC;AAK1B,SAAA,QAAQ;AAoBL,SAAA,kBAAe;AAiCrB,QAAI,QAAQ;AACR,WAAK,QAAQ,OAAO,MAAM,MAAK;AAC/B,WAAK,QAAQ,OAAO;AACpB,WAAK,iBAAiB,OAAO;AAC7B,WAAK,iBAAiB,OAAO;IACjC;AAEA,SAAK,wBAAwB;AAE7B,UAAM,UAAoB,CAAA;AAC1B,UAAM,UAA2C;MAC7C,YAAY,CAAC,aAAa,YAAY;MACtC,UAAU,CAAC,SAAS,gBAAgB;MACpC,mBAAmB;MACnB;MACA,cAAc;MACd,gBAAc;;AAGlB,QAAI,CAAC,KAAK,gBAAgB;AACtB,cAAQ,oBAAoB;IAChC,OAAO;AACH,cAAQ,QAAS,KAAK,qBAAqB;IAC/C;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACtB,cAAQ,SAAU,KAAK,OAAO;AAC9B,WAAK,UAAU,IAAI,OAAM;IAC7B,OAAO;AACH,cAAQ,QAAS,KAAK,qBAAqB;AAC3C,cAAQ,WAAY,KAAK,aAAa,SAAS;IACnD;AAEA,QAAI,UAAU;AACV,WAAK,WAAW;IACpB,OAAO;AACH,YAAM,SAAS,KAAK,SAAQ,EAAG,UAAS;AAExC,UAAI,OAAO,YAAY,CAAC,WAAU,WAAW;AACzC,aAAK,kBAAe;MACxB;AAEA,cAAQ,iBAAiB,KAAK;AAC9B,cAAQ,4BAA4B,YAAW;AAC3C,YAAI,KAAK,oBAAe,GAA0B;AAC9C,gBAAM,QAAQ,IAAI,CAAC,OAAO,4BAAgC,GAAA,OAAO,8BAAmC,CAAA,CAAA;QACxG,OAAO;AACH,gBAAM,QAAQ,IAAI,CAAC,OAAO,4BAA4B,GAAA,OAAO,8BAA+B,CAAA,CAAA;QAChG;MACJ;AAEA,WAAK,WAAW,IAAI,eAAe,eAAe,KAAK,SAAQ,GAAI,SAAS,SAAS,KAAK;AAC1F,WAAK,SAAS,iBAAiB;IACnC;EACJ;;;;EAKgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAoB,WAAQ;AACxB,WAAO,KAAK,8BAA8B;EAC9C;;;;EAKA,IAAoB,SAAS,OAAyB;AAClD,SAAK,aAAa,KAAK;AACvB,QAAI,KAAK,UAAU;AACf,WAAK,SAAS,WAAW,SAAS;IACtC;EACJ;;;;EAKA,IAAoB,kBAAe;AAC/B,WAAO;EACX;EAEA,IAAoB,gBAAgB,OAAc;EAElD;;;;EAKgB,MAAM,UAAmB,aAAmB;AACxD,QAAI,CAAC,KAAK,WAAW;AACjB,aAAO;IACX;AAGA,UAAM,cAAc,KAAK,cAAc,OAAO,KAAK,UAAU,eAAc;AAC3E,QAAI,CAAC,KAAK,gCAAgC,KAAK,kBAAkB;AAC7D,WAAK,UAAU,MAAM,aAAa,WAAW;IACjD,OAAO;AACH,WAAK,UAAU,MAAM,aAAa,aAAa,KAAK,6BAA6B,eAAe,KAAK,6BAA6B,kBAAkB;IACxJ;AAGA,QAAI,CAAC,KAAK,kBAAkB,KAAK,kBAAkB,KAAK,QAAQ,GAAG;AAC/D,YAAM,EAAE,GAAG,GAAG,EAAC,IAAK,KAAK;AACzB,WAAK,QAAQ,IAAI,GAAG,GAAG,GAAG,KAAK,KAAK;AACpC,WAAK,SAAS,UAAU,SAAS,KAAK,OAAO;IACjD;AAEA,WAAO;EACX;;;;EAKgB,MAAM,SAAkB,UAAkB,gBAAuB;AAC7E,QAAI,CAAC,KAAK,aAAa,CAAC,KAAK,UAAU,iBAAgB,KAAO,CAAC,KAAK,cAAc,CAAC,KAAK,UAAU,eAAc,GAAK;AACjH,aAAO;IACX;AAEA,UAAM,SAAS,KAAK,SAAQ,EAAG,UAAS;AAIxC,QAAI,KAAK,YAAY;AACjB,aAAO,eAAe,SAAS,kBAAkB,QAAQ,eAAe,QAAQ,eAAe,cAAc;IACjH,OAAO;AACH,aAAO,iBAAiB,SAAS,kBAAkB,QAAQ,YAAY,QAAQ,YAAY,cAAc;IAC7G;AACA,WAAO;EACX;;;;;;;;EASgB,QAAQ,cAAwB,6BAA6B,OAAO,sBAA8B;AAC9G,QAAI,CAAC,sBAAsB;AACvB,WAAK,UAAU,QAAQ,OAAO,OAAO,IAAI;IAC7C;AACA,UAAM,QAAQ,YAAY;EAC9B;;;;;;;;EASgB,MAAM,MAAc,YAAkD,MAAM,oBAA4B;AACpH,QAAI,aAAc,UAAmB,yBAAyB,QAAW;AACrE,YAAM,gBAAgB;AACtB,oBAAc,SAAS;AAEvB,aAAO,IAAI,WAAU,MAAM,KAAK,SAAQ,GAAI,cAAc,QAAQ,cAAc,QAA+B,cAAc,kBAAkB;IACnJ;AAEA,WAAO,IAAI,WAAU,MAAM,KAAK,SAAQ,GAAI,WAA6B,MAAM,kBAAkB;EACrG;;;;;;;EAQgB,eAAe,MAAY;AACvC,UAAM,WAAW,IAAI,mBAAmB,MAAM,IAAI;AAElD,QAAI,KAAK,kBAAkB;AACvB,eAAS,mBAAmB,CAAA;AAE5B,iBAAW,OAAO,KAAK,kBAAkB;AACrC,iBAAS,iBAAiB,GAAG,IAAI,KAAK,iBAAiB,GAAG;MAC9D;IACJ;AAEA,WAAO;EACX;;;;;EAMgB,UAAU,qBAAwB;AAC9C,UAAM,UAAU,mBAAmB;AACnC,wBAAoB,QAAQ,KAAK,MAAM,QAAO;AAC9C,wBAAoB,QAAQ,KAAK;EACrC;;;;;;;EAQO,OAAgB,MAAM,YAAiB,OAAY;AACtD,UAAM,SAAS,IAAI,WAAU,WAAW,MAAM,KAAK;AAEnD,WAAO,QAAQ,OAAO,UAAU,WAAW,KAAK;AAChD,WAAO,QAAQ,WAAW;AAE1B,WAAO;EACX;;AAnRc,UAAA,YAAY;AAyRxB,IAAO,qBAAP,cAAkC,cAAa;EAQjD,YAAY,MAAc,QAAiB;AACvC,UAAM,MAAM,MAAM;AAClB,SAAK,wBAAwB,OAAO;EACxC;;;;EAKgB,eAAY;AACxB,WAAO;EACX;;;;ACnTE,SAAU,2BAA2B,SAA8D;AACrG,QAAM,UAAU,CAAA;AAChB,QAAM,YAAY,CAAA;AAClB,QAAM,QAAQ,QAAQ;AACtB,QAAM,SAAS,QAAQ;AACvB,QAAM,eAAe,CAAA;AACrB,MAAI,MAAM;AAEV,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,SAAS,MAAM,CAAC;AACtB,aAAS,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;AAChD,YAAM,EAAE,GAAG,GAAG,EAAC,IAAK,OAAO,KAAK;AAChC,gBAAU,KAAK,GAAG,GAAG,CAAC;AACtB,UAAI,QAAQ;AACR,cAAM,QAAQ,OAAO,CAAC;AACtB,cAAM,EAAE,GAAG,GAAG,GAAG,EAAC,IAAK,MAAM,KAAK;AAClC,qBAAa,KAAK,GAAG,GAAG,GAAG,CAAC;MAChC;AACA,UAAI,QAAQ,GAAG;AACX,gBAAQ,KAAK,MAAM,CAAC;AACpB,gBAAQ,KAAK,GAAG;MACpB;AACA;IACJ;EACJ;AACA,QAAM,aAAa,IAAI,WAAU;AACjC,aAAW,UAAU;AACrB,aAAW,YAAY;AACvB,MAAI,QAAQ;AACR,eAAW,SAAS;EACxB;AACA,SAAO;AACX;AAWM,SAAU,4BAA4B,SAAoF;AAC5H,QAAM,WAAW,QAAQ,YAAY;AACrC,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,SAAS,QAAQ;AAEvB,QAAM,YAAsB,CAAA;AAC5B,QAAM,UAAoB,CAAA;AAE1B,QAAM,UAAU,QAAQ,KAAI;AAC5B,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,OAAO;AACX,MAAI,WAAW;AACf,MAAI,UAAU;AACd,MAAI,MAAM;AACV,MAAI,IAAI;AACR,OAAK,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AACpC,WAAO,IAAI,CAAC,EAAE,cAAc,OAAO,CAAC,GAAG,OAAO;AAC9C,UAAM,QAAQ,OAAM;EACxB;AACA,SAAO,KAAK;AACZ,aAAY,WAAW,QAAS,WAAW;AAC3C,OAAK,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AACpC,WAAO,IAAI,CAAC,EAAE,cAAc,OAAO,CAAC,GAAG,OAAO;AAC9C,SAAK,KAAK,MAAM,QAAQ,OAAM,IAAK,IAAI;AACvC,YAAQ,UAAS;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AACzB,gBAAU,OAAO;AACjB,gBAAU,KAAK,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ,GAAG,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ,GAAG,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ,CAAC;AACtH,gBAAU,KAAK,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ,GAAG,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ,GAAG,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ,CAAC;AAC7J,cAAQ,KAAK,KAAK,MAAM,CAAC;AACzB,aAAO;IACX;EACJ;AAGA,QAAM,aAAa,IAAI,WAAU;AACjC,aAAW,YAAY;AACvB,aAAW,UAAU;AAErB,SAAO;AACX;AAoBM,SAAU,iBACZ,MACA,SACA,QAAyB,MAAI;AAE7B,QAAM,WAAW,QAAQ;AACzB,QAAM,QAAQ,QAAQ;AACtB,QAAM,SAAS,QAAQ;AAEvB,MAAI,UAAU;AAEV,UAAM,YAAY,SAAS,gBAAgB,aAAa,YAAY;AACpE,QAAI;AACJ,QAAI;AACJ,QAAI,QAAQ;AACR,oBAAc,SAAS,gBAAgB,aAAa,SAAS;IACjE;AACA,QAAI,IAAI;AACR,QAAI,IAAI;AACR,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,SAAS,MAAM,CAAC;AACtB,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,kBAAU,CAAC,IAAI,OAAO,CAAC,EAAE;AACzB,kBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE;AAC7B,kBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE;AAC7B,YAAI,UAAU,aAAa;AACvB,uBAAa,OAAO,CAAC;AACrB,sBAAY,CAAC,IAAI,WAAW,CAAC,EAAE;AAC/B,sBAAY,IAAI,CAAC,IAAI,WAAW,CAAC,EAAE;AACnC,sBAAY,IAAI,CAAC,IAAI,WAAW,CAAC,EAAE;AACnC,sBAAY,IAAI,CAAC,IAAI,WAAW,CAAC,EAAE;AACnC,eAAK;QACT;AACA,aAAK;MACT;IACJ;AACA,aAAS,mBAAmB,aAAa,cAAc,WAAW,OAAO,KAAK;AAC9E,QAAI,UAAU,aAAa;AACvB,eAAS,mBAAmB,aAAa,WAAW,aAAa,OAAO,KAAK;IACjF;AACA,aAAS,oBAAmB;AAC5B,WAAO;EACX;AAGA,QAAM,iBAAiB,SAAS,OAAO;AACvC,QAAM,aAAa,IAAI,UAAU,MAAM,OAAO,MAAM,QAAW,QAAW,gBAAgB,QAAQ,gBAAgB,QAAQ,QAAQ;AAClI,QAAM,aAAa,2BAA2B,OAAO;AACrD,aAAW,YAAY,YAAY,QAAQ,SAAS;AACpD,SAAO;AACX;AAmBM,SAAU,YACZ,MACA,SACA,QAAyB,MAAI;AAE7B,QAAM,SAAS,QAAQ,SAAS,CAAC,QAAQ,MAAM,IAAI;AACnD,QAAM,QAAQ,iBACV,MACA,EAAE,OAAO,CAAC,QAAQ,MAAM,GAAG,WAAW,QAAQ,WAAW,UAAU,QAAQ,UAAU,QAAgB,gBAAgB,QAAQ,gBAAgB,UAAU,QAAQ,SAAQ,GACvK,KAAK;AAET,SAAO;AACX;AAqBM,SAAU,kBACZ,MACA,SACA,QAAyB,MAAI;AAE7B,QAAM,SAAS,QAAQ;AACvB,QAAM,WAAW,QAAQ;AACzB,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,WAAW,QAAQ,YAAY;AAErC,MAAI,UAAU;AAEV,UAAM,mBAAmB,CAAC,cAA+B;AACrD,YAAM,UAAU,QAAQ,KAAI;AAC5B,YAAM,QAAQ,UAAU,SAAS;AACjC,UAAI,KAAK;AACT,UAAI,KAAK;AACT,UAAI,OAAO;AACX,UAAI,WAAW;AACf,UAAI,UAAU;AACd,UAAI,IAAI;AACR,UAAI,IAAI;AACR,UAAI,IAAI;AACR,WAAK,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AACpC,eAAO,IAAI,CAAC,EAAE,cAAc,OAAO,CAAC,GAAG,OAAO;AAC9C,cAAM,QAAQ,OAAM;MACxB;AACA,aAAO,KAAK;AACZ,YAAMC,YAAW,SAAS,qBAAsB;AAChD,YAAMC,WAAU,SAAS,qBAAsB;AAC/C,iBAAYD,YAAW,QAASA,YAAWC;AAC3C,WAAK,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AACpC,eAAO,IAAI,CAAC,EAAE,cAAc,OAAO,CAAC,GAAG,OAAO;AAC9C,aAAK,KAAK,MAAM,QAAQ,OAAM,IAAK,IAAI;AACvC,gBAAQ,UAAS;AACjB,YAAI;AACJ,eAAO,IAAI,MAAM,IAAI,UAAU,QAAQ;AACnC,oBAAU,OAAO;AACjB,oBAAU,CAAC,IAAI,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ;AAC/C,oBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ;AACnD,oBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE,IAAI,UAAU,QAAQ;AACnD,oBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ;AAChE,oBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ;AAChE,oBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE,KAAK,UAAU,YAAY,QAAQ;AAChE,eAAK;AACL;QACJ;MACJ;AACA,aAAO,IAAI,UAAU,QAAQ;AACzB,kBAAU,CAAC,IAAI,OAAO,CAAC,EAAE;AACzB,kBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE;AAC7B,kBAAU,IAAI,CAAC,IAAI,OAAO,CAAC,EAAE;AAC7B,aAAK;MACT;IACJ;AACA,QAAI,QAAQ,UAAU,QAAQ,YAAY,QAAQ,WAAW,QAAQ,kBAAkB,QAAQ,UAAU;AACrG,aAAO,KAAK,+HAA+H;IAC/I;AACA,aAAS,oBAAoB,kBAAkB,KAAK;AACpD,WAAO;EACX;AAEA,QAAM,cAAc,IAAI,UAAU,MAAM,OAAO,MAAM,QAAW,QAAW,QAAW,QAAQ,gBAAgB,QAAQ,QAAQ;AAC9H,QAAM,aAAa,4BAA4B,OAAO;AACtD,aAAW,YAAY,aAAa,QAAQ,SAAS;AAErD,cAAY,uBAAuB,IAAI,qBAAoB;AAC3D,cAAY,qBAAqB,WAAW;AAC5C,cAAY,qBAAqB,UAAU;AAC3C,SAAO;AACX;AAWA,WAAW,mBAAmB;AAC9B,WAAW,oBAAoB;AAE/B,KAAK,cAAc,CAAC,MAAc,QAAmB,QAAyB,MAAM,YAAqB,OAAO,WAAgC,SAAmB;AAC/J,QAAM,UAAU;IACZ;IACA;IACA;;AAEJ,SAAO,YAAY,MAAM,SAAS,KAAK;AAC3C;AAEA,KAAK,oBAAoB,CACrB,MACA,QACA,UACA,SACA,QACA,QAAyB,MACzB,WACA,aACW;AACX,QAAM,UAAU;IACZ;IACA;IACA;IACA;IACA;IACA;;AAEJ,SAAO,kBAAkB,MAAM,SAAS,KAAK;AACjD;;;AChLM,IAAO,qCAAP,cAAkD,qBAAoB;;;;;EAsHxE,IAAW,kBAAe;AACtB,WAAO,KAAK;EAChB;;;;;EAMA,IAAW,gBAAgB,SAAgB;AACvC,SAAK,mBAAmB;AAExB,QAAI,KAAK,SAAS,yBAAyB;AACvC,YAAM,WAAW,KAAK,SAAS,wBAAwB,eAAe,OAAO,CAAC,SAAS,KAAK,SAAS,cAAc;AACnH,UAAI,SAAS,CAAC,GAAG;AACb,iBAAS,CAAC,EAAE,WAAW,OAAO;MAClC;IACJ;EACJ;;;;EAKA,IAAW,0BAAuB;AAC9B,WAAO,KAAK,SAAS,2BAA2B;EACpD;;;;;;EAOA,YACI,mBACQ,UAAoC;AAE5C,UAAM,iBAAiB;AAFf,SAAA,WAAA;AAtJJ,SAAA,eAiBJ,CAAA;AAMI,SAAA,kBAA2B;AAG3B,SAAA,qBAAqB,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC;AAC1C,SAAA,UAAU,IAAI,IAAI,IAAI,QAAO,GAAI,IAAI,QAAO,CAAE;AAC9C,SAAA,aAAa,IAAI,QAAO;AACxB,SAAA,iBAAiB,IAAI,WAAU;AAC/B,SAAA,sBAAoG;AAMrG,SAAA,wBAAwB;AAgBxB,SAAA,2BAA2B;AAI3B,SAAA,iCAAyC;AAMzC,SAAA,uBAA+B;AAM/B,SAAA,sBAA+B;AAM/B,SAAA,qBAA8B;AAI9B,SAAA,gBAAwB,KAAK,KAAK;AAMlC,SAAA,wCAAiE,IAAI,WAAU;AAK/E,SAAA,uBAAgC;AAE/B,SAAA,mBAA4B;AAK7B,SAAA,iCAAiC,IAAI,WAAU;AAK/C,SAAA,gCAAgC,IAAI,WAAU;AAwW7C,SAAA,oBAAoB,CAAC,iBAAkC;AAC3D,UAAI,KAAK,aAAa,aAAa,QAAQ,KAAM,KAAK,SAAS,mBAAmB,aAAa,YAAY,eAAe,KAAK,SAAS,iBAAkB;AAEtJ;MACJ;AACA,WAAK,aAAa,aAAa,QAAQ,IAAI;QACvC;QACA,oBAAoB;UAChB,SAAS;UACT,WAAW;UACX,UAAU;UACV,iBAAiB;UACjB,cAAc;UACd,SAAS;UACT,YAAY;UACZ,mBAAmB;;;AAG3B,YAAM,iBAAiB,KAAK,aAAa,aAAa,QAAQ;AAE9D,UAAI,eAAe,aAAa,YAAY,kBAAkB,qBAAqB,eAAe,aAAa,YAAY,SAAS;AAEhI,cAAM,uBAAuB,MAAK;AAC9B,cAAI,aAAa,kBAAkB;AAC/B,kBAAM,qBACF,aAAa,iBAAiB,mBAAmB,yBAAyB,eAAe,KACzF,aAAa,iBAAiB,mBAAmB,yBAAyB,aAAa;AAC3F,gBAAI,CAAC,sBAAsB,KAAK,SAAS,sBAAsB;AAE3D,oBAAM,gBAAgB,aAAa,iBAAiB,iBAAgB;AACpE,kBAAI,CAAC,eAAe;AAChB;cACJ;AACA,6BAAe,mBAAmB,oBAAoB;AACtD,6BAAe,yBAAyB;AACxC,6BAAe,0BAA0B,cAAc,+BAA+B,IAAI,MAAK;AAC3F,oBAAI,CAAC,KAAK,sBAAsB;AAC5B;gBACJ;AAEA,sBAAM,gBAAgB,MAAK;AAEvB,iCAAe,mBAAmB,UAAU;AAC5C,iCAAe,mBAAmB,aAAa;AAC/C,uBAAK,oCAAoC,eAAe,aAAa;AACrE,iCAAe,mBAAmB,eAAe,KAAK,SAAS,QAAQ,SAAS,mBAAmB,cAAa,EAAG;AACnH,iCAAe,mBAAmB,kBAAkB;AACpD,wBAAM,eAAe,KAAK,SAAS,kBAAkB;AACrD,mCAAiB;oBACb,SAAS;oBACT,mBAAmB,KAAK,kBAAkB;oBAC1C,gBAAgB,MAAM,CAAC,cAAc;oBACrC,SAAS,MAAK;AACV,0BAAI,KAAK,sCAAsC,eAAe,aAAa,YAAY,eAAe,mBAAmB,SAAS;AAC9H,6BAAK,iBAAiB,aAAa,QAAQ;sBAC/C;oBACJ;mBACH;gBACL;AAEA,oBAAI,cAAc,QAAQ,SAAS;AAC/B,sBAAI,cAAc,QAAQ,QAAQ,SAAS;AAEvC,wBAAI,KAAK,SAAS,qBAAqB;AACnC,uCAAiB;wBACb,SAAS,KAAK,SAAS;wBACvB,mBAAmB,KAAK,kBAAkB;wBAC1C,SAAS,MAAK;AAEV,8BAAI,cAAc,SAAS;AACvB,0CAAa;0BACjB;wBACJ;uBACH;oBACL,OAAO;AACH,oCAAa;oBACjB;kBACJ,OAAO;AACH,mCAAe,mBAAmB,UAAU;AAC5C,yBAAK,oCAAoC;kBAC7C;gBACJ;cACJ,CAAC;YACL,OAAO;AACH,6BAAe,yBAAyB;AAExC,6BAAe,wBAAwB,mBAAmB,6BAA6B,IAAI,CAAC,aAAY;AACpG,oBAAI,SAAS,KAAK,OAAO,eAAe,mBAAmB,WAAW;AAClE,iCAAe,mBAAmB,YAAY;gBAClD;AACA,oBAAI,SAAS,IAAI,OAAO,CAAC,eAAe,mBAAmB,WAAW,KAAK,4BAA4B,CAAC,KAAK,gBAAgB;AAIzH,sBAAI,CAAC,eAAe,mBAAmB,WAAW;AAC9C,mCAAe,mBAAmB,YAAY;AAE9C,yBAAK,eAAe,SAAS,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAC9E,yBAAK,eAAe,mBAAmB,KAAK,UAAU;AAEtD,yBAAK,WAAW,IAAI;AACpB,yBAAK,WAAW,IAAI;AAEpB,+BAAW,qBAAqB,KAAK,YAAY,KAAK,cAAc;AACpE,yBAAK,WAAW,IAAI,GAAG,GAAG,KAAK,kCAAkC,KAAK,kBAAkB,MAAM,uBAAuB,IAAM,GAAK;AAChI,yBAAK,WAAW,wBAAwB,KAAK,gBAAgB,KAAK,UAAU;AAC5E,yBAAK,WAAW,WAAW,KAAK,SAAS,QAAQ,SAAS,QAAQ;AAClE,yBAAK,QAAQ,OAAO,SAAS,KAAK,UAAU;AAG5C,yBAAK,QAAQ,SAAS,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAEvE,yBAAK,QAAQ,UAAU,IAAI,GAAG,IAAI,CAAC;AACnC,0BAAM,OAAO,KAAK,kBAAkB,MAAM,YAAY,KAAK,SAAS,CAAC,MAAK;AACtE,6BAAO,KAAK,aAAa,QAAQ,CAAC,MAAM;oBAC5C,CAAC;AAGD,wBAAI,QAAQ,KAAK,aAAa;AAG1B,2BAAK,SAAS,QAAQ,SAAS,SAAS,IAAI,KAAK,YAAY;AAC7D,2BAAK,SAAS,QAAQ,SAAS,SAAS,IAAI,KAAK,YAAY;oBACjE;kBACJ;gBACJ;AACA,oBAAI,SAAS,IAAI,QAAQ,CAAC,KAAK,qCAAqC,CAAC,eAAe,mBAAmB,YAAY,KAAK,sBAAsB;AAC1I,iCAAe,mBAAmB,UAAU;AAC5C,uBAAK,oCAAoC,eAAe,aAAa;AACrE,iCAAe,mBAAmB,eAAe,KAAK,SAAS,QAAQ,SAAS,mBAAmB,cAAa,EAAG;gBACvH;AACA,oBAAI,SAAS,GAAG;AACZ,sBAAI,CAAC,eAAe,mBAAmB,SAAS;AAC5C,wBAAI,CAAC,eAAe,mBAAmB,YAAY,KAAK,IAAI,SAAS,CAAC,IAAI,KAAK;AAE3E,qCAAe,mBAAmB,WAAW;AAC7C,4BAAM,WAAW,KAAK,iBAAiB,SAAS,IAAI,IAAI,IAAI,OAAO,KAAK,kBAAkB,MAAM,uBAAuB,KAAK;AAC5H,2BAAK,+BAA+B,gBAAgB,QAAQ;AAC5D,iCAAW,gBAAgB,GAAG,UAAU,CAAC,EAAE,cACvC,KAAK,SAAS,QAAQ,SAAS,oBAC/B,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAErD,2BAAK,8BAA8B,gBAAgB,KAAK,SAAS,QAAQ,SAAS,kBAAkB;oBACxG;kBACJ,OAAO;AACH,wBAAI,KAAK,sCAAsC,eAAe,aAAa,UAAU;AAEjF,0BAAI,KAAK,iBAAiB;AACtB,mCAAW,MAAK;AACZ,yCAAe,mBAAmB,kBAAkB,KAAK,MACrD,SAAS,GACT,SAAS,KAAK,KAAK,kBAAkB,MAAM,uBAAuB,IAAI,GAAG;wBAEjF,CAAC;sBACL,OAAO;AACH,uCAAe,mBAAmB,kBAAkB;sBACxD;oBACJ;kBACJ;gBACJ,OAAO;AACH,iCAAe,mBAAmB,WAAW;gBACjD;AAEA,oBAAI,SAAS,MAAM,KAAK,SAAS,MAAM,GAAG;AACtC,sBAAI,eAAe,mBAAmB,SAAS;AAC3C,mCAAe,mBAAmB,UAAU;AAC5C,yBAAK,yBAAyB,KAAK;kBACvC;AACA,sBAAI,eAAe,mBAAmB,SAAS;AAC3C,yBAAK,iBAAiB,aAAa,QAAQ;kBAC/C;gBACJ;cACJ,CAAC;YACL;UACJ;QACJ;AACA,YAAI,aAAa,kBAAkB;AAC/B,+BAAoB;QACxB,OAAO;AACH,uBAAa,iCAAiC,QAAQ,MAAK;AACvD,iCAAoB;UACxB,CAAC;QACL;MACJ,OAAO;AACH,uBAAe,mBAAmB,oBAAoB;AACtD,YAAI,gBAAgB;AACpB,cAAM,gBAAgB,MAAK;AACvB,eAAK,oCAAoC,eAAe,aAAa;AACrE,yBAAe,mBAAmB,UAAU;AAC5C,yBAAe,mBAAmB,aAAa;AAC/C,yBAAe,mBAAmB,eAAe,KAAK,SAAS,QAAQ,SAAS,mBAAmB,cAAa,EAAG;AACnH,yBAAe,mBAAmB,kBAAkB;AACpD,gBAAM,eAAe,KAAK,SAAS,kBAAkB;AACrD,2BAAiB;YACb,SAAS;YACT,mBAAmB,KAAK,kBAAkB;YAC1C,SAAS,MAAK;AACV,kBAAI,KAAK,sCAAsC,eAAe,aAAa,YAAY,eAAe,mBAAmB,SAAS;AAC9H,qBAAK,iBAAiB,aAAa,QAAQ;cAC/C;YACJ;WACH;QACL;AACA,aAAK,kBAAkB,MAAM,oBAAoB,IAAI,CAAC,gBAAe;AACjE,cAAI,YAAY,SAAS,kBAAkB,aAAa;AACpD,4BAAgB;AAEhB,gBAAI,KAAK,SAAS,qBAAqB;AACnC,+BAAiB;gBACb,SAAS,KAAK,SAAS;gBACvB,mBAAmB,KAAK,kBAAkB;gBAC1C,SAAS,MAAK;AAEV,sBAAI,KAAK,sCAAsC,eAAe,aAAa,UAAU;AACjF,kCAAa;kBACjB;gBACJ;gBACA,gBAAgB,MAAK;AACjB,sBAAI,eAAe;AACf,oCAAgB;AAChB,2BAAO;kBACX;AACA,yBAAO;gBACX;eACH;YACL,OAAO;AACH,4BAAa;YACjB;UACJ,WAAW,YAAY,SAAS,kBAAkB,WAAW;AACzD,4BAAgB;AAChB,2BAAe,mBAAmB,UAAU;AAC5C,iBAAK,oCAAoC;UAC7C;QACJ,CAAC;MACL;IACJ;AAiMQ,SAAA,cAAwB,MAAM,EAAE,EAAE,KAAK,KAAK,kBAAkB;AA/tBlE,QAAI,CAAC,KAAK,SAAS,yBAAyB;AACxC,WAAK,yBAAwB;IACjC;AAEA,SAAK,eAAe,KAAK,SAAS,eAAe,CAAA;AACjD,SAAK,mBAAmB,KAAK,SAAS,iBAAiB,CAAA;AACvD,SAAK,mBAAmB,KAAK,SAAS,mBAAmB,IAAI,OAAO,GAAG,GAAG,GAAG,IAAI;AAEjF,SAAK,yBAAyB,KAAK;AAGnC,SAAK,yBAAyB,SAAS,QAAQ,SAAS;AACxD,SAAK,wBAAwB,SAAS,QAAQ,SAAS;AAEvD,SAAK,wBAAwB,KAAK,kBAAkB;AACpD,SAAK,sBAAsB,kBAAkB,oCAAoC,IAAI,CAAC,WAAU;AAC5F,WAAK,uBAAwB,KAAK,uBAAuB,OAAO,sBAAuB,OAAO;AAC9F,WAAK,SAAS,yBAAyB,QAAQ,aAAa,OAAO,iBAAiB,OAAO,mBAAmB;IAClH,CAAC;EACL;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,CAAC,CAAC,KAAK,SAAS;EAC3B;;;;;EAMA,IAAW,eAAe,cAAqB;AAC3C,SAAK,SAAS,iBAAiB;EACnC;;;;;EAMO,aAAa,MAAkB;AAClC,SAAK,aAAa,KAAK,IAAI;EAC/B;;;;;EAMO,eAAe,MAAkB;AACpC,SAAK,SAAS,oBAAoB,KAAK,SAAS,qBAAqB,CAAA;AACrE,SAAK,SAAS,kBAAkB,KAAK,IAAI;EAC7C;;;;;EAMO,aAAa,cAAqB;AACrC,SAAK,iBAAiB,KAAK,YAAY;EAC3C;EAEgB,SAAM;AAClB,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;IACX;AAGA,SAAK,oCAAoC;AAEzC,eAAW,cAAc,KAAK,SAAS,QAAQ,aAAa;AACxD,WAAK,kBAAkB,UAAU;IACrC;AACA,SAAK,sBAAsB,KAAK,SAAS,QAAQ,6BAA6B,KAAK,iBAAiB;AACpG,SAAK,sBAAsB,KAAK,SAAS,QAAQ,+BAA+B,CAAC,eAAc;AAE3F,WAAK,kBAAkB,WAAW,QAAQ;IAC9C,CAAC;AAED,WAAO;EACX;EAEgB,SAAM;AAClB,QAAI,CAAC,MAAM,OAAM,GAAI;AACjB,aAAO;IACX;AAEA,UAAM,OAAO,OAAO,KAAK,KAAK,YAAY;AAE1C,eAAW,gBAAgB,MAAM;AAC7B,WAAK,kBAAkB,YAAY;IACvC;AAEA,SAAK,yBAAyB,KAAK;AACnC,SAAK,oCAAoC;AACzC,SAAK,eAAe,CAAA;AAEpB,WAAO;EACX;EAEgB,UAAO;AACnB,UAAM,QAAO;AACb,SAAK,SAAS,2BAA2B,KAAK,SAAS,wBAAwB,QAAQ,OAAO,IAAI;AAClG,QAAI,KAAK,qBAAqB;AAC1B,WAAK,kBAAkB,oCAAoC,OAAO,KAAK,mBAAmB;IAC9F;AACA,SAAK,sCAAsC,MAAK;AAChD,SAAK,sCAAsC,MAAK;AAChD,SAAK,+BAA+B,MAAK;AACzC,SAAK,8BAA8B,MAAK;AACxC,SAAK,uBAAuB,MAAK;AACjC,SAAK,sBAAsB,MAAK;EACpC;;;;;EAMO,gBAAgB,MAAkB;AACrC,UAAM,QAAQ,KAAK,aAAa,QAAQ,IAAI;AAC5C,QAAI,UAAU,IAAI;AACd,WAAK,aAAa,OAAO,OAAO,CAAC;IACrC;EACJ;;;;;EAMO,kBAAkB,MAAkB;AACvC,SAAK,SAAS,oBAAoB,KAAK,SAAS,qBAAqB,CAAA;AACrE,UAAM,QAAQ,KAAK,SAAS,kBAAkB,QAAQ,IAAI;AAC1D,QAAI,UAAU,IAAI;AACd,WAAK,SAAS,kBAAkB,OAAO,OAAO,CAAC;IACnD;EACJ;;;;;EAMO,sBAAsB,MAAY;AACrC,UAAM,OAAO,KAAK,kBAAkB,MAAM,cAAc,IAAI;AAC5D,QAAI,MAAM;AACN,WAAK,gBAAgB,IAAI;IAC7B;EACJ;;;;;;EAOO,gBAAgB,mBAA0B;AAE7C,QAAI,QAAQ,KAAK,iBAAiB,QAAQ,iBAAiB;AAE3D,QAAI,UAAU,IAAI;AACd,eAAS,IAAI,GAAG,IAAI,KAAK,iBAAiB,QAAQ,EAAE,GAAG;AAEnD,YAAI,KAAK,iBAAiB,CAAC,EAAE,OAAO,iBAAiB,GAAG;AACpD,kBAAQ;AACR;QACJ;MACJ;IACJ;AAEA,QAAI,UAAU,IAAI;AACd,WAAK,iBAAiB,OAAO,OAAO,CAAC;AACrC,aAAO;IACX;AACA,WAAO;EACX;;;;;;;EAQO,oBAAoB,kBAAyC;AAChE,SAAK,oBAAoB;EAC7B;EAEU,WAAW,UAAiB;AAClC,UAAM,QAAQ,KAAK,kBAAkB;AACrC,UAAM,QAAQ,KAAK,kBAAkB;AACrC,QAAI,CAAC,KAAK,UAAU,CAAC,OAAO;AACxB;IACJ;AAGA,UAAM,aAAa,KAAK,SAAS;AACjC,QAAI,KAAK,mCAAmC;AACxC,UAAI,CAAC,YAAY;AACb;MACJ;AACA,iBAAW,qBAAqB,WAAW,sBAAsB,IAAI,WAAU;AAC/E,YAAM,iBAAiB,KAAK,aAAa,KAAK,iCAAiC;AAC/E,UAAI,kBAAkB,eAAe,mBAAmB,SAAS;AAE7D,mBAAW,0BACP,eAAe,mBAAmB,kBAAkB,eAAe,mBAAmB,cACtF,GACA,GACA,WAAW,kBAAkB;AAIjC,YAAI,cAAc;AAClB,cAAM,0BAA0B,eAAe,aAAa,YAAY,kBAAkB;AAC1F,uBAAe,aAAa,wBAAwB,KAAK,OAAO;AAChE,YAAI,KAAK,oBAAoB;AAGzB,gBAAM,OAAO,MAAM,YAAY,KAAK,SAAS,CAAC,MAAK;AAC/C,gBAAI,KAAK,SAAS,0BAA0B,KAAK,SAAS,uBAAuB,CAAC,GAAG;AACjF,qBAAO;YACX;AACA,gBAAI,KAAK,SAAS,0BAA0B,EAAE,YAAY;AACtD,qBAAO;YACX;AAEA,gBAAI,KAAK,SAAS,qBAAqB,KAAK,SAAS,kBAAkB,QAAQ,CAAC,MAAM,IAAI;AACtF,qBAAO;YACX;AACA,kBAAM,QAAQ,KAAK,aAAa,QAAQ,CAAC;AACzC,gBAAI,UAAU,IAAI;AACd,qBAAO;YACX;AACA,mBAAO,KAAK,aAAa,KAAK,EAAE,iBAAiB,IAAI,KAAK,SAAS,QAAQ,SAAS,eAAe;UACvG,CAAC;AACD,gBAAM,kBAAkB,QAAQ,KAAK,cAAc,KAAK,aAAa,QAAQ,KAAK,UAAU,MAAM;AAClG,cAAI,QAAQ,KAAK,cAAc,CAAC,iBAAiB;AAC7C,gBAAI,eAAe,mBAAmB,qBAAqB,CAAC,eAAe,mBAAmB,YAAY;AACtG,6BAAe,mBAAmB,UAAU;AAC5C;YACJ;AACA,2BAAe,mBAAmB,UAAU;AAC5C,iBAAK,yBAAyB,OAAO,OAAO,uBAAuB;AACnE,iBAAK,mBAAmB,IAAI;AAC5B;UACJ,WAAW,QAAQ,KAAK,aAAa;AACjC,2BAAe,mBAAmB,aAAa;AAC/C,2BAAe,mBAAmB,UAAU;AAC5C,0BAAc;AACd,iBAAK,uBAAuB,IAAI;AAChC,iBAAK,yBAAyB,MAAM,OAAO,uBAAuB;AAClE,iBAAK,mBAAmB,IAAI;UAChC;QACJ;AAEA,YAAI,KAAK,uBAAuB,CAAC,aAAa;AAE1C,gBAAM,YAAY,eAAe,aAAa,QAAQ,mBAAoB,cAAa,EAAG;AAC1F,gBAAM,eAAe,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,SAAS;AAE1D,gBAAM,SAAS,KAAK,uBAAuB;AAC3C,eAAK,QAAQ,OAAO,SAAS,KAAK,QAAQ,UAAU,MAAM,SAAS,CAAC,GAAG,KAAK,UAAU;AACtF,eAAK,WAAW,IAAI,KAAK,QAAQ,OAAO;AACxC,eAAK,QAAQ,OAAO,WAAW,KAAK,QAAQ,UAAU,MAAM,MAAM,CAAC;AACnE,eAAK,WAAW,cAAc,KAAK,QAAQ,QAAQ,KAAK,QAAQ,SAAS;AACzE,eAAK,QAAQ,UAAU,UAAS;AAEhC,gBAAM,OAAO,MAAM,YAAY,KAAK,SAAS,CAAC,MAAK;AAC/C,gBAAI,KAAK,SAAS,0BAA0B,KAAK,SAAS,uBAAuB,CAAC,GAAG;AACjF,qBAAO;YACX;AACA,gBAAI,KAAK,SAAS,0BAA0B,EAAE,YAAY;AACtD,qBAAO;YACX;AAEA,gBAAI,KAAK,SAAS,qBAAqB,KAAK,SAAS,kBAAkB,QAAQ,CAAC,MAAM,IAAI;AACtF,qBAAO;YACX;AACA,mBAAO,KAAK,aAAa,QAAQ,CAAC,MAAM;UAC5C,CAAC;AACD,gBAAM,kBAAkB,QAAQ,KAAK,cAAc,KAAK,aAAa,QAAQ,KAAK,UAAU,MAAM;AAClG,cAAI,QAAQ,KAAK,cAAc,CAAC,iBAAiB;AAC7C,gBAAI,eAAe,mBAAmB,qBAAqB,CAAC,eAAe,mBAAmB,YAAY;AACtG,6BAAe,mBAAmB,UAAU;AAC5C;YACJ;AACA,2BAAe,mBAAmB,UAAU;AAC5C,iBAAK,yBAAyB,OAAO,OAAO,uBAAuB;AACnE,iBAAK,mBAAmB,IAAI;AAC5B;UACJ,WAAW,QAAQ,KAAK,aAAa;AACjC,2BAAe,mBAAmB,aAAa;AAC/C,2BAAe,mBAAmB,UAAU;AAC5C,0BAAc;AACd,iBAAK,uBAAuB,IAAI;AAChC,iBAAK,yBAAyB,MAAM,OAAO,uBAAuB;AAClE,iBAAK,mBAAmB,IAAI;UAChC;QACJ;AAGA,aAAK,yBAAyB,aAAa,OAAO,uBAAuB;MAC7E,OAAO;AACH,aAAK,yBAAyB,OAAO,OAAO,IAAI;MACpD;IACJ,OAAO;AACH,WAAK,oBAAmB;AACxB,WAAK,yBAAyB,OAAO,OAAO,IAAI;IACpD;EACJ;EA+OQ,2BAAwB;AAE5B,SAAK,SAAS,2BAA2B,KAAK,SAAS,4BAA4B,CAAA;AACnF,UAAM,kBAAkB,KAAK,SAAS,kBAChC,KAAK,SAAS,2BAA2B,qBAAqB,oBAAoB,oBAClF,KAAK,kBAAkB;AAC7B,UAAM,sBAAsB,aAAa,uBAAuB,EAAE,OAAO,GAAG,QAAQ,GAAG,cAAc,EAAC,GAAI,eAAe;AACzH,wBAAoB,aAAa;AAEjC,QAAI,KAAK,SAAS,yBAAyB,6BAA6B;AACpE,0BAAoB,WAAW,KAAK,SAAS,yBAAyB;IAC1E,OAAO;AACH,YAAM,SAAS;AACf,YAAM,iBAAiB,IAAI,eAAe,oCAAoC,QAAQ,iBAAiB,IAAI;AAC3G,qBAAe,WAAW;AAC1B,YAAM,UAAU,eAAe,WAAU;AACzC,YAAM,UAAU,SAAS;AACzB,YAAM,UAAU,SAAS;AACzB,YAAM,SAAS;AACf,cAAQ,UAAS;AACjB,cAAQ,IAAI,SAAS,SAAS,QAAQ,GAAG,IAAI,KAAK,IAAI,KAAK;AAC3D,cAAQ,YAAY,KAAK,SAAS,yBAAyB,0BAA0B;AACrF,cAAQ,KAAI;AACZ,cAAQ,YAAY;AACpB,cAAQ,cAAc,KAAK,SAAS,yBAAyB,4BAA4B;AACzF,cAAQ,OAAM;AACd,cAAQ,UAAS;AACjB,qBAAe,OAAM;AACrB,YAAM,8BAA8B,IAAI,iBAAiB,8BAA8B,eAAe;AACtG,kCAA4B,iBAAiB;AAC7C,0BAAoB,WAAW;IACnC;AAEA,UAAM,QAAQ,YACV,sBACA;MACI,UAAU;MACV,WAAW;MACX,cAAc;OAElB,eAAe;AAEnB,UAAM,aAAa;AACnB,UAAM,SAAS;AACf,QAAI,CAAC,KAAK,SAAS,yBAAyB,kBAAkB;AAC1D,YAAM,uBAAuB,IAAI,UAAU,wBAAwB,cAAc,IAAI,UAAU,qBAAqB,UAAU,uBAAuB;AACrJ,YAAM,OAA2C,CAAA;AACjD,WAAK,KAAK;QACN,OAAO;QACP,OAAO;OACV;AACD,WAAK,KAAK;QACN,OAAO;QACP,OAAO;OACV;AACD,WAAK,KAAK;QACN,OAAO;QACP,OAAO;OACV;AACD,2BAAqB,QAAQ,IAAI;AACjC,YAAM,iBAAiB,IAAI,SAAQ;AACnC,qBAAe,cAAc,eAAe,oBAAoB;AAChE,2BAAqB,kBAAkB,cAAc;AACrD,YAAM,aAAa,CAAA;AACnB,YAAM,WAAW,KAAK,oBAAoB;AAC1C,sBAAgB,eAAe,OAAO,GAAG,IAAI,IAAI;IACrD;AAEA,UAAM,OAAO,eAAe,gBAAgB,EAAE,aAAa,GAAG,cAAc,EAAC,GAAI,eAAe;AAChG,SAAK,aAAa;AAClB,SAAK,QAAQ,IAAI,KAAK,MAAM,GAAG;AAE/B,SAAK,OAAO,KAAK,GAAG,KAAK,KAAK,CAAC;AAE/B,SAAK,SAAS,IAAI;AAClB,SAAK,SAAS;AAEd,QAAI,KAAK,SAAS,yBAAyB,oBAAoB;AAC3D,YAAM,WAAW,KAAK,SAAS,yBAAyB;AACxD,WAAK,WAAW,KAAK,SAAS,yBAAyB;IAC3D,OAAO;AACH,YAAM,oBAAoB,IAAI,iBAAiB,gBAAgB,eAAe;AAC9E,wBAAkB,kBAAkB,CAAC,CAAC,KAAK,SAAS,yBAAyB;AAC7E,UAAI,kBAAkB,iBAAiB;AACnC,0BAAkB,gBAAgB,IAAI,OAAO,KAAK,KAAK,CAAG;MAC9D,OAAO;AACH,0BAAkB,eAAe,IAAI,OAAO,KAAK,KAAK,CAAG;MAC7D;AACA,wBAAkB,QAAQ;AAC1B,YAAM,WAAW;AACjB,WAAK,WAAW;AAChB,WAAK,6BAA6B;IACtC;AAEA,QAAI,KAAK,SAAS,qBAAqB,QAAW;AAC9C,0BAAoB,mBAAmB,KAAK,SAAS;AACrD,YAAM,mBAAmB,KAAK,SAAS;AACvC,WAAK,mBAAmB,KAAK,SAAS;IAC1C;AAEA,SAAK,SAAS,0BAA0B;AACxC,SAAK,SAAS,wBAAwB,QAAQ,OAAO,KAAK,kBAAkB,kBAAkB;AAE9F,SAAK,yBAAyB,KAAK;EACvC;EAEQ,kBAAkB,sBAA4B;AAClD,UAAM,iBAAiB,KAAK,aAAa,oBAAoB;AAC7D,QAAI,CAAC,gBAAgB;AACjB;IACJ;AACA,QAAI,eAAe,wBAAwB;AACvC,UAAI,eAAe,uBAAuB;AACtC,uBAAe,uBAAuB,6BAA6B,OAAO,eAAe,qBAAqB;MAClH;AACA,UAAI,eAAe,yBAAyB;AACxC,uBAAe,uBAAuB,+BAA+B,OAAO,eAAe,uBAAuB;MACtH;IACJ;AAEA,WAAO,KAAK,aAAa,oBAAoB;EACjD;EAEQ,gCAAgC,cAAuB,SAAiB,KAAK,SAAS,wBAAwB,KAAG;AACrH,QAAI,eAAkC;AACtC,QAAI,kBAAkB,OAAO;AAC7B,QAAI,KAAK,iBAAiB,QAAQ;AAC9B,YAAM,gBAAgB,SAAS;AAC/B,iBAAW,YAAY,KAAK,kBAAkB;AAC1C,cAAM,OAAO,QAAQ,gBAAgB,UAAU,YAAY;AAC3D,YAAI,QAAQ,iBAAiB,OAAO,iBAAiB;AACjD,4BAAkB;AAClB,yBAAe;QACnB;MACJ;IACJ;AACA,WAAO;EACX;EAEQ,uBAAuB,UAAqB;AAChD,UAAM,cAAc,SAAS;AAC7B,QAAI,CAAC,KAAK,SAAS,2BAA2B,CAAC,aAAa;AACxD;IACJ;AACA,UAAM,eAAe,KAAK,gCAAgC,WAAW;AACrE,SAAK,kBAAkB,CAAC,CAAC;AACzB,QAAI,KAAK,kBAAkB,CAAC,KAAK,mBAAmB,KAAK,4BAA4B;AACjF,WAAK,2BAA2B,aAAa,IAAI,GAAK,KAAK,GAAG;IAClE,WAAW,KAAK,kBAAkB,KAAK,mBAAmB,KAAK,4BAA4B;AACvF,WAAK,2BAA2B,aAAa,IAAI,KAAK,KAAK,CAAG;IAClE;AACA,SAAK,SAAS,wBAAwB,SAAS,SAAS,gBAAgB,WAAW;AACnF,SAAK,SAAS,wBAAwB,SAAS,KAAK;AACpD,SAAK,sCAAsC,gBAAgB,QAAQ;EACvE;EAEQ,yBAAyB,SAAkB,OAAiB,yBAAiC;AACjG,QAAI,CAAC,KAAK,SAAS,yBAAyB;AACxC;IACJ;AACA,QAAI,KAAK,SAAS,wBAAwB,cAAc,WAAW,CAAC,OAAO;AACvE;IACJ;AACA,SAAK,SAAS,wBAAwB,YAAY;AAClD,UAAM,WAAW,KAAK,SAAS,wBAAwB,YAAY,QAAW,KAAK;AACnF,eAAW,KAAK,UAAU;AAChB,QAAG,YAAY;IACzB;AAEA,QAAI,CAAC,SAAS;AACV,UAAI,KAAK,uBAAuB;AAC5B,aAAK,sBAAsB,QAAO;AAClC,aAAK,wBAAwB;MACjC;AACA,UAAI,KAAK,qBAAqB,yBAAyB;AACnD,aAAK,kBAAkB,OAAM;MACjC;IACJ,OAAO;AACH,UAAI,KAAK,qBAAqB,yBAAyB;AACnD,aAAK,kBAAkB,OAAM;MACjC;IACJ;EACJ;EAEQ,sBAAmB;AACvB,QAAI,KAAK,uBAAuB;AAC5B,WAAK,sBAAsB,QAAO;AAClC,WAAK,wBAAwB;IACjC;EACJ;EAIQ,mBAAmB,UAAqB;AAC5C,QAAI,CAAC,SAAS,eAAe,CAAC,KAAK,mCAAmC;AAClE;IACJ;AAEA,UAAM,kBAAkB,KAAK,SAAS,kBAChC,KAAK,SAAS,2BAA2B,qBAAqB,oBAAoB,oBAClF,KAAK,kBAAkB;AAE7B,UAAM,iBAAiB,KAAK,aAAa,KAAK,iCAAiC;AAE/E,UAAM,yBAAyB,OAAO,sBAAsB,eAAe,aAAa,QAAQ,kBAAkB,SAAS,IAAK,QAAQ,SAAS,aAAa,EAAE;AAChK,UAAM,QAAQ,eAAe,mBAAmB,UAAU,KAAK,mBAAmB;AAClF,UAAM,cAAc,KAAK,YAAY,KAAK,SAAS,KAAK,kBAAkB;AAE1E,UAAM,SAAS,uBAAuB,UAAS;AAC/C,WAAO,MAAK;AACZ,WAAO,MAAK;AACZ,QAAI,CAAC,KAAK,SAAS,qBAAqB;AACpC,WAAK,wBAAwB,YACzB,2BACA,EAAE,QAAgB,UAAU,KAAK,uBAAoC,WAAW,MAAM,QAAQ,YAAW,GACzG,eAAe;IAEvB,OAAO;AACH,WAAK,wBAAwB,KAAK,SAAS,oBAAoB,uBAAuB,UAAS,GAAI,QAAQ;IAC/G;AACA,SAAK,sBAAsB,aAAa;AACxC,QAAI,KAAK,SAAS,qBAAqB,QAAW;AAC9C,WAAK,sBAAsB,mBAAmB,KAAK,SAAS;IAChE;EACJ;EAEQ,iBAAiB,cAAoB;AACzC,UAAM,iBAAiB,KAAK,aAAa,YAAY;AACrD,QAAI,CAAC,kBAAkB,CAAC,eAAe,mBAAmB,WAAW,CAAC,KAAK,sBAAsB;AAC7F;IACJ;AACA,mBAAe,mBAAmB,UAAU;AAC5C,SAAK,oCAAoC;AACzC,QAAI,KAAK,kBAAkB,CAAC,KAAK,iBAAiB;AAC9C;IACJ;AAEA,QAAI,KAAK,uBAAuB;AAC5B,WAAK,wBAAwB;AAC7B;IACJ;AAEA,QAAI,KAAK,SAAS,2BAA2B,KAAK,SAAS,wBAAwB,WAAW;AAC1F,YAAM,SAAS,KAAK,SAAS,QAAQ,SAAS;AAC9C,WAAK,uBAAuB,gBAAgB,KAAK,SAAS,QAAQ,SAAS,QAAQ;AACnF,WAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,SAAS,wBAAwB,QAAQ;AAC/F,WAAK,SAAS,QAAQ,SAAS,SAAS,KAAK;AAC7C,iBAAW,gBAAgB,GAAG,eAAe,mBAAmB,mBAAmB,KAAK,kBAAkB,MAAM,uBAAuB,KAAK,KAAK,IAAI,CAAC,EAAE,cACpJ,KAAK,SAAS,QAAQ,SAAS,oBAC/B,KAAK,SAAS,QAAQ,SAAS,kBAAkB;AAErD,WAAK,sBAAsB,gBAAgB,KAAK,SAAS,QAAQ,SAAS,QAAQ;IACtF;EACJ;;AA94BuB,mCAAA,OAAO,iBAAiB;AAMxB,mCAAA,UAAU;AA24BrC,qBAAqB,gBACjB,mCAAmC,MACnC,CAAC,kBAAkB,YAAW;AAC1B,SAAO,MAAM,IAAI,mCAAmC,kBAAkB,OAAO;AACjF,GACA,mCAAmC,SACnC,IAAI;;;AC/kCF,IAAO,gCAAP,MAAoC;;AAmFpC,IAAO,yBAAP,MAAO,wBAAsB;EA+B/B,cAAA;EAAuB;;;;;;;EAQhB,aAAa,YAAY,OAAc,UAAyC,CAAA,GAAE;AACrF,UAAM,SAAS,IAAI,wBAAsB;AACzC,UAAM,oBAAoB,QAAQ,MAAK;AACnC,aAAO,QAAO;IAClB,CAAC;AAED,QAAI,CAAC,QAAQ,kBAAkB;AAC3B,YAAM,YAAqC;QACvC,cAAc,OAAO;QACrB,GAAI,QAAQ,aAAa,CAAA;;AAE7B,UAAI,QAAQ,kBAAkB;AAC1B,YAAI,OAAO,QAAQ,qBAAqB,WAAW;AAC/C,oBAAU,mBAAmB,CAAC,YAAY,WAAW,mBAAmB,eAAe;QAC3F,OAAO;AACH,oBAAU,mBAAmB,QAAQ;QACzC;MACJ;AACA,aAAO,cAAc,IAAI,iBAAiB,OAAO,SAAS;IAC9D;AAEA,QAAI;AAEA,YAAM,WAAW,MAAM,sBAAsB,YAAY,KAAK;AAE9D,aAAO,iBAAiB;AAExB,UAAI,QAAQ,kCAAkC;AAE1C,eAAO,eAAe,OAAO,yBAAyB;MAC1D;AAIA,aAAO,QAAQ,IAAI,WAAW,SAAS,gBAAgB,SAAS,QAAQ;QACpE,mBAAmB;UACf,kBAAkB,QAAQ;;QAE9B,GAAI,QAAQ,gBAAgB,CAAA;OAC/B;AAED,UAAI,CAAC,QAAQ,yBAAyB;AAElC,cAAM,0BAA0B;UAC5B,GAAG,QAAQ;UACX,SAAS,OAAO;UAChB,kBAAkB,QAAQ;;AAG9B,eAAO,mBACH,OAAO,eAAe,gBAAgB,cAClC,gCAAgC,MAChC,QAAQ,mBAAmB,WAAW,UACG,uBAAuB;AAIxE,YAAI,CAAC,QAAQ,sBAAsB;AAE/B,iBAAO,gBAAoD,OAAO,eAAe,gBAAgB,cAC7F,mCAAmC,MACnC,QAAQ,mBAAmB,WAAW,UACV;YACxB,aAAa,QAAQ;YACrB,SAAS,OAAO;YAChB,kBAAkB,QAAQ;YAC1B,GAAG,QAAQ;WACd;AAEL,iBAAO,cAAc,oBAAoB,OAAO,gBAAgB;QACpE;MACJ;AAEA,UAAI,CAAC,QAAQ,wBAAwB;AAEjC,eAAO,kBAAwC,OAAO,eAAe,gBAAgB,cACjF,qBAAqB,MACrB,QAAQ,mBAAmB,WAAW,UACR;UAC1B,SAAS,OAAO;UAChB,uBAAuB,OAAO;UAC9B,kBAAkB,QAAQ;UAC1B,iBAAiB;UACjB,uCAAuC;UACvC,GAAG,QAAQ;SACd;MAET;AAEA,UAAI,CAAC,QAAQ,qBAAqB;AAE9B,eAAO,eAAe,gBAAgB,cAClC,kBAAkB,MAClB,QAAQ,mBAAmB,WAAW,UACX;UACvB,SAAS,OAAO;UAChB,GAAG,QAAQ;WAEf,QACA,KAAK;MAEb;AAGA,aAAO,eAAe,OAAO,eAAe,eAAe,qBAAqB,QAAQ,mBAAmB;AAE3G,UAAI,CAAC,QAAQ,kBAAkB;AAE3B,cAAM,OAAO,YAAY,eAAe,OAAO,gBAAgB,OAAO,YAAY;MACtF;AACA,aAAO;IACX,SAAS,OAAO;AACZ,aAAO,MAAM,uBAAuB;AACpC,aAAO,MAAM,KAAK;AAClB,aAAO;IACX;EACJ;;;;EAKO,UAAO;AACV,QAAI,KAAK,gBAAgB;AACrB,WAAK,eAAe,QAAO;IAC/B;AACA,QAAI,KAAK,OAAO;AACZ,WAAK,MAAM,QAAO;IACtB;AACA,QAAI,KAAK,aAAa;AAClB,WAAK,YAAY,QAAO;IAC5B;AACA,QAAI,KAAK,cAAc;AACnB,WAAK,aAAa,QAAO;IAC7B;EACJ;;",
  "names": ["referenceSpace", "rejectionReason", "i", "featureName", "Xbox360Button", "Xbox360Dpad", "DualShockButton", "DualShockDpad", "pose", "radius", "angle", "i", "v", "result", "pointerEvent", "NodeMaterialBlockConnectionPointTypes", "NodeMaterialBlockTargets", "NodeMaterialConnectionPointCompatibilityStates", "NodeMaterialConnectionPointDirection", "prefix", "PropertyTypeForEdition", "FragmentOutputBlockColorSpace", "NodeMaterialModes", "NodeMaterialSystemValues", "AnimatedInputBlockTypes", "textureReadFunc", "TrigonometryBlockOperations", "result", "effect", "source", "ControllerOrbAnimationState", "WebXRNearControllerMode", "touchCollisionMesh", "touchCollisionMeshFunction", "hydrateCollisionMeshFunction", "HandPart", "WebXRHandJoint", "dashSize", "gapSize"]
}
