{
  "version": 3,
  "sources": ["../../@pmndrs/pointer-events/dist/event.js", "../../@pmndrs/pointer-events/dist/html-event.js", "../../@pmndrs/pointer-events/dist/pointer.js", "../../@pmndrs/pointer-events/dist/intersections/intersector.js", "../../@pmndrs/pointer-events/dist/intersections/utils.js", "../../@pmndrs/pointer-events/dist/intersections/lines.js", "../../@pmndrs/pointer-events/dist/utils.js", "../../@pmndrs/pointer-events/dist/intersections/ray.js", "../../@pmndrs/pointer-events/dist/intersections/sphere.js", "../../@pmndrs/pointer-events/dist/forward.js", "../../@pmndrs/pointer-events/dist/combine.js", "../../@pmndrs/pointer-events/dist/pointer/ray.js", "../../@pmndrs/pointer-events/dist/pointer/lines.js", "../../@pmndrs/pointer-events/dist/pointer/touch.js", "../../@pmndrs/pointer-events/dist/pointer/index.js", "../../@pmndrs/pointer-events/dist/pointer/grab.js"],
  "sourcesContent": ["import { Ray, Vector2, Vector3 } from 'three';\nimport { HtmlEvent } from './html-event.js';\nconst helperVector = new Vector3();\nexport class PointerEvent extends HtmlEvent {\n    type;\n    bubbles;\n    internalPointer;\n    intersection;\n    camera;\n    currentObject;\n    object;\n    propagationState;\n    //--- pointer events data\n    get pointerId() {\n        return this.internalPointer.id;\n    }\n    get pointerType() {\n        return this.internalPointer.type;\n    }\n    get pointerState() {\n        return this.internalPointer.state;\n    }\n    //--- intersection data\n    get distance() {\n        return this.intersection.distance;\n    }\n    get distanceToRay() {\n        return this.intersection.distanceToRay;\n    }\n    get point() {\n        return this.intersection.point;\n    }\n    get index() {\n        return this.intersection.index;\n    }\n    get face() {\n        return this.intersection.face;\n    }\n    get faceIndex() {\n        return this.intersection.faceIndex;\n    }\n    get uv() {\n        return this.intersection.uv;\n    }\n    get uv1() {\n        return this.intersection.uv1;\n    }\n    get normal() {\n        return this.intersection.normal;\n    }\n    get instanceId() {\n        return this.intersection.instanceId;\n    }\n    get pointOnLine() {\n        return this.intersection.pointOnLine;\n    }\n    get batchId() {\n        return this.intersection.batchId;\n    }\n    get pointerPosition() {\n        return this.intersection.pointerPosition;\n    }\n    get pointerQuaternion() {\n        return this.intersection.pointerQuaternion;\n    }\n    get pointOnFace() {\n        return this.intersection.pointOnFace;\n    }\n    get localPoint() {\n        return this.intersection.localPoint;\n    }\n    get details() {\n        return this.intersection.details;\n    }\n    /** same as object */\n    get target() {\n        return this.object;\n    }\n    /** same as currentObject */\n    get currentTarget() {\n        return this.currentObject;\n    }\n    /** same as currentObject */\n    get eventObject() {\n        return this.currentObject;\n    }\n    /** same as object */\n    get srcElement() {\n        return this.currentObject;\n    }\n    _pointer;\n    get pointer() {\n        if (this._pointer == null) {\n            helperVector.copy(this.intersection.point).project(this.camera);\n            this._pointer = new Vector2(helperVector.x, helperVector.y);\n        }\n        return this._pointer;\n    }\n    _ray;\n    get ray() {\n        if (this._ray != null) {\n            return this._ray;\n        }\n        switch (this.intersection.details.type) {\n            case 'screen-ray':\n            case 'ray':\n            case 'sphere':\n                return (this._ray = new Ray(this.intersection.pointerPosition, new Vector3(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion)));\n            case 'lines':\n                return (this._ray = new Ray(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize()));\n        }\n    }\n    _intersections = [];\n    get intersections() {\n        if (this._intersections == null) {\n            this._intersections = [{ ...this.intersection, eventObject: this.currentObject }];\n        }\n        return this._intersections;\n    }\n    _unprojectedPoint;\n    get unprojectedPoint() {\n        if (this._unprojectedPoint == null) {\n            const p = this.pointer;\n            this._unprojectedPoint = new Vector3(p.x, p.y, 0).unproject(this.camera);\n        }\n        return this._unprojectedPoint;\n    }\n    get stopped() {\n        return this.propagationState.stoppedImmediate || this.propagationState.stopped;\n    }\n    get stoppedImmediate() {\n        return this.propagationState.stoppedImmediate;\n    }\n    get delta() {\n        throw new Error(`not supported`);\n    }\n    constructor(type, bubbles, nativeEvent, internalPointer, intersection, camera, currentObject = intersection.object, object = currentObject, propagationState = {\n        stopped: !bubbles,\n        stoppedImmediate: false,\n    }) {\n        super(nativeEvent);\n        this.type = type;\n        this.bubbles = bubbles;\n        this.internalPointer = internalPointer;\n        this.intersection = intersection;\n        this.camera = camera;\n        this.currentObject = currentObject;\n        this.object = object;\n        this.propagationState = propagationState;\n    }\n    stopPropagation() {\n        this.propagationState.stopped = true;\n    }\n    stopImmediatePropagation() {\n        this.propagationState.stoppedImmediate = true;\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        return new PointerEvent(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target, this.propagationState);\n    }\n}\nexport class WheelEvent extends PointerEvent {\n    get deltaX() {\n        return this.nativeEvent.deltaX;\n    }\n    get deltaY() {\n        return this.nativeEvent.deltaY;\n    }\n    get deltaZ() {\n        return this.nativeEvent.deltaZ;\n    }\n    constructor(nativeEvent, pointer, intersection, camera, currentObject, object) {\n        super('wheel', true, nativeEvent, pointer, intersection, camera, currentObject, object);\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        return new WheelEvent(this.nativeEvent, this.internalPointer, this.intersection, this.camera, currentObject, this.target);\n    }\n}\nexport function emitPointerEvent(event) {\n    emitPointerEventRec(event, event.currentObject);\n}\nfunction emitPointerEventRec(baseEvent, currentObject) {\n    if (currentObject == null) {\n        return;\n    }\n    const listeners = getObjectListeners(currentObject, baseEvent.type);\n    if (listeners != null && listeners.length > 0) {\n        const event = baseEvent.retarget(currentObject);\n        const length = listeners.length;\n        for (let i = 0; i < length && !event.stoppedImmediate; i++) {\n            listeners[i](event);\n        }\n    }\n    if (baseEvent.stopped) {\n        return;\n    }\n    emitPointerEventRec(baseEvent, currentObject.parent);\n}\nconst r3fEventToHandlerMap = {\n    click: 'onClick',\n    contextmenu: 'onContextMenu',\n    dblclick: 'onDoubleClick',\n    pointercancel: 'onPointerCancel',\n    pointerdown: 'onPointerDown',\n    pointerenter: 'onPointerEnter',\n    pointerleave: 'onPointerLeave',\n    pointermove: 'onPointerMove',\n    pointerout: 'onPointerOut',\n    pointerover: 'onPointerOver',\n    pointerup: 'onPointerUp',\n    wheel: 'onWheel',\n};\nexport const listenerNames = Object.keys(r3fEventToHandlerMap);\nfunction getObjectListeners(object, forEvent) {\n    if (object._listeners != null && forEvent in object._listeners) {\n        return object._listeners[forEvent];\n    }\n    //R3F compatibility\n    let handler;\n    if (object.isVoidObject && forEvent === 'click' && object.parent?.__r3f != null) {\n        handler = object.parent.__r3f.root.getState().onPointerMissed;\n    }\n    if (object.__r3f != null) {\n        handler = object.__r3f.handlers[r3fEventToHandlerMap[forEvent]];\n    }\n    if (handler == null) {\n        return undefined;\n    }\n    return [handler];\n}\n", "export class HtmlEvent {\n    nativeEvent;\n    NONE = 0;\n    CAPTURING_PHASE = 1;\n    AT_TARGET = 2;\n    BUBBLING_PHASE = 3;\n    relatedTarget = null;\n    get altKey() {\n        return this.getFromNative('altKey', false);\n    }\n    get button() {\n        return this.getFromNative('button', 0);\n    }\n    get buttons() {\n        return this.getFromNative('buttons', 0);\n    }\n    get clientX() {\n        return this.getFromNative('clientX', 0);\n    }\n    get clientY() {\n        return this.getFromNative('clientY', 0);\n    }\n    get ctrlKey() {\n        return this.getFromNative('ctrlKey', false);\n    }\n    get layerX() {\n        return this.getFromNative('layerX', 0);\n    }\n    get layerY() {\n        return this.getFromNative('layerY', 0);\n    }\n    get metaKey() {\n        return this.getFromNative('metaKey', false);\n    }\n    get movementX() {\n        return this.getFromNative('movementX', 0);\n    }\n    get movementY() {\n        return this.getFromNative('movementY', 0);\n    }\n    get offsetX() {\n        return this.getFromNative('offsetX', 0);\n    }\n    get offsetY() {\n        return this.getFromNative('offsetY', 0);\n    }\n    get pageX() {\n        return this.getFromNative('pageX', 0);\n    }\n    get pageY() {\n        return this.getFromNative('pageY', 0);\n    }\n    get screenX() {\n        return this.getFromNative('screenX', 0);\n    }\n    get screenY() {\n        return this.getFromNative('screenY', 0);\n    }\n    get shiftKey() {\n        return this.getFromNative('shiftKey', false);\n    }\n    get x() {\n        return this.getFromNative('x', 0);\n    }\n    get y() {\n        return this.getFromNative('y', 0);\n    }\n    get detail() {\n        return this.getFromNative('detail', 0);\n    }\n    get view() {\n        return this.getFromNative('view', null);\n    }\n    get which() {\n        return this.getFromNative('which', 0);\n    }\n    get cancelBubble() {\n        return this.getFromNative('cancelBubble', false);\n    }\n    get composed() {\n        return this.getFromNative('composed', false);\n    }\n    get eventPhase() {\n        return this.getFromNative('eventPhase', 0);\n    }\n    get isTrusted() {\n        return this.getFromNative('isTrusted', false);\n    }\n    get returnValue() {\n        return this.getFromNative('returnValue', false);\n    }\n    get timeStamp() {\n        return this.getFromNative('timeStamp', 0);\n    }\n    get cancelable() {\n        return this.getFromNative('cancelable', false);\n    }\n    get defaultPrevented() {\n        return this.getFromNative('defaultPrevented', false);\n    }\n    constructor(nativeEvent) {\n        this.nativeEvent = nativeEvent;\n    }\n    getFromNative(key, defaultValue) {\n        if (key in this.nativeEvent) {\n            return this.nativeEvent[key];\n        }\n        return defaultValue;\n    }\n}\n", "import { Object3D } from 'three';\nimport { PointerEvent, WheelEvent, emitPointerEvent } from './event.js';\nimport { intersectPointerEventTargets } from './intersections/utils.js';\nconst buttonsDownTimeKey = Symbol('buttonsDownTime');\nconst buttonsClickTimeKey = Symbol('buttonsClickTime');\nglobalThis.pointerEventspointerMap ??= new Map();\nObject3D.prototype.setPointerCapture = function (pointerId) {\n    getPointerById(pointerId)?.setCapture(this);\n};\nObject3D.prototype.releasePointerCapture = function (pointerId) {\n    const pointer = getPointerById(pointerId);\n    if (pointer == null || !pointer.hasCaptured(this)) {\n        return;\n    }\n    pointer.setCapture(undefined);\n};\nObject3D.prototype.hasPointerCapture = function (pointerId) {\n    return getPointerById(pointerId)?.hasCaptured(this) ?? false;\n};\nexport function getPointerById(pointerId) {\n    return globalThis.pointerEventspointerMap?.get(pointerId);\n}\nexport class Pointer {\n    id;\n    type;\n    state;\n    intersector;\n    getCamera;\n    onMoveCommited;\n    parentSetPointerCapture;\n    parentReleasePointerCapture;\n    options;\n    //state\n    prevIntersection;\n    intersection;\n    prevEnabled = true;\n    enabled = true;\n    wheelIntersection;\n    //derived state\n    /**\n     * ordered leaf -> root (bottom -> top)\n     */\n    pointerEntered = [];\n    pointerEnteredHelper = [];\n    pointerCapture;\n    buttonsDownTime = new Map();\n    buttonsDown = new Set();\n    //to handle interaction before first move (after exit)\n    wasMoved = false;\n    onFirstMove = [];\n    constructor(id, type, state, intersector, getCamera, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {\n        this.id = id;\n        this.type = type;\n        this.state = state;\n        this.intersector = intersector;\n        this.getCamera = getCamera;\n        this.onMoveCommited = onMoveCommited;\n        this.parentSetPointerCapture = parentSetPointerCapture;\n        this.parentReleasePointerCapture = parentReleasePointerCapture;\n        this.options = options;\n        globalThis.pointerEventspointerMap?.set(id, this);\n    }\n    getPointerCapture() {\n        return this.pointerCapture;\n    }\n    hasCaptured(object) {\n        return this.pointerCapture?.object === object;\n    }\n    setCapture(object) {\n        if (this.pointerCapture?.object === object) {\n            return;\n        }\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        if (object != null && this.intersection != null) {\n            this.pointerCapture = { object, intersection: this.intersection };\n            this.parentSetPointerCapture?.();\n        }\n    }\n    getButtonsDown() {\n        return this.buttonsDown;\n    }\n    /**\n     * @returns undefined if no intersection was executed yet\n     */\n    getIntersection() {\n        return this.intersection;\n    }\n    getEnabled() {\n        return this.enabled;\n    }\n    setEnabled(enabled, nativeEvent, commit = true) {\n        if (this.enabled === enabled) {\n            return;\n        }\n        if (!enabled && this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.enabled = enabled;\n        if (commit) {\n            this.commit(nativeEvent, false);\n        }\n    }\n    computeIntersection(type, scene, nativeEvent) {\n        if (this.pointerCapture != null) {\n            return this.intersector.intersectPointerCapture(this.pointerCapture, nativeEvent);\n        }\n        this.intersector.startIntersection(nativeEvent);\n        intersectPointerEventTargets(type, scene, [this]);\n        return this.intersector.finalizeIntersection(scene);\n    }\n    setIntersection(intersection) {\n        this.intersection = intersection;\n    }\n    commit(nativeEvent, emitMove) {\n        const camera = this.getCamera();\n        const prevIntersection = this.prevEnabled ? this.prevIntersection : undefined;\n        const intersection = this.enabled ? this.intersection : undefined;\n        //pointer out\n        if (prevIntersection != null && prevIntersection.object != intersection?.object) {\n            emitPointerEvent(new PointerEvent('pointerout', true, nativeEvent, this, prevIntersection, camera));\n        }\n        const pointerLeft = this.pointerEntered;\n        this.pointerEntered = [];\n        this.pointerEnteredHelper.length = 0;\n        computeEnterLeave(intersection?.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);\n        //pointerleave\n        const length = pointerLeft.length;\n        for (let i = 0; i < length; i++) {\n            const object = pointerLeft[i];\n            emitPointerEvent(new PointerEvent('pointerleave', false, nativeEvent, this, prevIntersection, camera, object));\n        }\n        //pointer over\n        if (intersection != null && prevIntersection?.object != intersection.object) {\n            emitPointerEvent(new PointerEvent('pointerover', true, nativeEvent, this, intersection, camera));\n        }\n        //pointer enter\n        //inverse loop so that we emit enter from top -> bottom (root -> leaf)\n        for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {\n            const object = this.pointerEnteredHelper[i];\n            emitPointerEvent(new PointerEvent('pointerenter', false, nativeEvent, this, intersection, camera, object));\n        }\n        //pointer move\n        if (emitMove && intersection != null) {\n            emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, intersection, camera));\n        }\n        this.prevIntersection = this.intersection;\n        this.prevEnabled = this.enabled;\n        if (!this.wasMoved && this.intersector.isReady()) {\n            this.wasMoved = true;\n            const length = this.onFirstMove.length;\n            for (let i = 0; i < length; i++) {\n                this.onFirstMove[i](camera);\n            }\n            this.onFirstMove.length = 0;\n        }\n        this.onMoveCommited?.(this);\n    }\n    /**\n     * computes and commits a move\n     */\n    move(scene, nativeEvent) {\n        this.intersection = this.computeIntersection('pointer', scene, nativeEvent);\n        this.commit(nativeEvent, true);\n    }\n    /**\n     * emits a move without (re-)computing the intersection\n     * just emitting a move event to the current intersection\n     */\n    emitMove(nativeEvent) {\n        if (this.intersection == null) {\n            return;\n        }\n        emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, this.intersection, this.getCamera()));\n    }\n    down(nativeEvent) {\n        this.buttonsDown.add(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.down.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer down\n        emitPointerEvent(new PointerEvent('pointerdown', true, nativeEvent, this, this.intersection, this.getCamera()));\n        //store button down times on object and on pointer\n        const { object } = this.intersection;\n        object[buttonsDownTimeKey] ??= new Map();\n        object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);\n        this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);\n    }\n    up(nativeEvent) {\n        this.buttonsDown.delete(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.up.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        const { clickThesholdMs, contextMenuButton = 2, dblClickThresholdMs = 500, clickThresholdMs = clickThesholdMs ?? 300, } = this.options;\n        this.pointerCapture = undefined;\n        const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThresholdMs);\n        const camera = this.getCamera();\n        //context menu\n        if (isClicked && nativeEvent.button === contextMenuButton) {\n            emitPointerEvent(new PointerEvent('contextmenu', true, nativeEvent, this, this.intersection, camera));\n        }\n        //poinerup\n        emitPointerEvent(new PointerEvent('pointerup', true, nativeEvent, this, this.intersection, camera));\n        if (!isClicked || nativeEvent.button === contextMenuButton) {\n            return;\n        }\n        //click\n        emitPointerEvent(new PointerEvent('click', true, nativeEvent, this, this.intersection, camera));\n        //dblclick\n        const { object } = this.intersection;\n        const buttonsClickTime = (object[buttonsClickTimeKey] ??= new Map());\n        const buttonClickTime = buttonsClickTime.get(nativeEvent.button);\n        if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {\n            buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);\n            return;\n        }\n        emitPointerEvent(new PointerEvent('dblclick', true, nativeEvent, this, this.intersection, camera));\n        buttonsClickTime.delete(nativeEvent.button);\n    }\n    cancel(nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer cancel\n        emitPointerEvent(new PointerEvent('pointercancel', true, nativeEvent, this, this.intersection, this.getCamera()));\n    }\n    wheel(scene, nativeEvent, useMoveIntersection = false) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved && useMoveIntersection) {\n            this.onFirstMove.push(this.wheel.bind(this, scene, nativeEvent, useMoveIntersection));\n            return;\n        }\n        if (!useMoveIntersection) {\n            this.wheelIntersection = this.computeIntersection('wheel', scene, nativeEvent);\n        }\n        const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));\n    }\n    emitWheel(nativeEvent, useMoveIntersection = false) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved && useMoveIntersection) {\n            this.onFirstMove.push(this.emitWheel.bind(this, nativeEvent, useMoveIntersection));\n            return;\n        }\n        const intersection = useMoveIntersection ? this.intersection : this.wheelIntersection;\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection, this.getCamera()));\n    }\n    exit(nativeEvent) {\n        if (this.wasMoved) {\n            //reset state\n            if (this.pointerCapture != null) {\n                this.parentReleasePointerCapture?.();\n                this.pointerCapture = undefined;\n            }\n            this.intersection = undefined;\n            this.commit(nativeEvent, false);\n        }\n        this.onFirstMove.length = 0;\n        this.wasMoved = false;\n    }\n}\n/**\n * @returns an array that contains the object and all its ancestors ordered leaf -> root (bottom -> top)\n */\nfunction computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {\n    if (currentObject == null) {\n        return;\n    }\n    const index = targeDiffRemovedAncestors.indexOf(currentObject);\n    if (index != -1) {\n        targeDiffRemovedAncestors.splice(index, 1);\n    }\n    else {\n        targetDiffAddedAncestors.push(currentObject);\n    }\n    targetAllAncestors.push(currentObject);\n    computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);\n}\nfunction getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThresholdMs) {\n    if (objectButtonsDownTime == null) {\n        return false;\n    }\n    const objectButtonPressTime = objectButtonsDownTime.get(button);\n    if (objectButtonPressTime == null) {\n        return false;\n    }\n    if (buttonUpTime - objectButtonPressTime > clickThresholdMs) {\n        return false;\n    }\n    if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {\n        //we have released the button somewhere else\n        return false;\n    }\n    return true;\n}\n", "import { Mesh, SphereGeometry } from 'three';\nconst VoidObjectRadius = 10000000000;\nconst VoidObjectGeometry = new SphereGeometry(VoidObjectRadius);\nconst sceneVoidObjectMap = new Map();\nexport function getVoidObject(scene) {\n    let entry = sceneVoidObjectMap.get(scene);\n    if (entry == null) {\n        entry = new Mesh(VoidObjectGeometry);\n        entry.isVoidObject = true;\n        entry.parent = scene;\n        //makes sure all other intersections are always prioritized\n        entry.pointerEventsOrder = -Infinity;\n        sceneVoidObjectMap.set(scene, entry);\n    }\n    return entry;\n}\n", "import { getVoidObject } from './intersector.js';\nimport { listenerNames } from '../event.js';\nexport function computeIntersectionWorldPlane(target, intersection, objectMatrixWorld) {\n    const normal = intersection.normal ?? intersection.face?.normal;\n    if (normal == null) {\n        return false;\n    }\n    target.setFromNormalAndCoplanarPoint(normal, intersection.localPoint);\n    target.applyMatrix4(objectMatrixWorld);\n    return true;\n}\nfunction isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {\n    if (pointerEvents === 'none') {\n        return false;\n    }\n    if (pointerEvents === 'listener' && !hasListener) {\n        return false;\n    }\n    if (pointerEventsType === 'all') {\n        return true;\n    }\n    if (typeof pointerEventsType === 'function') {\n        return ({ id, type, state }) => pointerEventsType(id, type, state);\n    }\n    let value;\n    let invert;\n    if ('deny' in pointerEventsType) {\n        invert = true;\n        value = pointerEventsType.deny;\n    }\n    else {\n        invert = false;\n        value = pointerEventsType.allow;\n    }\n    if (Array.isArray(value)) {\n        return (pointer) => invertIf(value.includes(pointer.type), invert);\n    }\n    return (pointer) => invertIf(value === pointer.type, invert);\n}\nfunction invertIf(toInvert, ifIsTrue) {\n    return ifIsTrue ? !toInvert : toInvert;\n}\nexport function intersectPointerEventTargets(type, object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {\n    const hasListener = parentHasListener || hasObjectListeners(type, object);\n    const pointerEvents = object.pointerEvents ?? parentPointerEvents;\n    const pointerEventsOrDefault = pointerEvents ?? object.defaultPointerEvents ?? 'listener';\n    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? 'all';\n    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder ?? 0;\n    const isAllowed = isPointerEventsAllowed(hasListener, pointerEventsOrDefault, pointerEventsType);\n    const length = pointers.length;\n    if (length === 1) {\n        if (isAllowed === true || (typeof isAllowed === 'function' && isAllowed(pointers[0]))) {\n            filterAndInteresct(pointers[0], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    else if (isAllowed === true) {\n        for (let i = 0; i < length; i++) {\n            filterAndInteresct(pointers[i], object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    else if (typeof isAllowed === 'function') {\n        for (let i = 0; i < length; i++) {\n            const pointer = pointers[i];\n            if (!isAllowed(pointer)) {\n                continue;\n            }\n            filterAndInteresct(pointer, object, pointerEventsOrDefault, pointerEventsType, pointerEventsOrder);\n        }\n    }\n    if (object.children.length === 0 || object.intersectChildren === false) {\n        return;\n    }\n    const descendants = object.interactableDescendants ?? object.children;\n    const descendantsLength = descendants.length;\n    for (let i = 0; i < descendantsLength; i++) {\n        intersectPointerEventTargets(type, descendants[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);\n    }\n}\nfunction hasObjectListeners(type, object) {\n    if (object.ancestorsHaveListeners) {\n        return true;\n    }\n    if (type === 'pointer' && object.ancestorsHavePointerListeners) {\n        return true;\n    }\n    if (type === 'wheel' && object.ancestorsHaveWheelListeners) {\n        return true;\n    }\n    if (object.__r3f != null && object.__r3f?.eventCount > 0) {\n        if (type === 'wheel' && object.__r3f['handlers']['onWheel'] != null) {\n            return true;\n        }\n        if (type === 'pointer' && Object.keys(object.__r3f['handlers']).some((key) => key != 'onWheel')) {\n            return true;\n        }\n    }\n    if (object._listeners == null) {\n        return false;\n    }\n    if (type === 'wheel') {\n        const wheelListeners = object._listeners.wheel;\n        return wheelListeners != null && wheelListeners.length > 0;\n    }\n    const entries = Object.entries(object._listeners);\n    const length = entries.length;\n    for (let i = 0; i < length; i++) {\n        const entry = entries[i];\n        if (entry[0] === 'wheel') {\n            continue;\n        }\n        if (!listenerNames.includes(entry[0])) {\n            continue;\n        }\n        if (entry[1] != null && entry[1].length > 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction filterAndInteresct({ intersector, options }, object, pointerEvents, pointerEventsType, pointerEventsOrder) {\n    if (options.filter?.(object, pointerEvents, pointerEventsType, pointerEventsOrder) === false) {\n        return;\n    }\n    intersector.executeIntersection(object, pointerEventsOrder);\n}\n/**\n * @returns undefined if `i1` is the dominant intersection\n * @param i2DistanceOffset modifies i2 and adds the i2DistanceOffset to the current distance\n */\nexport function getDominantIntersectionIndex(intersections, pointerEventsOrders, { customSort: compare = defaultSort } = {}, filter) {\n    let intersection = undefined;\n    let pointerEventsOrder = undefined;\n    let index = undefined;\n    const length = intersections.length;\n    for (let i = 0; i < length; i++) {\n        const newIntersection = intersections[i];\n        if (filter?.(newIntersection) === false) {\n            continue;\n        }\n        const newPointerEventsOrder = pointerEventsOrders?.[i];\n        if (intersection == null || compare(newIntersection, newPointerEventsOrder, intersection, pointerEventsOrder) < 0) {\n            index = i;\n            intersection = newIntersection;\n            pointerEventsOrder = newPointerEventsOrder;\n        }\n    }\n    return index;\n}\n/**\n * @returns a negative number if i1 should be sorted before i2\n */\nfunction defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {\n    if (pointerEventsOrder1 != pointerEventsOrder2) {\n        //inverted order because order is sorted highest first\n        return pointerEventsOrder2 - pointerEventsOrder1;\n    }\n    //i1 - i2 because negative values mean the sorting i1 before i2 is correct\n    return i1.distance - i2.distance;\n}\nconst VoidObjectDistance = 10000000;\nexport function voidObjectIntersectionFromRay(scene, ray, getDetails, pointerPosition, pointerQuaternion, addToDistance = 0) {\n    const point = ray.direction.clone().multiplyScalar(VoidObjectDistance);\n    const distanceOnRay = VoidObjectDistance;\n    return {\n        distance: distanceOnRay + addToDistance,\n        object: getVoidObject(scene),\n        point,\n        normal: ray.origin.clone().sub(point).normalize(),\n        details: getDetails(point, distanceOnRay),\n        pointerPosition,\n        pointerQuaternion,\n        pointOnFace: point,\n        localPoint: point,\n    };\n}\nexport function pushTimes(target, value, times) {\n    while (times > 0) {\n        target.push(value);\n        --times;\n    }\n}\n", "import { Line3, Matrix4, Plane, Quaternion, Ray, Raycaster, Vector3, Mesh, Vector2, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, pushTimes, voidObjectIntersectionFromRay, } from './utils.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst invertedMatrixHelper = new Matrix4();\nconst lineHelper = new Line3();\nconst scaleHelper = new Vector3();\nconst planeHelper = new Plane();\nconst rayHelper = new Ray();\nconst point2Helper = new Vector2();\nconst defaultLinePoints = [new Vector3(0, 0, 0), new Vector3(0, 0, 1)];\nexport class LinesIntersector {\n    space;\n    options;\n    raycasters = [];\n    fromMatrixWorld = new Matrix4();\n    ready;\n    intersects = [];\n    pointerEventsOrders = [];\n    raycasterIndices = [];\n    constructor(space, options) {\n        this.space = space;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        this.fromMatrixWorld.copy(spaceObject.matrixWorld);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        const details = intersection.details;\n        if (details.type != 'lines') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a lines intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(this.fromMatrixWorld);\n        const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const pointOnFace = rayHelper.intersectPlane(planeHelper, new Vector3()) ?? point;\n        const pointerPosition = new Vector3();\n        const pointerQuaternion = new Quaternion();\n        this.fromMatrixWorld.decompose(pointerPosition, pointerQuaternion, scaleHelper);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            object,\n            uv,\n            pointOnFace,\n            point,\n            pointerPosition,\n            pointerQuaternion,\n        };\n    }\n    startIntersection() {\n        if (!this.prepareTransformation()) {\n            return;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        const length = linePoints.length - 1;\n        for (let i = 0; i < length; i++) {\n            const start = linePoints[i];\n            const end = linePoints[i + 1];\n            const raycaster = this.raycasters[i] ?? (this.raycasters[i] = new Raycaster());\n            //transform from local object to world\n            raycaster.ray.origin.copy(start).applyMatrix4(this.fromMatrixWorld);\n            raycaster.ray.direction.copy(end).applyMatrix4(this.fromMatrixWorld);\n            //compute length & normalized direction\n            raycaster.ray.direction.sub(raycaster.ray.origin);\n            const lineLength = raycaster.ray.direction.length();\n            raycaster.ray.direction.divideScalar(lineLength);\n            raycaster.far = lineLength;\n        }\n        this.raycasters.length = length;\n        return;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        if (!this.isReady()) {\n            return;\n        }\n        const startOuter = this.intersects.length;\n        const length = this.raycasters.length;\n        for (let i = 0; i < length; i++) {\n            const raycaster = this.raycasters[i];\n            const startInner = this.intersects.length;\n            object.raycast(raycaster, this.intersects);\n            pushTimes(this.raycasterIndices, i, this.intersects.length - startInner);\n        }\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - startOuter);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = new Vector3().setFromMatrixPosition(this.fromMatrixWorld);\n        const pointerQuaternion = new Quaternion().setFromRotationMatrix(this.fromMatrixWorld);\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        const raycasterIndex = index == null ? undefined : this.raycasterIndices[index];\n        this.intersects.length = 0;\n        this.raycasterIndices.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null || raycasterIndex == null) {\n            const lastRaycasterIndex = this.raycasters.length - 1;\n            const prevDistance = this.raycasters.reduce((prev, caster, i) => (i === lastRaycasterIndex ? prev : prev + caster.far), 0);\n            const lastRaycaster = this.raycasters[lastRaycasterIndex];\n            return voidObjectIntersectionFromRay(scene, lastRaycaster.ray, (point, distanceOnLine) => ({\n                line: new Line3(lastRaycaster.ray.origin.clone(), point),\n                lineIndex: this.raycasters.length - 1,\n                distanceOnLine,\n                type: 'lines',\n            }), pointerPosition, pointerQuaternion, prevDistance);\n        }\n        let distance = intersection.distance;\n        for (let i = 0; i < raycasterIndex; i++) {\n            distance += this.raycasters[i].far;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        //TODO: consider maxLength\n        const raycaster = this.raycasters[raycasterIndex];\n        return Object.assign(intersection, {\n            details: {\n                lineIndex: raycasterIndex,\n                distanceOnLine: intersection.distance,\n                type: 'lines',\n                line: new Line3(raycaster.ray.origin.clone(), raycaster.ray.direction.clone().multiplyScalar(raycaster.far).add(raycaster.ray.origin)),\n            },\n            distance,\n            pointerPosition,\n            pointerQuaternion,\n            pointOnFace: intersection.point,\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\n", "import { BufferAttribute, Matrix4, Triangle, Vector2, Vector3 } from 'three';\nexport function updateAndCheckWorldTransformation(object) {\n    if (object.transformReady === false) {\n        return false;\n    }\n    if (object.parent == null) {\n        object.matrixWorld.copy(object.matrix);\n        return true;\n    }\n    if (!updateAndCheckWorldTransformation(object.parent)) {\n        return false;\n    }\n    //we can just use parent.matrixWorld here because we already executed `updateAndCheckWorldTransformation` before which has updated parent.matrixWorld\n    object.matrixWorld.multiplyMatrices(object.parent.matrixWorld, object.matrix);\n    return true;\n}\nconst triangleHelper1 = new Triangle();\nconst triangleHelper2 = new Triangle();\nconst aVec2Helper = new Vector2();\nconst bVec2Helper = new Vector2();\nconst cVec2Helper = new Vector2();\nconst pointHelper = new Vector3();\nconst inverseMatrix = new Matrix4();\nconst localPointHelper = new Vector3();\n/**\n * @requires that `mesh.updateWorldMatrix(true, false)` was executed beforehand\n */\nexport function getClosestUV(target, point, mesh) {\n    localPointHelper.copy(point).applyMatrix4(inverseMatrix.copy(mesh.matrixWorld).invert());\n    const uv = mesh.geometry.attributes.uv;\n    if (uv == null || !(uv instanceof BufferAttribute)) {\n        return false;\n    }\n    let clostestDistance;\n    loopThroughTriangles(mesh, (i1, i2, i3) => {\n        mesh.getVertexPosition(i1, triangleHelper1.a);\n        mesh.getVertexPosition(i2, triangleHelper1.b);\n        mesh.getVertexPosition(i3, triangleHelper1.c);\n        const distance = triangleHelper1.closestPointToPoint(localPointHelper, pointHelper).distanceTo(localPointHelper);\n        if (clostestDistance != null && distance >= clostestDistance) {\n            return;\n        }\n        clostestDistance = distance;\n        triangleHelper2.copy(triangleHelper1);\n        aVec2Helper.fromBufferAttribute(uv, i1);\n        bVec2Helper.fromBufferAttribute(uv, i2);\n        cVec2Helper.fromBufferAttribute(uv, i3);\n    });\n    if (clostestDistance == null) {\n        return false;\n    }\n    triangleHelper2.closestPointToPoint(localPointHelper, pointHelper);\n    triangleHelper2.getInterpolation(pointHelper, aVec2Helper, bVec2Helper, cVec2Helper, target);\n    return true;\n}\nfunction loopThroughTriangles(mesh, fn) {\n    const drawRange = mesh.geometry.drawRange;\n    if (mesh.geometry.index != null) {\n        const index = mesh.geometry.index;\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start; i < end; i += 3) {\n            fn(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n        return;\n    }\n    const position = mesh.geometry.attributes.position;\n    if (position == null) {\n        return;\n    }\n    const start = Math.max(0, drawRange.start);\n    const end = Math.min(position.count, drawRange.start + drawRange.count);\n    for (let i = start; i < end; i += 3) {\n        fn(i, i + 1, i + 2);\n    }\n}\n", "import { Matrix4, Plane, Quaternion, Raycaster, Vector3, Vector2, Mesh, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex, pushTimes, voidObjectIntersectionFromRay, } from './utils.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst invertedMatrixHelper = new Matrix4();\nconst scaleHelper = new Vector3();\nconst NegZAxis = new Vector3(0, 0, -1);\nconst planeHelper = new Plane();\nconst point2Helper = new Vector2();\nexport class RayIntersector {\n    space;\n    options;\n    raycaster = new Raycaster();\n    raycasterQuaternion = new Quaternion();\n    worldScale = 0;\n    ready;\n    intersects = [];\n    pointerEventsOrders = [];\n    constructor(space, options) {\n        this.space = space;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        spaceObject.matrixWorld.decompose(this.raycaster.ray.origin, this.raycasterQuaternion, scaleHelper);\n        this.worldScale = scaleHelper.x;\n        this.raycaster.ray.direction.copy(this.options?.direction ?? NegZAxis).applyQuaternion(this.raycasterQuaternion);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        if (intersection.details.type != 'ray') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a ray intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const { ray } = this.raycaster;\n        const pointOnFace = ray.intersectPlane(planeHelper, new Vector3()) ?? intersection.point;\n        const point = ray.direction\n            .clone()\n            .multiplyScalar(intersection.pointerPosition.distanceTo(intersection.point))\n            .add(ray.origin);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            uv,\n            object,\n            pointOnFace,\n            point,\n            pointerPosition: ray.origin.clone(),\n            pointerQuaternion: this.raycasterQuaternion.clone(),\n        };\n    }\n    startIntersection() {\n        this.prepareTransformation();\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        if (!this.isReady()) {\n            return;\n        }\n        const start = this.intersects.length;\n        object.raycast(this.raycaster, this.intersects);\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.raycaster.ray.origin.clone();\n        const pointerQuaternion = this.raycasterQuaternion.clone();\n        let filter;\n        if (this.options.minDistance != null) {\n            const localMinDistance = this.options.minDistance / this.worldScale;\n            filter = (intersection) => intersection.distance >= localMinDistance;\n        }\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options, filter);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null) {\n            return voidObjectIntersectionFromRay(scene, this.raycaster.ray, () => ({ type: 'ray' }), pointerPosition, pointerQuaternion);\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        return Object.assign(intersection, {\n            details: {\n                type: 'ray',\n            },\n            pointerPosition,\n            pointerQuaternion,\n            pointOnFace: intersection.point,\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nconst directionHelper = new Vector3();\nexport class ScreenRayIntersector {\n    prepareTransformation;\n    options;\n    raycaster = new Raycaster();\n    cameraQuaternion = new Quaternion();\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    coords = new Vector2();\n    viewPlane = new Plane();\n    intersects = [];\n    pointerEventsOrders = [];\n    constructor(prepareTransformation, options) {\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    isReady() {\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        const details = intersection.details;\n        if (details.type != 'screen-ray') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a camera ray intersector`);\n        }\n        if (!this.startIntersection(nativeEvent)) {\n            return intersection;\n        }\n        this.viewPlane.constant -= details.distanceViewPlane;\n        //find captured intersection point by intersecting the ray to the plane of the camera\n        const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());\n        if (point == null) {\n            return intersection;\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(this.viewPlane, intersection, intersection.object.matrixWorld);\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            ...intersection,\n            details: {\n                ...details,\n                direction: this.raycaster.ray.direction.clone(),\n                screenPoint: this.coords.clone(),\n            },\n            uv,\n            object,\n            point,\n            pointOnFace: point,\n            pointerPosition: this.raycaster.ray.origin.clone(),\n            pointerQuaternion: this.cameraQuaternion.clone(),\n        };\n    }\n    startIntersection(nativeEvent) {\n        const from = this.prepareTransformation(nativeEvent, this.coords);\n        if (from == null) {\n            return false;\n        }\n        from.updateWorldMatrix(true, false);\n        from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);\n        this.raycaster.setFromCamera(this.coords, from);\n        this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        const start = this.intersects.length;\n        object.raycast(this.raycaster, this.intersects);\n        pushTimes(this.pointerEventsOrders, objectPointerEventsOrder, this.intersects.length - start);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.fromPosition.clone();\n        const pointerQuaternion = this.cameraQuaternion.clone();\n        const pointerDirection = this.raycaster.ray.direction.clone();\n        const index = getDominantIntersectionIndex(this.intersects, this.pointerEventsOrders, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        this.pointerEventsOrders.length = 0;\n        if (intersection == null) {\n            return voidObjectIntersectionFromRay(scene, this.raycaster.ray, (_point, distance) => ({\n                type: 'screen-ray',\n                distanceViewPlane: distance,\n                screenPoint: this.coords.clone(),\n                direction: pointerDirection,\n            }), pointerPosition, pointerQuaternion);\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        invertedMatrixHelper.copy(intersection.object.matrixWorld).invert();\n        return Object.assign(intersection, {\n            details: {\n                type: 'screen-ray',\n                distanceViewPlane: this.viewPlane.distanceToPoint(intersection.point),\n                screenPoint: this.coords.clone(),\n                direction: pointerDirection,\n            },\n            pointOnFace: intersection.point,\n            pointerPosition,\n            pointerQuaternion,\n            localPoint: intersection.point.clone().applyMatrix4(invertedMatrixHelper),\n        });\n    }\n}\n", "import { InstancedMesh, Matrix4, Mesh, Vector3, Sphere, Quaternion, Plane, Vector2, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';\nimport { getVoidObject } from '../index.js';\nimport { getClosestUV, updateAndCheckWorldTransformation } from '../utils.js';\nconst scaleHelper = new Vector3();\nconst point2Helper = new Vector2();\nexport class SphereIntersector {\n    space;\n    getSphereRadius;\n    options;\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    collisionSphere = new Sphere();\n    ready;\n    intersects = [];\n    constructor(space, getSphereRadius, options) {\n        this.space = space;\n        this.getSphereRadius = getSphereRadius;\n        this.options = options;\n    }\n    isReady() {\n        return this.ready ?? this.prepareTransformation();\n    }\n    prepareTransformation() {\n        const spaceObject = this.space.current;\n        if (spaceObject == null) {\n            return (this.ready = false);\n        }\n        this.ready = updateAndCheckWorldTransformation(spaceObject);\n        if (!this.ready) {\n            return false;\n        }\n        spaceObject.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);\n        return true;\n    }\n    intersectPointerCapture({ intersection, object }) {\n        if (intersection.details.type != 'sphere') {\n            throw new Error(`unable to process a pointer capture of type \"${intersection.details.type}\" with a sphere intersector`);\n        }\n        if (!this.prepareTransformation()) {\n            return intersection;\n        }\n        //compute old inputDevicePosition-point offset\n        oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);\n        //compute oldInputDeviceQuaternion-newInputDeviceQuaternion offset\n        inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(this.fromQuaternion);\n        //apply quaternion offset to old inputDevicePosition-point offset and add to new inputDevicePosition\n        const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(this.fromPosition);\n        intersection.object.updateWorldMatrix(true, false);\n        computeIntersectionWorldPlane(planeHelper, intersection, intersection.object.matrixWorld);\n        const pointOnFace = planeHelper.projectPoint(this.fromPosition, new Vector3());\n        let uv = intersection.uv;\n        if (intersection.object instanceof Mesh && getClosestUV(point2Helper, point, intersection.object)) {\n            uv = point2Helper.clone();\n        }\n        return {\n            details: {\n                type: 'sphere',\n            },\n            uv,\n            distance: point.distanceTo(pointOnFace),\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            object,\n            point,\n            pointOnFace,\n            face: intersection.face,\n            localPoint: intersection.localPoint,\n        };\n    }\n    startIntersection() {\n        if (!this.prepareTransformation()) {\n            return;\n        }\n        this.collisionSphere.center.copy(this.fromPosition);\n        this.collisionSphere.radius = this.getSphereRadius();\n    }\n    executeIntersection(object) {\n        if (!this.isReady()) {\n            return;\n        }\n        intersectSphereWithObject(this.collisionSphere, object, this.intersects);\n    }\n    finalizeIntersection(scene) {\n        const pointerPosition = this.fromPosition.clone();\n        const pointerQuaternion = this.fromQuaternion.clone();\n        const index = getDominantIntersectionIndex(this.intersects, undefined, this.options);\n        const intersection = index == null ? undefined : this.intersects[index];\n        this.intersects.length = 0;\n        if (intersection == null) {\n            return {\n                details: {\n                    type: 'sphere',\n                },\n                distance: 0,\n                point: pointerPosition,\n                object: getVoidObject(scene),\n                pointerPosition,\n                pointerQuaternion,\n                pointOnFace: pointerPosition,\n                localPoint: pointerPosition,\n            };\n        }\n        intersection.object.updateWorldMatrix(true, false);\n        return Object.assign(intersection, {\n            details: {\n                type: 'sphere',\n            },\n            pointOnFace: intersection.point,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            localPoint: intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nconst matrixHelper = new Matrix4();\nfunction intersectSphereWithObject(pointerSphere, object, target) {\n    object.updateWorldMatrix(true, false);\n    if (object.spherecast != null) {\n        object.spherecast(pointerSphere, target);\n        return;\n    }\n    if (object instanceof InstancedMesh) {\n        if (object.geometry.boundingSphere == null) {\n            object.geometry.computeBoundingSphere();\n        }\n        if (object.geometry.boundingBox == null) {\n            object.geometry.computeBoundingBox();\n        }\n        for (let i = 0; i < object.count; i++) {\n            object.getMatrixAt(i, matrixHelper);\n            matrixHelper.premultiply(object.matrixWorld);\n            if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper)) {\n                continue;\n            }\n            const intersection = intersectSphereMesh(pointerSphere, object, matrixHelper, i);\n            if (intersection == null) {\n                continue;\n            }\n            target.push(intersection);\n        }\n    }\n    if (!(object instanceof Mesh)) {\n        return;\n    }\n    if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {\n        return;\n    }\n    invertedMatrixHelper.copy(object.matrixWorld).invert();\n    const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);\n    if (intersection == null) {\n        return;\n    }\n    target.push(intersection);\n}\nconst oldInputDevicePointOffset = new Vector3();\nconst inputDeviceQuaternionOffset = new Quaternion();\nconst planeHelper = new Plane();\nconst helperSphere = new Sphere();\nfunction isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {\n    if (geometry.boundingSphere == null) {\n        geometry.computeBoundingSphere();\n    }\n    helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);\n    return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;\n}\nconst vectorHelper = new Vector3();\nconst boxSizeHelper = new Vector3();\nconst boxCenterHelper = new Vector3();\nconst vec0_0001 = new Vector3(0.0001, 0.0001, 0.0001);\nconst invertedMatrixHelper = new Matrix4();\nfunction intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {\n    invertedMatrixHelper.copy(meshMatrixWorld).invert();\n    helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper);\n    const { geometry } = mesh;\n    if (geometry.boundingBox == null) {\n        geometry.computeBoundingBox();\n    }\n    geometry.boundingBox.getSize(boxSizeHelper);\n    geometry.boundingBox.getCenter(boxCenterHelper);\n    geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper);\n    vectorHelper.applyMatrix4(meshMatrixWorld); //world coordinates\n    const distanceToSphereCenterSquared = vectorHelper.distanceToSquared(pointerSphere.center);\n    if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {\n        return undefined;\n    }\n    boxSizeHelper.max(vec0_0001);\n    const normal = helperSphere.center.clone().sub(boxCenterHelper);\n    normal.divide(boxSizeHelper);\n    maximizeAxisVector(normal);\n    const point = vectorHelper.clone();\n    let uv;\n    if (getClosestUV(point2Helper, point, mesh)) {\n        uv = point2Helper.clone();\n    }\n    return {\n        distance: Math.sqrt(distanceToSphereCenterSquared),\n        face: {\n            a: 0,\n            b: 0,\n            c: 0,\n            materialIndex: 0,\n            normal,\n        },\n        uv,\n        normal,\n        point,\n        instanceId,\n        object: mesh,\n    };\n}\nfunction maximizeAxisVector(vec) {\n    const absX = Math.abs(vec.x);\n    const absY = Math.abs(vec.y);\n    const absZ = Math.abs(vec.z);\n    if (absX >= absY && absX >= absZ) {\n        //x biggest\n        vec.set(vec.x < 0 ? -1 : 1, 0, 0);\n        return;\n    }\n    if (absY >= absX && absY >= absZ) {\n        //y biggest\n        vec.set(0, vec.y < 0 ? -1 : 1, 0);\n        return;\n    }\n    //z biggest\n    vec.set(0, 0, vec.z < 0 ? -1 : 1);\n}\n", "import { PointerEvent } from './event.js';\nimport { ScreenRayIntersector } from './intersections/ray.js';\nimport { generateUniquePointerId } from './pointer/index.js';\nimport { Pointer } from './pointer.js';\nfunction htmlEventToCoords(element, e, target) {\n    if (!(e instanceof globalThis.MouseEvent)) {\n        return target.set(0, 0);\n    }\n    const { width, height, top, left } = element.getBoundingClientRect();\n    const x = e.clientX - left;\n    const y = e.clientY - top;\n    return target.set((x / width) * 2 - 1, -(y / height) * 2 + 1);\n}\n/**\n * sets the `pointerTypePrefix` to `\"screen-\"`. Therefore, a event with pointerType `touch` is forwarded to the scene as `\"screen-touch\"`\n */\nexport function forwardHtmlEvents(fromElement, getCamera, scene, options) {\n    return forwardEvents(fromElement, \n    //backwards compatibility\n    typeof getCamera === 'function' ? getCamera : () => getCamera, scene, htmlEventToCoords.bind(null, fromElement), fromElement.setPointerCapture.bind(fromElement), (pointerId) => {\n        if (fromElement.hasPointerCapture(pointerId)) {\n            fromElement.releasePointerCapture(pointerId);\n        }\n    }, {\n        pointerTypePrefix: 'screen-',\n        ...options,\n    });\n}\nfunction portalEventToCoords(e, target) {\n    if (!(e instanceof PointerEvent)) {\n        return target.set(0, 0);\n    }\n    if (e.uv == null) {\n        return target.set(0, 0);\n    }\n    return target.copy(e.uv).multiplyScalar(2).addScalar(-1);\n}\nexport function forwardObjectEvents(fromPortal, getCamera, scene, options) {\n    return forwardEvents(fromPortal, getCamera, scene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);\n}\n/**\n * @returns cleanup function\n */\nfunction forwardEvents(from, getCamera, scene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {\n    const forwardPointerCapture = options?.forwardPointerCapture ?? true;\n    const pointerMap = new Map();\n    const pointerTypePrefix = options.pointerTypePrefix ?? 'forward-';\n    const getInnerPointer = (event, eventType) => {\n        let innerPointer = pointerMap.get(event.pointerId);\n        if (innerPointer != null) {\n            return innerPointer;\n        }\n        innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${event.pointerType}`, event.pointerState, new ScreenRayIntersector((nativeEvent, coords) => {\n            toCoords(nativeEvent, coords);\n            return getCamera();\n        }, options), getCamera, undefined, forwardPointerCapture ? setPointerCapture.bind(null, event.pointerId) : undefined, forwardPointerCapture ? releasePointerCapture.bind(null, event.pointerId) : undefined, options);\n        if (eventType != 'move' && eventType != 'wheel') {\n            //if we start with a non-move event no, we intersect and commit\n            //this allows enter, down, ... events to be forwarded to the scene even when they dont come with a move event\n            innerPointer.setIntersection(innerPointer.computeIntersection('pointer', scene, event));\n            innerPointer.commit(event, false);\n        }\n        pointerMap.set(event.pointerId, innerPointer);\n        return innerPointer;\n    };\n    const latestWheelEventMap = new Map();\n    const latestMoveEventMap = new Map();\n    const movedPointerList = [];\n    const eventList = [];\n    const emitEvent = (type, event, pointer) => {\n        switch (type) {\n            case 'move':\n                pointer.move(scene, event);\n                return;\n            case 'wheel':\n                pointer.wheel(scene, event);\n                return;\n            case 'cancel':\n                pointer.cancel(event);\n                return;\n            case 'down':\n                if (!hasButton(event)) {\n                    return;\n                }\n                pointer.down(event);\n                return;\n            case 'up':\n                if (!hasButton(event)) {\n                    return;\n                }\n                pointer.up(event);\n                return;\n            case 'exit':\n                latestMoveEventMap.delete(pointer);\n                latestWheelEventMap.delete(pointer);\n                pointer.exit(event);\n                return;\n        }\n    };\n    const onEvent = (type, event) => {\n        const pointer = getInnerPointer(event, type);\n        if (type === 'move') {\n            latestMoveEventMap.set(pointer, event);\n        }\n        if (type === 'wheel') {\n            latestWheelEventMap.set(pointer, event);\n        }\n        if (options.batchEvents ?? true) {\n            eventList.push({ type, event });\n        }\n        else {\n            emitEvent(type, event, pointer);\n        }\n    };\n    const pointerMoveListener = onEvent.bind(null, 'move');\n    const pointerCancelListener = onEvent.bind(null, 'cancel');\n    const pointerDownListener = onEvent.bind(null, 'down');\n    const pointerUpListener = onEvent.bind(null, 'up');\n    const wheelListener = onEvent.bind(null, 'wheel');\n    const pointerLeaveListener = onEvent.bind(null, 'exit');\n    from.addEventListener('pointermove', pointerMoveListener);\n    from.addEventListener('pointercancel', pointerCancelListener);\n    from.addEventListener('pointerdown', pointerDownListener);\n    from.addEventListener('pointerup', pointerUpListener);\n    from.addEventListener('wheel', wheelListener);\n    from.addEventListener('pointerleave', pointerLeaveListener);\n    return {\n        destroy() {\n            from.removeEventListener('pointermove', pointerMoveListener);\n            from.removeEventListener('pointercancel', pointerCancelListener);\n            from.removeEventListener('pointerdown', pointerDownListener);\n            from.removeEventListener('pointerup', pointerUpListener);\n            from.removeEventListener('wheel', wheelListener);\n            from.removeEventListener('pointerleave', pointerLeaveListener);\n            latestMoveEventMap.clear();\n            latestWheelEventMap.clear();\n        },\n        update() {\n            const length = eventList.length;\n            for (let i = 0; i < length; i++) {\n                const { type, event } = eventList[i];\n                const pointer = getInnerPointer(event, type);\n                if (type === 'move') {\n                    movedPointerList.push(pointer);\n                    if (latestMoveEventMap.get(pointer) != event) {\n                        //not the last move => move wihout recomputing the intersection\n                        pointer.emitMove(event);\n                        continue;\n                    }\n                }\n                if (type === 'wheel' && latestWheelEventMap.get(pointer) != event) {\n                    pointer.emitWheel(event);\n                    continue;\n                }\n                emitEvent(type, event, pointer);\n            }\n            eventList.length = 0;\n            if (options.intersectEveryFrame ?? false) {\n                for (const [pointer, event] of latestMoveEventMap.entries()) {\n                    if (movedPointerList.includes(pointer)) {\n                        continue;\n                    }\n                    pointer.move(scene, event);\n                }\n            }\n            movedPointerList.length = 0;\n        },\n    };\n}\nfunction hasButton(val) {\n    return val.button != null;\n}\n", "import { intersectPointerEventTargets } from './intersections/utils.js';\nexport class CombinedPointer {\n    enableMultiplePointers;\n    pointers = [];\n    isDefaults = [];\n    enabled = true;\n    activePointer;\n    nonCapturedPointers = [];\n    constructor(enableMultiplePointers) {\n        this.enableMultiplePointers = enableMultiplePointers;\n    }\n    register(pointer, isDefault = false) {\n        this.pointers.push(pointer);\n        this.isDefaults.push(isDefault);\n        return this.unregister.bind(this, pointer);\n    }\n    unregister(pointer) {\n        const index = this.pointers.indexOf(pointer);\n        if (index === -1) {\n            return;\n        }\n        this.isDefaults.splice(index, 1);\n        this.pointers.splice(index, 1);\n    }\n    /**\n     * @returns true if any pointer is captured\n     */\n    startIntersection(nonCapturedPointers, nativeEvent) {\n        const length = this.pointers.length;\n        let anyPointerIsCaptured = false;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.startIntersection(nonCapturedPointers, nativeEvent);\n                continue;\n            }\n            const pointerCapture = pointer.getPointerCapture();\n            if (pointerCapture != null) {\n                anyPointerIsCaptured = true;\n                pointer.setIntersection(pointer.intersector.intersectPointerCapture(pointerCapture, nativeEvent));\n                continue;\n            }\n            nonCapturedPointers.push(pointer);\n            pointer.intersector.startIntersection(nativeEvent);\n        }\n        return anyPointerIsCaptured;\n    }\n    /**\n     * only for internal use\n     */\n    getIntersection() {\n        return this.activePointer?.getIntersection();\n    }\n    /**\n     * only for internal use\n     */\n    getPointerCapture() {\n        return this.activePointer?.getPointerCapture();\n    }\n    computeActivePointer() {\n        let smallestDistance;\n        this.activePointer = undefined;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.computeActivePointer();\n            }\n            const intersection = pointer.getIntersection();\n            const distance = pointer.getPointerCapture() != null\n                ? -Infinity\n                : intersection?.object.isVoidObject\n                    ? Infinity\n                    : (intersection?.distance ?? Infinity);\n            const isDefault = this.isDefaults[i];\n            if (smallestDistance == null || (isDefault && distance === smallestDistance) || distance < smallestDistance) {\n                this.activePointer = pointer;\n                smallestDistance = distance;\n            }\n        }\n    }\n    /**\n     * only for internal use\n     */\n    commit(nativeEvent, emitMove, computeActivePointer = true) {\n        if (this.enableMultiplePointers) {\n            const length = this.pointers.length;\n            for (let i = 0; i < length; i++) {\n                this.pointers[i].commit(nativeEvent, emitMove);\n            }\n            return;\n        }\n        if (computeActivePointer) {\n            this.computeActivePointer();\n        }\n        //commit all pointers, enable the active pointer, and disable all other pointers\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(pointer === this.activePointer, nativeEvent, false);\n            pointer.commit(nativeEvent, emitMove, false);\n        }\n    }\n    move(scene, nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        //start intersection, build nonCapturedPointers list, and compute the intersection for all captured pointers\n        this.nonCapturedPointers.length = 0;\n        const anyPointerIsCaptured = this.startIntersection(this.nonCapturedPointers, nativeEvent);\n        //we only need to intersect the scene if no pointer is captured or (in case one or more pointers are captured) if mulitple pointers can be enabled\n        if (!anyPointerIsCaptured || this.enableMultiplePointers) {\n            //intersect scene using the non captured pointers\n            intersectPointerEventTargets('pointer', scene, this.nonCapturedPointers);\n            //finalize the intersection for the non captured pointers\n            const nonCapturedPointerLength = this.nonCapturedPointers.length;\n            for (let i = 0; i < nonCapturedPointerLength; i++) {\n                const pointer = this.nonCapturedPointers[i];\n                pointer.setIntersection(pointer.intersector.finalizeIntersection(scene));\n            }\n        }\n        //commit the intersection, compute active pointers, and enabling/disabling pointers\n        this.commit(nativeEvent, true);\n    }\n    setEnabled(enabled, nativeEvent) {\n        this.enabled = enabled;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(enabled && (this.enableMultiplePointers || pointer == this.activePointer), nativeEvent);\n        }\n    }\n}\n", "import { RayIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createRayPointer(getCamera, space, pointerState, options = {}, pointerType = 'ray') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new RayIntersector(space, options), getCamera, undefined, undefined, undefined, options);\n}\n", "import { LinesIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createLinesPointer(getCamera, space, pointerState, options = {}, pointerType = 'lines') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new LinesIntersector(space, options), getCamera, undefined, undefined, undefined, options);\n}\n", "import { SphereIntersector } from '../intersections/index.js';\nimport { Pointer } from '../pointer.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createTouchPointer(getCamera, space, pointerState, options = {}, pointerType = 'touch') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.hoverRadius ?? 0.1, options), getCamera, createUpdateTouchPointer(options), undefined, undefined, options);\n}\nfunction createUpdateTouchPointer(options) {\n    let wasPointerDown = false;\n    return (pointer) => {\n        if (!pointer.getEnabled()) {\n            return;\n        }\n        const intersection = pointer.getIntersection();\n        const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? 0.03);\n        if (isPointerDown === wasPointerDown) {\n            return;\n        }\n        const nativeEvent = { timeStamp: performance.now(), button: options.button ?? 0 };\n        if (isPointerDown) {\n            pointer.down(nativeEvent);\n        }\n        else {\n            pointer.up(nativeEvent);\n        }\n        wasPointerDown = isPointerDown;\n    };\n}\nfunction computeIsPointerDown(intersection, downRadius) {\n    if (intersection == null) {\n        return false;\n    }\n    return intersection.distance <= downRadius;\n}\n", "let pointerIdCounter = 23412;\nexport function generateUniquePointerId() {\n    return pointerIdCounter++;\n}\nexport * from './grab.js';\nexport * from './ray.js';\nexport * from './lines.js';\nexport * from './touch.js';\n", "import { generateUniquePointerId } from './index.js';\nimport { SphereIntersector } from '../intersections/sphere.js';\nimport { Pointer } from '../pointer.js';\nexport function createGrabPointer(getCamera, space, pointerState, options = {}, pointerType = 'grab') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector(space, () => options.radius ?? 0.07, options), getCamera, undefined, undefined, undefined, options);\n}\n"],
  "mappings": "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",
  "names": ["length", "Matrix4", "Ray", "Vector3", "Mesh", "Vector2", "Vector2", "Vector3", "start", "end", "Matrix4", "Vector3", "Ray", "Vector2", "Mesh", "Matrix4", "Plane", "Quaternion", "Raycaster", "Vector3", "Vector2", "Mesh", "invertedMatrixHelper", "Matrix4", "scaleHelper", "Vector3", "planeHelper", "Plane", "point2Helper", "Vector2", "Raycaster", "Quaternion", "Mesh", "intersection", "Matrix4", "Mesh", "Vector3", "Quaternion", "Plane", "Vector2", "length", "scaleHelper", "Vector3", "point2Helper", "Vector2", "Quaternion", "planeHelper", "Mesh", "invertedMatrixHelper", "Matrix4", "intersection", "Plane"]
}
