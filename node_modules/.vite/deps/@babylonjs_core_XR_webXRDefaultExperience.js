import {
  setAndStartTimer
} from "./chunk-A3ATWUDS.js";
import {
  ArcRotateCameraInputsManager
} from "./chunk-UP6IISC7.js";
import {
  EasingFunction,
  QuadraticEase,
  SineEase
} from "./chunk-ZZJ7VKXS.js";
import {
  FreeCamera,
  FreeCameraInputsManager,
  HemisphericLight,
  InstancedMesh,
  MaterialDefines,
  MaterialHelperGeometryRendering,
  PushMaterial,
  ShaderMaterial,
  StandardMaterial
} from "./chunk-CXPXQE5F.js";
import {
  CameraInputTypes,
  Material,
  Mesh,
  TargetCamera,
  _CreationDataStorage
} from "./chunk-7ZCEN2G2.js";
import {
  Animation
} from "./chunk-LCFLPBFK.js";
import {
  AbstractMesh,
  IntersectionInfo,
  SubMesh,
  TransformNode,
  VertexData
} from "./chunk-7Y22YVAV.js";
import {
  SceneLoader
} from "./chunk-IXJ5VHKF.js";
import {
  EffectFallbacks,
  Scene,
  UniqueIdGenerator,
  _ImportHelper
} from "./chunk-F6WBBMTV.js";
import "./chunk-OCEAH6DF.js";
import "./chunk-T2KPYHB2.js";
import "./chunk-GFXF2AHA.js";
import "./chunk-TOAF46MT.js";
import "./chunk-M53QMGBN.js";
import "./chunk-6W4IL5BZ.js";
import "./chunk-GJUHN7CQ.js";
import "./chunk-TXNJXLHN.js";
import "./chunk-UQXX2ELX.js";
import "./chunk-HCQBYAVY.js";
import "./chunk-TTTM2ZA3.js";
import "./chunk-CPLABIWJ.js";
import {
  BindLogDepth,
  Camera,
  PrepareDefinesForCamera,
  PrepareDefinesForPrePass,
  SceneComponentConstants
} from "./chunk-ELOAAAB7.js";
import {
  PointerEventTypes,
  PointerInfo
} from "./chunk-MVDNDG2U.js";
import "./chunk-WAGTS43G.js";
import {
  PostProcess,
  RenderTargetTexture
} from "./chunk-223YIK35.js";
import {
  Texture
} from "./chunk-P73WYAUZ.js";
import "./chunk-WIS6O5TF.js";
import "./chunk-4U4OQIRL.js";
import {
  BoundingSphere,
  PickingInfo
} from "./chunk-WV5WMLKG.js";
import "./chunk-LMHNSSMV.js";
import {
  Node
} from "./chunk-ULVTKDIK.js";
import "./chunk-SZB5QSYK.js";
import {
  useOpenGLOrientationForUV
} from "./chunk-HH35OB2V.js";
import {
  Tools
} from "./chunk-SQLRS6BV.js";
import {
  DrawWrapper,
  VertexBuffer
} from "./chunk-3ZXVYKCB.js";
import "./chunk-4OJANHPM.js";
import "./chunk-MMDFH52S.js";
import "./chunk-S3STKA5Z.js";
import {
  ThinEngine,
  WebGLHardwareTexture,
  WebGLShaderProcessor
} from "./chunk-HLDBRION.js";
import "./chunk-2EVLQBBY.js";
import {
  Curve3
} from "./chunk-AAYY4GXB.js";
import {
  Axis
} from "./chunk-VR3O2TRF.js";
import "./chunk-2BVSSZO5.js";
import {
  SerializationHelper
} from "./chunk-RHOADBW3.js";
import {
  __decorate,
  serialize
} from "./chunk-ZRPHACZ5.js";
import {
  Color3,
  Color4,
  TmpColors
} from "./chunk-TROWLGN2.js";
import "./chunk-NOD22NBO.js";
import {
  Viewport
} from "./chunk-5LTYGTJL.js";
import "./chunk-T7C6CI7L.js";
import {
  WebRequest
} from "./chunk-2ZEUD233.js";
import "./chunk-7XY2OFQB.js";
import "./chunk-I2PO3XEU.js";
import {
  GetExponentOfTwo
} from "./chunk-I4NFOKIT.js";
import {
  AbstractEngine,
  Effect,
  InternalTexture,
  Process,
  TimingTools
} from "./chunk-FCN7ZBEY.js";
import "./chunk-OWCZTH5B.js";
import {
  IsWindowObjectExist,
  PrecisionDate
} from "./chunk-CZRRPEW3.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";
import {
  BuildArray,
  Epsilon,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-SAE7R3H2.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-MIVJKRRS.js";
import "./chunk-NTQN2BXV.js";
import {
  EngineStore
} from "./chunk-DDXCXL26.js";
import {
  Observable
} from "./chunk-GCT36VBF.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@babylonjs/core/XR/webXRLayerWrapper.js
var WebXRLayerWrapper = class {
  /**
   * Check if fixed foveation is supported on this device
   */
  get isFixedFoveationSupported() {
    return this.layerType == "XRWebGLLayer" && typeof this.layer.fixedFoveation == "number";
  }
  /**
   * Get the fixed foveation currently set, as specified by the webxr specs
   * If this returns null, then fixed foveation is not supported
   */
  get fixedFoveation() {
    if (this.isFixedFoveationSupported) {
      return this.layer.fixedFoveation;
    }
    return null;
  }
  /**
   * Set the fixed foveation to the specified value, as specified by the webxr specs
   * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation
   */
  set fixedFoveation(value) {
    if (this.isFixedFoveationSupported) {
      const val = Math.max(0, Math.min(1, value || 0));
      this.layer.fixedFoveation = val;
    }
  }
  /**
   * Create a render target provider for the wrapped layer.
   * @param xrSessionManager The XR Session Manager
   * @returns A new render target texture provider for the wrapped layer.
   */
  createRenderTargetTextureProvider(xrSessionManager) {
    this._rttWrapper = this._createRenderTargetTextureProvider(xrSessionManager);
    return this._rttWrapper;
  }
  dispose() {
    if (this._rttWrapper) {
      this._rttWrapper.dispose();
      this._rttWrapper = null;
    }
  }
  constructor(getWidth, getHeight, layer, layerType, _createRenderTargetTextureProvider) {
    this.getWidth = getWidth;
    this.getHeight = getHeight;
    this.layer = layer;
    this.layerType = layerType;
    this._createRenderTargetTextureProvider = _createRenderTargetTextureProvider;
    this._rttWrapper = null;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/MultiviewRenderTarget.js
var MultiviewRenderTarget = class extends RenderTargetTexture {
  set samples(value) {
    this._samples = value;
  }
  get samples() {
    return this._samples;
  }
  /**
   * Creates a multiview render target
   * @param scene scene used with the render target
   * @param size the size of the render target (used for each view)
   */
  constructor(scene, size = 512) {
    super("multiview rtt", size, scene, false, true, 0, false, void 0, false, false, true, void 0, true);
    this._renderTarget = this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());
    this._texture = this._renderTarget.texture;
    this._texture.isMultiview = true;
    this._texture.format = 5;
    this.samples = this._getEngine().getCaps().maxSamples || this.samples;
    this._texture.samples = this._samples;
  }
  /**
   * @internal
   */
  _bindFrameBuffer() {
    if (!this._renderTarget) {
      return;
    }
    this.getScene().getEngine().bindMultiviewFramebuffer(this._renderTarget);
  }
  /**
   * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
   * @returns the view count
   */
  getViewCount() {
    return 2;
  }
};

// node_modules/@babylonjs/core/XR/webXRRenderTargetTextureProvider.js
var WebXRLayerRenderTargetTextureProvider = class {
  constructor(_scene, layerWrapper) {
    this._scene = _scene;
    this.layerWrapper = layerWrapper;
    this._renderTargetTextures = new Array();
    this._engine = _scene.getEngine();
  }
  _createInternalTexture(textureSize, texture) {
    const internalTexture = new InternalTexture(this._engine, 0, true);
    internalTexture.width = textureSize.width;
    internalTexture.height = textureSize.height;
    internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);
    internalTexture.isReady = true;
    return internalTexture;
  }
  _createRenderTargetTexture(width, height, framebuffer, colorTexture, depthStencilTexture, multiview) {
    if (!this._engine) {
      throw new Error("Engine is disposed");
    }
    const textureSize = { width, height };
    const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture("XR renderTargetTexture", textureSize, this._scene);
    const renderTargetWrapper = renderTargetTexture.renderTarget;
    renderTargetWrapper._samples = renderTargetTexture.samples;
    if (framebuffer || !colorTexture) {
      renderTargetWrapper._framebuffer = framebuffer;
    }
    if (colorTexture) {
      if (multiview) {
        renderTargetWrapper._colorTextureArray = colorTexture;
      } else {
        const internalTexture = this._createInternalTexture(textureSize, colorTexture);
        renderTargetWrapper.setTexture(internalTexture, 0);
        renderTargetTexture._texture = internalTexture;
      }
    }
    if (depthStencilTexture) {
      if (multiview) {
        renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;
      } else {
        renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);
      }
    }
    renderTargetTexture.disableRescaling();
    this._renderTargetTextures.push(renderTargetTexture);
    return renderTargetTexture;
  }
  _destroyRenderTargetTexture(renderTargetTexture) {
    this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);
    renderTargetTexture.dispose();
  }
  getFramebufferDimensions() {
    return this._framebufferDimensions;
  }
  dispose() {
    for (const rtt of this._renderTargetTextures) {
      rtt.dispose();
    }
    this._renderTargetTextures.length = 0;
  }
};

// node_modules/@babylonjs/core/XR/webXRWebGLLayer.js
var WebXRWebGLLayerWrapper = class extends WebXRLayerWrapper {
  /**
   * @param layer is the layer to be wrapped.
   * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.
   */
  constructor(layer) {
    super(() => layer.framebufferWidth, () => layer.framebufferHeight, layer, "XRWebGLLayer", (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this));
    this.layer = layer;
  }
};
var WebXRWebGLLayerRenderTargetTextureProvider = class extends WebXRLayerRenderTargetTextureProvider {
  constructor(scene, layerWrapper) {
    super(scene, layerWrapper);
    this.layerWrapper = layerWrapper;
    this._layer = layerWrapper.layer;
    this._framebufferDimensions = {
      framebufferWidth: this._layer.framebufferWidth,
      framebufferHeight: this._layer.framebufferHeight
    };
  }
  trySetViewportForView(viewport, view) {
    const xrViewport = this._layer.getViewport(view);
    if (!xrViewport) {
      return false;
    }
    const framebufferWidth = this._framebufferDimensions.framebufferWidth;
    const framebufferHeight = this._framebufferDimensions.framebufferHeight;
    viewport.x = xrViewport.x / framebufferWidth;
    viewport.y = xrViewport.y / framebufferHeight;
    viewport.width = xrViewport.width / framebufferWidth;
    viewport.height = xrViewport.height / framebufferHeight;
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getRenderTargetTextureForEye(eye) {
    const layerWidth = this._layer.framebufferWidth;
    const layerHeight = this._layer.framebufferHeight;
    const framebuffer = this._layer.framebuffer;
    if (!this._rtt || layerWidth !== this._framebufferDimensions.framebufferWidth || layerHeight !== this._framebufferDimensions.framebufferHeight || framebuffer !== this._framebuffer) {
      this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);
      this._framebufferDimensions.framebufferWidth = layerWidth;
      this._framebufferDimensions.framebufferHeight = layerHeight;
      this._framebuffer = framebuffer;
    }
    return this._rtt;
  }
  getRenderTargetTextureForView(view) {
    return this.getRenderTargetTextureForEye(view.eye);
  }
};

// node_modules/@babylonjs/core/XR/webXRManagedOutputCanvas.js
var WebXRManagedOutputCanvasOptions = class _WebXRManagedOutputCanvasOptions {
  /**
   * Get the default values of the configuration object
   * @param engine defines the engine to use (can be null)
   * @returns default values of this configuration object
   */
  static GetDefaults(engine) {
    const defaults = new _WebXRManagedOutputCanvasOptions();
    defaults.canvasOptions = {
      antialias: true,
      depth: true,
      stencil: engine ? engine.isStencilEnable : true,
      alpha: true,
      framebufferScaleFactor: 1
    };
    defaults.newCanvasCssStyle = "position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;";
    return defaults;
  }
};
var WebXRManagedOutputCanvas = class {
  /**
   * Initializes the canvas to be added/removed upon entering/exiting xr
   * @param _xrSessionManager The XR Session manager
   * @param _options optional configuration for this canvas output. defaults will be used if not provided
   */
  constructor(_xrSessionManager, _options = WebXRManagedOutputCanvasOptions.GetDefaults()) {
    this._options = _options;
    this._canvas = null;
    this._engine = null;
    this.xrLayer = null;
    this._xrLayerWrapper = null;
    this.onXRLayerInitObservable = new Observable();
    this._engine = _xrSessionManager.scene.getEngine();
    this._engine.onDisposeObservable.addOnce(() => {
      this._engine = null;
    });
    if (!_options.canvasElement) {
      const canvas = document.createElement("canvas");
      canvas.style.cssText = this._options.newCanvasCssStyle || "position:absolute; bottom:0px;right:0px;";
      this._setManagedOutputCanvas(canvas);
    } else {
      this._setManagedOutputCanvas(_options.canvasElement);
    }
    _xrSessionManager.onXRSessionInit.add(() => {
      this._addCanvas();
    });
    _xrSessionManager.onXRSessionEnded.add(() => {
      this._removeCanvas();
    });
    this._makeCanvasCompatible();
  }
  /**
   * Disposes of the object
   */
  dispose() {
    this._removeCanvas();
    this._setManagedOutputCanvas(null);
    this.onXRLayerInitObservable.clear();
  }
  _makeCanvasCompatible() {
    this._canvasCompatiblePromise = new Promise((resolve, reject) => {
      try {
        if (this.canvasContext && this.canvasContext.makeXRCompatible) {
          this.canvasContext.makeXRCompatible().then(() => {
            resolve();
          }, () => {
            Tools.Warn("Error executing makeXRCompatible. This does not mean that the session will work incorrectly.");
            resolve();
          });
        } else {
          resolve();
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * Initializes a XRWebGLLayer to be used as the session's baseLayer.
   * @param xrSession xr session
   * @returns a promise that will resolve once the XR Layer has been created
   */
  async initializeXRLayerAsync(xrSession) {
    const createLayer = () => {
      this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);
      this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);
      this.onXRLayerInitObservable.notifyObservers(this.xrLayer);
      return this.xrLayer;
    };
    return await this._canvasCompatiblePromise.then(
      // catch any error and continue. When using the emulator is throws this error for no apparent reason.
      () => {
      },
      () => {
      }
    ).then(() => {
      return createLayer();
    });
  }
  _addCanvas() {
    if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.appendChild(this._canvas);
    }
    if (this.xrLayer) {
      this._setCanvasSize(true);
    } else {
      this.onXRLayerInitObservable.addOnce(() => {
        this._setCanvasSize(true);
      });
    }
  }
  _removeCanvas() {
    if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {
      document.body.removeChild(this._canvas);
    }
    this._setCanvasSize(false);
  }
  _setCanvasSize(init = true, xrLayer = this._xrLayerWrapper) {
    if (!this._canvas || !this._engine) {
      return;
    }
    if (init) {
      if (xrLayer) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = xrLayer.getWidth() + "px";
          this._canvas.style.height = xrLayer.getHeight() + "px";
        } else {
          this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());
        }
      }
    } else {
      if (this._originalCanvasSize) {
        if (this._canvas !== this._engine.getRenderingCanvas()) {
          this._canvas.style.width = this._originalCanvasSize.width + "px";
          this._canvas.style.height = this._originalCanvasSize.height + "px";
        } else {
          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);
        }
      }
    }
  }
  _setManagedOutputCanvas(canvas) {
    this._removeCanvas();
    if (!canvas) {
      this._canvas = null;
      this.canvasContext = null;
    } else {
      this._originalCanvasSize = {
        width: canvas.offsetWidth,
        height: canvas.offsetHeight
      };
      this._canvas = canvas;
      this.canvasContext = this._canvas.getContext("webgl2");
      if (!this.canvasContext) {
        this.canvasContext = this._canvas.getContext("webgl");
      }
    }
  }
};

// node_modules/@babylonjs/core/XR/native/nativeXRRenderTarget.js
var NativeXRLayerWrapper = class extends WebXRLayerWrapper {
  constructor(layer) {
    super(() => layer.framebufferWidth, () => layer.framebufferHeight, layer, "XRWebGLLayer", (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this));
    this.layer = layer;
  }
};
var NativeXRLayerRenderTargetTextureProvider = class extends WebXRLayerRenderTargetTextureProvider {
  constructor(sessionManager, layerWrapper) {
    super(sessionManager.scene, layerWrapper);
    this.layerWrapper = layerWrapper;
    this._nativeRTTProvider = navigator.xr.getNativeRenderTargetProvider(sessionManager.session, this._createRenderTargetTexture.bind(this), this._destroyRenderTargetTexture.bind(this));
    this._nativeLayer = layerWrapper.layer;
  }
  trySetViewportForView(viewport) {
    viewport.x = 0;
    viewport.y = 0;
    viewport.width = 1;
    viewport.height = 1;
    return true;
  }
  getRenderTargetTextureForEye(eye) {
    return this._nativeRTTProvider.getRenderTargetForEye(eye);
  }
  getRenderTargetTextureForView(view) {
    return this._nativeRTTProvider.getRenderTargetForEye(view.eye);
  }
  getFramebufferDimensions() {
    return {
      framebufferWidth: this._nativeLayer.framebufferWidth,
      framebufferHeight: this._nativeLayer.framebufferHeight
    };
  }
};
var NativeXRRenderTarget = class {
  constructor(_xrSessionManager) {
    this._nativeRenderTarget = navigator.xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());
  }
  async initializeXRLayerAsync(xrSession) {
    await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);
    this.xrLayer = this._nativeRenderTarget.xrLayer;
    return this.xrLayer;
  }
  dispose() {
  }
};

// node_modules/@babylonjs/core/XR/webXRSessionManager.js
var WebXRSessionManager = class _WebXRSessionManager {
  /**
   * Scale factor to apply to all XR-related elements (camera, controllers)
   */
  get worldScalingFactor() {
    return this._worldScalingFactor;
  }
  set worldScalingFactor(value) {
    const oldValue = this._worldScalingFactor;
    this._worldScalingFactor = value;
    this.onWorldScaleFactorChangedObservable.notifyObservers({
      previousScaleFactor: oldValue,
      newScaleFactor: value
    });
  }
  /**
   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage
   * @param scene The scene which the session should be created for
   */
  constructor(scene) {
    this.scene = scene;
    this.currentTimestamp = -1;
    this.defaultHeightCompensation = 1.7;
    this.onXRFrameObservable = new Observable();
    this.onXRReferenceSpaceChanged = new Observable();
    this.onXRSessionEnded = new Observable();
    this.onXRSessionInit = new Observable();
    this.onXRReferenceSpaceInitialized = new Observable();
    this.onXRReady = new Observable();
    this.inXRFrameLoop = false;
    this.inXRSession = false;
    this._worldScalingFactor = 1;
    this.onWorldScaleFactorChangedObservable = new Observable(void 0, true);
    this._engine = scene.getEngine();
    this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {
      this._engine = null;
    });
    scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
  }
  /**
   * The current reference space used in this session. This reference space can constantly change!
   * It is mainly used to offset the camera's position.
   */
  get referenceSpace() {
    return this._referenceSpace;
  }
  /**
   * Set a new reference space and triggers the observable
   */
  set referenceSpace(newReferenceSpace) {
    this._referenceSpace = newReferenceSpace;
    this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);
  }
  /**
   * The mode for the managed XR session
   */
  get sessionMode() {
    return this._sessionMode;
  }
  /**
   * Disposes of the session manager
   * This should be called explicitly by the dev, if required.
   */
  dispose() {
    if (this.inXRSession) {
      this.exitXRAsync();
    }
    this.onXRReady.clear();
    this.onXRFrameObservable.clear();
    this.onXRSessionEnded.clear();
    this.onXRReferenceSpaceChanged.clear();
    this.onXRSessionInit.clear();
    this.onWorldScaleFactorChangedObservable.clear();
    this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);
    this._engine = null;
  }
  /**
   * Stops the xrSession and restores the render loop
   * @returns Promise which resolves after it exits XR
   */
  async exitXRAsync() {
    if (this.session && this.inXRSession) {
      this.inXRSession = false;
      try {
        return await this.session.end();
      } catch {
        Logger.Warn("Could not end XR session.");
      }
    }
  }
  /**
   * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.
   * In the event of a failure, the supplied viewport is not updated.
   * @param viewport the viewport to which the view will be rendered
   * @param view the view for which to set the viewport
   * @returns whether the operation was successful
   */
  trySetViewportForView(viewport, view) {
    return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;
  }
  /**
   * Gets the correct render target texture to be rendered this frame for this eye
   * @param eye the eye for which to get the render target
   * @returns the render target for the specified eye or null if not available
   */
  getRenderTargetTextureForEye(eye) {
    return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;
  }
  /**
   * Gets the correct render target texture to be rendered this frame for this view
   * @param view the view for which to get the render target
   * @returns the render target for the specified view or null if not available
   */
  getRenderTargetTextureForView(view) {
    return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;
  }
  /**
   * Creates a WebXRRenderTarget object for the XR session
   * @param options optional options to provide when creating a new render target
   * @returns a WebXR render target to which the session can render
   */
  getWebXRRenderTarget(options) {
    const engine = this.scene.getEngine();
    if (this._xrNavigator.xr.native) {
      return new NativeXRRenderTarget(this);
    } else {
      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);
      options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || void 0;
      return new WebXRManagedOutputCanvas(this, options);
    }
  }
  /**
   * Initializes the manager
   * After initialization enterXR can be called to start an XR session
   * @returns Promise which resolves after it is initialized
   */
  async initializeAsync() {
    this._xrNavigator = navigator;
    if (!this._xrNavigator.xr) {
      throw new Error("WebXR not supported on this browser.");
    }
  }
  /**
   * Initializes an xr session
   * @param xrSessionMode mode to initialize
   * @param xrSessionInit defines optional and required values to pass to the session builder
   * @returns a promise which will resolve once the session has been initialized
   */
  async initializeSessionAsync(xrSessionMode = "immersive-vr", xrSessionInit = {}) {
    const session = await this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit);
    this.session = session;
    this._sessionMode = xrSessionMode;
    this.inXRSession = true;
    this.onXRSessionInit.notifyObservers(session);
    this.session.addEventListener("end", () => {
      this.inXRSession = false;
      this.onXRSessionEnded.notifyObservers(null);
      if (this._engine) {
        this._engine.framebufferDimensionsObject = null;
        this._engine.restoreDefaultFramebuffer();
        this._engine.customAnimationFrameRequester = null;
        this._engine._renderLoop();
      }
      if (this.isNative) {
        this._baseLayerRTTProvider?.dispose();
      }
      this._baseLayerRTTProvider = null;
      this._baseLayerWrapper = null;
    }, { once: true });
    return this.session;
  }
  /**
   * Checks if a session would be supported for the creation options specified
   * @param sessionMode session mode to check if supported eg. immersive-vr
   * @returns A Promise that resolves to true if supported and false if not
   */
  async isSessionSupportedAsync(sessionMode) {
    return await _WebXRSessionManager.IsSessionSupportedAsync(sessionMode);
  }
  /**
   * Resets the reference space to the one started the session
   */
  resetReferenceSpace() {
    this.referenceSpace = this.baseReferenceSpace;
  }
  /**
   * Starts rendering to the xr layer
   */
  runXRRenderLoop() {
    if (!this.inXRSession || !this._engine) {
      return;
    }
    this._engine.customAnimationFrameRequester = {
      requestAnimationFrame: (callback) => this.session.requestAnimationFrame(callback),
      renderFunction: (timestamp, xrFrame) => {
        if (!this.inXRSession || !this._engine) {
          return;
        }
        this.currentFrame = xrFrame;
        this.currentTimestamp = timestamp;
        if (xrFrame) {
          this.inXRFrameLoop = true;
          const framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;
          if (this._engine.framebufferDimensionsObject !== framebufferDimensionsObject) {
            this._engine.framebufferDimensionsObject = framebufferDimensionsObject;
          }
          this.onXRFrameObservable.notifyObservers(xrFrame);
          this._engine._renderLoop();
          this._engine.framebufferDimensionsObject = null;
          this.inXRFrameLoop = false;
        }
      }
    };
    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;
    this.onXRFrameObservable.addOnce(() => {
      this.onXRReady.notifyObservers(this);
    });
    if (typeof window !== "undefined" && window.cancelAnimationFrame) {
      window.cancelAnimationFrame(this._engine._frameHandler);
    }
    this._engine._renderLoop();
  }
  /**
   * Sets the reference space on the xr session
   * @param referenceSpaceType space to set
   * @returns a promise that will resolve once the reference space has been set
   */
  async setReferenceSpaceTypeAsync(referenceSpaceType = "local-floor") {
    let referenceSpace;
    try {
      referenceSpace = await this.session.requestReferenceSpace(referenceSpaceType);
    } catch (rejectionReason) {
      Logger.Error("XR.requestReferenceSpace failed for the following reason: ");
      Logger.Error(rejectionReason);
      Logger.Log('Defaulting to universally-supported "viewer" reference space type.');
      try {
        const referenceSpace2 = await this.session.requestReferenceSpace("viewer");
        const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });
        return referenceSpace2.getOffsetReferenceSpace(heightCompensation);
      } catch (rejectionReason2) {
        Logger.Error(rejectionReason2);
        throw 'XR initialization failed: required "viewer" reference space type not supported.';
      }
    }
    const viewerReferenceSpace = await this.session.requestReferenceSpace("viewer");
    this.viewerReferenceSpace = viewerReferenceSpace;
    this.referenceSpace = this.baseReferenceSpace = referenceSpace;
    this.onXRReferenceSpaceInitialized.notifyObservers(referenceSpace);
    return this.referenceSpace;
  }
  /**
   * Updates the render state of the session.
   * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().
   * @param state state to set
   * @returns a promise that resolves once the render state has been updated
   * @deprecated Use updateRenderState() instead.
   */
  async updateRenderStateAsync(state) {
    return await this.session.updateRenderState(state);
  }
  /**
   * @internal
   */
  _setBaseLayerWrapper(baseLayerWrapper) {
    if (this.isNative) {
      this._baseLayerRTTProvider?.dispose();
    }
    this._baseLayerWrapper = baseLayerWrapper;
    this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;
  }
  /**
   * @internal
   */
  _getBaseLayerWrapper() {
    return this._baseLayerWrapper;
  }
  /**
   * Updates the render state of the session
   * @param state state to set
   */
  updateRenderState(state) {
    if (state.baseLayer) {
      this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));
    }
    this.session.updateRenderState(state);
  }
  /**
   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser
   * @param sessionMode defines the session to test
   * @returns a promise with boolean as final value
   */
  static async IsSessionSupportedAsync(sessionMode) {
    if (!navigator.xr) {
      return false;
    }
    const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
    if (!functionToUse) {
      return false;
    } else {
      try {
        const result = functionToUse.call(navigator.xr, sessionMode);
        const returnValue = typeof result === "undefined" ? true : result;
        return returnValue;
      } catch (e) {
        Logger.Warn(e);
        return false;
      }
    }
  }
  /**
   * Returns true if Babylon.js is using the BabylonNative backend, otherwise false
   */
  get isNative() {
    return this._xrNavigator.xr.native ?? false;
  }
  /**
   * The current frame rate as reported by the device
   */
  get currentFrameRate() {
    return this.session?.frameRate;
  }
  /**
   * A list of supported frame rates (only available in-session!
   */
  get supportedFrameRates() {
    return this.session?.supportedFrameRates;
  }
  /**
   * Set the framerate of the session.
   * @param rate the new framerate. This value needs to be in the supportedFrameRates array
   * @returns a promise that resolves once the framerate has been set
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  async updateTargetFrameRate(rate) {
    return await this.session.updateTargetFrameRate(rate);
  }
  /**
   * Run a callback in the xr render loop
   * @param callback the callback to call when in XR Frame
   * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session
   */
  runInXRFrame(callback, ignoreIfNotInSession = true) {
    if (this.inXRFrameLoop) {
      callback();
    } else if (this.inXRSession || !ignoreIfNotInSession) {
      this.onXRFrameObservable.addOnce(callback);
    }
  }
  /**
   * Check if fixed foveation is supported on this device
   */
  get isFixedFoveationSupported() {
    return this._baseLayerWrapper?.isFixedFoveationSupported || false;
  }
  /**
   * Get the fixed foveation currently set, as specified by the webxr specs
   * If this returns null, then fixed foveation is not supported
   */
  get fixedFoveation() {
    return this._baseLayerWrapper?.fixedFoveation || null;
  }
  /**
   * Set the fixed foveation to the specified value, as specified by the webxr specs
   * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation
   */
  set fixedFoveation(value) {
    const val = Math.max(0, Math.min(1, value || 0));
    if (this._baseLayerWrapper) {
      this._baseLayerWrapper.fixedFoveation = val;
    }
  }
  /**
   * Get the features enabled on the current session
   * This is only available in-session!
   * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures
   */
  get enabledFeatures() {
    return this.session?.enabledFeatures ?? null;
  }
};

// node_modules/@babylonjs/core/XR/webXRCamera.js
var WebXRCamera = class _WebXRCamera extends FreeCamera {
  /**
   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
   * @param name the name of the camera
   * @param scene the scene to add the camera to
   * @param _xrSessionManager a constructed xr session manager
   */
  constructor(name, scene, _xrSessionManager) {
    super(name, Vector3.Zero(), scene);
    this._xrSessionManager = _xrSessionManager;
    this._firstFrame = false;
    this._referenceQuaternion = Quaternion.Identity();
    this._referencedPosition = new Vector3();
    this._trackingState = 0;
    this.onXRCameraInitializedObservable = new Observable();
    this.onBeforeCameraTeleport = new Observable();
    this.onAfterCameraTeleport = new Observable();
    this.onTrackingStateChanged = new Observable();
    this.compensateOnFirstFrame = true;
    this.minZ = 0.1;
    this.rotationQuaternion = new Quaternion();
    this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
    this.updateUpVectorFromRotation = true;
    this._updateNumberOfRigCameras(1);
    this.freezeProjectionMatrix();
    this._deferOnly = true;
    this._xrSessionManager.onXRSessionInit.add(() => {
      this._referencedPosition.copyFromFloats(0, 0, 0);
      this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      this._firstFrame = this.compensateOnFirstFrame;
      this._xrSessionManager.onWorldScaleFactorChangedObservable.add(() => {
        if (!this._xrSessionManager.currentFrame) {
          return;
        }
        this._updateDepthNearFar();
      });
    });
    this._xrSessionManager.onXRFrameObservable.add(() => {
      if (this._firstFrame) {
        this._updateFromXRSession();
      }
      if (this.onXRCameraInitializedObservable.hasObservers()) {
        this.onXRCameraInitializedObservable.notifyObservers(this);
        this.onXRCameraInitializedObservable.clear();
      }
      if (this._deferredUpdated) {
        this.position.copyFrom(this._deferredPositionUpdate);
        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
      }
      this._updateReferenceSpace();
      this._updateFromXRSession();
    }, void 0, true);
  }
  /**
   * Get the current XR tracking state of the camera
   */
  get trackingState() {
    return this._trackingState;
  }
  _setTrackingState(newState) {
    if (this._trackingState !== newState) {
      this._trackingState = newState;
      this.onTrackingStateChanged.notifyObservers(newState);
    }
  }
  /**
   * Return the user's height, unrelated to the current ground.
   * This will be the y position of this camera, when ground level is 0.
   *
   * Note - this value is multiplied by the worldScalingFactor (if set), so it will be in the same units as the scene.
   */
  get realWorldHeight() {
    const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);
    if (basePose && basePose.transform) {
      return basePose.transform.position.y * this._xrSessionManager.worldScalingFactor;
    } else {
      return 0;
    }
  }
  /** @internal */
  _updateForDualEyeDebugging() {
    this._updateNumberOfRigCameras(2);
    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);
    this.rigCameras[0].outputRenderTarget = null;
    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1);
    this.rigCameras[1].outputRenderTarget = null;
  }
  /**
   * Sets this camera's transformation based on a non-vr camera
   * @param otherCamera the non-vr camera to copy the transformation from
   * @param resetToBaseReferenceSpace should XR reset to the base reference space
   */
  setTransformationFromNonVRCamera(otherCamera = this.getScene().activeCamera, resetToBaseReferenceSpace = true) {
    if (!otherCamera || otherCamera === this) {
      return;
    }
    const mat = otherCamera.computeWorldMatrix();
    mat.decompose(void 0, this.rotationQuaternion, this.position);
    this.position.y = 0;
    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);
    this._firstFrame = true;
    if (resetToBaseReferenceSpace) {
      this._xrSessionManager.resetReferenceSpace();
    }
  }
  /**
   * Gets the current instance class name ("WebXRCamera").
   * @returns the class name
   */
  getClassName() {
    return "WebXRCamera";
  }
  /**
   * Set the target for the camera to look at.
   * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras
   * @param target the target to set the camera to look at
   */
  setTarget(target) {
    const tmpVector = TmpVectors.Vector3[1];
    target.subtractToRef(this.position, tmpVector);
    tmpVector.y = 0;
    tmpVector.normalize();
    const yRotation = Math.atan2(tmpVector.x, tmpVector.z) + (this._scene.useRightHandedSystem ? Math.PI : 0);
    this.rotationQuaternion.toEulerAnglesToRef(tmpVector);
    Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);
  }
  dispose() {
    super.dispose();
    this._lastXRViewerPose = void 0;
    this.onTrackingStateChanged.clear();
  }
  _updateDepthNearFar() {
    const far = (this.maxZ || 1e4) * this._xrSessionManager.worldScalingFactor;
    const xrRenderState = {
      // if maxZ is 0 it should be "Infinity", but it doesn't work with the WebXR API. Setting to a large number.
      depthFar: far,
      depthNear: this.minZ
    };
    this._xrSessionManager.updateRenderState(xrRenderState);
    this._cache.minZ = this.minZ;
    this._cache.maxZ = far;
  }
  _updateFromXRSession() {
    const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);
    this._lastXRViewerPose = pose || void 0;
    if (!pose) {
      this._setTrackingState(
        0
        /* WebXRTrackingState.NOT_TRACKING */
      );
      return;
    }
    const trackingState = pose.emulatedPosition ? 1 : 2;
    this._setTrackingState(trackingState);
    if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {
      this._updateDepthNearFar();
    }
    if (pose.transform) {
      const orientation = pose.transform.orientation;
      if (pose.transform.orientation.x === void 0) {
        return;
      }
      const pos = pose.transform.position;
      this._referencedPosition.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);
      this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        this._referencedPosition.z *= -1;
        this._referenceQuaternion.z *= -1;
        this._referenceQuaternion.w *= -1;
      }
      if (this._firstFrame) {
        this._firstFrame = false;
        this.position.y += this._referencedPosition.y;
        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);
      } else {
        this.rotationQuaternion.copyFrom(this._referenceQuaternion);
        this.position.copyFrom(this._referencedPosition);
      }
    }
    if (this.rigCameras.length !== pose.views.length) {
      this._updateNumberOfRigCameras(pose.views.length);
    }
    for (let i = 0; i < pose.views.length; i++) {
      const view = pose.views[i];
      const currentRig = this.rigCameras[i];
      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {
        if (view.eye === "right") {
          currentRig._isRightCamera = true;
        } else if (view.eye === "left") {
          currentRig._isLeftCamera = true;
        }
      }
      const customRenderTargets = this.getScene().customRenderTargets;
      for (let i2 = 0; i2 < customRenderTargets.length; i2++) {
        const rt = customRenderTargets[i2];
        if (currentRig.customRenderTargets.indexOf(rt) === -1) {
          currentRig.customRenderTargets.push(rt);
        }
      }
      const pos = view.transform.position;
      const orientation = view.transform.orientation;
      currentRig.parent = this.parent;
      currentRig.position.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);
      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        currentRig.position.z *= -1;
        currentRig.rotationQuaternion.z *= -1;
        currentRig.rotationQuaternion.w *= -1;
      }
      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);
      if (!this._scene.useRightHandedSystem) {
        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();
      }
      const fov = Math.atan2(1, view.projectionMatrix[5]) * 2;
      currentRig.fov = fov;
      if (i === 0) {
        this.fov = fov;
        this._projectionMatrix.copyFrom(currentRig._projectionMatrix);
      }
      const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);
      this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;
      if (this._renderingMultiview) {
        if (i == 0) {
          this._xrSessionManager.trySetViewportForView(this.viewport, view);
          this.outputRenderTarget = renderTargetTexture;
        }
      } else {
        this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);
        currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);
      }
      currentRig.layerMask = this.layerMask;
    }
  }
  _updateNumberOfRigCameras(viewCount = 1) {
    while (this.rigCameras.length < viewCount) {
      const newCamera = new TargetCamera("XR-RigCamera: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
      newCamera.minZ = 0.1;
      newCamera.rotationQuaternion = new Quaternion();
      newCamera.updateUpVectorFromRotation = true;
      newCamera.isRigCamera = true;
      newCamera.rigParent = this;
      newCamera.freezeProjectionMatrix();
      this.rigCameras.push(newCamera);
    }
    while (this.rigCameras.length > viewCount) {
      const removedCamera = this.rigCameras.pop();
      if (removedCamera) {
        removedCamera.dispose();
      }
    }
  }
  _updateReferenceSpace() {
    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {
      const referencedMat = TmpVectors.Matrix[0];
      const poseMat = TmpVectors.Matrix[1];
      const transformMat = TmpVectors.Matrix[2];
      Matrix.ComposeToRef(_WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);
      Matrix.ComposeToRef(_WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);
      referencedMat.invert().multiplyToRef(poseMat, transformMat);
      transformMat.invert();
      if (!this._scene.useRightHandedSystem) {
        transformMat.toggleModelMatrixHandInPlace();
      }
      transformMat.decompose(void 0, this._referenceQuaternion, this._referencedPosition);
      const transform = new XRRigidTransform({
        x: this._referencedPosition.x / this._xrSessionManager.worldScalingFactor,
        y: this._referencedPosition.y / this._xrSessionManager.worldScalingFactor,
        z: this._referencedPosition.z / this._xrSessionManager.worldScalingFactor
      }, {
        x: this._referenceQuaternion.x,
        y: this._referenceQuaternion.y,
        z: this._referenceQuaternion.z,
        w: this._referenceQuaternion.w
      });
      this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);
    }
  }
};
WebXRCamera._ScaleReadOnly = Vector3.One();

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName = class {
};
WebXRFeatureName.ANCHOR_SYSTEM = "xr-anchor-system";
WebXRFeatureName.BACKGROUND_REMOVER = "xr-background-remover";
WebXRFeatureName.HIT_TEST = "xr-hit-test";
WebXRFeatureName.MESH_DETECTION = "xr-mesh-detection";
WebXRFeatureName.PHYSICS_CONTROLLERS = "xr-physics-controller";
WebXRFeatureName.PLANE_DETECTION = "xr-plane-detection";
WebXRFeatureName.POINTER_SELECTION = "xr-controller-pointer-selection";
WebXRFeatureName.TELEPORTATION = "xr-controller-teleportation";
WebXRFeatureName.FEATURE_POINTS = "xr-feature-points";
WebXRFeatureName.HAND_TRACKING = "xr-hand-tracking";
WebXRFeatureName.IMAGE_TRACKING = "xr-image-tracking";
WebXRFeatureName.NEAR_INTERACTION = "xr-near-interaction";
WebXRFeatureName.DOM_OVERLAY = "xr-dom-overlay";
WebXRFeatureName.MOVEMENT = "xr-controller-movement";
WebXRFeatureName.LIGHT_ESTIMATION = "xr-light-estimation";
WebXRFeatureName.EYE_TRACKING = "xr-eye-tracking";
WebXRFeatureName.WALKING_LOCOMOTION = "xr-walking-locomotion";
WebXRFeatureName.LAYERS = "xr-layers";
WebXRFeatureName.DEPTH_SENSING = "xr-depth-sensing";
WebXRFeatureName.SPACE_WARP = "xr-space-warp";
WebXRFeatureName.RAW_CAMERA_ACCESS = "xr-raw-camera-access";
var WebXRFeaturesManager = class _WebXRFeaturesManager {
  /**
   * constructs a new features manages.
   *
   * @param _xrSessionManager an instance of WebXRSessionManager
   */
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._features = {};
    this._xrSessionManager.onXRSessionInit.add(() => {
      const features = this.getEnabledFeatures();
      for (const featureName of features) {
        const feature = this._features[featureName];
        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
          this.attachFeature(featureName);
        }
      }
    });
    this._xrSessionManager.onXRSessionEnded.add(() => {
      const features = this.getEnabledFeatures();
      for (const featureName of features) {
        const feature = this._features[featureName];
        if (feature.enabled && feature.featureImplementation.attached) {
          this.detachFeature(featureName);
        }
      }
    });
  }
  /**
   * Used to register a module. After calling this function a developer can use this feature in the scene.
   * Mainly used internally.
   *
   * @param featureName the name of the feature to register
   * @param constructorFunction the function used to construct the module
   * @param version the (babylon) version of the module
   * @param stable is that a stable version of this module
   */
  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {
    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
    if (version > this._AvailableFeatures[featureName].latest) {
      this._AvailableFeatures[featureName].latest = version;
    }
    if (stable) {
      this._AvailableFeatures[featureName].stable = version;
    }
    this._AvailableFeatures[featureName][version] = constructorFunction;
  }
  /**
   * Returns a constructor of a specific feature.
   *
   * @param featureName the name of the feature to construct
   * @param version the version of the feature to load
   * @param xrSessionManager the xrSessionManager. Used to construct the module
   * @param options optional options provided to the module.
   * @returns a function that, when called, will return a new instance of this feature
   */
  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {
    const constructorFunction = this._AvailableFeatures[featureName][version];
    if (!constructorFunction) {
      throw new Error("feature not found");
    }
    return constructorFunction(xrSessionManager, options);
  }
  /**
   * Can be used to return the list of features currently registered
   *
   * @returns an Array of available features
   */
  static GetAvailableFeatures() {
    return Object.keys(this._AvailableFeatures);
  }
  /**
   * Gets the versions available for a specific feature
   * @param featureName the name of the feature
   * @returns an array with the available versions
   */
  static GetAvailableVersions(featureName) {
    return Object.keys(this._AvailableFeatures[featureName]);
  }
  /**
   * Return the latest unstable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetLatestVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
  }
  /**
   * Return the latest stable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetStableVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
  }
  /**
   * Attach a feature to the current session. Mainly used when session started to start the feature effect.
   * Can be used during a session to start a feature
   * @param featureName the name of feature to attach
   */
  attachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.enabled && !feature.featureImplementation.attached) {
      const attached = feature.featureImplementation.attach();
      if (!attached) {
        Tools.Warn(`Feature ${featureName} failed to attach`);
      }
    }
  }
  /**
   * Can be used inside a session or when the session ends to detach a specific feature
   * @param featureName the name of the feature to detach
   */
  detachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.featureImplementation.attached) {
      const detached = feature.featureImplementation.detach();
      if (!detached) {
        Tools.Warn(`Feature ${featureName} failed to detach`);
      }
    }
  }
  /**
   * Used to disable an already-enabled feature
   * The feature will be disposed and will be recreated once enabled.
   * @param featureName the feature to disable
   * @returns true if disable was successful
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  disableFeature(featureName) {
    const name = typeof featureName === "string" ? featureName : featureName.Name;
    const feature = this._features[name];
    if (feature && feature.enabled) {
      feature.enabled = false;
      this.detachFeature(name);
      feature.featureImplementation.dispose();
      delete this._features[name];
      return true;
    }
    return false;
  }
  /**
   * dispose this features manager
   */
  dispose() {
    const features = this.getEnabledFeatures();
    for (const featureName of features) {
      this.disableFeature(featureName);
    }
  }
  /**
   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
   *
   * @param featureName the name of the feature to load or the class of the feature
   * @param version optional version to load. if not provided the latest version will be enabled
   * @param moduleOptions options provided to the module. Ses the module documentation / constructor
   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.
   */
  enableFeature(featureName, version = "latest", moduleOptions = {}, attachIfPossible = true, required = true) {
    const name = typeof featureName === "string" ? featureName : featureName.Name;
    let versionToLoad = 0;
    if (typeof version === "string") {
      if (!version) {
        throw new Error(`Error in provided version - ${name} (${version})`);
      }
      if (version === "stable") {
        versionToLoad = _WebXRFeaturesManager.GetStableVersionOfFeature(name);
      } else if (version === "latest") {
        versionToLoad = _WebXRFeaturesManager.GetLatestVersionOfFeature(name);
      } else {
        versionToLoad = +version;
      }
      if (versionToLoad === -1 || isNaN(versionToLoad)) {
        throw new Error(`feature not found - ${name} (${version})`);
      }
    } else {
      versionToLoad = version;
    }
    const conflictingFeature = _WebXRFeaturesManager._ConflictingFeatures[name];
    if (conflictingFeature !== void 0 && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {
      throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);
    }
    const feature = this._features[name];
    const constructFunction = _WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);
    if (!constructFunction) {
      throw new Error(`feature not found - ${name}`);
    }
    if (feature) {
      this.disableFeature(name);
    }
    const constructed = constructFunction();
    if (constructed.dependsOn) {
      const dependentsFound = constructed.dependsOn.every((featureName2) => !!this._features[featureName2]);
      if (!dependentsFound) {
        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(", ")}`);
      }
    }
    if (constructed.isCompatible()) {
      this._features[name] = {
        featureImplementation: constructed,
        enabled: true,
        version: versionToLoad,
        required
      };
      if (attachIfPossible) {
        if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {
          this.attachFeature(name);
        }
      } else {
        this._features[name].featureImplementation.disableAutoAttach = true;
      }
      return this._features[name].featureImplementation;
    } else {
      if (required) {
        throw new Error("required feature not compatible");
      } else {
        Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);
        return constructed;
      }
    }
  }
  /**
   * get the implementation of an enabled feature.
   * @param featureName the name of the feature to load
   * @returns the feature class, if found
   */
  getEnabledFeature(featureName) {
    return this._features[featureName] && this._features[featureName].featureImplementation;
  }
  /**
   * Get the list of enabled features
   * @returns an array of enabled features
   */
  getEnabledFeatures() {
    return Object.keys(this._features);
  }
  /**
   * This function will extend the session creation configuration object with enabled features.
   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
   * according to the defined "required" variable, provided during enableFeature call
   * @param xrSessionInit the xr Session init object to extend
   *
   * @returns an extended XRSessionInit object
   */
  async _extendXRSessionInitObject(xrSessionInit) {
    const enabledFeatures = this.getEnabledFeatures();
    for (const featureName of enabledFeatures) {
      const feature = this._features[featureName];
      const nativeName = feature.featureImplementation.xrNativeFeatureName;
      if (nativeName) {
        if (feature.required) {
          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.requiredFeatures.push(nativeName);
          }
        } else {
          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.optionalFeatures.push(nativeName);
          }
        }
      }
      if (feature.featureImplementation.getXRSessionInitExtension) {
        const extended = await feature.featureImplementation.getXRSessionInitExtension();
        xrSessionInit = {
          ...xrSessionInit,
          ...extended
        };
      }
    }
    return xrSessionInit;
  }
};
WebXRFeaturesManager._AvailableFeatures = {};
WebXRFeaturesManager._ConflictingFeatures = {
  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,
  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION
};

// node_modules/@babylonjs/core/Cameras/touchCamera.js
Node.AddNodeConstructor("TouchCamera", (name, scene) => {
  return () => new TouchCamera(name, Vector3.Zero(), scene);
});
var TouchCamera = class extends FreeCamera {
  /**
   * Defines the touch sensibility for rotation.
   * The higher the faster.
   */
  get touchAngularSensibility() {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      return touch.touchAngularSensibility;
    }
    return 0;
  }
  set touchAngularSensibility(value) {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      touch.touchAngularSensibility = value;
    }
  }
  /**
   * Defines the touch sensibility for move.
   * The higher the faster.
   */
  get touchMoveSensibility() {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      return touch.touchMoveSensibility;
    }
    return 0;
  }
  set touchMoveSensibility(value) {
    const touch = this.inputs.attached["touch"];
    if (touch) {
      touch.touchMoveSensibility = value;
    }
  }
  /**
   * Instantiates a new touch camera.
   * This represents a FPS type of camera controlled by touch.
   * This is like a universal camera minus the Gamepad controls.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
   * @param name Define the name of the camera in the scene
   * @param position Define the start position of the camera in the scene
   * @param scene Define the scene the camera belongs to
   */
  constructor(name, position, scene) {
    super(name, position, scene);
    this.inputs.addTouch();
    this._setupInputs();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "TouchCamera";
  }
  /** @internal */
  _setupInputs() {
    const touch = this.inputs.attached["touch"];
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.touchEnabled = !touch;
    } else {
      touch.allowMouse = !mouse;
    }
  }
};

// node_modules/@babylonjs/core/Gamepads/gamepad.js
var Gamepad = class _Gamepad {
  /**
   * Specifies if the gamepad has been connected
   */
  get isConnected() {
    return this._isConnected;
  }
  /**
   * Initializes the gamepad
   * @param id The id of the gamepad
   * @param index The index of the gamepad
   * @param browserGamepad The browser gamepad
   * @param leftStickX The x component of the left joystick
   * @param leftStickY The y component of the left joystick
   * @param rightStickX The x component of the right joystick
   * @param rightStickY The y component of the right joystick
   */
  constructor(id, index, browserGamepad, leftStickX = 0, leftStickY = 1, rightStickX = 2, rightStickY = 3) {
    this.id = id;
    this.index = index;
    this.browserGamepad = browserGamepad;
    this._leftStick = { x: 0, y: 0 };
    this._rightStick = { x: 0, y: 0 };
    this._isConnected = true;
    this._invertLeftStickY = false;
    this.type = _Gamepad.GAMEPAD;
    this._leftStickAxisX = leftStickX;
    this._leftStickAxisY = leftStickY;
    this._rightStickAxisX = rightStickX;
    this._rightStickAxisY = rightStickY;
    if (this.browserGamepad.axes.length >= 2) {
      this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
    }
    if (this.browserGamepad.axes.length >= 4) {
      this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  }
  /**
   * Callback triggered when the left joystick has changed
   * @param callback callback to trigger
   */
  onleftstickchanged(callback) {
    this._onleftstickchanged = callback;
  }
  /**
   * Callback triggered when the right joystick has changed
   * @param callback callback to trigger
   */
  onrightstickchanged(callback) {
    this._onrightstickchanged = callback;
  }
  /**
   * Gets the left joystick
   */
  get leftStick() {
    return this._leftStick;
  }
  /**
   * Sets the left joystick values
   */
  set leftStick(newValues) {
    if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {
      this._onleftstickchanged(newValues);
    }
    this._leftStick = newValues;
  }
  /**
   * Gets the right joystick
   */
  get rightStick() {
    return this._rightStick;
  }
  /**
   * Sets the right joystick value
   */
  set rightStick(newValues) {
    if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {
      this._onrightstickchanged(newValues);
    }
    this._rightStick = newValues;
  }
  /**
   * Updates the gamepad joystick positions
   */
  update() {
    if (this._leftStick) {
      this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
      if (this._invertLeftStickY) {
        this.leftStick.y *= -1;
      }
    }
    if (this._rightStick) {
      this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
    }
  }
  /**
   * Disposes the gamepad
   */
  dispose() {
  }
};
Gamepad.GAMEPAD = 0;
Gamepad.GENERIC = 1;
Gamepad.XBOX = 2;
Gamepad.POSE_ENABLED = 3;
Gamepad.DUALSHOCK = 4;
var GenericPad = class extends Gamepad {
  /**
   * Callback triggered when a button has been pressed
   * @param callback Called when a button has been pressed
   */
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  /**
   * Callback triggered when a button has been released
   * @param callback Called when a button has been released
   */
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  /**
   * Initializes the generic gamepad
   * @param id The id of the generic gamepad
   * @param index The index of the generic gamepad
   * @param browserGamepad The browser gamepad
   */
  constructor(id, index, browserGamepad) {
    super(id, index, browserGamepad);
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.type = Gamepad.GENERIC;
    this._buttons = new Array(browserGamepad.buttons.length);
  }
  _setButtonValue(newValue, currentValue, buttonIndex) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonIndex);
        }
        this.onButtonDownObservable.notifyObservers(buttonIndex);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonIndex);
        }
        this.onButtonUpObservable.notifyObservers(buttonIndex);
      }
    }
    return newValue;
  }
  /**
   * Updates the generic gamepad
   */
  update() {
    super.update();
    for (let index = 0; index < this._buttons.length; index++) {
      this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);
    }
  }
  /**
   * Disposes the generic gamepad
   */
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Gamepads/xboxGamepad.js
var Xbox360Button;
(function(Xbox360Button2) {
  Xbox360Button2[Xbox360Button2["A"] = 0] = "A";
  Xbox360Button2[Xbox360Button2["B"] = 1] = "B";
  Xbox360Button2[Xbox360Button2["X"] = 2] = "X";
  Xbox360Button2[Xbox360Button2["Y"] = 3] = "Y";
  Xbox360Button2[Xbox360Button2["LB"] = 4] = "LB";
  Xbox360Button2[Xbox360Button2["RB"] = 5] = "RB";
  Xbox360Button2[Xbox360Button2["Back"] = 8] = "Back";
  Xbox360Button2[Xbox360Button2["Start"] = 9] = "Start";
  Xbox360Button2[Xbox360Button2["LeftStick"] = 10] = "LeftStick";
  Xbox360Button2[Xbox360Button2["RightStick"] = 11] = "RightStick";
})(Xbox360Button || (Xbox360Button = {}));
var Xbox360Dpad;
(function(Xbox360Dpad2) {
  Xbox360Dpad2[Xbox360Dpad2["Up"] = 12] = "Up";
  Xbox360Dpad2[Xbox360Dpad2["Down"] = 13] = "Down";
  Xbox360Dpad2[Xbox360Dpad2["Left"] = 14] = "Left";
  Xbox360Dpad2[Xbox360Dpad2["Right"] = 15] = "Right";
})(Xbox360Dpad || (Xbox360Dpad = {}));
var Xbox360Pad = class extends Gamepad {
  /**
   * Creates a new XBox360 gamepad object
   * @param id defines the id of this gamepad
   * @param index defines its index
   * @param gamepad defines the internal HTML gamepad object
   * @param xboxOne defines if it is a XBox One gamepad
   */
  constructor(id, index, gamepad, xboxOne = false) {
    super(id, index, gamepad, 0, 1, 2, 3);
    this._leftTrigger = 0;
    this._rightTrigger = 0;
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.onPadDownObservable = new Observable();
    this.onPadUpObservable = new Observable();
    this._buttonA = 0;
    this._buttonB = 0;
    this._buttonX = 0;
    this._buttonY = 0;
    this._buttonBack = 0;
    this._buttonStart = 0;
    this._buttonLb = 0;
    this._buttonRb = 0;
    this._buttonLeftStick = 0;
    this._buttonRightStick = 0;
    this._dPadUp = 0;
    this._dPadDown = 0;
    this._dPadLeft = 0;
    this._dPadRight = 0;
    this._isXboxOnePad = false;
    this.type = Gamepad.XBOX;
    this._isXboxOnePad = xboxOne;
  }
  /**
   * Defines the callback to call when left trigger is pressed
   * @param callback defines the callback to use
   */
  onlefttriggerchanged(callback) {
    this._onlefttriggerchanged = callback;
  }
  /**
   * Defines the callback to call when right trigger is pressed
   * @param callback defines the callback to use
   */
  onrighttriggerchanged(callback) {
    this._onrighttriggerchanged = callback;
  }
  /**
   * Gets the left trigger value
   */
  get leftTrigger() {
    return this._leftTrigger;
  }
  /**
   * Sets the left trigger value
   */
  set leftTrigger(newValue) {
    if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
      this._onlefttriggerchanged(newValue);
    }
    this._leftTrigger = newValue;
  }
  /**
   * Gets the right trigger value
   */
  get rightTrigger() {
    return this._rightTrigger;
  }
  /**
   * Sets the right trigger value
   */
  set rightTrigger(newValue) {
    if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
      this._onrighttriggerchanged(newValue);
    }
    this._rightTrigger = newValue;
  }
  /**
   * Defines the callback to call when a button is pressed
   * @param callback defines the callback to use
   */
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  /**
   * Defines the callback to call when a button is released
   * @param callback defines the callback to use
   */
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  /**
   * Defines the callback to call when a pad is pressed
   * @param callback defines the callback to use
   */
  ondpaddown(callback) {
    this._ondpaddown = callback;
  }
  /**
   * Defines the callback to call when a pad is released
   * @param callback defines the callback to use
   */
  ondpadup(callback) {
    this._ondpadup = callback;
  }
  _setButtonValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  _setDpadValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  /**
   * Gets the value of the `A` button
   */
  get buttonA() {
    return this._buttonA;
  }
  /**
   * Sets the value of the `A` button
   */
  set buttonA(value) {
    this._buttonA = this._setButtonValue(
      value,
      this._buttonA,
      0
      /* Xbox360Button.A */
    );
  }
  /**
   * Gets the value of the `B` button
   */
  get buttonB() {
    return this._buttonB;
  }
  /**
   * Sets the value of the `B` button
   */
  set buttonB(value) {
    this._buttonB = this._setButtonValue(
      value,
      this._buttonB,
      1
      /* Xbox360Button.B */
    );
  }
  /**
   * Gets the value of the `X` button
   */
  get buttonX() {
    return this._buttonX;
  }
  /**
   * Sets the value of the `X` button
   */
  set buttonX(value) {
    this._buttonX = this._setButtonValue(
      value,
      this._buttonX,
      2
      /* Xbox360Button.X */
    );
  }
  /**
   * Gets the value of the `Y` button
   */
  get buttonY() {
    return this._buttonY;
  }
  /**
   * Sets the value of the `Y` button
   */
  set buttonY(value) {
    this._buttonY = this._setButtonValue(
      value,
      this._buttonY,
      3
      /* Xbox360Button.Y */
    );
  }
  /**
   * Gets the value of the `Start` button
   */
  get buttonStart() {
    return this._buttonStart;
  }
  /**
   * Sets the value of the `Start` button
   */
  set buttonStart(value) {
    this._buttonStart = this._setButtonValue(
      value,
      this._buttonStart,
      9
      /* Xbox360Button.Start */
    );
  }
  /**
   * Gets the value of the `Back` button
   */
  get buttonBack() {
    return this._buttonBack;
  }
  /**
   * Sets the value of the `Back` button
   */
  set buttonBack(value) {
    this._buttonBack = this._setButtonValue(
      value,
      this._buttonBack,
      8
      /* Xbox360Button.Back */
    );
  }
  /**
   * Gets the value of the `Left` button
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get buttonLB() {
    return this._buttonLb;
  }
  /**
   * Sets the value of the `Left` button
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set buttonLB(value) {
    this._buttonLb = this._setButtonValue(
      value,
      this._buttonLb,
      4
      /* Xbox360Button.LB */
    );
  }
  /**
   * Gets the value of the `Right` button
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get buttonRB() {
    return this._buttonRb;
  }
  /**
   * Sets the value of the `Right` button
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set buttonRB(value) {
    this._buttonRb = this._setButtonValue(
      value,
      this._buttonRb,
      5
      /* Xbox360Button.RB */
    );
  }
  /**
   * Gets the value of the Left joystick
   */
  get buttonLeftStick() {
    return this._buttonLeftStick;
  }
  /**
   * Sets the value of the Left joystick
   */
  set buttonLeftStick(value) {
    this._buttonLeftStick = this._setButtonValue(
      value,
      this._buttonLeftStick,
      10
      /* Xbox360Button.LeftStick */
    );
  }
  /**
   * Gets the value of the Right joystick
   */
  get buttonRightStick() {
    return this._buttonRightStick;
  }
  /**
   * Sets the value of the Right joystick
   */
  set buttonRightStick(value) {
    this._buttonRightStick = this._setButtonValue(
      value,
      this._buttonRightStick,
      11
      /* Xbox360Button.RightStick */
    );
  }
  /**
   * Gets the value of D-pad up
   */
  get dPadUp() {
    return this._dPadUp;
  }
  /**
   * Sets the value of D-pad up
   */
  set dPadUp(value) {
    this._dPadUp = this._setDpadValue(
      value,
      this._dPadUp,
      12
      /* Xbox360Dpad.Up */
    );
  }
  /**
   * Gets the value of D-pad down
   */
  get dPadDown() {
    return this._dPadDown;
  }
  /**
   * Sets the value of D-pad down
   */
  set dPadDown(value) {
    this._dPadDown = this._setDpadValue(
      value,
      this._dPadDown,
      13
      /* Xbox360Dpad.Down */
    );
  }
  /**
   * Gets the value of D-pad left
   */
  get dPadLeft() {
    return this._dPadLeft;
  }
  /**
   * Sets the value of D-pad left
   */
  set dPadLeft(value) {
    this._dPadLeft = this._setDpadValue(
      value,
      this._dPadLeft,
      14
      /* Xbox360Dpad.Left */
    );
  }
  /**
   * Gets the value of D-pad right
   */
  get dPadRight() {
    return this._dPadRight;
  }
  /**
   * Sets the value of D-pad right
   */
  set dPadRight(value) {
    this._dPadRight = this._setDpadValue(
      value,
      this._dPadRight,
      15
      /* Xbox360Dpad.Right */
    );
  }
  /**
   * Force the gamepad to synchronize with device values
   */
  update() {
    super.update();
    if (this._isXboxOnePad) {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    } else {
      this.buttonA = this.browserGamepad.buttons[0].value;
      this.buttonB = this.browserGamepad.buttons[1].value;
      this.buttonX = this.browserGamepad.buttons[2].value;
      this.buttonY = this.browserGamepad.buttons[3].value;
      this.buttonLB = this.browserGamepad.buttons[4].value;
      this.buttonRB = this.browserGamepad.buttons[5].value;
      this.leftTrigger = this.browserGamepad.buttons[6].value;
      this.rightTrigger = this.browserGamepad.buttons[7].value;
      this.buttonBack = this.browserGamepad.buttons[8].value;
      this.buttonStart = this.browserGamepad.buttons[9].value;
      this.buttonLeftStick = this.browserGamepad.buttons[10].value;
      this.buttonRightStick = this.browserGamepad.buttons[11].value;
      this.dPadUp = this.browserGamepad.buttons[12].value;
      this.dPadDown = this.browserGamepad.buttons[13].value;
      this.dPadLeft = this.browserGamepad.buttons[14].value;
      this.dPadRight = this.browserGamepad.buttons[15].value;
    }
  }
  /**
   * Disposes the gamepad
   */
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Gamepads/dualShockGamepad.js
var DualShockButton;
(function(DualShockButton2) {
  DualShockButton2[DualShockButton2["Cross"] = 0] = "Cross";
  DualShockButton2[DualShockButton2["Circle"] = 1] = "Circle";
  DualShockButton2[DualShockButton2["Square"] = 2] = "Square";
  DualShockButton2[DualShockButton2["Triangle"] = 3] = "Triangle";
  DualShockButton2[DualShockButton2["L1"] = 4] = "L1";
  DualShockButton2[DualShockButton2["R1"] = 5] = "R1";
  DualShockButton2[DualShockButton2["Share"] = 8] = "Share";
  DualShockButton2[DualShockButton2["Options"] = 9] = "Options";
  DualShockButton2[DualShockButton2["LeftStick"] = 10] = "LeftStick";
  DualShockButton2[DualShockButton2["RightStick"] = 11] = "RightStick";
})(DualShockButton || (DualShockButton = {}));
var DualShockDpad;
(function(DualShockDpad2) {
  DualShockDpad2[DualShockDpad2["Up"] = 12] = "Up";
  DualShockDpad2[DualShockDpad2["Down"] = 13] = "Down";
  DualShockDpad2[DualShockDpad2["Left"] = 14] = "Left";
  DualShockDpad2[DualShockDpad2["Right"] = 15] = "Right";
})(DualShockDpad || (DualShockDpad = {}));
var DualShockPad = class extends Gamepad {
  /**
   * Creates a new DualShock gamepad object
   * @param id defines the id of this gamepad
   * @param index defines its index
   * @param gamepad defines the internal HTML gamepad object
   */
  constructor(id, index, gamepad) {
    super(id.replace("STANDARD GAMEPAD", "SONY PLAYSTATION DUALSHOCK"), index, gamepad, 0, 1, 2, 3);
    this._leftTrigger = 0;
    this._rightTrigger = 0;
    this.onButtonDownObservable = new Observable();
    this.onButtonUpObservable = new Observable();
    this.onPadDownObservable = new Observable();
    this.onPadUpObservable = new Observable();
    this._buttonCross = 0;
    this._buttonCircle = 0;
    this._buttonSquare = 0;
    this._buttonTriangle = 0;
    this._buttonShare = 0;
    this._buttonOptions = 0;
    this._buttonL1 = 0;
    this._buttonR1 = 0;
    this._buttonLeftStick = 0;
    this._buttonRightStick = 0;
    this._dPadUp = 0;
    this._dPadDown = 0;
    this._dPadLeft = 0;
    this._dPadRight = 0;
    this.type = Gamepad.DUALSHOCK;
  }
  /**
   * Defines the callback to call when left trigger is pressed
   * @param callback defines the callback to use
   */
  onlefttriggerchanged(callback) {
    this._onlefttriggerchanged = callback;
  }
  /**
   * Defines the callback to call when right trigger is pressed
   * @param callback defines the callback to use
   */
  onrighttriggerchanged(callback) {
    this._onrighttriggerchanged = callback;
  }
  /**
   * Gets the left trigger value
   */
  get leftTrigger() {
    return this._leftTrigger;
  }
  /**
   * Sets the left trigger value
   */
  set leftTrigger(newValue) {
    if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
      this._onlefttriggerchanged(newValue);
    }
    this._leftTrigger = newValue;
  }
  /**
   * Gets the right trigger value
   */
  get rightTrigger() {
    return this._rightTrigger;
  }
  /**
   * Sets the right trigger value
   */
  set rightTrigger(newValue) {
    if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
      this._onrighttriggerchanged(newValue);
    }
    this._rightTrigger = newValue;
  }
  /**
   * Defines the callback to call when a button is pressed
   * @param callback defines the callback to use
   */
  onbuttondown(callback) {
    this._onbuttondown = callback;
  }
  /**
   * Defines the callback to call when a button is released
   * @param callback defines the callback to use
   */
  onbuttonup(callback) {
    this._onbuttonup = callback;
  }
  /**
   * Defines the callback to call when a pad is pressed
   * @param callback defines the callback to use
   */
  ondpaddown(callback) {
    this._ondpaddown = callback;
  }
  /**
   * Defines the callback to call when a pad is released
   * @param callback defines the callback to use
   */
  ondpadup(callback) {
    this._ondpadup = callback;
  }
  _setButtonValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._onbuttondown) {
          this._onbuttondown(buttonType);
        }
        this.onButtonDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._onbuttonup) {
          this._onbuttonup(buttonType);
        }
        this.onButtonUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  _setDpadValue(newValue, currentValue, buttonType) {
    if (newValue !== currentValue) {
      if (newValue === 1) {
        if (this._ondpaddown) {
          this._ondpaddown(buttonType);
        }
        this.onPadDownObservable.notifyObservers(buttonType);
      }
      if (newValue === 0) {
        if (this._ondpadup) {
          this._ondpadup(buttonType);
        }
        this.onPadUpObservable.notifyObservers(buttonType);
      }
    }
    return newValue;
  }
  /**
   * Gets the value of the `Cross` button
   */
  get buttonCross() {
    return this._buttonCross;
  }
  /**
   * Sets the value of the `Cross` button
   */
  set buttonCross(value) {
    this._buttonCross = this._setButtonValue(
      value,
      this._buttonCross,
      0
      /* DualShockButton.Cross */
    );
  }
  /**
   * Gets the value of the `Circle` button
   */
  get buttonCircle() {
    return this._buttonCircle;
  }
  /**
   * Sets the value of the `Circle` button
   */
  set buttonCircle(value) {
    this._buttonCircle = this._setButtonValue(
      value,
      this._buttonCircle,
      1
      /* DualShockButton.Circle */
    );
  }
  /**
   * Gets the value of the `Square` button
   */
  get buttonSquare() {
    return this._buttonSquare;
  }
  /**
   * Sets the value of the `Square` button
   */
  set buttonSquare(value) {
    this._buttonSquare = this._setButtonValue(
      value,
      this._buttonSquare,
      2
      /* DualShockButton.Square */
    );
  }
  /**
   * Gets the value of the `Triangle` button
   */
  get buttonTriangle() {
    return this._buttonTriangle;
  }
  /**
   * Sets the value of the `Triangle` button
   */
  set buttonTriangle(value) {
    this._buttonTriangle = this._setButtonValue(
      value,
      this._buttonTriangle,
      3
      /* DualShockButton.Triangle */
    );
  }
  /**
   * Gets the value of the `Options` button
   */
  get buttonOptions() {
    return this._buttonOptions;
  }
  /**
   * Sets the value of the `Options` button
   */
  set buttonOptions(value) {
    this._buttonOptions = this._setButtonValue(
      value,
      this._buttonOptions,
      9
      /* DualShockButton.Options */
    );
  }
  /**
   * Gets the value of the `Share` button
   */
  get buttonShare() {
    return this._buttonShare;
  }
  /**
   * Sets the value of the `Share` button
   */
  set buttonShare(value) {
    this._buttonShare = this._setButtonValue(
      value,
      this._buttonShare,
      8
      /* DualShockButton.Share */
    );
  }
  /**
   * Gets the value of the `L1` button
   */
  get buttonL1() {
    return this._buttonL1;
  }
  /**
   * Sets the value of the `L1` button
   */
  set buttonL1(value) {
    this._buttonL1 = this._setButtonValue(
      value,
      this._buttonL1,
      4
      /* DualShockButton.L1 */
    );
  }
  /**
   * Gets the value of the `R1` button
   */
  get buttonR1() {
    return this._buttonR1;
  }
  /**
   * Sets the value of the `R1` button
   */
  set buttonR1(value) {
    this._buttonR1 = this._setButtonValue(
      value,
      this._buttonR1,
      5
      /* DualShockButton.R1 */
    );
  }
  /**
   * Gets the value of the Left joystick
   */
  get buttonLeftStick() {
    return this._buttonLeftStick;
  }
  /**
   * Sets the value of the Left joystick
   */
  set buttonLeftStick(value) {
    this._buttonLeftStick = this._setButtonValue(
      value,
      this._buttonLeftStick,
      10
      /* DualShockButton.LeftStick */
    );
  }
  /**
   * Gets the value of the Right joystick
   */
  get buttonRightStick() {
    return this._buttonRightStick;
  }
  /**
   * Sets the value of the Right joystick
   */
  set buttonRightStick(value) {
    this._buttonRightStick = this._setButtonValue(
      value,
      this._buttonRightStick,
      11
      /* DualShockButton.RightStick */
    );
  }
  /**
   * Gets the value of D-pad up
   */
  get dPadUp() {
    return this._dPadUp;
  }
  /**
   * Sets the value of D-pad up
   */
  set dPadUp(value) {
    this._dPadUp = this._setDpadValue(
      value,
      this._dPadUp,
      12
      /* DualShockDpad.Up */
    );
  }
  /**
   * Gets the value of D-pad down
   */
  get dPadDown() {
    return this._dPadDown;
  }
  /**
   * Sets the value of D-pad down
   */
  set dPadDown(value) {
    this._dPadDown = this._setDpadValue(
      value,
      this._dPadDown,
      13
      /* DualShockDpad.Down */
    );
  }
  /**
   * Gets the value of D-pad left
   */
  get dPadLeft() {
    return this._dPadLeft;
  }
  /**
   * Sets the value of D-pad left
   */
  set dPadLeft(value) {
    this._dPadLeft = this._setDpadValue(
      value,
      this._dPadLeft,
      14
      /* DualShockDpad.Left */
    );
  }
  /**
   * Gets the value of D-pad right
   */
  get dPadRight() {
    return this._dPadRight;
  }
  /**
   * Sets the value of D-pad right
   */
  set dPadRight(value) {
    this._dPadRight = this._setDpadValue(
      value,
      this._dPadRight,
      15
      /* DualShockDpad.Right */
    );
  }
  /**
   * Force the gamepad to synchronize with device values
   */
  update() {
    super.update();
    this.buttonCross = this.browserGamepad.buttons[0].value;
    this.buttonCircle = this.browserGamepad.buttons[1].value;
    this.buttonSquare = this.browserGamepad.buttons[2].value;
    this.buttonTriangle = this.browserGamepad.buttons[3].value;
    this.buttonL1 = this.browserGamepad.buttons[4].value;
    this.buttonR1 = this.browserGamepad.buttons[5].value;
    this.leftTrigger = this.browserGamepad.buttons[6].value;
    this.rightTrigger = this.browserGamepad.buttons[7].value;
    this.buttonShare = this.browserGamepad.buttons[8].value;
    this.buttonOptions = this.browserGamepad.buttons[9].value;
    this.buttonLeftStick = this.browserGamepad.buttons[10].value;
    this.buttonRightStick = this.browserGamepad.buttons[11].value;
    this.dPadUp = this.browserGamepad.buttons[12].value;
    this.dPadDown = this.browserGamepad.buttons[13].value;
    this.dPadLeft = this.browserGamepad.buttons[14].value;
    this.dPadRight = this.browserGamepad.buttons[15].value;
  }
  /**
   * Disposes the gamepad
   */
  dispose() {
    super.dispose();
    this.onButtonDownObservable.clear();
    this.onButtonUpObservable.clear();
    this.onPadDownObservable.clear();
    this.onPadUpObservable.clear();
  }
};

// node_modules/@babylonjs/core/Gamepads/gamepadManager.js
var GamepadManager = class {
  /**
   * Initializes the gamepad manager
   * @param _scene BabylonJS scene
   */
  constructor(_scene) {
    this._scene = _scene;
    this._babylonGamepads = [];
    this._oneGamepadConnected = false;
    this._isMonitoring = false;
    this.onGamepadDisconnectedObservable = new Observable();
    if (!IsWindowObjectExist()) {
      this._gamepadEventSupported = false;
    } else {
      this._gamepadEventSupported = "GamepadEvent" in window;
      this._gamepadSupport = navigator && navigator.getGamepads;
    }
    this.onGamepadConnectedObservable = new Observable((observer) => {
      for (const i in this._babylonGamepads) {
        const gamepad = this._babylonGamepads[i];
        if (gamepad && gamepad._isConnected) {
          this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);
        }
      }
    });
    this._onGamepadConnectedEvent = (evt) => {
      const gamepad = evt.gamepad;
      if (gamepad.index in this._babylonGamepads) {
        if (this._babylonGamepads[gamepad.index].isConnected) {
          return;
        }
      }
      let newGamepad;
      if (this._babylonGamepads[gamepad.index]) {
        newGamepad = this._babylonGamepads[gamepad.index];
        newGamepad.browserGamepad = gamepad;
        newGamepad._isConnected = true;
      } else {
        newGamepad = this._addNewGamepad(gamepad);
      }
      this.onGamepadConnectedObservable.notifyObservers(newGamepad);
      this._startMonitoringGamepads();
    };
    this._onGamepadDisconnectedEvent = (evt) => {
      const gamepad = evt.gamepad;
      for (const i in this._babylonGamepads) {
        if (this._babylonGamepads[i].index === gamepad.index) {
          const disconnectedGamepad = this._babylonGamepads[i];
          disconnectedGamepad._isConnected = false;
          this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);
          if (disconnectedGamepad.dispose) {
            disconnectedGamepad.dispose();
          }
          break;
        }
      }
    };
    if (this._gamepadSupport) {
      this._updateGamepadObjects();
      if (this._babylonGamepads.length) {
        this._startMonitoringGamepads();
      }
      if (this._gamepadEventSupported) {
        const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;
        if (hostWindow) {
          hostWindow.addEventListener("gamepadconnected", this._onGamepadConnectedEvent, false);
          hostWindow.addEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent, false);
        }
      } else {
        this._startMonitoringGamepads();
      }
    }
  }
  /**
   * The gamepads in the game pad manager
   */
  get gamepads() {
    return this._babylonGamepads;
  }
  /**
   * Get the gamepad controllers based on type
   * @param type The type of gamepad controller
   * @returns Nullable gamepad
   */
  getGamepadByType(type = Gamepad.XBOX) {
    for (const gamepad of this._babylonGamepads) {
      if (gamepad && gamepad.type === type) {
        return gamepad;
      }
    }
    return null;
  }
  /**
   * Disposes the gamepad manager
   */
  dispose() {
    if (this._gamepadEventSupported) {
      if (this._onGamepadConnectedEvent) {
        window.removeEventListener("gamepadconnected", this._onGamepadConnectedEvent);
      }
      if (this._onGamepadDisconnectedEvent) {
        window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent);
      }
      this._onGamepadConnectedEvent = null;
      this._onGamepadDisconnectedEvent = null;
    }
    for (const gamepad of this._babylonGamepads) {
      gamepad.dispose();
    }
    this.onGamepadConnectedObservable.clear();
    this.onGamepadDisconnectedObservable.clear();
    this._oneGamepadConnected = false;
    this._stopMonitoringGamepads();
    this._babylonGamepads = [];
  }
  _addNewGamepad(gamepad) {
    if (!this._oneGamepadConnected) {
      this._oneGamepadConnected = true;
    }
    let newGamepad;
    const dualShock = gamepad.id.search("054c") !== -1 && gamepad.id.search("0ce6") === -1;
    const xboxOne = gamepad.id.search("Xbox One") !== -1;
    if (xboxOne || gamepad.id.search("Xbox 360") !== -1 || gamepad.id.search("xinput") !== -1 || gamepad.id.search("045e") !== -1 && gamepad.id.search("Surface Dock") === -1) {
      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);
    } else if (dualShock) {
      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);
    } else {
      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);
    }
    this._babylonGamepads[newGamepad.index] = newGamepad;
    return newGamepad;
  }
  _startMonitoringGamepads() {
    if (!this._isMonitoring) {
      this._isMonitoring = true;
      this._checkGamepadsStatus();
    }
  }
  _stopMonitoringGamepads() {
    this._isMonitoring = false;
  }
  /** @internal */
  _checkGamepadsStatus() {
    this._updateGamepadObjects();
    for (const i in this._babylonGamepads) {
      const gamepad = this._babylonGamepads[i];
      if (!gamepad || !gamepad.isConnected) {
        continue;
      }
      try {
        gamepad.update();
      } catch {
        if (this._loggedErrors.indexOf(gamepad.index) === -1) {
          Tools.Warn(`Error updating gamepad ${gamepad.id}`);
          this._loggedErrors.push(gamepad.index);
        }
      }
    }
    if (this._isMonitoring) {
      AbstractEngine.QueueNewFrame(() => {
        this._checkGamepadsStatus();
      });
    }
  }
  // This function is called only on Chrome, which does not properly support
  // connection/disconnection events and forces you to recopy again the gamepad object
  _updateGamepadObjects() {
    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (gamepad) {
        if (!this._babylonGamepads[gamepad.index]) {
          const newGamepad = this._addNewGamepad(gamepad);
          this.onGamepadConnectedObservable.notifyObservers(newGamepad);
        } else {
          this._babylonGamepads[i].browserGamepad = gamepad;
          if (!this._babylonGamepads[i].isConnected) {
            this._babylonGamepads[i]._isConnected = true;
            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js
var FreeCameraGamepadInput = class {
  constructor() {
    this.gamepadAngularSensibility = 200;
    this.gamepadMoveSensibility = 40;
    this.deadzoneDelta = 0.1;
    this._yAxisScale = 1;
    this._cameraTransform = Matrix.Identity();
    this._deltaTransform = Vector3.Zero();
    this._vector3 = Vector3.Zero();
    this._vector2 = Vector2.Zero();
  }
  /**
   * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
   */
  get invertYAxis() {
    return this._yAxisScale !== 1;
  }
  set invertYAxis(value) {
    this._yAxisScale = value ? -1 : 1;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   */
  attachControl() {
    const manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
          this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
      if (this.gamepad === gamepad) {
        this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    if (!this.gamepad && manager.gamepads.length) {
      this.gamepad = manager.gamepads[0];
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this.gamepad && this.gamepad.leftStick) {
      const camera = this.camera;
      const lsValues = this.gamepad.leftStick;
      if (this.gamepadMoveSensibility !== 0) {
        lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;
        lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;
      }
      let rsValues = this.gamepad.rightStick;
      if (rsValues && this.gamepadAngularSensibility !== 0) {
        rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;
        rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;
      } else {
        rsValues = { x: 0, y: 0 };
      }
      if (!camera.rotationQuaternion) {
        Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);
      } else {
        camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);
      }
      const speed = camera._computeLocalCameraSpeed() * 50;
      this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);
      Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);
      camera.cameraDirection.addInPlace(this._deltaTransform);
      this._vector2.copyFromFloats(rsValues.y, rsValues.x);
      camera.cameraRotation.addInPlace(this._vector2);
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraGamepadInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "gamepad";
  }
};
__decorate([
  serialize()
], FreeCameraGamepadInput.prototype, "gamepadAngularSensibility", void 0);
__decorate([
  serialize()
], FreeCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
CameraInputTypes["FreeCameraGamepadInput"] = FreeCameraGamepadInput;

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js
var ArcRotateCameraGamepadInput = class {
  constructor() {
    this.gamepadRotationSensibility = 80;
    this.gamepadMoveSensibility = 40;
    this._yAxisScale = 1;
  }
  /**
   * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
   */
  get invertYAxis() {
    return this._yAxisScale !== 1;
  }
  set invertYAxis(value) {
    this._yAxisScale = value ? -1 : 1;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   */
  attachControl() {
    const manager = this.camera.getScene().gamepadManager;
    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
      if (gamepad.type !== Gamepad.POSE_ENABLED) {
        if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
          this.gamepad = gamepad;
        }
      }
    });
    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
      if (this.gamepad === gamepad) {
        this.gamepad = null;
      }
    });
    this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
    if (!this.gamepad && manager.gamepads.length) {
      this.gamepad = manager.gamepads[0];
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
    this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
    this.gamepad = null;
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this.gamepad) {
      const camera = this.camera;
      const rsValues = this.gamepad.rightStick;
      if (rsValues) {
        if (rsValues.x != 0) {
          const normalizedRX = rsValues.x / this.gamepadRotationSensibility;
          if (normalizedRX != 0 && Math.abs(normalizedRX) > 5e-3) {
            camera.inertialAlphaOffset += normalizedRX;
          }
        }
        if (rsValues.y != 0) {
          const normalizedRY = rsValues.y / this.gamepadRotationSensibility * this._yAxisScale;
          if (normalizedRY != 0 && Math.abs(normalizedRY) > 5e-3) {
            camera.inertialBetaOffset += normalizedRY;
          }
        }
      }
      const lsValues = this.gamepad.leftStick;
      if (lsValues && lsValues.y != 0) {
        const normalizedLY = lsValues.y / this.gamepadMoveSensibility;
        if (normalizedLY != 0 && Math.abs(normalizedLY) > 5e-3) {
          this.camera.inertialRadiusOffset -= normalizedLY;
        }
      }
    }
  }
  /**
   * Gets the class name of the current intput.
   * @returns the class name
   */
  getClassName() {
    return "ArcRotateCameraGamepadInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "gamepad";
  }
};
__decorate([
  serialize()
], ArcRotateCameraGamepadInput.prototype, "gamepadRotationSensibility", void 0);
__decorate([
  serialize()
], ArcRotateCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
CameraInputTypes["ArcRotateCameraGamepadInput"] = ArcRotateCameraGamepadInput;

// node_modules/@babylonjs/core/Gamepads/gamepadSceneComponent.js
Object.defineProperty(Scene.prototype, "gamepadManager", {
  get: function() {
    if (!this._gamepadManager) {
      this._gamepadManager = new GamepadManager(this);
      let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD);
      if (!component) {
        component = new GamepadSystemSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._gamepadManager;
  },
  enumerable: true,
  configurable: true
});
FreeCameraInputsManager.prototype.addGamepad = function() {
  this.add(new FreeCameraGamepadInput());
  return this;
};
ArcRotateCameraInputsManager.prototype.addGamepad = function() {
  this.add(new ArcRotateCameraGamepadInput());
  return this;
};
var GamepadSystemSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_GAMEPAD;
    this.scene = scene;
  }
  /**
   * Registers the component in a given scene
   */
  register() {
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources
   */
  dispose() {
    const gamepadManager = this.scene._gamepadManager;
    if (gamepadManager) {
      gamepadManager.dispose();
      this.scene._gamepadManager = null;
    }
  }
};

// node_modules/@babylonjs/core/Cameras/universalCamera.js
Node.AddNodeConstructor("FreeCamera", (name, scene) => {
  return () => new UniversalCamera(name, Vector3.Zero(), scene);
});
var UniversalCamera = class extends TouchCamera {
  /**
   * Defines the gamepad rotation sensibility.
   * This is the threshold from when rotation starts to be accounted for to prevent jittering.
   */
  get gamepadAngularSensibility() {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      return gamepad.gamepadAngularSensibility;
    }
    return 0;
  }
  set gamepadAngularSensibility(value) {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      gamepad.gamepadAngularSensibility = value;
    }
  }
  /**
   * Defines the gamepad move sensibility.
   * This is the threshold from when moving starts to be accounted for to prevent jittering.
   */
  get gamepadMoveSensibility() {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      return gamepad.gamepadMoveSensibility;
    }
    return 0;
  }
  set gamepadMoveSensibility(value) {
    const gamepad = this.inputs.attached["gamepad"];
    if (gamepad) {
      gamepad.gamepadMoveSensibility = value;
    }
  }
  /**
   * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
   * which still works and will still be found in many Playgrounds.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
   * @param name Define the name of the camera in the scene
   * @param position Define the start position of the camera in the scene
   * @param scene Define the scene the camera belongs to
   */
  constructor(name, position, scene) {
    super(name, position, scene);
    this.inputs.addGamepad();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "UniversalCamera";
  }
};
Camera._CreateDefaultParsedCamera = (name, scene) => {
  return new UniversalCamera(name, Vector3.Zero(), scene);
};

// node_modules/@babylonjs/core/XR/webXRExperienceHelper.js
var WebXRExperienceHelper = class _WebXRExperienceHelper {
  /**
   * Creates a WebXRExperienceHelper
   * @param _scene The scene the helper should be created in
   */
  constructor(_scene) {
    this._scene = _scene;
    this._nonVRCamera = null;
    this._attachedToElement = false;
    this._spectatorCamera = null;
    this._originalSceneAutoClear = true;
    this._supported = false;
    this._spectatorMode = false;
    this._lastTimestamp = 0;
    this.onInitialXRPoseSetObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this.state = 3;
    this.sessionManager = new WebXRSessionManager(_scene);
    this.camera = new WebXRCamera("webxr", _scene, this.sessionManager);
    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);
    _scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
  }
  /**
   * Creates the experience helper
   * @param scene the scene to attach the experience helper to
   * @returns a promise for the experience helper
   */
  static async CreateAsync(scene) {
    const helper = new _WebXRExperienceHelper(scene);
    return await helper.sessionManager.initializeAsync().then(() => {
      helper._supported = true;
      return helper;
    }).catch((e) => {
      helper._setState(
        3
        /* WebXRState.NOT_IN_XR */
      );
      helper.dispose();
      throw e;
    });
  }
  /**
   * Disposes of the experience helper
   */
  dispose() {
    this.exitXRAsync();
    this.camera.dispose();
    this.onStateChangedObservable.clear();
    this.onInitialXRPoseSetObservable.clear();
    this.sessionManager.dispose();
    this._spectatorCamera?.dispose();
    if (this._nonVRCamera) {
      this._scene.activeCamera = this._nonVRCamera;
    }
  }
  /**
   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
   * @param sessionMode options for the XR session
   * @param referenceSpaceType frame of reference of the XR session
   * @param renderTarget the output canvas that will be used to enter XR mode
   * @param sessionCreationOptions optional XRSessionInit object to init the session with
   * @returns promise that resolves after xr mode has entered
   */
  async enterXRAsync(sessionMode, referenceSpaceType, renderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions = {}) {
    if (!this._supported) {
      throw "WebXR not supported in this browser or environment";
    }
    this._setState(
      0
      /* WebXRState.ENTERING_XR */
    );
    if (referenceSpaceType !== "viewer" && referenceSpaceType !== "local") {
      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];
      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);
    }
    sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);
    if (sessionMode === "immersive-ar" && referenceSpaceType !== "unbounded") {
      Logger.Warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");
    }
    try {
      await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);
      await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);
      const xrRenderState = {
        // if maxZ is 0 it should be "Infinity", but it doesn't work with the WebXR API. Setting to a large number.
        depthFar: this.camera.maxZ || 1e4,
        depthNear: this.camera.minZ
      };
      if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {
        const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);
        xrRenderState.baseLayer = baseLayer;
      }
      this.sessionManager.updateRenderState(xrRenderState);
      this.sessionManager.runXRRenderLoop();
      this._originalSceneAutoClear = this._scene.autoClear;
      this._nonVRCamera = this._scene.activeCamera;
      this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;
      this._nonVRCamera?.detachControl();
      this._scene.activeCamera = this.camera;
      if (sessionMode !== "immersive-ar") {
        this._nonXRToXRCamera();
      } else {
        this._scene.autoClear = false;
        this.camera.compensateOnFirstFrame = false;
        this.camera.position.set(0, 0, 0);
        this.camera.rotationQuaternion.set(0, 0, 0, 1);
        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);
      }
      AbstractEngine.audioEngine?._resumeAudioContextOnStateChange();
      this.sessionManager.onXRSessionEnded.addOnce(() => {
        if (this.state !== 1) {
          this._setState(
            1
            /* WebXRState.EXITING_XR */
          );
        }
        for (const c of this.camera.rigCameras) {
          c.outputRenderTarget = null;
        }
        this._scene.autoClear = this._originalSceneAutoClear;
        this._scene.activeCamera = this._nonVRCamera;
        if (this._attachedToElement && this._nonVRCamera) {
          this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);
        }
        if (sessionMode !== "immersive-ar" && this.camera.compensateOnFirstFrame) {
          if (this._nonVRCamera.setPosition) {
            this._nonVRCamera.setPosition(this.camera.position);
          } else {
            this._nonVRCamera.position.copyFrom(this.camera.position);
          }
        }
        this._setState(
          3
          /* WebXRState.NOT_IN_XR */
        );
      });
      this.sessionManager.onXRFrameObservable.addOnce(() => {
        this._setState(
          2
          /* WebXRState.IN_XR */
        );
      });
      return this.sessionManager;
    } catch (e) {
      Logger.Log(e);
      Logger.Log(e.message);
      this._setState(
        3
        /* WebXRState.NOT_IN_XR */
      );
      throw e;
    }
  }
  /**
   * Exits XR mode and returns the scene to its original state
   * @returns promise that resolves after xr mode has exited
   */
  async exitXRAsync() {
    if (this.state !== 2) {
      return;
    }
    this._setState(
      1
      /* WebXRState.EXITING_XR */
    );
    return await this.sessionManager.exitXRAsync();
  }
  /**
   * Enable spectator mode for desktop VR experiences.
   * When spectator mode is enabled a camera will be attached to the desktop canvas and will
   * display the first rig camera's view on the desktop canvas.
   * Please note that this will degrade performance, as it requires another camera render.
   * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.
   * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.
   */
  enableSpectatorMode(options) {
    if (!this._spectatorMode) {
      this._spectatorMode = true;
      this._switchSpectatorMode(options);
    }
  }
  /**
   * Disable spectator mode for desktop VR experiences.
   */
  disableSpecatatorMode() {
    if (this._spectatorMode) {
      this._spectatorMode = false;
      this._switchSpectatorMode();
    }
  }
  _switchSpectatorMode(options) {
    const fps = options?.fps ? options.fps : 1e3;
    const refreshRate = 1 / fps * 1e3;
    const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;
    const updateSpectatorCamera = () => {
      if (this._spectatorCamera) {
        const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;
        if (delta >= refreshRate) {
          this._lastTimestamp = this.sessionManager.currentTimestamp;
          this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);
          this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);
        }
      }
    };
    if (this._spectatorMode) {
      if (cameraIndex >= this.camera.rigCameras.length) {
        throw new Error("the preferred camera index is beyond the length of rig camera array.");
      }
      const onStateChanged = () => {
        if (this.state === 2) {
          this._spectatorCamera = new UniversalCamera("webxr-spectator", Vector3.Zero(), this._scene);
          this._spectatorCamera.rotationQuaternion = new Quaternion();
          this._scene.activeCameras = [this.camera, this._spectatorCamera];
          this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);
          this._scene.onAfterRenderCameraObservable.add((camera) => {
            if (camera === this.camera) {
              this._scene.getEngine().framebufferDimensionsObject = null;
            }
          });
        } else if (this.state === 1) {
          this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);
          this._scene.activeCameras = null;
        }
      };
      this.onStateChangedObservable.add(onStateChanged);
      onStateChanged();
    } else {
      this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);
      this._scene.activeCameras = [this.camera];
    }
  }
  _nonXRToXRCamera() {
    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);
    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);
  }
  _setState(val) {
    if (this.state === val) {
      return;
    }
    this.state = val;
    this.onStateChangedObservable.notifyObservers(this.state);
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRControllerComponent.js
var WebXRControllerComponent = class {
  /**
   * Creates a new component for a motion controller.
   * It is created by the motion controller itself
   *
   * @param id the id of this component
   * @param type the type of the component
   * @param _buttonIndex index in the buttons array of the gamepad
   * @param _axesIndices indices of the values in the axes array of the gamepad
   */
  constructor(id, type, _buttonIndex = -1, _axesIndices = []) {
    this.id = id;
    this.type = type;
    this._buttonIndex = _buttonIndex;
    this._axesIndices = _axesIndices;
    this._axes = {
      x: 0,
      y: 0
    };
    this._changes = {};
    this._currentValue = 0;
    this._hasChanges = false;
    this._pressed = false;
    this._touched = false;
    this.onAxisValueChangedObservable = new Observable();
    this.onButtonStateChangedObservable = new Observable();
  }
  /**
   * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }
   */
  get axes() {
    return this._axes;
  }
  /**
   * Get the changes. Elements will be populated only if they changed with their previous and current value
   */
  get changes() {
    return this._changes;
  }
  /**
   * Return whether or not the component changed the last frame
   */
  get hasChanges() {
    return this._hasChanges;
  }
  /**
   * is the button currently pressed
   */
  get pressed() {
    return this._pressed;
  }
  /**
   * is the button currently touched
   */
  get touched() {
    return this._touched;
  }
  /**
   * Get the current value of this component
   */
  get value() {
    return this._currentValue;
  }
  /**
   * Dispose this component
   */
  dispose() {
    this.onAxisValueChangedObservable.clear();
    this.onButtonStateChangedObservable.clear();
  }
  /**
   * Are there axes correlating to this component
   * @returns true is axes data is available
   */
  isAxes() {
    return this._axesIndices.length !== 0;
  }
  /**
   * Is this component a button (hence - pressable)
   * @returns true if can be pressed
   */
  isButton() {
    return this._buttonIndex !== -1;
  }
  /**
   * update this component using the gamepad object it is in. Called on every frame
   * @param nativeController the native gamepad controller object
   */
  update(nativeController) {
    let buttonUpdated = false;
    let axesUpdate = false;
    this._hasChanges = false;
    this._changes = {};
    if (this.isButton()) {
      const button = nativeController.buttons[this._buttonIndex];
      if (!button) {
        return;
      }
      if (this._currentValue !== button.value) {
        this.changes.value = {
          current: button.value,
          previous: this._currentValue
        };
        buttonUpdated = true;
        this._currentValue = button.value;
      }
      if (this._touched !== button.touched) {
        this.changes.touched = {
          current: button.touched,
          previous: this._touched
        };
        buttonUpdated = true;
        this._touched = button.touched;
      }
      if (this._pressed !== button.pressed) {
        this.changes.pressed = {
          current: button.pressed,
          previous: this._pressed
        };
        buttonUpdated = true;
        this._pressed = button.pressed;
      }
    }
    if (this.isAxes()) {
      if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {
        this.changes.axes = {
          current: {
            x: nativeController.axes[this._axesIndices[0]],
            y: this._axes.y
          },
          previous: {
            x: this._axes.x,
            y: this._axes.y
          }
        };
        this._axes.x = nativeController.axes[this._axesIndices[0]];
        axesUpdate = true;
      }
      if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {
        if (this.changes.axes) {
          this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];
        } else {
          this.changes.axes = {
            current: {
              x: this._axes.x,
              y: nativeController.axes[this._axesIndices[1]]
            },
            previous: {
              x: this._axes.x,
              y: this._axes.y
            }
          };
        }
        this._axes.y = nativeController.axes[this._axesIndices[1]];
        axesUpdate = true;
      }
    }
    if (buttonUpdated) {
      this._hasChanges = true;
      this.onButtonStateChangedObservable.notifyObservers(this);
    }
    if (axesUpdate) {
      this._hasChanges = true;
      this.onAxisValueChangedObservable.notifyObservers(this._axes);
    }
  }
};
WebXRControllerComponent.BUTTON_TYPE = "button";
WebXRControllerComponent.SQUEEZE_TYPE = "squeeze";
WebXRControllerComponent.THUMBSTICK_TYPE = "thumbstick";
WebXRControllerComponent.TOUCHPAD_TYPE = "touchpad";
WebXRControllerComponent.TRIGGER_TYPE = "trigger";

// node_modules/@babylonjs/core/XR/motionController/webXRAbstractMotionController.js
var WebXRAbstractMotionController = class {
  /**
   * constructs a new abstract motion controller
   * @param scene the scene to which the model of the controller will be added
   * @param layout The profile layout to load
   * @param gamepadObject The gamepad object correlating to this controller
   * @param handedness handedness (left/right/none) of this controller
   * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading
   * @param _controllerCache a cache holding controller models already loaded in this session
   */
  constructor(scene, layout, gamepadObject, handedness, _doNotLoadControllerMesh = false, _controllerCache) {
    this.scene = scene;
    this.layout = layout;
    this.gamepadObject = gamepadObject;
    this.handedness = handedness;
    this._doNotLoadControllerMesh = _doNotLoadControllerMesh;
    this._controllerCache = _controllerCache;
    this._initComponent = (id) => {
      if (!id) {
        return;
      }
      const componentDef = this.layout.components[id];
      const type = componentDef.type;
      const buttonIndex = componentDef.gamepadIndices.button;
      const axes = [];
      if (componentDef.gamepadIndices.xAxis !== void 0 && componentDef.gamepadIndices.yAxis !== void 0) {
        axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);
      }
      this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);
    };
    this._modelReady = false;
    this.components = {};
    this.disableAnimation = false;
    this.onModelLoadedObservable = new Observable();
    if (layout.components) {
      const keys = Object.keys(layout.components);
      for (const key of keys) {
        this._initComponent(key);
      }
    }
  }
  /**
   * Dispose this controller, the model mesh and all its components
   */
  dispose() {
    const ids = this.getComponentIds();
    for (const id of ids) {
      this.getComponent(id).dispose();
    }
    if (this.rootMesh) {
      const nodes = this.rootMesh.getChildren(void 0, true);
      for (const node of nodes) {
        node.setEnabled(false);
      }
      this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);
    }
    this.onModelLoadedObservable.clear();
  }
  /**
   * Returns all components of specific type
   * @param type the type to search for
   * @returns an array of components with this type
   */
  getAllComponentsOfType(type) {
    return this.getComponentIds().map((id) => this.components[id]).filter((component) => component.type === type);
  }
  /**
   * get a component based an its component id as defined in layout.components
   * @param id the id of the component
   * @returns the component correlates to the id or undefined if not found
   */
  getComponent(id) {
    return this.components[id];
  }
  /**
   * Get the list of components available in this motion controller
   * @returns an array of strings correlating to available components
   */
  getComponentIds() {
    return Object.keys(this.components);
  }
  /**
   * Get the first component of specific type
   * @param type type of component to find
   * @returns a controller component or null if not found
   */
  getComponentOfType(type) {
    return this.getAllComponentsOfType(type)[0] || null;
  }
  /**
   * Get the main (Select) component of this controller as defined in the layout
   * @returns the main component of this controller
   */
  getMainComponent() {
    return this.getComponent(this.layout.selectComponentId);
  }
  /**
   * Loads the model correlating to this controller
   * When the mesh is loaded, the onModelLoadedObservable will be triggered
   * @returns A promise fulfilled with the result of the model loading
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  async loadModel() {
    const useGeneric = !this._getModelLoadingConstraints();
    let loadingParams = this._getGenericFilenameAndPath();
    if (useGeneric) {
      Logger.Warn("Falling back to generic models");
    } else {
      loadingParams = this._getFilenameAndPath();
    }
    return await new Promise((resolve, reject) => {
      const meshesLoaded = (meshes) => {
        if (useGeneric) {
          this._getGenericParentMesh(meshes);
        } else {
          this._setRootMesh(meshes);
        }
        this._processLoadedModel(meshes);
        this._modelReady = true;
        this.onModelLoadedObservable.notifyObservers(this);
        resolve(true);
      };
      if (this._controllerCache) {
        const found = this._controllerCache.filter((c) => {
          return c.filename === loadingParams.filename && c.path === loadingParams.path;
        });
        if (found[0]) {
          for (const mesh of found[0].meshes) {
            mesh.setEnabled(true);
          }
          meshesLoaded(found[0].meshes);
          return;
        }
      }
      SceneLoader.ImportMesh("", loadingParams.path, loadingParams.filename, this.scene, (meshes) => {
        if (this._controllerCache) {
          this._controllerCache.push({
            ...loadingParams,
            meshes
          });
        }
        meshesLoaded(meshes);
      }, null, (_scene, message) => {
        Logger.Log(message);
        Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);
        reject(message);
      });
    });
  }
  /**
   * Update this model using the current XRFrame
   * @param xrFrame the current xr frame to use and update the model
   */
  updateFromXRFrame(xrFrame) {
    for (const id of this.getComponentIds()) {
      this.getComponent(id).update(this.gamepadObject);
    }
    this.updateModel(xrFrame);
  }
  /**
   * Backwards compatibility due to a deeply-integrated typo
   */
  get handness() {
    return this.handedness;
  }
  /**
   * Pulse (vibrate) this controller
   * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called
   * Consecutive calls to this function will cancel the last pulse call
   *
   * @param value the strength of the pulse in 0.0...1.0 range
   * @param duration Duration of the pulse in milliseconds
   * @param hapticActuatorIndex optional index of actuator (will usually be 0)
   * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  async pulse(value, duration, hapticActuatorIndex = 0) {
    if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {
      return await this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);
    } else {
      return false;
    }
  }
  // Look through all children recursively. This will return null if no mesh exists with the given name.
  _getChildByName(node, name) {
    return node.getChildren((n) => n.name === name, false)[0];
  }
  // Look through only immediate children. This will return null if no mesh exists with the given name.
  _getImmediateChildByName(node, name) {
    return node.getChildren((n) => n.name == name, true)[0];
  }
  /**
   * Moves the axis on the controller mesh based on its current state
   * @param axisMap
   * @param axisValue the value of the axis which determines the meshes new position
   * @internal
   */
  _lerpTransform(axisMap, axisValue, fixValueCoordinates) {
    if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {
      return;
    }
    if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {
      return;
    }
    const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;
    Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);
    Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);
  }
  /**
   * Update the model itself with the current frame data
   * @param xrFrame the frame to use for updating the model mesh
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  updateModel(xrFrame) {
    if (!this._modelReady) {
      return;
    }
    this._updateModel(xrFrame);
  }
  _getGenericFilenameAndPath() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  }
  _getGenericParentMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    for (const mesh of meshes) {
      if (!mesh.parent) {
        mesh.isPickable = false;
        mesh.setParent(this.rootMesh);
      }
    }
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRGenericMotionController.js
var WebXRGenericTriggerMotionController = class _WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {
  constructor(scene, gamepadObject, handedness) {
    super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);
    this.profileId = _WebXRGenericTriggerMotionController.ProfileId;
  }
  _getFilenameAndPath() {
    return {
      filename: "generic.babylon",
      path: "https://controllers.babylonjs.com/generic/"
    };
  }
  _getModelLoadingConstraints() {
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _processLoadedModel(meshes) {
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + " " + this.handedness, this.scene);
    for (const mesh of meshes) {
      mesh.isPickable = false;
      if (!mesh.parent) {
        mesh.setParent(this.rootMesh);
      }
    }
    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
  }
  _updateModel() {
  }
};
WebXRGenericTriggerMotionController.ProfileId = "generic-trigger";
var GenericTriggerLayout = {
  left: {
    selectComponentId: "xr-standard-trigger",
    components: {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-left",
    assetPath: "left.glb"
  },
  right: {
    selectComponentId: "xr-standard-trigger",
    components: {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-right",
    assetPath: "right.glb"
  },
  none: {
    selectComponentId: "xr-standard-trigger",
    components: {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "xr-standard-trigger": {
        type: "trigger",
        gamepadIndices: {
          button: 0
        },
        rootNodeName: "xr_standard_trigger",
        visualResponses: {}
      }
    },
    gamepadMapping: "xr-standard",
    rootNodeName: "generic-trigger-none",
    assetPath: "none.glb"
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js
function CreateSphereVertexData(options) {
  const segments = (options.segments || 32) | 0;
  const diameterX = options.diameterX || options.diameter || 1;
  const diameterY = options.diameterY || options.diameter || 1;
  const diameterZ = options.diameterZ || options.diameter || 1;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const slice = options.slice && options.slice <= 0 ? 1 : options.slice || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;
  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
  const totalZRotationSteps = 2 + segments;
  const totalYRotationSteps = 2 * totalZRotationSteps;
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    const normalizedZ = zRotationStep / totalZRotationSteps;
    const angleZ = normalizedZ * Math.PI * slice;
    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      const normalizedY = yRotationStep / totalYRotationSteps;
      const angleY = normalizedY * Math.PI * 2 * arc;
      const rotationZ = Matrix.RotationZ(-angleZ);
      const rotationY = Matrix.RotationY(angleY);
      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
      const vertex = complete.multiply(radius);
      const normal = complete.divide(radius).normalize();
      positions.push(vertex.x, vertex.y, vertex.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(normalizedY, useOpenGLOrientationForUV ? 1 - normalizedZ : normalizedZ);
    }
    if (zRotationStep > 0) {
      const verticesCount = positions.length / 3;
      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        if (dedupTopBottomIndices) {
          if (zRotationStep > 1) {
            indices.push(firstIndex);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 1);
          }
          if (zRotationStep < totalZRotationSteps || slice < 1) {
            indices.push(firstIndex + totalYRotationSteps + 1);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 2);
          }
        } else {
          indices.push(firstIndex);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 2);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateSphere(name, options = {}, scene = null) {
  const sphere = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
VertexData.CreateSphere = CreateSphereVertexData;
Mesh.CreateSphere = (name, segments, diameter, scene, updatable, sideOrientation) => {
  const options = {
    segments,
    diameterX: diameter,
    diameterY: diameter,
    diameterZ: diameter,
    sideOrientation,
    updatable
  };
  return CreateSphere(name, options, scene);
};

// node_modules/@babylonjs/core/XR/motionController/webXRProfiledMotionController.js
var WebXRProfiledMotionController = class extends WebXRAbstractMotionController {
  constructor(scene, xrInput, _profile, _repositoryUrl, controllerCache) {
    super(scene, _profile.layouts[xrInput.handedness || "none"], xrInput.gamepad, xrInput.handedness, void 0, controllerCache);
    this._repositoryUrl = _repositoryUrl;
    this.controllerCache = controllerCache;
    this._buttonMeshMapping = {};
    this._touchDots = {};
    this.profileId = _profile.profileId;
  }
  dispose() {
    super.dispose();
    if (!this.controllerCache) {
      const keys = Object.keys(this._touchDots);
      for (const visResKey of keys) {
        this._touchDots[visResKey].dispose();
      }
    }
  }
  _getFilenameAndPath() {
    return {
      filename: this.layout.assetPath,
      path: `${this._repositoryUrl}/profiles/${this.profileId}/`
    };
  }
  _getModelLoadingConstraints() {
    const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(".glb");
    if (!glbLoaded) {
      Logger.Warn("glTF / glb loader was not registered, using generic controller instead");
    }
    return glbLoaded;
  }
  _processLoadedModel(_meshes) {
    const ids = this.getComponentIds();
    for (const type of ids) {
      const componentInLayout = this.layout.components[type];
      this._buttonMeshMapping[type] = {
        mainMesh: this._getChildByName(this.rootMesh, componentInLayout.rootNodeName),
        states: {}
      };
      const keys = Object.keys(componentInLayout.visualResponses);
      for (const visualResponseKey of keys) {
        const visResponse = componentInLayout.visualResponses[visualResponseKey];
        if (visResponse.valueNodeProperty === "transform") {
          this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: this._getChildByName(this.rootMesh, visResponse.valueNodeName),
            minMesh: this._getChildByName(this.rootMesh, visResponse.minNodeName),
            maxMesh: this._getChildByName(this.rootMesh, visResponse.maxNodeName)
          };
        } else {
          const nameOfMesh = componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName ? componentInLayout.touchPointNodeName : visResponse.valueNodeName;
          this._buttonMeshMapping[type].states[visualResponseKey] = {
            valueMesh: this._getChildByName(this.rootMesh, nameOfMesh)
          };
          if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {
            const dot = CreateSphere(visualResponseKey + "dot", {
              diameter: 15e-4,
              segments: 8
            }, this.scene);
            dot.material = new StandardMaterial(visualResponseKey + "mat", this.scene);
            dot.material.diffuseColor = Color3.Red();
            dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;
            dot.isVisible = false;
            this._touchDots[visualResponseKey] = dot;
          }
        }
      }
    }
  }
  _setRootMesh(meshes) {
    this.rootMesh = new Mesh(this.profileId + "-" + this.handedness, this.scene);
    this.rootMesh.isPickable = false;
    let rootMesh;
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      mesh.isPickable = false;
      if (!mesh.parent) {
        rootMesh = mesh;
      }
    }
    if (rootMesh) {
      rootMesh.setParent(this.rootMesh);
    }
    if (!this.scene.useRightHandedSystem) {
      this.rootMesh.rotate(
        Axis.Y,
        Math.PI,
        1
        /* Space.WORLD */
      );
    }
  }
  _updateModel(_xrFrame) {
    if (this.disableAnimation) {
      return;
    }
    const ids = this.getComponentIds();
    for (const id of ids) {
      const component = this.getComponent(id);
      if (!component.hasChanges) {
        continue;
      }
      const meshes = this._buttonMeshMapping[id];
      const componentInLayout = this.layout.components[id];
      const keys = Object.keys(componentInLayout.visualResponses);
      for (const visualResponseKey of keys) {
        const visResponse = componentInLayout.visualResponses[visualResponseKey];
        let value = component.value;
        if (visResponse.componentProperty === "xAxis") {
          value = component.axes.x;
        } else if (visResponse.componentProperty === "yAxis") {
          value = component.axes.y;
        }
        if (visResponse.valueNodeProperty === "transform") {
          this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== "button");
        } else {
          const valueMesh = meshes.states[visualResponseKey].valueMesh;
          if (valueMesh) {
            valueMesh.isVisible = component.touched || component.pressed;
          }
          if (this._touchDots[visualResponseKey]) {
            this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/XR/motionController/webXRMotionControllerManager.js
var ControllerCache = [];
var WebXRMotionControllerManager = class {
  /**
   * Clear the cache used for profile loading and reload when requested again
   */
  static ClearProfilesCache() {
    this._ProfilesList = null;
    this._ProfileLoadingPromises = {};
  }
  /**
   * Register the default fallbacks.
   * This function is called automatically when this file is imported.
   */
  static DefaultFallbacks() {
    this.RegisterFallbacksForProfileId("google-daydream", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive-focus", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("htc-vive", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("magicleap-one", ["generic-trigger-squeeze-touchpad"]);
    this.RegisterFallbacksForProfileId("windows-mixed-reality", ["generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("microsoft-mixed-reality", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-go", ["generic-trigger-touchpad"]);
    this.RegisterFallbacksForProfileId("oculus-touch-v2", ["oculus-touch", "generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("oculus-touch", ["generic-trigger-squeeze-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-gearvr", ["windows-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("samsung-odyssey", ["generic-touchpad"]);
    this.RegisterFallbacksForProfileId("valve-index", ["generic-trigger-squeeze-touchpad-thumbstick"]);
    this.RegisterFallbacksForProfileId("generic-hand-select", ["generic-trigger"]);
  }
  /**
   * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.
   * @param profileId the profile to which a fallback needs to be found
   * @returns an array with corresponding fallback profiles
   */
  static FindFallbackWithProfileId(profileId) {
    const returnArray = this._Fallbacks[profileId] || [];
    returnArray.unshift(profileId);
    return returnArray;
  }
  /**
   * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.
   * The order of search:
   *
   * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller
   * 2) (If not found) search in the gamepad id and try using it (legacy versions only)
   * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)
   * 4) return the generic trigger controller if none were found
   *
   * @param xrInput the xrInput to which a new controller is initialized
   * @param scene the scene to which the model will be added
   * @param forceProfile force a certain profile for this controller
   * @returns A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found
   */
  static async GetMotionControllerWithXRInput(xrInput, scene, forceProfile) {
    const profileArray = [];
    if (forceProfile) {
      profileArray.push(forceProfile);
    }
    profileArray.push(...xrInput.profiles || []);
    if (profileArray.length && !profileArray[0]) {
      profileArray.pop();
    }
    if (xrInput.gamepad && xrInput.gamepad.id) {
      switch (xrInput.gamepad.id) {
        case (xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : void 0):
          profileArray.push("oculus-touch-v2");
          break;
      }
    }
    const windowsMRIdx = profileArray.indexOf("windows-mixed-reality");
    if (windowsMRIdx !== -1) {
      profileArray.splice(windowsMRIdx, 0, "microsoft-mixed-reality");
    }
    if (!profileArray.length) {
      profileArray.push("generic-trigger");
    }
    if (this.UseOnlineRepository) {
      const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepositoryAsync : this._LoadProfilesFromAvailableControllersAsync;
      const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllersAsync : this._LoadProfileFromRepositoryAsync;
      return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {
        return secondFunction.call(this, profileArray, xrInput, scene);
      });
    } else {
      return await this._LoadProfilesFromAvailableControllersAsync(profileArray, xrInput, scene);
    }
  }
  /**
   * Register a new controller based on its profile. This function will be called by the controller classes themselves.
   *
   * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.
   *
   * @param type the profile type to register
   * @param constructFunction the function to be called when loading this profile
   */
  static RegisterController(type, constructFunction) {
    this._AvailableControllers[type] = constructFunction;
  }
  /**
   * Register a fallback to a specific profile.
   * @param profileId the profileId that will receive the fallbacks
   * @param fallbacks A list of fallback profiles
   */
  static RegisterFallbacksForProfileId(profileId, fallbacks) {
    if (this._Fallbacks[profileId]) {
      this._Fallbacks[profileId].push(...fallbacks);
    } else {
      this._Fallbacks[profileId] = fallbacks;
    }
  }
  /**
   * Will update the list of profiles available in the repository
   * @returns a promise that resolves to a map of profiles available online
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static async UpdateProfilesList() {
    const data = await Tools.LoadFileAsync(this.BaseRepositoryUrl + "/profiles/profilesList.json", false);
    this._ProfilesList = JSON.parse(data);
    return await this._ProfilesList;
  }
  /**
   * Clear the controller's cache (usually happens at the end of a session)
   */
  static ClearControllerCache() {
    for (const cacheItem of ControllerCache) {
      for (const mesh of cacheItem.meshes) {
        mesh.dispose(false, true);
      }
    }
    ControllerCache.length = 0;
  }
  static async _LoadProfileFromRepositoryAsync(profileArray, xrInput, scene) {
    return await Promise.resolve().then(async () => {
      if (!this._ProfilesList) {
        return await this.UpdateProfilesList();
      } else {
        return await this._ProfilesList;
      }
    }).then((profilesList) => {
      for (let i = 0; i < profileArray.length; ++i) {
        if (!profileArray[i]) {
          continue;
        }
        if (profilesList[profileArray[i]]) {
          return profileArray[i];
        }
      }
      throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);
    }).then(async (profileToLoad) => {
      if (!this._ProfileLoadingPromises[profileToLoad]) {
        this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then((data) => JSON.parse(data));
      }
      return await this._ProfileLoadingPromises[profileToLoad];
    }).then((profile) => {
      return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? void 0 : ControllerCache);
    });
  }
  static async _LoadProfilesFromAvailableControllersAsync(profileArray, xrInput, scene) {
    for (let i = 0; i < profileArray.length; ++i) {
      if (!profileArray[i]) {
        continue;
      }
      const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);
      for (let j = 0; j < fallbacks.length; ++j) {
        const constructionFunction = this._AvailableControllers[fallbacks[j]];
        if (constructionFunction) {
          return constructionFunction(xrInput, scene);
        }
      }
    }
    throw new Error(`no controller requested was found in the available controllers list`);
  }
};
WebXRMotionControllerManager._AvailableControllers = {};
WebXRMotionControllerManager._Fallbacks = {};
WebXRMotionControllerManager._ProfileLoadingPromises = {};
WebXRMotionControllerManager.BaseRepositoryUrl = "https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist";
WebXRMotionControllerManager.PrioritizeOnlineRepository = true;
WebXRMotionControllerManager.UseOnlineRepository = true;
WebXRMotionControllerManager.DisableControllerCache = true;
WebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput, scene) => {
  return new WebXRGenericTriggerMotionController(scene, xrInput.gamepad, xrInput.handedness);
});
WebXRMotionControllerManager.DefaultFallbacks();

// node_modules/@babylonjs/core/XR/webXRInputSource.js
var IdCount = 0;
var WebXRInputSource = class {
  /**
   * Creates the input source object
   * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport
   * @param _scene the scene which the controller should be associated to
   * @param inputSource the underlying input source for the controller
   * @param _options options for this controller creation
   */
  constructor(_scene, inputSource, _options = {}) {
    this._scene = _scene;
    this.inputSource = inputSource;
    this._options = _options;
    this._tmpVector = new Vector3();
    this._disposed = false;
    this.onDisposeObservable = new Observable();
    this.onMeshLoadedObservable = new Observable();
    this.onMotionControllerInitObservable = new Observable();
    this._uniqueId = `controller-${IdCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;
    this.pointer = new Mesh(`${this._uniqueId}-pointer`, _scene);
    this.pointer.rotationQuaternion = new Quaternion();
    if (this.inputSource.gripSpace) {
      this.grip = new Mesh(`${this._uniqueId}-grip`, this._scene);
      this.grip.rotationQuaternion = new Quaternion();
    }
    this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    if (this.inputSource.gamepad && this.inputSource.targetRayMode === "tracked-pointer") {
      WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then((motionController) => {
        this.motionController = motionController;
        this.onMotionControllerInitObservable.notifyObservers(motionController);
        if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {
          this.motionController.loadModel().then((success) => {
            if (success && this.motionController && this.motionController.rootMesh) {
              if (this._options.renderingGroupId) {
                this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;
                const childMeshes = this.motionController.rootMesh.getChildMeshes(false);
                for (const mesh of childMeshes) {
                  mesh.renderingGroupId = this._options.renderingGroupId;
                }
              }
              this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);
              this.motionController.rootMesh.parent = this.grip || this.pointer;
              this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;
            }
            if (this._disposed) {
              this.motionController?.dispose();
            }
          });
        }
      }, () => {
        Tools.Warn(`Could not find a matching motion controller for the registered input source`);
      });
    }
  }
  /**
   * Get this controllers unique id
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Disposes of the object
   */
  dispose() {
    if (this.grip) {
      this.grip.dispose(true);
    }
    if (this.motionController) {
      this.motionController.dispose();
    }
    this.pointer.dispose(true);
    this.onMotionControllerInitObservable.clear();
    this.onMeshLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this._disposed = true;
  }
  /**
   * Gets a world space ray coming from the pointer or grip
   * @param result the resulting ray
   * @param gripIfAvailable use the grip mesh instead of the pointer, if available
   */
  getWorldPointerRayToRef(result, gripIfAvailable = false) {
    const object = gripIfAvailable && this.grip ? this.grip : this.pointer;
    Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);
    result.direction.normalize();
    result.origin.copyFrom(object.absolutePosition);
    result.length = 1e3;
  }
  /**
   * Updates the controller pose based on the given XRFrame
   * @param xrFrame xr frame to update the pose with
   * @param referenceSpace reference space to use
   * @param xrCamera the xr camera, used for parenting
   * @param xrSessionManager the session manager used to get the world reference system
   */
  updateFromXRFrame(xrFrame, referenceSpace, xrCamera, xrSessionManager) {
    const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);
    this._lastXRPose = pose;
    if (pose) {
      const pos = pose.transform.position;
      this.pointer.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);
      const orientation = pose.transform.orientation;
      this.pointer.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
      if (!this._scene.useRightHandedSystem) {
        this.pointer.position.z *= -1;
        this.pointer.rotationQuaternion.z *= -1;
        this.pointer.rotationQuaternion.w *= -1;
      }
      this.pointer.parent = xrCamera.parent;
      this.pointer.scaling.setAll(xrSessionManager.worldScalingFactor);
    }
    if (this.inputSource.gripSpace && this.grip) {
      const pose2 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);
      if (pose2) {
        const pos = pose2.transform.position;
        const orientation = pose2.transform.orientation;
        this.grip.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);
        this.grip.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
        if (!this._scene.useRightHandedSystem) {
          this.grip.position.z *= -1;
          this.grip.rotationQuaternion.z *= -1;
          this.grip.rotationQuaternion.w *= -1;
        }
      }
      this.grip.parent = xrCamera.parent;
      this.grip.scaling.setAll(xrSessionManager.worldScalingFactor);
    }
    if (this.motionController) {
      this.motionController.updateFromXRFrame(xrFrame);
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRInput.js
var WebXRInput = class {
  /**
   * Initializes the WebXRInput
   * @param xrSessionManager the xr session manager for this session
   * @param xrCamera the WebXR camera for this session. Mainly used for teleportation
   * @param _options = initialization options for this xr input
   */
  constructor(xrSessionManager, xrCamera, _options = {}) {
    this.xrSessionManager = xrSessionManager;
    this.xrCamera = xrCamera;
    this._options = _options;
    this.controllers = [];
    this.onControllerAddedObservable = new Observable();
    this.onControllerRemovedObservable = new Observable();
    this._onInputSourcesChange = (event) => {
      this._addAndRemoveControllers(event.added, event.removed);
    };
    this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {
      this._addAndRemoveControllers([], this.controllers.map((c) => {
        return c.inputSource;
      }));
    });
    this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {
      session.addEventListener("inputsourceschange", this._onInputSourcesChange);
    });
    this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {
      for (const controller of this.controllers) {
        controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera, this.xrSessionManager);
      }
    });
    if (this._options.customControllersRepositoryURL) {
      WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;
    }
    WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;
    if (WebXRMotionControllerManager.UseOnlineRepository) {
      try {
        WebXRMotionControllerManager.UpdateProfilesList().catch(() => {
          WebXRMotionControllerManager.UseOnlineRepository = false;
        });
      } catch (e) {
        WebXRMotionControllerManager.UseOnlineRepository = false;
      }
    }
  }
  _addAndRemoveControllers(addInputs, removeInputs) {
    const sources = this.controllers.map((c) => {
      return c.inputSource;
    });
    for (const input of addInputs) {
      if (sources.indexOf(input) === -1) {
        const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {
          ...this._options.controllerOptions || {},
          forceControllerProfile: this._options.forceInputProfile,
          doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,
          disableMotionControllerAnimation: this._options.disableControllerAnimation
        });
        this.controllers.push(controller);
        this.onControllerAddedObservable.notifyObservers(controller);
      }
    }
    const keepControllers = [];
    const removedControllers = [];
    for (const c of this.controllers) {
      if (removeInputs.indexOf(c.inputSource) === -1) {
        keepControllers.push(c);
      } else {
        removedControllers.push(c);
      }
    }
    this.controllers = keepControllers;
    for (const c of removedControllers) {
      this.onControllerRemovedObservable.notifyObservers(c);
      c.dispose();
    }
  }
  /**
   * Disposes of the object
   */
  dispose() {
    for (const c of this.controllers) {
      c.dispose();
    }
    this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);
    this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);
    this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);
    this.onControllerAddedObservable.clear();
    this.onControllerRemovedObservable.clear();
    WebXRMotionControllerManager.ClearControllerCache();
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js
function CreateCylinderVertexData(options) {
  const height = options.height || 2;
  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;
  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;
  diameterTop = diameterTop || 1e-5;
  diameterBottom = diameterBottom || 1e-5;
  const tessellation = (options.tessellation || 24) | 0;
  const subdivisions = (options.subdivisions || 1) | 0;
  const hasRings = options.hasRings ? true : false;
  const enclose = options.enclose ? true : false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(3);
  const faceColors = options.faceColors;
  const quadNb = arc !== 1 && enclose ? 2 : 0;
  const ringNb = hasRings ? subdivisions : 1;
  const surfaceNb = 2 + (1 + quadNb) * ringNb;
  let f;
  for (f = 0; f < surfaceNb; f++) {
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (f = 0; f < surfaceNb; f++) {
    if (faceUV && faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
  }
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const colors = [];
  const angleStep = Math.PI * 2 * arc / tessellation;
  let angle;
  let h;
  let radius;
  const tan = (diameterBottom - diameterTop) / 2 / height;
  const ringVertex = Vector3.Zero();
  const ringNormal = Vector3.Zero();
  const ringFirstVertex = Vector3.Zero();
  const ringFirstNormal = Vector3.Zero();
  const quadNormal = Vector3.Zero();
  const y = Axis.Y;
  let i;
  let j;
  let r;
  let ringIdx = 1;
  let s = 1;
  let cs = 0;
  let v = 0;
  for (i = 0; i <= subdivisions; i++) {
    h = i / subdivisions;
    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;
    for (r = 0; r < ringIdx; r++) {
      if (hasRings) {
        s += r;
      }
      if (enclose) {
        s += 2 * r;
      }
      for (j = 0; j <= tessellation; j++) {
        angle = j * angleStep;
        ringVertex.x = Math.cos(-angle) * radius;
        ringVertex.y = -height / 2 + h * height;
        ringVertex.z = Math.sin(-angle) * radius;
        if (diameterTop === 0 && i === subdivisions) {
          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
        } else {
          ringNormal.x = ringVertex.x;
          ringNormal.z = ringVertex.z;
          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
          ringNormal.normalize();
        }
        if (j === 0) {
          ringFirstVertex.copyFrom(ringVertex);
          ringFirstNormal.copyFrom(ringNormal);
        }
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s].y : faceUV[s].w;
        } else {
          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
        }
        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, useOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
        }
      }
      if (arc !== 1 && enclose) {
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        positions.push(0, ringVertex.y, 0);
        positions.push(0, ringVertex.y, 0);
        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
        Vector3.CrossToRef(y, ringNormal, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        Vector3.CrossToRef(ringFirstNormal, y, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;
        } else {
          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
        }
        uvs.push(faceUV[s + 1].x, useOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 1].z, useOpenGLOrientationForUV ? 1 - v : v);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;
        } else {
          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
        }
        uvs.push(faceUV[s + 2].x, useOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 2].z, useOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
        }
      }
      if (cs !== s) {
        cs = s;
      }
    }
  }
  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation;
  i = 0;
  for (s = 0; s < subdivisions; s++) {
    let i0 = 0;
    let i1 = 0;
    let i2 = 0;
    let i3 = 0;
    for (j = 0; j < tessellation; j++) {
      i0 = i * (e + 1) + j;
      i1 = (i + 1) * (e + 1) + j;
      i2 = i * (e + 1) + (j + 1);
      i3 = (i + 1) * (e + 1) + (j + 1);
      indices.push(i0, i1, i2);
      indices.push(i3, i2, i1);
    }
    if (arc !== 1 && enclose) {
      indices.push(i0 + 2, i1 + 2, i2 + 2);
      indices.push(i3 + 2, i2 + 2, i1 + 2);
      indices.push(i0 + 4, i1 + 4, i2 + 4);
      indices.push(i3 + 4, i2 + 4, i1 + 4);
    }
    i = hasRings ? i + 2 : i + 1;
  }
  const createCylinderCap = (isTop) => {
    const radius2 = isTop ? diameterTop / 2 : diameterBottom / 2;
    if (radius2 === 0) {
      return;
    }
    let angle2;
    let circleVector;
    let i2;
    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];
    let c = null;
    if (faceColors) {
      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];
    }
    const vbase = positions.length / 3;
    const offset = isTop ? height / 2 : -height / 2;
    const center = new Vector3(0, offset, 0);
    positions.push(center.x, center.y, center.z);
    normals.push(0, isTop ? 1 : -1, 0);
    const v2 = u.y + (u.w - u.y) * 0.5;
    uvs.push(u.x + (u.z - u.x) * 0.5, useOpenGLOrientationForUV ? 1 - v2 : v2);
    if (c) {
      colors.push(c.r, c.g, c.b, c.a);
    }
    const textureScale = new Vector2(0.5, 0.5);
    for (i2 = 0; i2 <= tessellation; i2++) {
      angle2 = Math.PI * 2 * i2 * arc / tessellation;
      const cos = Math.cos(-angle2);
      const sin = Math.sin(-angle2);
      circleVector = new Vector3(cos * radius2, offset, sin * radius2);
      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
      positions.push(circleVector.x, circleVector.y, circleVector.z);
      normals.push(0, isTop ? 1 : -1, 0);
      const v3 = u.y + (u.w - u.y) * textureCoordinate.y;
      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, useOpenGLOrientationForUV ? 1 - v3 : v3);
      if (c) {
        colors.push(c.r, c.g, c.b, c.a);
      }
    }
    for (i2 = 0; i2 < tessellation; i2++) {
      if (!isTop) {
        indices.push(vbase);
        indices.push(vbase + (i2 + 1));
        indices.push(vbase + (i2 + 2));
      } else {
        indices.push(vbase);
        indices.push(vbase + (i2 + 2));
        indices.push(vbase + (i2 + 1));
      }
    }
  };
  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {
    createCylinderCap(false);
  }
  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {
    createCylinderCap(true);
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreateCylinder(name, options = {}, scene) {
  const cylinder = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  cylinder._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateCylinderVertexData(options);
  vertexData.applyToMesh(cylinder, options.updatable);
  return cylinder;
}
VertexData.CreateCylinder = CreateCylinderVertexData;
Mesh.CreateCylinder = (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {
  if (scene === void 0 || !(scene instanceof Scene)) {
    if (scene !== void 0) {
      sideOrientation = updatable || Mesh.DEFAULTSIDE;
      updatable = scene;
    }
    scene = subdivisions;
    subdivisions = 1;
  }
  const options = {
    height,
    diameterTop,
    diameterBottom,
    tessellation,
    subdivisions,
    sideOrientation,
    updatable
  };
  return CreateCylinder(name, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js
function CreateTorusVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const diameter = options.diameter || 1;
  const thickness = options.thickness || 0.5;
  const tessellation = (options.tessellation || 16) | 0;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const stride = tessellation + 1;
  for (let i = 0; i <= tessellation; i++) {
    const u = i / tessellation;
    const outerAngle = i * Math.PI * 2 / tessellation - Math.PI / 2;
    const transform = Matrix.Translation(diameter / 2, 0, 0).multiply(Matrix.RotationY(outerAngle));
    for (let j = 0; j <= tessellation; j++) {
      const v = 1 - j / tessellation;
      const innerAngle = j * Math.PI * 2 / tessellation + Math.PI;
      const dx = Math.cos(innerAngle);
      const dy = Math.sin(innerAngle);
      let normal = new Vector3(dx, dy, 0);
      let position = normal.scale(thickness / 2);
      const textureCoordinate = new Vector2(u, v);
      position = Vector3.TransformCoordinates(position, transform);
      normal = Vector3.TransformNormal(normal, transform);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(textureCoordinate.x, useOpenGLOrientationForUV ? 1 - textureCoordinate.y : textureCoordinate.y);
      const nextI = (i + 1) % stride;
      const nextJ = (j + 1) % stride;
      indices.push(i * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + nextJ);
      indices.push(nextI * stride + j);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorus(name, options = {}, scene) {
  const torus = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torus._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusVertexData(options);
  vertexData.applyToMesh(torus, options.updatable);
  return torus;
}
VertexData.CreateTorus = CreateTorusVertexData;
Mesh.CreateTorus = (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) => {
  const options = {
    diameter,
    thickness,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateTorus(name, options, scene);
};

// node_modules/@babylonjs/core/Culling/ray.core.js
var PickingCustomization = {
  internalPickerForMesh: void 0
};
var Ray = class _Ray {
  /**
   * Creates a new ray
   * @param origin origin point
   * @param direction direction
   * @param length length of the ray
   * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants)
   */
  constructor(origin, direction, length = Number.MAX_VALUE, epsilon = Epsilon) {
    this.origin = origin;
    this.direction = direction;
    this.length = length;
    this.epsilon = epsilon;
  }
  // Methods
  /**
   * Clone the current ray
   * @returns a new ray
   */
  clone() {
    return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray length by design to improve perfs.
   * @param minimum bound of the box
   * @param maximum bound of the box
   * @param intersectionTreshold extra extend to be added to the box in all direction
   * @returns if the box was hit
   */
  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
    const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    let d = 0;
    let maxValue = Number.MAX_VALUE;
    let inv;
    let min;
    let max;
    let temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray length by design to improve perfs.
   * @param box the bounding box to check
   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
   * @returns if the box was hit
   */
  intersectsBox(box, intersectionTreshold = 0) {
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  }
  /**
   * If the ray hits a sphere
   * @param sphere the bounding sphere to check
   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
   * @returns true if it hits the sphere
   */
  intersectsSphere(sphere, intersectionTreshold = 0) {
    const x = sphere.center.x - this.origin.x;
    const y = sphere.center.y - this.origin.y;
    const z = sphere.center.z - this.origin.z;
    const pyth = x * x + y * y + z * z;
    const radius = sphere.radius + intersectionTreshold;
    const rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    const temp = pyth - dot * dot;
    return temp <= rr;
  }
  /**
   * If the ray hits a triange
   * @param vertex0 triangle vertex
   * @param vertex1 triangle vertex
   * @param vertex2 triangle vertex
   * @returns intersection information if hit
   */
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const edge1 = _Ray._TmpVector3[0];
    const edge2 = _Ray._TmpVector3[1];
    const pvec = _Ray._TmpVector3[2];
    const tvec = _Ray._TmpVector3[3];
    const qvec = _Ray._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    const det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    const invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    const bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < -this.epsilon || bv > 1 + this.epsilon) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    const bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
      return null;
    }
    const distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  }
  /**
   * Checks if ray intersects a plane
   * @param plane the plane to check
   * @returns the distance away it was hit
   */
  intersectsPlane(plane) {
    let distance;
    const result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      const result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  }
  /**
   * Calculate the intercept of a ray on a given axis
   * @param axis to check 'x' | 'y' | 'z'
   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
   */
  intersectsAxis(axis, offset = 0) {
    switch (axis) {
      case "y": {
        const t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      }
      case "x": {
        const t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      }
      case "z": {
        const t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      }
      default:
        return null;
    }
  }
  /**
   * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param mesh the mesh to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns picking info of the intersection
   */
  intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      _Ray.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = _Ray.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
  }
  /**
   * Checks if ray intersects a mesh
   * @param meshes the meshes to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param results array to store result in
   * @returns Array of picking infos
   */
  intersectsMeshes(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (let i = 0; i < meshes.length; i++) {
      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  }
  _comparePickingInfo(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  }
  /**
   * Intersection test between the ray and a given segment within a given tolerance (threshold)
   * @param sega the first point of the segment to test the intersection against
   * @param segb the second point of the segment to test the intersection against
   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
   */
  intersectionSegment(sega, segb, threshold) {
    const o = this.origin;
    const u = TmpVectors.Vector3[0];
    const rsegb = TmpVectors.Vector3[1];
    const v = TmpVectors.Vector3[2];
    const w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(_Ray._Rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    const a = Vector3.Dot(u, u);
    const b = Vector3.Dot(u, v);
    const c = Vector3.Dot(v, v);
    const d = Vector3.Dot(u, w);
    const e = Vector3.Dot(v, w);
    const discriminant = a * c - b * b;
    let sN, sD = discriminant;
    let tN, tD = discriminant;
    if (discriminant < _Ray._Smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
    const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
    const qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    const qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    const dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  }
  /**
   * Update the ray from viewport position
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns this ray updated
   */
  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
    if (enableDistantPicking) {
      if (!_Ray._RayDistant) {
        _Ray._RayDistant = _Ray.Zero();
      }
      _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      const tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      _Ray.TransformToRef(_Ray._RayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  }
  // Statics
  /**
   * Creates a ray with origin and direction of 0,0,0
   * @returns the new ray
   */
  static Zero() {
    return new _Ray(Vector3.Zero(), Vector3.Zero());
  }
  /**
   * Creates a new ray from screen space and viewport
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @returns new ray
   */
  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
    const result = _Ray.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  }
  /**
   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the new ray
   */
  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    return _Ray.CreateFromToToRef(origin, end, result, world);
  }
  /**
   * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param result the object to store the result
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the ref ray
   */
  static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
    result.origin.copyFrom(origin);
    const direction = end.subtractToRef(origin, result.direction);
    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    result.length = length;
    result.direction.normalize();
    return _Ray.TransformToRef(result, world, result);
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @returns the resulting new ray
   */
  static Transform(ray, matrix) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    _Ray.TransformToRef(ray, matrix, result);
    return result;
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @param result ray to store result in
   * @returns the updated result ray
   */
  static TransformToRef(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    result.epsilon = ray.epsilon;
    const dir = result.direction;
    const len = dir.length();
    if (!(len === 0 || len === 1)) {
      const num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
    return result;
  }
  /**
   * Unproject a ray from screen space to object space
   * @param sourceX defines the screen space x coordinate to use
   * @param sourceY defines the screen space y coordinate to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   */
  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    const matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const engine = EngineStore.LastCreatedEngine;
    const nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;
    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    const nearVec3 = TmpVectors.Vector3[2];
    const farVec3 = TmpVectors.Vector3[3];
    Vector3.TransformCoordinatesToRef(nearScreenSource, matrix, nearVec3);
    Vector3.TransformCoordinatesToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  }
};
Ray._TmpVector3 = BuildArray(6, Vector3.Zero);
Ray._RayDistant = Ray.Zero();
Ray._Smallnum = 1e-8;
Ray._Rayl = 1e9;
function CreatePickingRay(scene, x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);
  return result;
}
function CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    return scene;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return scene;
}
function CreatePickingRayInCameraSpace(scene, x, y, camera) {
  const result = Ray.Zero();
  CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);
  return result;
}
function CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera) {
  if (!PickingInfo) {
    return scene;
  }
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return scene;
}
function InternalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
}
function InternalPick(scene, rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
}
function InternalMultiPick(scene, rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
}
function PickWithBoundingInfo(scene, x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = InternalPick(scene, (world) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);
    return scene._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function Pick(scene, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = InternalPick(scene, (world, enableDistantPicking) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);
    return scene._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function PickWithRay(scene, ray, predicate, fastCheck, trianglePredicate) {
  const result = InternalPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
}
function MultiPick(scene, x, y, predicate, camera, trianglePredicate) {
  return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);
}
function MultiPickWithRay(scene, ray, predicate, trianglePredicate) {
  return InternalMultiPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, trianglePredicate);
}
function GetForwardRayToRef(camera, refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = camera.getWorldMatrix();
  }
  refRay.length = length;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(camera.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
}
function AddRayExtensions(sceneClass, cameraClass) {
  if (cameraClass) {
    cameraClass.prototype.getForwardRay = function(length = 100, transform, origin) {
      return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
    };
    cameraClass.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
      return GetForwardRayToRef(this, refRay, length, transform, origin);
    };
  }
  if (!sceneClass) {
    return;
  }
  _ImportHelper._IsPickingAvailable = true;
  sceneClass.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
    return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);
  };
}

// node_modules/@babylonjs/core/Culling/ray.js
AddRayExtensions(Scene, Camera);
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  return CreatePickingRayInCameraSpace(this, x, y, camera);
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);
};
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  return MultiPick(this, x, y, predicate, camera, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  return MultiPickWithRay(this, ray, predicate, trianglePredicate);
};

// node_modules/@babylonjs/core/XR/features/WebXRAbstractFeature.js
var WebXRAbstractFeature = class {
  /**
   * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)
   */
  get xrNativeFeatureName() {
    return this._xrNativeFeatureName;
  }
  set xrNativeFeatureName(name) {
    if (!this._xrSessionManager.isNative && name && this._xrSessionManager.inXRSession && this._xrSessionManager.enabledFeatures?.indexOf(name) === -1) {
      Logger.Warn(`The feature ${name} needs to be enabled before starting the XR session. Note - It is still possible it is not supported.`);
    }
    this._xrNativeFeatureName = name;
  }
  /**
   * Construct a new (abstract) WebXR feature
   * @param _xrSessionManager the xr session manager for this feature
   */
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._attached = false;
    this._removeOnDetach = [];
    this.isDisposed = false;
    this.disableAutoAttach = false;
    this._xrNativeFeatureName = "";
    this.onFeatureAttachObservable = new Observable();
    this.onFeatureDetachObservable = new Observable();
  }
  /**
   * Is this feature attached
   */
  get attached() {
    return this._attached;
  }
  /**
   * attach this feature
   *
   * @param force should attachment be forced (even when already attached)
   * @returns true if successful, false is failed or already attached
   */
  attach(force) {
    if (this.isDisposed) {
      return false;
    }
    if (!force) {
      if (this.attached) {
        return false;
      }
    } else {
      if (this.attached) {
        this.detach();
      }
    }
    if (!this._xrSessionManager.enabledFeatures) {
      Logger.Warn("session.enabledFeatures is not available on this device. It is possible that this feature is not supported.");
    } else if (!this._xrSessionManager.isNative && this.xrNativeFeatureName && this._xrSessionManager.enabledFeatures.indexOf(this.xrNativeFeatureName) === -1) {
      return false;
    }
    this._attached = true;
    this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));
    this.onFeatureAttachObservable.notifyObservers(this);
    return true;
  }
  /**
   * detach this feature.
   *
   * @returns true if successful, false if failed or already detached
   */
  detach() {
    if (!this._attached) {
      this.disableAutoAttach = true;
      return false;
    }
    this._attached = false;
    for (const toRemove of this._removeOnDetach) {
      toRemove.observable.remove(toRemove.observer);
    }
    this.onFeatureDetachObservable.notifyObservers(this);
    return true;
  }
  /**
   * Dispose this feature and all of the resources attached
   */
  dispose() {
    this.detach();
    this.isDisposed = true;
    this.onFeatureAttachObservable.clear();
    this.onFeatureDetachObservable.clear();
  }
  /**
   * This function will be executed during before enabling the feature and can be used to not-allow enabling it.
   * Note that at this point the session has NOT started, so this is purely checking if the browser supports it
   *
   * @returns whether or not the feature is compatible in this environment
   */
  isCompatible() {
    return true;
  }
  /**
   * This is used to register callbacks that will automatically be removed when detach is called.
   * @param observable the observable to which the observer will be attached
   * @param callback the callback to register
   * @param insertFirst should the callback be executed as soon as it is registered
   */
  _addNewAttachObserver(observable, callback, insertFirst) {
    this._removeOnDetach.push({
      observable,
      observer: observable.add(callback, void 0, insertFirst)
    });
  }
};

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer = class _UtilityLayerRenderer {
  /**
   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
   * @returns the camera that is used when rendering the utility layer
   */
  getRenderCamera(getRigParentIfPossible) {
    if (this._renderCamera) {
      return this._renderCamera;
    } else {
      let activeCam;
      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
      } else {
        activeCam = this.originalScene.activeCamera;
      }
      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
        return activeCam.rigParent;
      }
      return activeCam;
    }
  }
  /**
   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
   * @param cam the camera that should be used when rendering the utility layer
   */
  setRenderCamera(cam) {
    this._renderCamera = cam;
  }
  /**
   * @internal
   * Light which used by gizmos to get light shading
   */
  _getSharedGizmoLight() {
    if (!this._sharedGizmoLight) {
      this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
      this._sharedGizmoLight.intensity = 2;
      this._sharedGizmoLight.groundColor = Color3.Gray();
    }
    return this._sharedGizmoLight;
  }
  /**
   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
   */
  static get DefaultUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultUtilityLayer == null) {
      return _UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
    }
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * Creates an utility layer, and set it as a default utility layer
   * @param scene associated scene
   * @internal
   */
  static _CreateDefaultUtilityLayerFromScene(scene) {
    _UtilityLayerRenderer._DefaultUtilityLayer = new _UtilityLayerRenderer(scene);
    _UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
      _UtilityLayerRenderer._DefaultUtilityLayer = null;
    });
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
   */
  static get DefaultKeepDepthUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new _UtilityLayerRenderer(EngineStore.LastCreatedScene);
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
      });
    }
    return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
  }
  /**
   * Instantiates a UtilityLayerRenderer
   * @param originalScene the original scene that will be rendered on top of
   * @param handleEvents boolean indicating if the utility layer should handle events
   * @param manualRender boolean indicating if the utility layer should render manually.
   */
  constructor(originalScene, handleEvents = true, manualRender = false) {
    this.originalScene = originalScene;
    this.handleEvents = handleEvents;
    this._pointerCaptures = {};
    this._lastPointerEvents = {};
    this._sharedGizmoLight = null;
    this._renderCamera = null;
    this.pickUtilitySceneFirst = true;
    this.shouldRender = true;
    this.onlyCheckPointerDownEvents = true;
    this.processAllEvents = false;
    this.pickingEnabled = true;
    this.onPointerOutObservable = new Observable();
    this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
    this.utilityLayerScene._allowPostProcessClearColor = false;
    this.utilityLayerScene.postProcessesEnabled = false;
    this.utilityLayerScene.detachControl();
    if (handleEvents) {
      this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
        if (!this.utilityLayerScene.activeCamera) {
          return;
        }
        if (!this.pickingEnabled) {
          return;
        }
        if (!this.processAllEvents) {
          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
            return;
          }
        }
        this.utilityLayerScene.pointerX = originalScene.pointerX;
        this.utilityLayerScene.pointerY = originalScene.pointerY;
        const pointerEvent = prePointerInfo.event;
        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
          this._pointerCaptures[pointerEvent.pointerId] = false;
          return;
        }
        const getNearPickDataForScene = (scene) => {
          let scenePick = null;
          if (prePointerInfo.nearInteractionPickingInfo) {
            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
              scenePick = prePointerInfo.nearInteractionPickingInfo;
            } else {
              scenePick = new PickingInfo();
            }
          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
            scenePick = prePointerInfo.originalPickingInfo;
          } else {
            let previousActiveCamera = null;
            if (this._renderCamera) {
              previousActiveCamera = scene._activeCamera;
              scene._activeCamera = this._renderCamera;
              prePointerInfo.ray = null;
            }
            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
            if (previousActiveCamera) {
              scene._activeCamera = previousActiveCamera;
            }
          }
          return scenePick;
        };
        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
        if (!prePointerInfo.ray && utilityScenePick) {
          prePointerInfo.ray = utilityScenePick.ray;
        }
        if (prePointerInfo.originalPickingInfo?.aimTransform && utilityScenePick) {
          utilityScenePick.aimTransform = prePointerInfo.originalPickingInfo.aimTransform;
          utilityScenePick.gripTransform = prePointerInfo.originalPickingInfo.gripTransform;
        }
        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
          if (!prePointerInfo.skipOnPointerObservable) {
            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
          }
          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
            this._pointerCaptures[pointerEvent.pointerId] = false;
          }
          return;
        }
        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
          if (utilityScenePick && utilityScenePick.hit) {
            if (!prePointerInfo.skipOnPointerObservable) {
              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
            }
            prePointerInfo.skipOnPointerObservable = true;
          }
        } else {
          const originalScenePick = getNearPickDataForScene(originalScene);
          const pointerEvent2 = prePointerInfo.event;
          if (originalScenePick && utilityScenePick) {
            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                this._pointerCaptures[pointerEvent2.pointerId] = true;
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                  this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                  delete this._lastPointerEvents[pointerEvent2.pointerId];
                }
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              if (!prePointerInfo.skipOnPointerObservable) {
                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else {
                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                  if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                    this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                    delete this._lastPointerEvents[pointerEvent2.pointerId];
                  }
                }
                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              }
            }
            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
              this._pointerCaptures[pointerEvent2.pointerId] = false;
            }
          }
        }
      });
      if (this._originalPointerObserver) {
        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
      }
    }
    this.utilityLayerScene.autoClear = false;
    if (!manualRender) {
      this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
        if (this.shouldRender && camera == this.getRenderCamera()) {
          this.render();
        }
      });
    }
    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._updateCamera();
  }
  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
    if (!prePointerInfo.skipOnPointerObservable) {
      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
      this._lastPointerEvents[pointerEvent.pointerId] = true;
    }
  }
  /**
   * Renders the utility layers scene on top of the original scene
   */
  render() {
    this._updateCamera();
    if (this.utilityLayerScene.activeCamera) {
      const oldScene = this.utilityLayerScene.activeCamera.getScene();
      const camera = this.utilityLayerScene.activeCamera;
      camera._scene = this.utilityLayerScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = this.utilityLayerScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = this.utilityLayerScene;
      }
      this.utilityLayerScene.render(false);
      camera._scene = oldScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = oldScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = oldScene;
      }
    }
  }
  /**
   * Disposes of the renderer
   */
  dispose() {
    this.onPointerOutObservable.clear();
    if (this._afterRenderObserver) {
      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
    }
    if (this._sceneDisposeObserver) {
      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
    if (this._originalPointerObserver) {
      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
    }
    this.utilityLayerScene.dispose();
  }
  _updateCamera() {
    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
    this.utilityLayerScene.activeCamera = this.getRenderCamera();
  }
};
UtilityLayerRenderer._DefaultUtilityLayer = null;
UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;

// node_modules/@babylonjs/core/XR/features/WebXRControllerPointerSelection.js
var WebXRControllerPointerSelection = class _WebXRControllerPointerSelection extends WebXRAbstractFeature {
  /**
   * constructs a new background remover module
   * @param _xrSessionManager the session manager for this module
   * @param _options read-only options to be used in this module
   */
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      const { laserPointer, selectionMesh } = this._generateNewMeshPair(this._options.forceGripIfAvailable && xrController.grip ? xrController.grip : xrController.pointer);
      this._controllers[xrController.uniqueId] = {
        xrController,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        disabledByNearInteraction: false,
        id: _WebXRControllerPointerSelection._IdCounter++
      };
      if (this._attachedController) {
        if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {
          this._attachedController = xrController.uniqueId;
        }
      } else {
        if (!this._options.enablePointerSelectionOnAllControllers) {
          this._attachedController = xrController.uniqueId;
        }
      }
      switch (xrController.inputSource.targetRayMode) {
        case "tracked-pointer":
          return this._attachTrackedPointerRayMode(xrController);
        case "gaze":
          return this._attachGazeMode(xrController);
        case "screen":
        case "transient-pointer":
          return this._attachScreenRayMode(xrController);
      }
    };
    this._controllers = {};
    this._tmpVectorForPickCompare = new Vector3();
    this.disablePointerLighting = true;
    this.disableSelectionMeshLighting = true;
    this.displayLaserPointer = true;
    this.displaySelectionMesh = true;
    this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);
    this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);
    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);
    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1);
    this._identityMatrix = Matrix.Identity();
    this._screenCoordinatesRef = Vector3.Zero();
    this._viewportRef = new Viewport(0, 0, 0, 0);
    this._scene = this._xrSessionManager.scene;
    if (this._options.lookAndPickMode === void 0 && (this._scene.getEngine()._badDesktopOS || this._scene.getEngine()._badOS)) {
      this._options.lookAndPickMode = true;
    }
    if (this._options.lookAndPickMode) {
      this._options.enablePointerSelectionOnAllControllers = true;
      this.displayLaserPointer = false;
    }
  }
  /**
   * attach this feature
   * Will usually be called by the features manager
   *
   * @returns true if successful.
   */
  attach() {
    if (!super.attach()) {
      return false;
    }
    for (const controller of this._options.xrInput.controllers) {
      this._attachController(controller);
    }
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController, true);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    }, true);
    this._scene.constantlyUpdateMeshUnderPointer = true;
    if (this._options.gazeCamera) {
      const webXRCamera = this._options.gazeCamera;
      const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);
      this._controllers["camera"] = {
        webXRCamera,
        laserPointer,
        selectionMesh,
        meshUnderPointer: null,
        pick: null,
        tmpRay: new Ray(new Vector3(), new Vector3()),
        disabledByNearInteraction: false,
        id: _WebXRControllerPointerSelection._IdCounter++
      };
      this._attachGazeMode();
    }
    return true;
  }
  /**
   * detach this feature.
   * Will usually be called by the features manager
   *
   * @returns true if successful.
   */
  detach() {
    if (!super.detach()) {
      return false;
    }
    const keys = Object.keys(this._controllers);
    for (const controllerId of keys) {
      this._detachController(controllerId);
    }
    return true;
  }
  /**
   * Will get the mesh under a specific pointer.
   * `scene.meshUnderPointer` will only return one mesh - either left or right.
   * @param controllerId the controllerId to check
   * @returns The mesh under pointer or null if no mesh is under the pointer
   */
  getMeshUnderPointer(controllerId) {
    if (this._controllers[controllerId]) {
      return this._controllers[controllerId].meshUnderPointer;
    } else {
      return null;
    }
  }
  /**
   * Get the xr controller that correlates to the pointer id in the pointer event
   *
   * @param id the pointer id to search for
   * @returns the controller that correlates to this id or null if not found
   */
  getXRControllerByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].xrController || null;
      }
    }
    return null;
  }
  /**
   * @internal
   */
  _getPointerSelectionDisabledByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].disabledByNearInteraction;
      }
    }
    return true;
  }
  /**
   * @internal
   */
  _setPointerSelectionDisabledByPointerId(id, state) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        this._controllers[keys[i]].disabledByNearInteraction = state;
        return;
      }
    }
  }
  _onXRFrame(_xrFrame) {
    const keys = Object.keys(this._controllers);
    for (const id of keys) {
      const controllerData = this._controllers[id];
      if (this._options.lookAndPickMode && controllerData.xrController?.inputSource.targetRayMode !== "transient-pointer") {
        continue;
      }
      if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController || controllerData.disabledByNearInteraction) {
        controllerData.selectionMesh.isVisible = false;
        controllerData.laserPointer.isVisible = false;
        controllerData.pick = null;
        continue;
      }
      controllerData.laserPointer.isVisible = this.displayLaserPointer;
      let controllerGlobalPosition;
      if (controllerData.xrController) {
        controllerGlobalPosition = this._options.forceGripIfAvailable && controllerData.xrController.grip ? controllerData.xrController.grip.position : controllerData.xrController.pointer.position;
        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay, this._options.forceGripIfAvailable);
      } else if (controllerData.webXRCamera) {
        controllerGlobalPosition = controllerData.webXRCamera.position;
        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);
      } else {
        continue;
      }
      if (this._options.maxPointerDistance) {
        controllerData.tmpRay.length = this._options.maxPointerDistance;
      }
      if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {
        const scene = this._xrSessionManager.scene;
        const camera = this._options.xrInput.xrCamera;
        if (camera) {
          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth() / camera.rigCameras.length, scene.getEngine().getRenderHeight(), this._viewportRef);
          Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, camera.getTransformationMatrix(), this._viewportRef, this._screenCoordinatesRef);
          if (typeof this._screenCoordinatesRef.x === "number" && typeof this._screenCoordinatesRef.y === "number" && !isNaN(this._screenCoordinatesRef.x) && !isNaN(this._screenCoordinatesRef.y) && this._screenCoordinatesRef.x !== Infinity && this._screenCoordinatesRef.y !== Infinity) {
            scene.pointerX = this._screenCoordinatesRef.x;
            scene.pointerY = this._screenCoordinatesRef.y;
            controllerData.screenCoordinates = {
              x: this._screenCoordinatesRef.x,
              y: this._screenCoordinatesRef.y
            };
          }
        }
      }
      let utilityScenePick = null;
      if (this._utilityLayerScene) {
        utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);
      }
      const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);
      if (!utilityScenePick || !utilityScenePick.hit) {
        controllerData.pick = originalScenePick;
      } else if (!originalScenePick || !originalScenePick.hit) {
        controllerData.pick = utilityScenePick;
      } else if (utilityScenePick.distance < originalScenePick.distance) {
        controllerData.pick = utilityScenePick;
      } else {
        controllerData.pick = originalScenePick;
      }
      if (controllerData.pick && controllerData.xrController) {
        controllerData.pick.aimTransform = controllerData.xrController.pointer;
        controllerData.pick.gripTransform = controllerData.xrController.grip || null;
        controllerData.pick.originMesh = controllerData.xrController.pointer;
        controllerData.tmpRay.length = controllerData.pick.distance;
      }
      const pick = controllerData.pick;
      if (pick && pick.pickedPoint && pick.hit) {
        this._updatePointerDistance(controllerData.laserPointer, pick.distance);
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);
        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);
        const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);
        const deltaFighting = 1e-3;
        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);
        if (pickNormal) {
          const axis1 = Vector3.Cross(Axis.Y, pickNormal);
          const axis2 = Vector3.Cross(pickNormal, axis1);
          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);
          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));
        }
        controllerData.selectionMesh.isVisible = this.displaySelectionMesh;
        controllerData.meshUnderPointer = pick.pickedMesh;
      } else {
        controllerData.selectionMesh.isVisible = false;
        this._updatePointerDistance(controllerData.laserPointer, 1);
        controllerData.meshUnderPointer = null;
      }
    }
  }
  get _utilityLayerScene() {
    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;
  }
  _attachGazeMode(xrController) {
    const controllerData = this._controllers[xrController && xrController.uniqueId || "camera"];
    const timeToSelect = this._options.timeToSelect || 3e3;
    const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;
    let oldPick = new PickingInfo();
    const discMesh = CreateTorus("selection", {
      diameter: 35e-4 * 15,
      thickness: 25e-4 * 6,
      tessellation: 20
    }, sceneToRenderTo);
    discMesh.isVisible = false;
    discMesh.isPickable = false;
    discMesh.parent = controllerData.selectionMesh;
    let timer = 0;
    let downTriggered = false;
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      if (!controllerData.pick) {
        return;
      }
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      controllerData.laserPointer.material.alpha = 0;
      discMesh.isVisible = false;
      if (controllerData.pick.hit) {
        if (!this._pickingMoved(oldPick, controllerData.pick)) {
          if (timer > timeToSelect / 10) {
            discMesh.isVisible = true;
          }
          timer += this._scene.getEngine().getDeltaTime();
          if (timer >= timeToSelect) {
            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
            downTriggered = true;
            if (this._options.disablePointerUpOnTouchOut) {
              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
            }
            discMesh.isVisible = false;
          } else {
            const scaleFactor = 1 - timer / timeToSelect;
            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);
          }
        } else {
          if (downTriggered) {
            if (!this._options.disablePointerUpOnTouchOut) {
              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
            }
          }
          downTriggered = false;
          timer = 0;
        }
      } else {
        downTriggered = false;
        timer = 0;
      }
      this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      oldPick = controllerData.pick;
    });
    if (this._options.renderingGroupId !== void 0) {
      discMesh.renderingGroupId = this._options.renderingGroupId;
    }
    if (xrController) {
      xrController.onDisposeObservable.addOnce(() => {
        if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.finalPointerUpTriggered = true;
        }
        discMesh.dispose();
      });
    }
  }
  _attachScreenRayMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    let downTriggered = false;
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      if (!controllerData.pick || this._options.disablePointerUpOnTouchOut && downTriggered) {
        return;
      }
      if (!downTriggered) {
        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
        controllerData.pointerDownTriggered = true;
        downTriggered = true;
        if (this._options.disablePointerUpOnTouchOut) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
        }
      } else {
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
    });
    xrController.onDisposeObservable.addOnce(() => {
      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
      this._xrSessionManager.runInXRFrame(() => {
        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.finalPointerUpTriggered = true;
        }
      });
    });
  }
  _attachTrackedPointerRayMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    if (this._options.forceGazeMode) {
      return this._attachGazeMode(xrController);
    }
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;
      controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;
      if (controllerData.pick) {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
    });
    if (xrController.inputSource.gamepad) {
      const init = (motionController) => {
        if (this._options.overrideButtonId) {
          controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);
        }
        if (!controllerData.selectionComponent) {
          controllerData.selectionComponent = motionController.getMainComponent();
        }
        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {
          if (component.changes.pressed) {
            const pressed = component.changes.pressed.current;
            if (controllerData.pick) {
              if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {
                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
                if (pressed) {
                  this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
                  controllerData.pointerDownTriggered = true;
                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;
                  controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;
                } else {
                  this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;
                  controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;
                }
              }
            } else {
              if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {
                const prevController = this._controllers[this._attachedController];
                if (prevController && prevController.pointerDownTriggered && !prevController.finalPointerUpTriggered) {
                  this._augmentPointerInit(pointerEventInit, prevController.id, prevController.screenCoordinates);
                  this._scene.simulatePointerUp(new PickingInfo(), {
                    pointerId: prevController.id,
                    pointerType: "xr"
                  });
                  prevController.finalPointerUpTriggered = true;
                }
                this._attachedController = xrController.uniqueId;
              }
            }
          }
        });
      };
      if (xrController.motionController) {
        init(xrController.motionController);
      } else {
        xrController.onMotionControllerInitObservable.add(init);
      }
    } else {
      const selectStartListener = (event) => {
        this._xrSessionManager.onXRFrameObservable.addOnce(() => {
          this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
          if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
            controllerData.pointerDownTriggered = true;
            controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;
            controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;
          }
        });
      };
      const selectEndListener = (event) => {
        this._xrSessionManager.onXRFrameObservable.addOnce(() => {
          this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
          if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {
            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
            controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;
            controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;
          }
        });
      };
      controllerData.eventListeners = {
        selectend: selectEndListener,
        selectstart: selectStartListener
      };
      this._xrSessionManager.session.addEventListener("selectstart", selectStartListener);
      this._xrSessionManager.session.addEventListener("selectend", selectEndListener);
    }
  }
  _convertNormalToDirectionOfRay(normal, ray) {
    if (normal) {
      const angle = Math.acos(Vector3.Dot(normal, ray.direction));
      if (angle < Math.PI / 2) {
        normal.scaleInPlace(-1);
      }
    }
    return normal;
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.selectionComponent) {
      if (controllerData.onButtonChangedObserver) {
        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    if (controllerData.onFrameObserver) {
      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);
    }
    if (controllerData.eventListeners) {
      const keys = Object.keys(controllerData.eventListeners);
      for (const eventName of keys) {
        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];
        if (func) {
          this._xrSessionManager.session.removeEventListener(eventName, func);
        }
      }
    }
    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {
      const pointerEventInit = {
        pointerId: controllerData.id,
        pointerType: "xr"
      };
      this._xrSessionManager.runInXRFrame(() => {
        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);
        this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);
        controllerData.finalPointerUpTriggered = true;
      });
    }
    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {
      try {
        controllerData.selectionMesh.dispose();
        controllerData.laserPointer.dispose();
        delete this._controllers[xrControllerUniqueId];
        if (this._attachedController === xrControllerUniqueId) {
          const keys = Object.keys(this._controllers);
          if (keys.length) {
            this._attachedController = keys[0];
          } else {
            this._attachedController = "";
          }
        }
      } catch (e) {
        Tools.Warn("controller already detached.");
      }
    });
  }
  _generateNewMeshPair(meshParent) {
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder("laserPointer", {
      height: 1,
      diameterTop: 2e-4,
      diameterBottom: 4e-3,
      tessellation: 20,
      subdivisions: 1
    }, sceneToRenderTo);
    laserPointer.parent = meshParent;
    const laserPointerMaterial = new StandardMaterial("laserPointerMat", sceneToRenderTo);
    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;
    laserPointerMaterial.alpha = 0.7;
    laserPointer.material = laserPointerMaterial;
    laserPointer.rotation.x = Math.PI / 2;
    this._updatePointerDistance(laserPointer, 1);
    laserPointer.isPickable = false;
    laserPointer.isVisible = false;
    const selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus("gazeTracker", {
      diameter: 35e-4 * 3,
      thickness: 25e-4 * 3,
      tessellation: 20
    }, sceneToRenderTo);
    selectionMesh.bakeCurrentTransformIntoVertices();
    selectionMesh.isPickable = false;
    selectionMesh.isVisible = false;
    const targetMat = new StandardMaterial("targetMat", sceneToRenderTo);
    targetMat.specularColor = Color3.Black();
    targetMat.emissiveColor = this.selectionMeshDefaultColor;
    targetMat.backFaceCulling = false;
    selectionMesh.material = targetMat;
    if (this._options.renderingGroupId !== void 0) {
      laserPointer.renderingGroupId = this._options.renderingGroupId;
      selectionMesh.renderingGroupId = this._options.renderingGroupId;
    }
    return {
      laserPointer,
      selectionMesh
    };
  }
  _pickingMoved(oldPick, newPick) {
    if (!oldPick.hit || !newPick.hit) {
      return true;
    }
    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {
      return true;
    }
    if (oldPick.pickedMesh !== newPick.pickedMesh) {
      return true;
    }
    oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);
    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));
    const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;
    const length = this._tmpVectorForPickCompare.length();
    if (length > delta) {
      return true;
    }
    return false;
  }
  _updatePointerDistance(_laserPointer, distance = 100) {
    _laserPointer.scaling.y = distance;
    if (this._scene.useRightHandedSystem) {
      distance *= -1;
    }
    _laserPointer.position.z = distance / 2 + 0.05;
  }
  _augmentPointerInit(pointerEventInit, id, screenCoordinates) {
    pointerEventInit.pointerId = id;
    pointerEventInit.pointerType = "xr";
    if (screenCoordinates) {
      pointerEventInit.screenX = screenCoordinates.x;
      pointerEventInit.screenY = screenCoordinates.y;
    }
  }
  /** @internal */
  get lasterPointerDefaultColor() {
    return this.laserPointerDefaultColor;
  }
};
WebXRControllerPointerSelection._IdCounter = 200;
WebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;
WebXRControllerPointerSelection.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {
  return () => new WebXRControllerPointerSelection(xrSessionManager, options);
}, WebXRControllerPointerSelection.Version, true);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
(function(NodeMaterialBlockConnectionPointTypes2) {
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["All"] = 4095] = "All";
})(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
(function(NodeMaterialBlockTargets2) {
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
})(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState = class {
  constructor() {
    this.supportUniformBuffers = false;
    this.attributes = [];
    this.uniforms = [];
    this.constants = [];
    this.samplers = [];
    this.functions = {};
    this.extensions = {};
    this.prePassOutput = {};
    this.counters = {};
    this._terminalBlocks = /* @__PURE__ */ new Set();
    this._attributeDeclaration = "";
    this._uniformDeclaration = "";
    this._constantDeclaration = "";
    this._samplerDeclaration = "";
    this._varyingTransfer = "";
    this._injectAtEnd = "";
    this._injectAtTop = "";
    this._customEntryHeader = "";
    this._repeatableContentAnchorIndex = 0;
    this._builtCompilationString = "";
    this.compilationString = "";
  }
  /**
   * Gets the current shader language to use
   */
  get shaderLanguage() {
    return this.sharedData.nodeMaterial.shaderLanguage;
  }
  /** Gets suffix to add behind type casting */
  get fSuffix() {
    return this.shaderLanguage === 1 ? "f" : "";
  }
  /**
   * Returns the processed, compiled shader code
   * @param defines defines to use for the shader processing
   * @returns the raw shader code used by the engine
   */
  async getProcessedShaderAsync(defines) {
    if (!this._builtCompilationString) {
      Logger.Error("getProcessedShaderAsync: Shader not built yet.");
      return "";
    }
    const engine = this.sharedData.nodeMaterial.getScene().getEngine();
    const options = {
      defines: defines.split("\n"),
      indexParameters: void 0,
      isFragment: this.target === NodeMaterialBlockTargets.Fragment,
      shouldUseHighPrecisionShader: engine._shouldUseHighPrecisionShader,
      processor: engine._getShaderProcessor(this.shaderLanguage),
      supportsUniformBuffers: engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this.shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this.shaderLanguage),
      version: (engine.version * 100).toString(),
      platformName: engine.shaderPlatformName,
      processingContext: null,
      isNDCHalfZRange: engine.isNDCHalfZRange,
      useReverseDepthBuffer: engine.useReverseDepthBuffer
    };
    if (!engine.isWebGPU && engine.version > 1) {
      options.processor = new WebGLShaderProcessor();
    }
    return await new Promise((resolve) => {
      Process(this._builtCompilationString, options, (migratedCode, _) => {
        resolve(migratedCode);
      }, engine);
    });
  }
  /**
   * Finalize the compilation strings
   * @param state defines the current compilation state
   */
  finalize(state) {
    const emitComments = state.sharedData.emitComments;
    const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
    let entryPointString = `
${emitComments ? "//Entry point\n" : ""}`;
    if (this._customEntryHeader) {
      entryPointString += this._customEntryHeader;
    } else if (this.shaderLanguage === 1) {
      if (isFragmentMode) {
        entryPointString += `@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
${this.sharedData.varyingInitializationsFragment}`;
      } else {
        entryPointString += `@vertex
fn main(input: VertexInputs) -> FragmentInputs{
`;
      }
    } else {
      entryPointString += `void main(void) {
`;
    }
    this.compilationString = entryPointString + this.compilationString;
    if (this._constantDeclaration) {
      this.compilationString = `
${emitComments ? "//Constants\n" : ""}${this._constantDeclaration}
${this.compilationString}`;
    }
    let functionCode = "";
    for (const functionName in this.functions) {
      functionCode += this.functions[functionName] + `
`;
    }
    this.compilationString = `
${functionCode}
${this.compilationString}`;
    if (!isFragmentMode && this._varyingTransfer) {
      this.compilationString = `${this.compilationString}
${this._varyingTransfer}`;
    }
    if (this._injectAtEnd) {
      this.compilationString = `${this.compilationString}
${this._injectAtEnd}`;
    }
    this.compilationString = `${this.compilationString}
}`;
    if (this.sharedData.varyingDeclaration) {
      this.compilationString = `
${emitComments ? "//Varyings\n" : ""}${isFragmentMode ? this.sharedData.varyingDeclarationFragment : this.sharedData.varyingDeclaration}
${this.compilationString}`;
    }
    if (this._samplerDeclaration) {
      this.compilationString = `
${emitComments ? "//Samplers\n" : ""}${this._samplerDeclaration}
${this.compilationString}`;
    }
    if (this._uniformDeclaration) {
      this.compilationString = `
${emitComments ? "//Uniforms\n" : ""}${this._uniformDeclaration}
${this.compilationString}`;
    }
    if (this._attributeDeclaration && !isFragmentMode) {
      this.compilationString = `
${emitComments ? "//Attributes\n" : ""}${this._attributeDeclaration}
${this.compilationString}`;
    }
    if (this.shaderLanguage !== 1) {
      this.compilationString = "precision highp float;\n" + this.compilationString;
      this.compilationString = "#if defined(WEBGL2) || defined(WEBGPU)\nprecision highp sampler2DArray;\n#endif\n" + this.compilationString;
      if (isFragmentMode) {
        this.compilationString = "#if defined(PREPASS)\r\n#extension GL_EXT_draw_buffers : require\r\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r\nhighp vec4 gl_FragColor;\r\n#endif\r\n" + this.compilationString;
      }
      for (const extensionName in this.extensions) {
        const extension = this.extensions[extensionName];
        this.compilationString = `
${extension}
${this.compilationString}`;
      }
    }
    if (this._injectAtTop) {
      this.compilationString = `${this._injectAtTop}
${this.compilationString}`;
    }
    this._builtCompilationString = this.compilationString;
  }
  /** @internal */
  get _repeatableContentAnchor() {
    return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;
  }
  /**
   * @internal
   */
  _getFreeVariableName(prefix) {
    prefix = this.sharedData.formatConfig.formatVariablename(prefix);
    if (this.sharedData.variableNames[prefix] === void 0) {
      this.sharedData.variableNames[prefix] = 0;
      if (prefix === "output" || prefix === "texture") {
        return prefix + this.sharedData.variableNames[prefix];
      }
      return prefix;
    } else {
      this.sharedData.variableNames[prefix]++;
    }
    return prefix + this.sharedData.variableNames[prefix];
  }
  /**
   * @internal
   */
  _getFreeDefineName(prefix) {
    if (this.sharedData.defineNames[prefix] === void 0) {
      this.sharedData.defineNames[prefix] = 0;
    } else {
      this.sharedData.defineNames[prefix]++;
    }
    return prefix + this.sharedData.defineNames[prefix];
  }
  /**
   * @internal
   */
  _excludeVariableName(name) {
    this.sharedData.variableNames[name] = 0;
  }
  /**
   * @internal
   */
  _emit2DSampler(name, define = "", force = false, annotation, unsignedSampler, precision) {
    if (this.samplers.indexOf(name) < 0 || force) {
      if (define) {
        this._samplerDeclaration += `#if ${define}
`;
      }
      if (this.shaderLanguage === 1) {
        const unsignedSamplerPrefix = unsignedSampler ? "u" : "f";
        this._samplerDeclaration += `var ${name + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name}: texture_2d<${unsignedSamplerPrefix}32>;
`;
      } else {
        const unsignedSamplerPrefix = unsignedSampler ? "u" : "";
        const precisionDecl = precision ?? "";
        this._samplerDeclaration += `uniform ${precisionDecl} ${unsignedSamplerPrefix}sampler2D ${name}; ${annotation ? annotation : ""}
`;
      }
      if (define) {
        this._samplerDeclaration += `#endif
`;
      }
      if (!force) {
        this.samplers.push(name);
      }
    }
  }
  /**
   * @internal
   */
  _emitCubeSampler(name, define = "", force = false) {
    if (this.samplers.indexOf(name) < 0 || force) {
      if (define) {
        this._samplerDeclaration += `#if ${define}
`;
      }
      if (this.shaderLanguage === 1) {
        this._samplerDeclaration += `var ${name + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name}: texture_cube<f32>;
`;
      } else {
        this._samplerDeclaration += `uniform samplerCube ${name};
`;
      }
      if (define) {
        this._samplerDeclaration += `#endif
`;
      }
      if (!force) {
        this.samplers.push(name);
      }
    }
  }
  /**
   * @internal
   */
  _emit2DArraySampler(name) {
    if (this.samplers.indexOf(name) < 0) {
      if (this.shaderLanguage === 1) {
        this._samplerDeclaration += `var ${name + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name}: texture_2d_array<f32>;
`;
      } else {
        this._samplerDeclaration += `uniform sampler2DArray ${name};
`;
      }
      this.samplers.push(name);
    }
  }
  /**
   * @internal
   */
  _getGLType(type) {
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return "mat4";
    }
    return "";
  }
  /**
   * @internal
   */
  _getShaderType(type) {
    const isWGSL = this.shaderLanguage === 1;
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return isWGSL ? "f32" : "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return isWGSL ? "i32" : "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return isWGSL ? "vec2f" : "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return isWGSL ? "vec3f" : "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return isWGSL ? "vec4f" : "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return isWGSL ? "mat4x4f" : "mat4";
    }
    return "";
  }
  /**
   * @internal
   */
  _emitExtension(name, extension, define = "") {
    if (this.extensions[name]) {
      return;
    }
    if (define) {
      extension = `#if ${define}
${extension}
#endif`;
    }
    this.extensions[name] = extension;
  }
  /**
   * @internal
   */
  _emitFunction(name, code, comments) {
    if (this.functions[name]) {
      return;
    }
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    this.functions[name] = code;
  }
  /**
   * @internal
   */
  _emitCodeFromInclude(includeName, comments, options) {
    const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
    if (options && options.repeatKey) {
      return `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
    }
    let code = store[includeName] + "\n";
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    if (!options) {
      return code;
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        code = code.replace(replaceString.search, replaceString.replace);
      }
    }
    return code;
  }
  /**
   * @internal
   */
  _emitFunctionFromInclude(includeName, comments, options, storeKey = "") {
    const key = includeName + storeKey;
    if (this.functions[key]) {
      return;
    }
    const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
      if (options && options.repeatKey) {
        this.functions[key] = `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
      } else {
        this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? "(" + options?.substitutionVars + ")" : ""}
`;
      }
      if (this.sharedData.emitComments) {
        this.functions[key] = comments + `
` + this.functions[key];
      }
      return;
    }
    this.functions[key] = store[includeName];
    if (this.sharedData.emitComments) {
      this.functions[key] = comments + `
` + this.functions[key];
    }
    if (options.removeIfDef) {
      this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
    }
    if (options.removeAttributes) {
      this.functions[key] = this.functions[key].replace(/\s*?attribute .+?;/g, "\n");
    }
    if (options.removeUniforms) {
      this.functions[key] = this.functions[key].replace(/\s*?uniform .*?;/g, "\n");
    }
    if (options.removeVaryings) {
      this.functions[key] = this.functions[key].replace(/\s*?(varying|in) .+?;/g, "\n");
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
      }
    }
  }
  /**
   * @internal
   */
  _registerTempVariable(name) {
    if (this.sharedData.temps.indexOf(name) !== -1) {
      return false;
    }
    this.sharedData.temps.push(name);
    return true;
  }
  /**
   * @internal
   */
  _emitVaryingFromString(name, type, define = "", notDefine = false) {
    if (this.sharedData.varyings.indexOf(name) !== -1) {
      return false;
    }
    this.sharedData.varyings.push(name);
    const shaderType = this._getShaderType(type);
    const emitCode = (forFragment = false) => {
      let code = "";
      if (define) {
        if (define.startsWith("defined(")) {
          code += `#if ${define}
`;
        } else {
          code += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
        }
      }
      if (this.shaderLanguage === 1) {
        switch (shaderType) {
          case "mat4x4f":
            code += `varying ${name}_r0: vec4f;
`;
            code += `varying ${name}_r1: vec4f;
`;
            code += `varying ${name}_r2: vec4f;
`;
            code += `varying ${name}_r3: vec4f;
`;
            if (forFragment) {
              code += `var<private> ${name}: mat4x4f;
`;
              this.sharedData.varyingInitializationsFragment += `${name} = mat4x4f(fragmentInputs.${name}_r0, fragmentInputs.${name}_r1, fragmentInputs.${name}_r2, fragmentInputs.${name}_r3);
`;
            }
            break;
          default:
            code += `varying ${name}: ${shaderType};
`;
            break;
        }
      } else {
        code += `varying ${shaderType} ${name};
`;
      }
      if (define) {
        code += `#endif
`;
      }
      return code;
    };
    if (this.shaderLanguage === 1) {
      this.sharedData.varyingDeclaration += emitCode(false);
      this.sharedData.varyingDeclarationFragment += emitCode(true);
    } else {
      const code = emitCode();
      this.sharedData.varyingDeclaration += code;
      this.sharedData.varyingDeclarationFragment += code;
    }
    return true;
  }
  /**
   * @internal
   */
  _getVaryingName(name) {
    if (this.shaderLanguage === 1) {
      return (this.target !== NodeMaterialBlockTargets.Fragment ? "vertexOutputs." : "fragmentInputs.") + name;
    }
    return name;
  }
  /**
   * @internal
   */
  _emitUniformFromString(name, type, define = "", notDefine = false) {
    if (this.uniforms.indexOf(name) !== -1) {
      return;
    }
    this.uniforms.push(name);
    if (define) {
      if (define.startsWith("defined(")) {
        this._uniformDeclaration += `#if ${define}
`;
      } else {
        this._uniformDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
    }
    if (this.sharedData.formatConfig.getUniformAnnotation) {
      this._uniformDeclaration += this.sharedData.formatConfig.getUniformAnnotation(name);
    }
    const shaderType = this._getShaderType(type);
    if (this.shaderLanguage === 1) {
      this._uniformDeclaration += `uniform ${name}: ${shaderType};
`;
    } else {
      this._uniformDeclaration += `uniform ${shaderType} ${name};
`;
    }
    if (define) {
      this._uniformDeclaration += `#endif
`;
    }
  }
  /**
   * @internal
   */
  _generateTernary(trueStatement, falseStatement, condition) {
    if (this.shaderLanguage === 1) {
      return `select(${falseStatement}, ${trueStatement}, ${condition})`;
    }
    return `(${condition}) ? ${trueStatement} : ${falseStatement}`;
  }
  /**
   * @internal
   */
  _emitFloat(value) {
    if (value.toString() === value.toFixed(0)) {
      return `${value}.0`;
    }
    return value.toString();
  }
  /**
   * @internal
   */
  _declareOutput(output, isConst) {
    return this._declareLocalVar(output.associatedVariableName, output.type, isConst);
  }
  /**
   * @internal
   */
  _declareLocalVar(name, type, isConst) {
    if (this.shaderLanguage === 1) {
      return `${isConst ? "const" : "var"} ${name}: ${this._getShaderType(type)}`;
    } else {
      return `${isConst ? "const " : ""}${this._getShaderType(type)} ${name}`;
    }
  }
  /**
   * @internal
   */
  _samplerCubeFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSample";
    }
    return "textureCube";
  }
  /**
   * @internal
   */
  _samplerFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSample";
    }
    return "texture2D";
  }
  /**
   * @internal
   */
  _samplerLODFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSampleLevel";
    }
    return "texture2DLodEXT";
  }
  _toLinearSpace(output) {
    if (this.shaderLanguage === 1) {
      if (output.type === NodeMaterialBlockConnectionPointTypes.Color3 || output.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
        return `toLinearSpaceVec3(${output.associatedVariableName})`;
      }
      return `toLinearSpace(${output.associatedVariableName})`;
    }
    return `toLinearSpace(${output.associatedVariableName})`;
  }
  /**
   * @internal
   */
  _generateTextureSample(uv, samplerName) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
    }
    return `${this._samplerFunc()}(${samplerName}, ${uv})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleLOD(uv, samplerName, lod) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerLODFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
    }
    return `${this._samplerLODFunc()}(${samplerName}, ${uv}, ${lod})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleCube(uv, samplerName) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
    }
    return `${this._samplerCubeFunc()}(${samplerName}, ${uv})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleCubeLOD(uv, samplerName, lod) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
    }
    return `${this._samplerCubeFunc()}(${samplerName}, ${uv}, ${lod})`;
  }
  _convertVariableDeclarationToWGSL(type, dest, source) {
    return source.replace(new RegExp(`(${type})\\s+(\\w+)`, "g"), `var $2: ${dest}`);
  }
  _convertVariableConstructorsToWGSL(type, dest, source) {
    return source.replace(new RegExp(`(${type})\\(`, "g"), ` ${dest}(`);
  }
  _convertOutParametersToWGSL(source) {
    return source.replace(new RegExp(`out\\s+var\\s+(\\w+)\\s*:\\s*(\\w+)`, "g"), `$1: ptr<function, $2>`);
  }
  _convertTernaryOperandsToWGSL(source) {
    return source.replace(new RegExp(`\\[(.*?)\\?(.*?):(.*)\\]`, "g"), (match, condition, trueCase, falseCase) => `select(${falseCase}, ${trueCase}, ${condition})`);
  }
  _convertModOperatorsToWGSL(source) {
    return source.replace(new RegExp(`mod\\((.+?),\\s*(.+?)\\)`, "g"), (match, left, right) => `((${left})%(${right}))`);
  }
  _convertConstToWGSL(source) {
    return source.replace(new RegExp(`const var`, "g"), `const`);
  }
  _convertInnerFunctionsToWGSL(source) {
    return source.replace(new RegExp(`inversesqrt`, "g"), `inverseSqrt`);
  }
  _convertFunctionsToWGSL(source) {
    const regex = /var\s+(\w+)\s*:\s*(\w+)\((.*)\)/g;
    let match;
    while ((match = regex.exec(source)) !== null) {
      const funcName = match[1];
      const funcType = match[2];
      const params = match[3];
      const formattedParams = params.replace(/var\s/g, "");
      source = source.replace(match[0], `fn ${funcName}(${formattedParams}) -> ${funcType}`);
    }
    return source;
  }
  _babylonSLtoWGSL(code) {
    code = this._convertVariableDeclarationToWGSL("void", "voidnull", code);
    code = this._convertVariableDeclarationToWGSL("bool", "bool", code);
    code = this._convertVariableDeclarationToWGSL("int", "i32", code);
    code = this._convertVariableDeclarationToWGSL("uint", "u32", code);
    code = this._convertVariableDeclarationToWGSL("float", "f32", code);
    code = this._convertVariableDeclarationToWGSL("vec2", "vec2f", code);
    code = this._convertVariableDeclarationToWGSL("vec3", "vec3f", code);
    code = this._convertVariableDeclarationToWGSL("vec4", "vec4f", code);
    code = this._convertVariableDeclarationToWGSL("mat2", "mat2x2f", code);
    code = this._convertVariableDeclarationToWGSL("mat3", "mat3x3f", code);
    code = this._convertVariableDeclarationToWGSL("mat4", "mat4x4f", code);
    code = this._convertVariableConstructorsToWGSL("float", "f32", code);
    code = this._convertVariableConstructorsToWGSL("vec2", "vec2f", code);
    code = this._convertVariableConstructorsToWGSL("vec3", "vec3f", code);
    code = this._convertVariableConstructorsToWGSL("vec4", "vec4f", code);
    code = this._convertVariableConstructorsToWGSL("mat2", "mat2x2f", code);
    code = this._convertVariableConstructorsToWGSL("mat3", "mat3x3f", code);
    code = this._convertVariableConstructorsToWGSL("mat4", "mat4x4f", code);
    code = this._convertTernaryOperandsToWGSL(code);
    code = this._convertModOperatorsToWGSL(code);
    code = this._convertConstToWGSL(code);
    code = this._convertInnerFunctionsToWGSL(code);
    code = this._convertOutParametersToWGSL(code);
    code = code.replace(/\[\*\]/g, "*");
    code = this._convertFunctionsToWGSL(code);
    code = code.replace(/\s->\svoidnull/g, "");
    code = code.replace(/dFdx/g, "dpdx");
    code = code.replace(/dFdy/g, "dpdy");
    return code;
  }
  _convertTernaryOperandsToGLSL(source) {
    return source.replace(new RegExp(`\\[(.+?)\\?(.+?):(.+)\\]`, "g"), (match, condition, trueCase, falseCase) => `${condition} ? ${trueCase} : ${falseCase}`);
  }
  _babylonSLtoGLSL(code) {
    code = code.replace(/\[\*\]/g, "");
    code = this._convertTernaryOperandsToGLSL(code);
    return code;
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData = class {
  /** Creates a new shared data */
  constructor() {
    this.temps = [];
    this.varyings = [];
    this.varyingDeclaration = "";
    this.varyingDeclarationFragment = "";
    this.varyingInitializationsFragment = "";
    this.inputBlocks = [];
    this.textureBlocks = [];
    this.bindableBlocks = [];
    this.forcedBindableBlocks = [];
    this.blocksWithFallbacks = [];
    this.blocksWithDefines = [];
    this.repeatableContentBlocks = [];
    this.dynamicUniformBlocks = [];
    this.blockingBlocks = [];
    this.animatedInputs = [];
    this.formatConfig = {
      getUniformAnnotation: null,
      formatVariablename: (name) => name.replace(/[^a-zA-Z_]+/g, "")
    };
    this.variableNames = {};
    this.defineNames = {};
    this.hints = {
      needWorldViewMatrix: false,
      needWorldViewProjectionMatrix: false,
      needAlphaBlending: false,
      needAlphaTesting: false
    };
    this.checks = {
      emitVertex: false,
      emitFragment: false,
      notConnectedNonOptionalInputs: new Array(),
      customErrors: new Array()
    };
    this.allowEmptyVertexProgram = false;
    this.variableNames["position"] = 0;
    this.variableNames["normal"] = 0;
    this.variableNames["tangent"] = 0;
    this.variableNames["uv"] = 0;
    this.variableNames["uv2"] = 0;
    this.variableNames["uv3"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv5"] = 0;
    this.variableNames["uv6"] = 0;
    this.variableNames["color"] = 0;
    this.variableNames["matricesIndices"] = 0;
    this.variableNames["matricesWeights"] = 0;
    this.variableNames["matricesIndicesExtra"] = 0;
    this.variableNames["matricesWeightsExtra"] = 0;
    this.variableNames["diffuseBase"] = 0;
    this.variableNames["specularBase"] = 0;
    this.variableNames["worldPos"] = 0;
    this.variableNames["shadow"] = 0;
    this.variableNames["view"] = 0;
    this.variableNames["vTBN"] = 0;
    this.defineNames["MAINUV0"] = 0;
    this.defineNames["MAINUV1"] = 0;
    this.defineNames["MAINUV2"] = 0;
    this.defineNames["MAINUV3"] = 0;
    this.defineNames["MAINUV4"] = 0;
    this.defineNames["MAINUV5"] = 0;
    this.defineNames["MAINUV6"] = 0;
    this.defineNames["MAINUV7"] = 0;
  }
  /**
   * Push a new error to the build state, avoiding exceptions that can break the build process
   * @param message defines the error message to push
   */
  raiseBuildError(message) {
    if (this.checks.customErrors.indexOf(message) !== -1) {
      this.checks.customErrors.push(message);
    }
  }
  /**
   * Emits console errors and exceptions if there is a failing check
   * @returns true if all checks pass
   */
  emitErrors() {
    let errorMessage = "";
    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
      errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.\n";
    }
    if (!this.checks.emitFragment) {
      errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.\n";
    }
    for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {
      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
    }
    for (const customError of this.checks.customErrors) {
      errorMessage += customError + "\n";
    }
    if (errorMessage) {
      errorMessage = "Node material build failed: \n" + errorMessage;
      Logger.Error(errorMessage);
      this.nodeMaterial.onBuildErrorObservable.notifyObservers(errorMessage);
      return false;
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates;
(function(NodeMaterialConnectionPointCompatibilityStates2) {
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["HierarchyIssue"] = 3] = "HierarchyIssue";
})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
var NodeMaterialConnectionPointDirection;
(function(NodeMaterialConnectionPointDirection2) {
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
var NodeMaterialConnectionPoint = class _NodeMaterialConnectionPoint {
  /**
   * Checks if two types are equivalent
   * @param type1 type 1 to check
   * @param type2 type 2 to check
   * @returns true if both types are equivalent, else false
   */
  static AreEquivalentTypes(type1, type2) {
    switch (type1) {
      case NodeMaterialBlockConnectionPointTypes.Vector3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Vector4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
          return true;
        }
        break;
      }
    }
    return false;
  }
  /**
   * Boolean used to provide visual clue to users when some ports are not active in the current block configuration
   */
  get isInactive() {
    return this._isInactive;
  }
  get _connectedPoint() {
    return this._connectedPointBackingField;
  }
  set _connectedPoint(value) {
    if (this._connectedPointBackingField === value) {
      return;
    }
    this._connectedPointTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._connectedPointBackingField = value);
    if (this._connectedPointBackingField) {
      this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** @internal */
  get _typeConnectionSource() {
    return this._typeConnectionSourceBackingField;
  }
  /** @internal */
  set _typeConnectionSource(value) {
    if (this._typeConnectionSourceBackingField === value) {
      return;
    }
    this._typeConnectionSourceTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._typeConnectionSourceBackingField = value);
    if (this._typeConnectionSourceBackingField) {
      this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** @internal */
  get _defaultConnectionPointType() {
    return this._defaultConnectionPointTypeBackingField;
  }
  /** @internal */
  set _defaultConnectionPointType(value) {
    this._updateTypeDependentState(() => this._defaultConnectionPointTypeBackingField = value);
  }
  /** @internal */
  get _linkedConnectionSource() {
    return this._linkedConnectionSourceBackingField;
  }
  /** @internal */
  set _linkedConnectionSource(value) {
    if (this._linkedConnectionSourceBackingField === value) {
      return;
    }
    this._linkedConnectionSourceTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._linkedConnectionSourceBackingField = value);
    this._isMainLinkSource = false;
    if (this._linkedConnectionSourceBackingField) {
      this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** Gets the direction of the point */
  get direction() {
    return this._direction;
  }
  /**
   * Gets the declaration variable name in the shader
   */
  get declarationVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.declarationVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.declarationVariableName;
    }
    return this._associatedVariableName;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.associatedVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.associatedVariableName;
    }
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
  get innerType() {
    if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource) {
        if (this._linkedConnectionSource.isConnected) {
          if (this._linkedConnectionSource.connectedPoint._redirectedSource && this._linkedConnectionSource.connectedPoint._redirectedSource.isConnected) {
            return this._linkedConnectionSource.connectedPoint._redirectedSource.type;
          }
          return this._linkedConnectionSource.type;
        }
        if (this._linkedConnectionSource._defaultConnectionPointType) {
          return this._linkedConnectionSource._defaultConnectionPointType;
        }
      }
      if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
          return this._defaultConnectionPointType;
        }
        return this._typeConnectionSource.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._updateTypeDependentState(() => this._type = value);
  }
  /** Gets or sets the target of that connection point */
  get target() {
    if (!this._prioritizeVertex || !this._ownerBlock) {
      return this._target;
    }
    if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
      return this._target;
    }
    if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      return NodeMaterialBlockTargets.Fragment;
    }
    return NodeMaterialBlockTargets.Vertex;
  }
  set target(value) {
    this._target = value;
  }
  /**
   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
   */
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  /**
   * Gets a boolean indicating that the current point is connected to an input block
   */
  get isConnectedToInputBlock() {
    return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
  }
  /**
   * Gets a the connected input block (if any)
   */
  get connectInputBlock() {
    if (!this.isConnectedToInputBlock) {
      return null;
    }
    return this.connectedPoint.ownerBlock;
  }
  /** Get the other side of the connection (if any) */
  get connectedPoint() {
    return this._connectedPoint;
  }
  /** Get the block that owns this connection point */
  get ownerBlock() {
    return this._ownerBlock;
  }
  /** Get the block connected on the other side of this connection (if any) */
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  /** Get the block connected on the endpoints of this connection (if any) */
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  /** Gets the list of connected endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /** Gets a boolean indicating if that output point is connected to at least one input */
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  /** Gets a boolean indicating that this connection has a path to the vertex output*/
  get isDirectlyConnectedToVertexOutput() {
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the vertex shader */
  get isConnectedInVertexShader() {
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader */
  get isConnectedInFragmentShader() {
    if (this.target === NodeMaterialBlockTargets.Fragment) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.isConnectedInFragmentShader()) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Creates a block suitable to be used as an input for this input point.
   * If null is returned, a block based on the point type will be created.
   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
   */
  createCustomInputBlock() {
    return null;
  }
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   */
  constructor(name, ownerBlock, direction) {
    this._isInactive = false;
    this._preventBubbleUp = false;
    this._connectedPointBackingField = null;
    this._endpoints = new Array();
    this._redirectedSource = null;
    this._typeConnectionSourceBackingField = null;
    this._defaultConnectionPointTypeBackingField = null;
    this._isMainLinkSource = false;
    this._linkedConnectionSourceBackingField = null;
    this._acceptedConnectionPointType = null;
    this._type = NodeMaterialBlockConnectionPointTypes.Float;
    this._enforceAssociatedVariableName = false;
    this._forPostBuild = false;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = [];
    this.excludedConnectionPointTypes = [];
    this.onConnectionObservable = new Observable();
    this.onDisconnectionObservable = new Observable();
    this.onTypeChangedObservable = new Observable();
    this._isTypeChangeObservableNotifying = false;
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._prioritizeVertex = false;
    this._target = NodeMaterialBlockTargets.VertexAndFragment;
    this._ownerBlock = ownerBlock;
    this.name = name;
    this._direction = direction;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialConnectionPoint"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialConnectionPoint";
  }
  /**
   * Gets a boolean indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a boolean
   */
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === 0;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
        return 2;
      }
      for (const output of otherBlock.outputs) {
        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {
          return 2;
        }
      }
    }
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (_NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {
        return 0;
      }
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && _NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
        return 0;
      } else {
        return 1;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return 1;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === 0) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return 3;
    }
    return 0;
  }
  /**
   * Connect this point to another connection point
   * @param connectionPoint defines the other connection point
   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
   * @returns the current connection point
   */
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw `Cannot connect these two connectors. source: "${this.ownerBlock.name}".${this.name}, target: "${connectionPoint.ownerBlock.name}".${connectionPoint.name}`;
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this._enforceAssociatedVariableName = false;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Disconnect this point from one of his endpoint
   * @param endpoint defines the other connection point
   * @returns the current connection point
   */
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this._enforceAssociatedVariableName = false;
    endpoint._enforceAssociatedVariableName = false;
    this.onDisconnectionObservable.notifyObservers(endpoint);
    endpoint.onDisconnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Fill the list of excluded connection point types with all types other than those passed in the parameter
   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
   */
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 1;
    while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {
      if (!(mask & bitmask)) {
        this.excludedConnectionPointTypes.push(bitmask);
      }
      bitmask = bitmask << 1;
    }
  }
  /**
   * Serializes this point in a JSON representation
   * @param isInput defines if the connection point is an input (default is true)
   * @returns the serialized point object
   */
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    if (this.displayName) {
      serializationObject.displayName = this.displayName;
    }
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  }
  /**
   * Release resources
   */
  dispose() {
    this.onConnectionObservable.clear();
    this.onDisconnectionObservable.clear();
    this.onTypeChangedObservable.clear();
    this._connectedPoint = null;
    this._typeConnectionSource = null;
    this._linkedConnectionSource = null;
  }
  _updateTypeDependentState(update) {
    const previousType = this.type;
    update();
    if (this.type !== previousType) {
      this._notifyTypeChanged();
    }
  }
  _notifyTypeChanged() {
    if (this._isTypeChangeObservableNotifying) {
      return;
    }
    this._isTypeChangeObservableNotifying = true;
    this.onTypeChangedObservable.notifyObservers(this.type);
    this._isTypeChangeObservableNotifying = false;
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock = class {
  /** @internal */
  get _isFinalOutputAndActive() {
    return this._isFinalOutput;
  }
  /** @internal */
  get _hasPrecedence() {
    return false;
  }
  /**
   * Gets the name of the block
   */
  get name() {
    return this._name;
  }
  /**
   * Gets a boolean indicating that this block has is code ready to be used
   */
  get codeIsReady() {
    return this._codeIsReady;
  }
  /**
   * Sets the name of the block. Will check if the name is valid.
   */
  set name(newName) {
    if (!this.validateBlockName(newName)) {
      return;
    }
    this._name = newName;
  }
  /**
   * Gets a boolean indicating that this block can only be used once per NodeMaterial
   */
  get isUnique() {
    return this._isUnique;
  }
  /**
   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
   */
  get isFinalMerger() {
    return this._isFinalMerger;
  }
  /**
   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
   */
  get isInput() {
    return this._isInput;
  }
  /**
   * Gets a boolean indicating if this block is a teleport out
   */
  get isTeleportOut() {
    return this._isTeleportOut;
  }
  /**
   * Gets a boolean indicating if this block is a teleport in
   */
  get isTeleportIn() {
    return this._isTeleportIn;
  }
  /**
   * Gets a boolean indicating if this block is a loop
   */
  get isLoop() {
    return this._isLoop;
  }
  /**
   * Gets or sets the build Id
   */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  /**
   * Gets the list of input points
   */
  get inputs() {
    return this._inputs;
  }
  /** Gets the list of output points */
  get outputs() {
    return this._outputs;
  }
  /**
   * Find an input by its name
   * @param name defines the name of the input to look for
   * @returns the input or null if not found
   */
  getInputByName(name) {
    const filter = this._inputs.filter((e) => e.name === name);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Find an output by its name
   * @param name defines the name of the output to look for
   * @returns the output or null if not found
   */
  getOutputByName(name) {
    const filter = this._outputs.filter((e) => e.name === name);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Creates a new NodeMaterialBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
   * @param isFinalOutput defines a boolean indicating that this block is generating a final output and no other block should be generated after
   */
  constructor(name, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isFinalOutput = false) {
    this._isFinalMerger = false;
    this._isInput = false;
    this._isLoop = false;
    this._isTeleportOut = false;
    this._isTeleportIn = false;
    this._name = "";
    this._isUnique = false;
    this._codeIsReady = true;
    this._isFinalOutput = false;
    this.onCodeIsReadyObservable = new Observable();
    this.inputsAreExclusive = false;
    this._codeVariableName = "";
    this._inputs = new Array();
    this._outputs = new Array();
    this.comments = "";
    this.visibleInInspector = false;
    this.visibleOnFrame = false;
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
    this._isFinalMerger = isFinalMerger;
    this._isFinalOutput = isFinalOutput;
    switch (this.getClassName()) {
      case "InputBlock":
        this._isInput = true;
        break;
      case "NodeMaterialTeleportOutBlock":
        this._isTeleportOut = true;
        break;
      case "NodeMaterialTeleportInBlock":
        this._isTeleportIn = true;
        break;
      case "LoopBlock":
        this._isLoop = true;
        break;
    }
    this._name = name;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  /** @internal */
  _setInitialTarget(target) {
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initialize(state) {
  }
  /**
   * Bind data to effect. Will only be called for blocks with isBindable === true
   * @param effect defines the effect to bind data to
   * @param nodeMaterial defines the hosting NodeMaterial
   * @param mesh defines the mesh that will be rendered
   * @param subMesh defines the submesh that will be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bind(effect, nodeMaterial, mesh, subMesh) {
  }
  _writeVariable(currentPoint) {
    const connectionPoint = currentPoint.connectedPoint;
    if (connectionPoint) {
      return `${currentPoint.associatedVariableName}`;
    }
    return `0.`;
  }
  _writeFloat(value) {
    let stringVersion = value.toString();
    if (stringVersion.indexOf(".") === -1) {
      stringVersion += ".0";
    }
    return `${stringVersion}`;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialBlock"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialBlock";
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader
   * @returns true if connected in fragment shader
   */
  isConnectedInFragmentShader() {
    return this.outputs.some((o) => o.isConnectedInFragmentShader);
  }
  /**
   * Register a new input. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param isOptional defines a boolean indicating that this input can be omitted
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerInput(name, type, isOptional = false, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(
      name,
      this,
      0
      /* NodeMaterialConnectionPointDirection.Input */
    );
    point.type = type;
    point.isOptional = isOptional;
    if (target) {
      point.target = target;
    }
    this._inputs.push(point);
    return this;
  }
  /**
   * Register a new output. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerOutput(name, type, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(
      name,
      this,
      1
      /* NodeMaterialConnectionPointDirection.Output */
    );
    point.type = type;
    if (target) {
      point.target = target;
    }
    this._outputs.push(point);
    return this;
  }
  /**
   * Will return the first available input e.g. the first one which is not an uniform or an attribute
   * @param forOutput defines an optional connection point to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableInput(forOutput = null) {
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect || input.acceptedConnectionPointTypes.indexOf(forOutput.type) !== -1) {
          return input;
        }
      }
    }
    return null;
  }
  /**
   * Will return the first available output e.g. the first one which is not yet connected and not a varying
   * @param forBlock defines an optional block to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableOutput(forBlock = null) {
    for (const output of this._outputs) {
      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
        return output;
      }
    }
    return null;
  }
  /**
   * Gets the sibling of the given output
   * @param current defines the current output
   * @returns the next output in the list or null
   */
  getSiblingOutput(current) {
    const index = this._outputs.indexOf(current);
    if (index === -1 || index >= this._outputs.length) {
      return null;
    }
    return this._outputs[index + 1];
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Connect current block with another block
   * @param other defines the block to connect with
   * @param options define the various options to help pick the right connections
   * @param options.input
   * @param options.output
   * @param options.outputSwizzle
   * @returns the current block
   */
  connectTo(other, options) {
    if (this._outputs.length === 0) {
      return;
    }
    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
    let notFound = true;
    while (notFound) {
      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
      if (output && input && output.canConnectTo(input)) {
        output.connectTo(input);
        notFound = false;
      } else if (!output) {
        throw "Unable to find a compatible match";
      } else {
        output = this.getSiblingOutput(output);
      }
    }
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _buildBlock(state) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _postBuildBlock(state) {
  }
  /**
   * Add uniforms, samplers and uniform buffers at compilation time
   * @param state defines the state to update
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param uniformBuffers defines the list of uniform buffer names
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
  }
  /**
   * Add potential fallbacks if shader compilation fails
   * @param fallbacks defines the current prioritized list of fallbacks
   * @param mesh defines the mesh to be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  provideFallbacks(fallbacks, mesh) {
  }
  /**
   * Initialize defines for shader compilation
   * @param defines defines the material defines to update
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initializeDefines(defines) {
  }
  /**
   * Update defines for shader compilation
   * @param defines defines the material defines to update
   * @param nodeMaterial defines the node material requesting the update
   * @param mesh defines the mesh to be rendered
   * @param useInstances specifies that instances should be used
   * @param subMesh defines which submesh to render
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prepareDefines(defines, nodeMaterial, mesh, useInstances = false, subMesh) {
  }
  /**
   * Lets the block try to connect some inputs automatically
   * @param material defines the hosting NodeMaterial
   * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  autoConfigure(material, additionalFilteringInfo = () => true) {
  }
  /**
   * Function called when a block is declared as repeatable content generator
   * @param vertexShaderState defines the current compilation state for the vertex shader
   * @param defines defines the material defines to update
   * @param mesh defines the mesh to be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  replaceRepeatableContent(vertexShaderState, defines, mesh) {
  }
  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */
  get willBeGeneratedIntoVertexShaderFromFragmentShader() {
    if (this.isInput || this.isFinalMerger) {
      return false;
    }
    if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {
      if (this._outputs.some((o) => o.isConnectedInVertexShader)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if the block is ready
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param useInstances specifies that instances should be used
   * @returns true if the block is ready
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReady(mesh, nodeMaterial, defines, useInstances = false) {
    return true;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
      this._inputs[inputIndex0]._isMainLinkSource = true;
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  _processBuild(block, state, input, activeBlocks) {
    block.build(state, activeBlocks);
    const localBlockIsFragment = state._vertexState != null;
    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
    if (block.isTeleportOut && block.entryPoint?.isConnectedToUniform) {
      return;
    }
    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
      if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader
      block.isInput && block.isAttribute && !block._noContextSwitch) {
        const connectedPoint = input.connectedPoint;
        if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.declarationVariableName, connectedPoint.type)) {
          const prefix2 = state.shaderLanguage === 1 ? "vertexOutputs." : "";
          if (state.shaderLanguage === 1 && connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Matrix) {
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r0 = ${connectedPoint.associatedVariableName}[0];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r1 = ${connectedPoint.associatedVariableName}[1];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r2 = ${connectedPoint.associatedVariableName}[2];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r3 = ${connectedPoint.associatedVariableName}[3];
`;
          } else {
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName} = ${connectedPoint.associatedVariableName};
`;
          }
        }
        const prefix = state.shaderLanguage === 1 && connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Matrix ? "fragmentInputs." : "";
        input.associatedVariableName = prefix + "v_" + connectedPoint.declarationVariableName;
        input._enforceAssociatedVariableName = true;
      }
    }
  }
  /**
   * Validates the new name for the block node.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    const reservedNames = [
      "position",
      "normal",
      "tangent",
      "particle_positionw",
      "uv",
      "uv2",
      "uv3",
      "uv4",
      "uv5",
      "uv6",
      "position2d",
      "particle_uv",
      "postprocess_uv",
      "matricesIndices",
      "matricesWeights",
      "world0",
      "world1",
      "world2",
      "world3",
      "particle_color",
      "particle_texturemask"
    ];
    for (const reservedName of reservedNames) {
      if (newName === reservedName) {
        return false;
      }
    }
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _customBuildStep(state, activeBlocks) {
  }
  /**
   * Compile the current node and generate the shader code
   * @param state defines the current compilation state (uniforms, samplers, current string)
   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
   * @returns true if already built
   */
  build(state, activeBlocks) {
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (!this.isInput) {
      for (const output of this._outputs) {
        if (!output.associatedVariableName) {
          output.associatedVariableName = state._getFreeVariableName(output.name);
        }
      }
    }
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      if (this.target !== NodeMaterialBlockTargets.Neutral) {
        if ((input.target & this.target) === 0) {
          continue;
        }
        if ((input.target & state.target) === 0) {
          continue;
        }
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        this._processBuild(block, state, input, activeBlocks);
      }
    }
    this._customBuildStep(state, activeBlocks);
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (state.sharedData.verbose) {
      Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader"}: Building ${this.name} [${this.getClassName()}]`);
    }
    if (this.isFinalMerger) {
      switch (state.target) {
        case NodeMaterialBlockTargets.Vertex:
          state.sharedData.checks.emitVertex = true;
          break;
        case NodeMaterialBlockTargets.Fragment:
          state.sharedData.checks.emitFragment = true;
          break;
      }
    }
    if (!this.isInput && state.sharedData.emitComments) {
      state.compilationString += `
//${this.name}
`;
    }
    this._buildBlock(state);
    this._buildId = state.sharedData.buildId;
    this._buildTarget = state.target;
    for (const output of this._outputs) {
      if (output._forPostBuild) {
        continue;
      }
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block) {
          if ((block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1 || state._terminalBlocks.has(block)) {
            this._processBuild(block, state, endpoint, activeBlocks);
          }
        }
      }
    }
    this._postBuildBlock(state);
    for (const output of this._outputs) {
      if (!output._forPostBuild) {
        continue;
      }
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
          this._processBuild(block, state, endpoint, activeBlocks);
        }
      }
    }
    return false;
  }
  _inputRename(name) {
    return name;
  }
  _outputRename(name) {
    return name;
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleInInspector = ${this.visibleInInspector};
${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.target = ${this.target};
`;
  }
  /**
   * @internal
   */
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    let codeString = `
// ${this.getClassName()}
`;
    if (this.comments) {
      codeString += `// ${this.comments}
`;
    }
    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`;
    codeString += this._dumpPropertiesCode();
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  /**
   * @internal
   */
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a copy of the current block
   */
  clone(scene, rootUrl = "") {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const block = new blockType();
      block._deserialize(serializationObject, scene, rootUrl);
      return block;
    }
    return null;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.comments = this.comments;
    serializationObject.visibleInInspector = this.visibleInInspector;
    serializationObject.visibleOnFrame = this.visibleOnFrame;
    serializationObject.target = this.target;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _deserialize(serializationObject, scene, rootUrl, urlRewriter) {
    this.name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleInInspector = !!serializationObject.visibleInInspector;
    this.visibleOnFrame = !!serializationObject.visibleOnFrame;
    this._target = serializationObject.target ?? this.target;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      for (let i = 0; i < serializedInputs.length; i++) {
        const port = serializedInputs[i];
        if (port.displayName) {
          this.inputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.inputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      }
    }
    if (serializedOutputs) {
      for (let i = 0; i < serializedOutputs.length; i++) {
        const port = serializedOutputs[i];
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      }
    }
  }
  /**
   * Release resources
   */
  dispose() {
    this.onCodeIsReadyObservable.clear();
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Decorators/nodeDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 4] = "List";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Color4"] = 5] = "Color4";
  PropertyTypeForEdition2[PropertyTypeForEdition2["SamplingMode"] = 6] = "SamplingMode";
  PropertyTypeForEdition2[PropertyTypeForEdition2["TextureFormat"] = 7] = "TextureFormat";
  PropertyTypeForEdition2[PropertyTypeForEdition2["TextureType"] = 8] = "TextureType";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType = 0, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options ?? {},
      className: target.getClassName()
    });
  };
}

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlockColorSpace;
(function(FragmentOutputBlockColorSpace2) {
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["NoColorSpace"] = 0] = "NoColorSpace";
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Gamma"] = 1] = "Gamma";
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Linear"] = 2] = "Linear";
})(FragmentOutputBlockColorSpace || (FragmentOutputBlockColorSpace = {}));
var FragmentOutputBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FragmentOutputBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Fragment, true, true);
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this.useLogarithmicDepth = false;
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("glow", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets or sets the color space used for the block
   */
  get colorSpace() {
    if (this.convertToGammaSpace) {
      return FragmentOutputBlockColorSpace.Gamma;
    }
    if (this.convertToLinearSpace) {
      return FragmentOutputBlockColorSpace.Linear;
    }
    return FragmentOutputBlockColorSpace.NoColorSpace;
  }
  set colorSpace(value) {
    this.convertToGammaSpace = value === FragmentOutputBlockColorSpace.Gamma;
    this.convertToLinearSpace = value === FragmentOutputBlockColorSpace.Linear;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FragmentOutputBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("logarithmicDepthConstant");
    state._excludeVariableName("vFragmentDepth");
  }
  /**
   * Gets the rgba input component
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb input component
   */
  get rgb() {
    return this._inputs[1];
  }
  /**
   * Gets the a input component
   */
  get a() {
    return this._inputs[2];
  }
  /**
   * Gets the additionalColor input component (named glow in the UI for now)
   */
  get additionalColor() {
    return this._inputs[3];
  }
  _getOutputString(state) {
    return state.shaderLanguage === 1 ? "fragmentOutputsColor" : "gl_FragColor";
  }
  prepareDefines(defines, nodeMaterial) {
    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._additionalColorDefineName, this.additionalColor.connectedPoint && nodeMaterial._useAdditionalColor, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {
      BindLogDepth(void 0, effect, mesh.getScene());
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rgba = this.rgba;
    const rgb = this.rgb;
    const a = this.a;
    const additionalColor = this.additionalColor;
    const isWebGPU = state.shaderLanguage === 1;
    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
    state.sharedData.blocksWithDefines.push(this);
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
      state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
      state.sharedData.bindableBlocks.push(this);
    }
    if (additionalColor.connectedPoint) {
      state._excludeVariableName("useAdditionalColor");
      state._emitUniformFromString("useAdditionalColor", NodeMaterialBlockConnectionPointTypes.Float);
      this._additionalColorDefineName = state._getFreeDefineName("USEADDITIONALCOLOR");
    }
    this._linearDefineName = state._getFreeDefineName("CONVERTTOLINEAR");
    this._gammaDefineName = state._getFreeDefineName("CONVERTTOGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    const outputString = this._getOutputString(state);
    if (state.shaderLanguage === 1) {
      state.compilationString += `var ${outputString} : vec4<f32>;\r
`;
    }
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    if (additionalColor.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      state.compilationString += `#ifdef ${this._additionalColorDefineName}
`;
      if (additionalColor.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${aValue});
`;
      } else {
        state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${aValue});
`;
      }
      state.compilationString += `#else
`;
    }
    if (rgba.connectedPoint) {
      if (a.isConnected) {
        state.compilationString += `${outputString} = ${vec4}(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});
`;
      } else {
        state.compilationString += `${outputString}  = ${rgba.associatedVariableName};
`;
      }
    } else if (rgb.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});
`;
      } else {
        state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${aValue});
`;
      }
    } else {
      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
    }
    if (additionalColor.connectedPoint) {
      state.compilationString += `#endif
`;
    }
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${outputString}  = toLinearSpace(${outputString});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${outputString}  = toGammaSpace(${outputString});
`;
    state.compilationString += `#endif
`;
    if (state.shaderLanguage === 1) {
      state.compilationString += `#if !defined(PREPASS)\r
`;
      state.compilationString += `fragmentOutputs.color = ${outputString};\r
`;
      state.compilationString += `#endif\r
`;
    }
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      const fragDepth = isWebGPU ? "input.vFragmentDepth" : "vFragmentDepth";
      const uniformP = isWebGPU ? "uniforms." : "";
      const output = isWebGPU ? "fragmentOutputs.fragDepth" : "gl_FragDepthEXT";
      state.compilationString += `${output} = log2(${fragDepth}) * ${uniformP}logarithmicDepthConstant * 0.5;
`;
    }
    state.compilationString += `#if defined(PREPASS)\r
`;
    state.compilationString += `${isWebGPU ? "fragmentOutputs.fragData0" : "gl_FragData[0]"} = ${outputString};\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;
  }
};
__decorate([
  editableInPropertyPage("Use logarithmic depth", 0, "PROPERTIES", { embedded: true })
], FragmentOutputBlock.prototype, "useLogarithmicDepth", void 0);
__decorate([
  editableInPropertyPage("Color space", 4, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "No color space", value: FragmentOutputBlockColorSpace.NoColorSpace },
      { label: "Gamma", value: FragmentOutputBlockColorSpace.Gamma },
      { label: "Linear", value: FragmentOutputBlockColorSpace.Linear }
    ]
  })
], FragmentOutputBlock.prototype, "colorSpace", null);
RegisterClass("BABYLON.FragmentOutputBlock", FragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
(function(NodeMaterialModes2) {
  NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
  NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
  NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
  NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
  NodeMaterialModes2[NodeMaterialModes2["GaussianSplatting"] = 4] = "GaussianSplatting";
  NodeMaterialModes2[NodeMaterialModes2["SFE"] = 5] = "SFE";
})(NodeMaterialModes || (NodeMaterialModes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
(function(NodeMaterialSystemValues2) {
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraParameters"] = 10] = "CameraParameters";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["MaterialAlpha"] = 11] = "MaterialAlpha";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ProjectionInverse"] = 12] = "ProjectionInverse";
})(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
(function(AnimatedInputBlockTypes2) {
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["RealTime"] = 2] = "RealTime";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["MouseInfo"] = 3] = "MouseInfo";
})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName = {
  position2d: "position",
  // From particle.vertex:
  particle_uv: "vUV",
  particle_color: "vColor",
  particle_texturemask: "textureMask",
  particle_positionw: "vPositionW",
  // From postprocess.vertex:
  postprocess_uv: "vUV"
};
var attributeInFragmentOnly = {
  particle_uv: true,
  particle_color: true,
  particle_texturemask: true,
  particle_positionw: true,
  postprocess_uv: true
};
var attributeAsUniform = {
  particle_texturemask: true
};
var attributeDefine = {
  normal: "NORMAL",
  tangent: "TANGENT",
  uv: "UV1",
  uv2: "UV2",
  uv3: "UV3",
  uv4: "UV4",
  uv5: "UV5",
  uv6: "UV6",
  uv7: "UV7",
  uv8: "UV8"
};
var InputBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this.isUniform && this.value != null) {
        if (!isNaN(this.value)) {
          this._type = NodeMaterialBlockConnectionPointTypes.Float;
          return this._type;
        }
        switch (this.value.getClassName()) {
          case "Vector2":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "Vector3":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "Vector4":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "Color3":
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case "Color4":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
          case "Matrix":
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
        }
      }
      if (this.isAttribute) {
        switch (this.name) {
          case "splatIndex":
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case "position":
          case "normal":
          case "particle_positionw":
          case "splatPosition":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "uv":
          case "uv2":
          case "uv3":
          case "uv4":
          case "uv5":
          case "uv6":
          case "position2d":
          case "particle_uv":
          case "splatScale":
          case "postprocess_uv":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "matricesIndices":
          case "matricesWeights":
          case "matricesIndicesExtra":
          case "matricesWeightsExtra":
          case "world0":
          case "world1":
          case "world2":
          case "world3":
          case "tangent":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "color":
          case "instanceColor":
          case "particle_color":
          case "particle_texturemask":
          case "splatColor":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
        }
      }
      if (this.isSystemValue) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.World:
          case NodeMaterialSystemValues.WorldView:
          case NodeMaterialSystemValues.WorldViewProjection:
          case NodeMaterialSystemValues.View:
          case NodeMaterialSystemValues.ViewProjection:
          case NodeMaterialSystemValues.Projection:
          case NodeMaterialSystemValues.ProjectionInverse:
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
          case NodeMaterialSystemValues.CameraPosition:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case NodeMaterialSystemValues.FogColor:
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case NodeMaterialSystemValues.DeltaTime:
          case NodeMaterialSystemValues.MaterialAlpha:
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case NodeMaterialSystemValues.CameraParameters:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
        }
      }
    }
    return this._type;
  }
  /**
   * Creates a new InputBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
   */
  constructor(name, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {
    super(name, target, false);
    this._mode = 3;
    this._animationType = AnimatedInputBlockTypes.None;
    this._prefix = "";
    this.min = 0;
    this.max = 0;
    this.isBoolean = false;
    this.matrixMode = 0;
    this._systemValue = null;
    this.isConstant = false;
    this.groupInInspector = "";
    this.onValueChangedObservable = new Observable();
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._type = type;
    this.setDefaultValue();
    this.registerOutput("output", type);
  }
  /**
   * Validates if a name is a reserve word.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    if (!this.isAttribute) {
      return super.validateBlockName(newName);
    }
    return true;
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Set the source of this connection point to a vertex attribute
   * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
   * @returns the current connection point
   */
  setAsAttribute(attributeName) {
    this._mode = 1;
    if (attributeName) {
      this.name = attributeName;
    }
    return this;
  }
  /**
   * Set the source of this connection point to a system value
   * @param value define the system value to use (world, view, etc...) or null to switch to manual value
   * @returns the current connection point
   */
  setAsSystemValue(value) {
    this.systemValue = value;
    return this;
  }
  /**
   * Gets or sets the value of that point.
   * Please note that this value will be ignored if valueCallback is defined
   */
  get value() {
    return this._storedValue;
  }
  set value(value) {
    if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
      if (this.isBoolean) {
        value = value ? 1 : 0;
      } else if (this.min !== this.max) {
        value = Math.max(this.min, value);
        value = Math.min(this.max, value);
      }
    }
    this._storedValue = value;
    this._mode = 0;
    this.onValueChangedObservable.notifyObservers(this);
  }
  /**
   * Gets or sets a callback used to get the value of that point.
   * Please note that setting this value will force the connection point to ignore the value property
   */
  get valueCallback() {
    return this._valueCallback;
  }
  set valueCallback(value) {
    this._valueCallback = value;
    this._mode = 0;
  }
  /**
   * Gets the declaration variable name in the shader
   */
  get declarationVariableName() {
    return this._associatedVariableName;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    return this._prefix + this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Gets or sets the type of animation applied to the input */
  get animationType() {
    return this._animationType;
  }
  set animationType(value) {
    this._animationType = value;
  }
  /**
   * Gets a boolean indicating that this connection point not defined yet
   */
  get isUndefined() {
    return this._mode === 3;
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an uniform.
   * In this case the connection point name must be the name of the uniform to use.
   * Can only be set on inputs
   */
  get isUniform() {
    return this._mode === 0;
  }
  set isUniform(value) {
    this._mode = value ? 0 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an attribute.
   * In this case the connection point name must be the name of the attribute to use
   * Can only be set on inputs
   */
  get isAttribute() {
    return this._mode === 1;
  }
  set isAttribute(value) {
    this._mode = value ? 1 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is generating a varying variable.
   * Can only be set on exit points
   */
  get isVarying() {
    return this._mode === 2;
  }
  set isVarying(value) {
    this._mode = value ? 2 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets a boolean indicating that the current connection point is a system value
   */
  get isSystemValue() {
    return this._systemValue != null;
  }
  /**
   * Gets or sets the current well known value or null if not defined as a system value
   */
  get systemValue() {
    return this._systemValue;
  }
  set systemValue(value) {
    this._mode = 0;
    this.associatedVariableName = "";
    this._systemValue = value;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InputBlock";
  }
  /**
   * Animate the input if animationType !== None
   * @param scene defines the rendering scene
   */
  animate(scene) {
    switch (this._animationType) {
      case AnimatedInputBlockTypes.Time: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value += scene.getAnimationRatio() * 0.01;
        }
        break;
      }
      case AnimatedInputBlockTypes.RealTime: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1e3;
        }
        break;
      }
      case AnimatedInputBlockTypes.MouseInfo: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
          const event = scene._inputManager._originMouseEvent;
          if (event) {
            const x = event.offsetX;
            const y = event.offsetY;
            const z = (event.buttons & 1) != 0 ? 1 : 0;
            const w = (event.buttons & 2) != 0 ? 1 : 0;
            this.value = new Vector4(x, y, z, w);
          } else {
            this.value = new Vector4(0, 0, 0, 0);
          }
        }
        break;
      }
    }
  }
  _emitDefine(define, notDefine = false) {
    return `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
  }
  initialize() {
    this.associatedVariableName = "";
  }
  /**
   * Set the input block to its default value (based on its type)
   */
  setDefaultValue() {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        this.value = Color3.White();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        this.value = new Color4(1, 1, 1, 1);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  }
  _emitConstant(state) {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return `${state._emitFloat(this.value)}`;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return `vec2(${this.value.x}, ${this.value.y})`;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;
    }
    return "";
  }
  /** @internal */
  get _noContextSwitch() {
    return attributeInFragmentOnly[this.name];
  }
  _emit(state) {
    if (this.isUniform) {
      if (!this._associatedVariableName) {
        this._associatedVariableName = state._getFreeVariableName("u_" + this.name);
      }
      if (this.isConstant) {
        if (state.constants.indexOf(this.associatedVariableName) !== -1) {
          return;
        }
        state.constants.push(this.associatedVariableName);
        state._constantDeclaration += state._declareOutput(this.output, true) + ` = ${this._emitConstant(state)};
`;
        return;
      }
      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state._emitUniformFromString(this._associatedVariableName, this.type);
      if (state.shaderLanguage === 1) {
        this._prefix = "uniforms.";
      }
      const hints = state.sharedData.hints;
      if (this._systemValue !== null && this._systemValue !== void 0) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.WorldView:
            hints.needWorldViewMatrix = true;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            hints.needWorldViewProjectionMatrix = true;
            break;
        }
      } else {
        if (this._animationType !== AnimatedInputBlockTypes.None) {
          state.sharedData.animatedInputs.push(this);
        }
      }
      return;
    }
    if (this.isAttribute) {
      this.associatedVariableName = remapAttributeName[this.name] ?? this.name;
      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
        if (attributeInFragmentOnly[this.name]) {
          if (attributeAsUniform[this.name]) {
            state._emitUniformFromString(this.declarationVariableName, this.type);
            if (state.shaderLanguage === 1) {
              this._prefix = `vertexInputs.`;
            }
          } else {
            state._emitVaryingFromString(this.declarationVariableName, this.type);
          }
        } else {
          this._emit(state._vertexState);
        }
        return;
      }
      const alreadyDeclared = state.attributes.indexOf(this.declarationVariableName) !== -1;
      if (!alreadyDeclared) {
        state.attributes.push(this.declarationVariableName);
      }
      if (attributeInFragmentOnly[this.name]) {
        if (attributeAsUniform[this.name]) {
          if (!alreadyDeclared) {
            state._emitUniformFromString(this.declarationVariableName, this.type);
          }
          if (state.shaderLanguage === 1) {
            this._prefix = `uniforms.`;
          }
        } else {
          if (!alreadyDeclared) {
            state._emitVaryingFromString(this.declarationVariableName, this.type);
          }
          if (state.shaderLanguage === 1) {
            this._prefix = `fragmentInputs.`;
          }
        }
      } else {
        if (state.shaderLanguage === 1) {
          if (!alreadyDeclared) {
            const defineName = attributeDefine[this.name];
            if (defineName) {
              state._attributeDeclaration += this._emitDefine(defineName);
              state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
              state._attributeDeclaration += `#else
`;
              state._attributeDeclaration += `var<private> ${this.declarationVariableName}: ${state._getShaderType(this.type)} = ${state._getShaderType(this.type)}(0.);
`;
              state._attributeDeclaration += `#endif
`;
            } else {
              state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
            }
          }
          this._prefix = `vertexInputs.`;
        } else {
          if (!alreadyDeclared) {
            const defineName = attributeDefine[this.name];
            if (defineName) {
              state._attributeDeclaration += this._emitDefine(defineName);
              state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
              state._attributeDeclaration += `#else
`;
              state._attributeDeclaration += `${state._getShaderType(this.type)} ${this.declarationVariableName} = ${state._getShaderType(this.type)}(0.);
`;
              state._attributeDeclaration += `#endif
`;
            } else {
              state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   */
  _transmitWorld(effect, world, worldView, worldViewProjection) {
    if (!this._systemValue) {
      return;
    }
    const variableName = this._associatedVariableName;
    switch (this._systemValue) {
      case NodeMaterialSystemValues.World:
        effect.setMatrix(variableName, world);
        break;
      case NodeMaterialSystemValues.WorldView:
        effect.setMatrix(variableName, worldView);
        break;
      case NodeMaterialSystemValues.WorldViewProjection:
        effect.setMatrix(variableName, worldViewProjection);
        break;
    }
  }
  /**
   * @internal
   */
  _transmit(effect, scene, material) {
    if (this.isAttribute) {
      return;
    }
    const variableName = this._associatedVariableName;
    if (this._systemValue) {
      switch (this._systemValue) {
        case NodeMaterialSystemValues.World:
        case NodeMaterialSystemValues.WorldView:
        case NodeMaterialSystemValues.WorldViewProjection:
          return;
        case NodeMaterialSystemValues.View:
          effect.setMatrix(variableName, scene.getViewMatrix());
          break;
        case NodeMaterialSystemValues.Projection:
          effect.setMatrix(variableName, scene.getProjectionMatrix());
          break;
        case NodeMaterialSystemValues.ProjectionInverse: {
          const projectionMatrix = scene.getProjectionMatrix();
          projectionMatrix.invertToRef(TmpVectors.Matrix[0]);
          effect.setMatrix(variableName, TmpVectors.Matrix[0]);
          break;
        }
        case NodeMaterialSystemValues.ViewProjection:
          effect.setMatrix(variableName, scene.getTransformMatrix());
          break;
        case NodeMaterialSystemValues.CameraPosition:
          scene.bindEyePosition(effect, variableName, true);
          break;
        case NodeMaterialSystemValues.FogColor:
          effect.setColor3(variableName, scene.fogColor);
          break;
        case NodeMaterialSystemValues.DeltaTime:
          effect.setFloat(variableName, scene.deltaTime / 1e3);
          break;
        case NodeMaterialSystemValues.CameraParameters:
          if (scene.activeCamera) {
            effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);
          }
          break;
        case NodeMaterialSystemValues.MaterialAlpha:
          effect.setFloat(variableName, material.alpha);
          break;
      }
      return;
    }
    const value = this._valueCallback ? this._valueCallback() : this._storedValue;
    if (value === null) {
      return;
    }
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        effect.setFloat(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Int:
        effect.setInt(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setColor3(variableName, TmpColors.Color3[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setDirectColor4(variableName, TmpColors.Color4[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        effect.setVector2(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        effect.setVector3(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        effect.setVector4(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        effect.setMatrix(variableName, value);
        break;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.isUniform || this.isSystemValue) {
      state.sharedData.inputBlocks.push(this);
    }
    this._emit(state);
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    if (this.isAttribute) {
      return super._dumpPropertiesCode() + `${variableName}.setAsAttribute("${this.name}");
`;
    }
    if (this.isSystemValue) {
      return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});
`;
    }
    if (this.isUniform) {
      const codes = [];
      let valueString = "";
      switch (this.type) {
        case NodeMaterialBlockConnectionPointTypes.Float:
          valueString = `${this.value}`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector2:
          valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector3:
          valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector4:
          valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Color3:
          valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Color4:
          valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Matrix:
          valueString = `BABYLON.Matrix.FromArray([${this.value.m.join(", ")}])`;
          break;
      }
      codes.push(`${variableName}.value = ${valueString}`);
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);
      }
      codes.push(`${variableName}.isConstant = ${this.isConstant}`);
      codes.push("");
      return super._dumpPropertiesCode() + codes.join(";\n");
    }
    return super._dumpPropertiesCode();
  }
  dispose() {
    this.onValueChangedObservable.clear();
    super.dispose();
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.type = this.type;
    serializationObject.mode = this._mode;
    serializationObject.systemValue = this._systemValue;
    serializationObject.animationType = this._animationType;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.isBoolean = this.isBoolean;
    serializationObject.matrixMode = this.matrixMode;
    serializationObject.isConstant = this.isConstant;
    serializationObject.groupInInspector = this.groupInInspector;
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this._storedValue != null && this._mode === 0) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._mode = serializationObject.mode;
    super._deserialize(serializationObject, scene, rootUrl);
    this._type = serializationObject.type;
    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
    this._animationType = serializationObject.animationType;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.isBoolean = !!serializationObject.isBoolean;
    this.matrixMode = serializationObject.matrixMode || 0;
    this.isConstant = !!serializationObject.isConstant;
    this.groupInInspector = serializationObject.groupInInspector || "";
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.name === "tangent" && serializationObject.mode === 1 && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
      this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
    }
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      const valueType = GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  }
};
RegisterClass("BABYLON.InputBlock", InputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js
var ScreenSizeBlock = class extends NodeMaterialBlock {
  /**
   * Name of the variable in the shader that holds the screen size
   */
  get associatedVariableName() {
    return this._varName;
  }
  /**
   * Creates a new ScreenSizeBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ScreenSizeBlock";
  }
  /**
   * Gets the xy component
   */
  get xy() {
    return this._outputs[0];
  }
  /**
   * Gets the x component
   */
  get x() {
    return this._outputs[1];
  }
  /**
   * Gets the y component
   */
  get y() {
    return this._outputs[2];
  }
  bind(effect) {
    const engine = this._scene.getEngine();
    effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  writeOutputs(state, varName) {
    let code = "";
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        code += `${state._declareOutput(output)} = ${varName}.${output.name};
`;
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      state.sharedData.raiseBuildError("ScreenSizeBlock must only be used in a fragment shader");
      return this;
    }
    state.sharedData.bindableBlocks.push(this);
    this._varName = state._getFreeVariableName("screenSize");
    state._emitUniformFromString(this._varName, NodeMaterialBlockConnectionPointTypes.Vector2);
    const prefix = state.shaderLanguage === 1 ? "uniforms." : "";
    state.compilationString += this.writeOutputs(state, prefix + this._varName);
    return this;
  }
};
RegisterClass("BABYLON.ScreenSizeBlock", ScreenSizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.js
var SfeModeDefine = "USE_SFE_FRAMEWORK";
var SmartFilterFragmentOutputBlock = class extends FragmentOutputBlock {
  /**
   * Create a new SmartFilterFragmentOutputBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SmartFilterFragmentOutputBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    super.initialize(state);
    if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {
      state.sharedData.raiseBuildError("SmartFilterFragmentOutputBlock should not be used outside of SFE mode.");
    }
    if (state.sharedData.nodeMaterial.shaderLanguage !== 0) {
      state.sharedData.raiseBuildError("WebGPU is not supported in SmartFilters mode.");
    }
    if (!state.sharedData.formatConfig.getUniformAnnotation) {
      state.sharedData.formatConfig.getUniformAnnotation = (name) => {
        for (const block of state.sharedData.nodeMaterial.attachedBlocks) {
          if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name) {
            return this._generateInputBlockAnnotation(block);
          }
          if (block instanceof ScreenSizeBlock && block.associatedVariableName === name) {
            return this._generateScreenSizeBlockAnnotation();
          }
        }
        return "";
      };
    }
    state.sharedData.formatConfig.formatVariablename = (n) => {
      let name = n;
      const hasUnderscoredPrefix = name.length > 1 && name[1] === "_";
      if (hasUnderscoredPrefix) {
        name = name.substring(2);
      }
      return name.replace(/[^a-zA-Z]+/g, "");
    };
  }
  _generateInputBlockAnnotation(inputBlock) {
    const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;
    return `// { "default": ${JSON.stringify(value)} }
`;
  }
  _generateScreenSizeBlockAnnotation() {
    return `// { "autoBind": "outputResolution" }
`;
  }
  _getMainUvName(state) {
    const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === "postprocess_uv");
    if (!screenUv || !screenUv.isAnAncestorOf(this)) {
      return "";
    }
    return screenUv.associatedVariableName;
  }
  _getOutputString() {
    return "outColor";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const outputString = this._getOutputString();
    state._injectAtTop = `// { "smartFilterBlockType": "${state.sharedData.nodeMaterial.name}", "namespace": "Babylon.NME.Exports" }`;
    state._customEntryHeader += `#ifdef ${SfeModeDefine}
`;
    state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main
`;
    state._customEntryHeader += `#else
`;
    state._customEntryHeader += `void main(void) {
`;
    state._customEntryHeader += `#endif
`;
    state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);
`;
    state.compilationString += `
#ifndef ${SfeModeDefine}
`;
    state.compilationString += `gl_FragColor = ${outputString};
`;
    state.compilationString += `#else
`;
    state.compilationString += `return ${outputString};
`;
    state.compilationString += `#endif
`;
    return this;
  }
};
RegisterClass("BABYLON.SmartFilterFragmentOutputBlock", SmartFilterFragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock = class extends NodeMaterialBlock {
  /**
   * Boolean indicating if the transformation is made for a direction vector and not a position vector
   * If set to true the complementW value will be set to 0 else it will be set to 1
   */
  get transformAsDirection() {
    return this.complementW === 0;
  }
  set transformAsDirection(value) {
    this.complementW = value ? 0 : 1;
  }
  /**
   * Creates a new TransformBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.complementW = 1;
    this.complementZ = 0;
    this.target = NodeMaterialBlockTargets.Vertex;
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].onConnectionObservable.add((other) => {
      if (other.ownerBlock.isInput) {
        const otherAsInput = other.ownerBlock;
        if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
          this.complementW = 0;
        }
      }
    });
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TransformBlock";
  }
  /**
   * Gets the vector input
   */
  get vector() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz output component
   */
  get xyz() {
    return this._outputs[1];
  }
  /**
   * Gets the matrix transform input
   */
  get transform() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const transform = this.transform;
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    if (vector.connectedPoint) {
      if (this.complementW === 0 || this.transformAsDirection) {
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.sharedData.blocksWithDefines.push(this);
        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);
        if (state.shaderLanguage === 1) {
          state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);
`;
        } else {
          state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});
`;
        }
        state.compilationString += `#ifdef NONUNIFORMSCALING
`;
        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));
`;
        state.compilationString += `#endif
`;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});
`;
            break;
        }
      } else {
        const transformName = transform.associatedVariableName;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};
`;
            break;
        }
      }
      if (this.xyz.hasEndpoints) {
        state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;
`;
      }
    }
    return this;
  }
  /**
   * Update defines for shader compilation
   * @param defines defines the material defines to update
   * @param nodeMaterial defines the node material requesting the update
   * @param mesh defines the mesh to be rendered
   */
  prepareDefines(defines, nodeMaterial, mesh) {
    if (mesh && mesh.nonUniformScaling) {
      defines.setValue("NONUNIFORMSCALING", true);
    }
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.complementZ = this.complementZ;
    serializationObject.complementW = this.complementW;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
    this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};
`;
    codeString += `${this._codeVariableName}.complementW = ${this.complementW};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Transform as direction", 0, void 0, { embedded: true })
], TransformBlock.prototype, "transformAsDirection", null);
RegisterClass("BABYLON.TransformBlock", TransformBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new VertexOutputBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Vertex, true);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VertexOutputBlock";
  }
  /**
   * Gets the vector input component
   */
  get vector() {
    return this._inputs[0];
  }
  _isLogarithmicDepthEnabled(nodeList, useLogarithmicDepth) {
    if (useLogarithmicDepth) {
      return true;
    }
    for (const node of nodeList) {
      if (node.useLogarithmicDepth) {
        return true;
      }
    }
    return false;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.vector;
    const isWebGPU = state.shaderLanguage === 1;
    if (state.shaderLanguage === 1) {
      state.compilationString += `vertexOutputs.position = ${input.associatedVariableName};
`;
    } else {
      state.compilationString += `gl_Position = ${input.associatedVariableName};
`;
    }
    if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {
      state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
      state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
      const fragDepth = isWebGPU ? "vertexOutputs.vFragmentDepth" : "vFragmentDepth";
      const uniformP = isWebGPU ? "uniforms." : "";
      const position = isWebGPU ? "vertexOutputs.position" : "gl_Position";
      state.compilationString += `${fragDepth} = 1.0 + ${position}.w;
`;
      state.compilationString += `${position}.z = log2(max(0.000001, ${fragDepth})) * ${uniformP}logarithmicDepthConstant;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VertexOutputBlock", VertexOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock = class extends NodeMaterialBlock {
  /**
   * The name of the sampler to read the screen texture from.
   */
  get samplerName() {
    return this._samplerName;
  }
  /**
   * Create a new CurrentScreenBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.VertexAndFragment);
    this._samplerName = "textureSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CurrentScreenBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName(this._samplerName);
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  prepareDefines(defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _getMainUvName(state) {
    return "vMain" + this.uv.associatedVariableName;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, NodeMaterialBlockConnectionPointTypes.Vector2);
      }
    }
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      const textureReadFunc2 = state.shaderLanguage === 0 ? `texture2D(${this._samplerName},` : `textureSampleLevel(${this._samplerName}, ${this._samplerName + `Sampler`},`;
      const complement = state.shaderLanguage === 0 ? "" : ", 0";
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc2} ${uvInput.associatedVariableName}${complement});
`;
      return;
    }
    const textureReadFunc = state.shaderLanguage === 0 ? `texture2D(${this._samplerName},` : `textureSample(${this._samplerName}, ${this._samplerName + `Sampler`},`;
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName});
`;
      return;
    }
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _emitUvAndSampler(state) {
    state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emit2DSampler(this._samplerName);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
      state.sharedData.blockingBlocks.push(this);
    }
    if (state.sharedData.textureBlocks.indexOf(this) < 0) {
      state.sharedData.textureBlocks.push(this);
    }
    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
      state.sharedData.blocksWithDefines.push(this);
    }
    this._mainUVName = this._getMainUvName(state);
    this._emitUvAndSampler(state);
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.CurrentScreenBlock", CurrentScreenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleTextureBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Fragment);
    this._samplerName = "diffuseSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleTextureBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("diffuseSampler");
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "particle_uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("particle_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  prepareDefines(defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _writeOutput(state, output, swizzle) {
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    state._emit2DSampler(this._samplerName);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(this.uv.associatedVariableName, this._samplerName)};
`;
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.ParticleTextureBlock", ParticleTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleRampGradientBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleRampGradientBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the rampColor output component
   */
  get rampColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("remapRanges");
    state._excludeVariableName("rampSampler");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("alpha");
    state._excludeVariableName("remappedColorIndex");
    state._excludeVariableName("rampColor");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state._emit2DSampler("rampSampler", "RAMPGRADIENT");
    state._emitVaryingFromString("remapRanges", NodeMaterialBlockConnectionPointTypes.Vector4, "RAMPGRADIENT");
    const varyingString = state.shaderLanguage === 0 ? "" : "fragmentInputs.";
    state.compilationString += `
            #ifdef RAMPGRADIENT
                ${state._declareLocalVar("baseColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.color.associatedVariableName};
                ${state._declareLocalVar("alpha", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.color.associatedVariableName}.a;

                ${state._declareLocalVar("remappedColorIndex", NodeMaterialBlockConnectionPointTypes.Float)} = clamp((alpha - ${varyingString}remapRanges.x) / ${varyingString}remapRanges.y, 0.0, 1.0);

                ${state._declareLocalVar("rampColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample("vec2(1.0 - remappedColorIndex, 0.)", "rampSampler")};

                // Remapped alpha
                ${state._declareOutput(this.rampColor)} = vec4${state.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${varyingString}remapRanges.z) / ${varyingString}remapRanges.w, 0.0, 1.0));
            #else
                ${state._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleRampGradientBlock", ParticleRampGradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleBlendMultiplyBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleBlendMultiplyBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the alphaTexture input component
   */
  get alphaTexture() {
    return this._inputs[1];
  }
  /**
   * Gets the alphaColor input component
   */
  get alphaColor() {
    return this._inputs[2];
  }
  /**
   * Gets the blendColor output component
   */
  get blendColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("sourceAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state.compilationString += `
            #ifdef BLENDMULTIPLYMODE
                ${state._declareOutput(this.blendColor)};
                ${state._declareLocalVar("sourceAlpha", NodeMaterialBlockConnectionPointTypes.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName} = vec4${state.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);
            #else
                ${state._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleBlendMultiplyBlock", ParticleBlendMultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock = class extends NodeMaterialBlock {
  /**
   * Create a new VectorMergerBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.xSwizzle = "x";
    this.ySwizzle = "y";
    this.zSwizzle = "z";
    this.wSwizzle = "w";
    this.registerInput("xyzw ", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("zw ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VectorMergerBlock";
  }
  /**
   * Gets the xyzw component (input)
   */
  get xyzwIn() {
    return this._inputs[0];
  }
  /**
   * Gets the xyz component (input)
   */
  get xyzIn() {
    return this._inputs[1];
  }
  /**
   * Gets the xy component (input)
   */
  get xyIn() {
    return this._inputs[2];
  }
  /**
   * Gets the zw component (input)
   */
  get zwIn() {
    return this._inputs[3];
  }
  /**
   * Gets the x component (input)
   */
  get x() {
    return this._inputs[4];
  }
  /**
   * Gets the y component (input)
   */
  get y() {
    return this._inputs[5];
  }
  /**
   * Gets the z component (input)
   */
  get z() {
    return this._inputs[6];
  }
  /**
   * Gets the w component (input)
   */
  get w() {
    return this._inputs[7];
  }
  /**
   * Gets the xyzw component (output)
   */
  get xyzw() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component (output)
   */
  get xyzOut() {
    return this._outputs[1];
  }
  /**
   * Gets the xy component (output)
   */
  get xyOut() {
    return this._outputs[2];
  }
  /**
   * Gets the zw component (output)
   */
  get zwOut() {
    return this._outputs[3];
  }
  /**
   * Gets the xy component (output)
   * @deprecated Please use xyOut instead.
   */
  get xy() {
    return this.xyOut;
  }
  /**
   * Gets the xyz component (output)
   * @deprecated Please use xyzOut instead.
   */
  get xyz() {
    return this.xyzOut;
  }
  _inputRename(name) {
    if (name === "xyzw ") {
      return "xyzwIn";
    }
    if (name === "xyz ") {
      return "xyzIn";
    }
    if (name === "xy ") {
      return "xyIn";
    }
    if (name === "zw ") {
      return "zwIn";
    }
    return name;
  }
  _buildSwizzle(len) {
    const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;
    return "." + swizzle.substring(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const xInput = this.x;
    const yInput = this.y;
    const zInput = this.z;
    const wInput = this.w;
    const xyInput = this.xyIn;
    const zwInput = this.zwIn;
    const xyzInput = this.xyzIn;
    const xyzwInput = this.xyzwIn;
    const v4Output = this._outputs[0];
    const v3Output = this._outputs[1];
    const v2Output = this._outputs[2];
    const v2CompOutput = this._outputs[3];
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);
    if (xyzwInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v4Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyzInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyInput.isConnected) {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    } else {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${vec2}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"})${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.xSwizzle = this.xSwizzle;
    serializationObject.ySwizzle = this.ySwizzle;
    serializationObject.zSwizzle = this.zSwizzle;
    serializationObject.wSwizzle = this.wSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.xSwizzle = serializationObject.xSwizzle ?? "x";
    this.ySwizzle = serializationObject.ySwizzle ?? "y";
    this.zSwizzle = serializationObject.zSwizzle ?? "z";
    this.wSwizzle = serializationObject.wSwizzle ?? "w";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";
`;
    codeString += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";
`;
    codeString += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";
`;
    codeString += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";
`;
    return codeString;
  }
};
RegisterClass("BABYLON.VectorMergerBlock", VectorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new RemapBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.sourceRange = new Vector2(-1, 1);
    this.targetRange = new Vector2(0, 1);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RemapBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the source min input component
   */
  get sourceMin() {
    return this._inputs[1];
  }
  /**
   * Gets the source max input component
   */
  get sourceMax() {
    return this._inputs[2];
  }
  /**
   * Gets the target min input component
   */
  get targetMin() {
    return this._inputs[3];
  }
  /**
   * Gets the target max input component
   */
  get targetMax() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
    const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
    const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
    const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
    state.compilationString += state._declareOutput(output) + ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});
`;
    codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.sourceRange = this.sourceRange.asArray();
    serializationObject.targetRange = this.targetRange.asArray();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
    this.targetRange = Vector2.FromArray(serializationObject.targetRange);
  }
};
__decorate([
  editableInPropertyPage(
    "From",
    3
    /* PropertyTypeForEdition.Vector2 */
  )
], RemapBlock.prototype, "sourceRange", void 0);
__decorate([
  editableInPropertyPage(
    "To",
    3
    /* PropertyTypeForEdition.Vector2 */
  )
], RemapBlock.prototype, "targetRange", void 0);
RegisterClass("BABYLON.RemapBlock", RemapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/baseMathBlock.js
var BaseMathBlock = class extends NodeMaterialBlock {
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this.output._typeConnectionSource = this.left;
    this._linkConnectionTypes(0, 1, true);
    this.left.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this.right.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._connectionObservers = [
      this.left.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),
      this.right.onTypeChangedObservable.add(() => this._updateInputOutputTypes())
    ];
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _updateInputOutputTypes() {
    this.output._typeConnectionSource = this.left;
    if (this.left.isConnected && this.right.isConnected) {
      if (this.left.type === NodeMaterialBlockConnectionPointTypes.Int || this.left.type === NodeMaterialBlockConnectionPointTypes.Float && this.right.type !== NodeMaterialBlockConnectionPointTypes.Int) {
        this.output._typeConnectionSource = this.right;
      }
    } else if (this.left.isConnected !== this.right.isConnected) {
      this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;
    }
    if (this.left.isConnected || this.right.isConnected) {
      for (const [first, second] of [
        [this.left, this.right],
        [this.right, this.left]
      ]) {
        first.acceptedConnectionPointTypes = [NodeMaterialBlockConnectionPointTypes.Int, NodeMaterialBlockConnectionPointTypes.Float];
        if (second.isConnected) {
          first.acceptedConnectionPointTypes.push(second.type);
          if (second.type === NodeMaterialBlockConnectionPointTypes.Int || second.type === NodeMaterialBlockConnectionPointTypes.Float) {
            first.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockConnectionPointTypes.Matrix);
          }
        }
      }
    }
  }
  /**
   * Release resources
   */
  dispose() {
    super.dispose();
    for (const observer of this._connectionObservers) {
      observer.remove();
    }
    this._connectionObservers.length = 0;
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock = class extends BaseMathBlock {
  /**
   * Creates a new MultiplyBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MultiplyBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.MultiplyBlock", MultiplyBlock);

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.defines.js
var ImageProcessingConfigurationDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = 0;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.EXPOSURE = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.rebuild();
  }
};

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = class _BaseParticleSystem {
  /**
   * The amount of time the particle system is running (depends of the overall update speed).
   */
  get targetStopDuration() {
    return this._targetStopDuration;
  }
  set targetStopDuration(value) {
    if (this._targetStopDuration === value) {
      return;
    }
    this._targetStopDuration = value;
  }
  /**
   * Returns true if the particle system was generated by a node particle system set
   */
  get isNodeGenerated() {
    return false;
  }
  /**
   * Gets or sets a texture used to add random noise to particle positions
   */
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this._noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    this._reset();
  }
  /** @internal */
  get _isAnimationSheetEnabled() {
    return this._animationSheetEnabled;
  }
  set _isAnimationSheetEnabled(value) {
    if (this._animationSheetEnabled === value) {
      return;
    }
    this._animationSheetEnabled = value;
  }
  /**
   * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
   */
  get isAnimationSheetEnabled() {
    return this._isAnimationSheetEnabled;
  }
  set isAnimationSheetEnabled(value) {
    if (this._isAnimationSheetEnabled == value) {
      return;
    }
    this._isAnimationSheetEnabled = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.
   */
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
  }
  /**
   * Get hosting scene
   * @returns the scene
   */
  getScene() {
    return this._scene;
  }
  _hasTargetStopDurationDependantGradient() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  }
  _setEngineBasedOnBlendMode(blendMode) {
    switch (blendMode) {
      case _BaseParticleSystem.BLENDMODE_MULTIPLYADD:
        return;
      case _BaseParticleSystem.BLENDMODE_ADD:
        blendMode = 1;
        break;
      case _BaseParticleSystem.BLENDMODE_ONEONE:
        blendMode = 6;
        break;
      case _BaseParticleSystem.BLENDMODE_STANDARD:
        blendMode = 2;
        break;
      case _BaseParticleSystem.BLENDMODE_MULTIPLY:
        blendMode = 4;
        break;
      case _BaseParticleSystem.BLENDMODE_SUBTRACT:
        blendMode = 3;
        break;
      default:
        break;
    }
    this._engine.setAlphaMode(blendMode);
  }
  /**
   * Gets the current list of drag gradients.
   * You must use addDragGradient and removeDragGradient to update this list
   * @returns the list of drag gradients
   */
  getDragGradients() {
    return this._dragGradients;
  }
  /**
   * Gets the current list of limit velocity gradients.
   * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list
   * @returns the list of limit velocity gradients
   */
  getLimitVelocityGradients() {
    return this._limitVelocityGradients;
  }
  /**
   * Gets the current list of color gradients.
   * You must use addColorGradient and removeColorGradient to update this list
   * @returns the list of color gradients
   */
  getColorGradients() {
    return this._colorGradients;
  }
  /**
   * Gets the current list of size gradients.
   * You must use addSizeGradient and removeSizeGradient to update this list
   * @returns the list of size gradients
   */
  getSizeGradients() {
    return this._sizeGradients;
  }
  /**
   * Gets the current list of color remap gradients.
   * You must use addColorRemapGradient and removeColorRemapGradient to update this list
   * @returns the list of color remap gradients
   */
  getColorRemapGradients() {
    return this._colorRemapGradients;
  }
  /**
   * Gets the current list of alpha remap gradients.
   * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list
   * @returns the list of alpha remap gradients
   */
  getAlphaRemapGradients() {
    return this._alphaRemapGradients;
  }
  /**
   * Gets the current list of life time gradients.
   * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list
   * @returns the list of life time gradients
   */
  getLifeTimeGradients() {
    return this._lifeTimeGradients;
  }
  /**
   * Gets the current list of angular speed gradients.
   * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list
   * @returns the list of angular speed gradients
   */
  getAngularSpeedGradients() {
    return this._angularSpeedGradients;
  }
  /**
   * Gets the current list of velocity gradients.
   * You must use addVelocityGradient and removeVelocityGradient to update this list
   * @returns the list of velocity gradients
   */
  getVelocityGradients() {
    return this._velocityGradients;
  }
  /**
   * Gets the current list of start size gradients.
   * You must use addStartSizeGradient and removeStartSizeGradient to update this list
   * @returns the list of start size gradients
   */
  getStartSizeGradients() {
    return this._startSizeGradients;
  }
  /**
   * Gets the current list of emit rate gradients.
   * You must use addEmitRateGradient and removeEmitRateGradient to update this list
   * @returns the list of emit rate gradients
   */
  getEmitRateGradients() {
    return this._emitRateGradients;
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction1() {
    if (this.particleEmitterType.direction1) {
      return this.particleEmitterType.direction1;
    }
    return Vector3.Zero();
  }
  set direction1(value) {
    if (this.particleEmitterType.direction1) {
      this.particleEmitterType.direction1 = value;
    }
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction2() {
    if (this.particleEmitterType.direction2) {
      return this.particleEmitterType.direction2;
    }
    return Vector3.Zero();
  }
  set direction2(value) {
    if (this.particleEmitterType.direction2) {
      this.particleEmitterType.direction2 = value;
    }
  }
  /**
   * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get minEmitBox() {
    if (this.particleEmitterType.minEmitBox) {
      return this.particleEmitterType.minEmitBox;
    }
    return Vector3.Zero();
  }
  set minEmitBox(value) {
    if (this.particleEmitterType.minEmitBox) {
      this.particleEmitterType.minEmitBox = value;
    }
  }
  /**
   * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get maxEmitBox() {
    if (this.particleEmitterType.maxEmitBox) {
      return this.particleEmitterType.maxEmitBox;
    }
    return Vector3.Zero();
  }
  set maxEmitBox(value) {
    if (this.particleEmitterType.maxEmitBox) {
      this.particleEmitterType.maxEmitBox = value;
    }
  }
  /**
   * Gets or sets the billboard mode to use when isBillboardBased = true.
   * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
   */
  get isBillboardBased() {
    return this._isBillboardBased;
  }
  set isBillboardBased(value) {
    if (this._isBillboardBased === value) {
      return;
    }
    this._isBillboardBased = value;
    this._reset();
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  }
  /** @internal */
  _reset() {
  }
  /**
   * @internal
   */
  _removeGradientAndTexture(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    let index = 0;
    for (const valueGradient of gradients) {
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  }
  /**
   * Instantiates a particle system.
   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
   * @param name The name of the particle system
   */
  constructor(name) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this._targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this.applyFog = false;
    this._wasDispatched = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = _BaseParticleSystem.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this._animationSheetEnabled = false;
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this._useLogarithmicDepth = false;
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name;
    this.name = name;
  }
  /**
   * Creates a Point Emitter for the particle system (emits directly from the emitter position)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   */
  createPointEmitter(direction1, direction2) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
   * @param radius The radius of the hemisphere to emit from
   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
   * @param radius The radius of the sphere to emit from
   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createSphereEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the sphere to emit from
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
   */
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
   * @param radius The radius of the emission cylinder
   * @param height The height of the emission cylinder
   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
   * @param directionRandomizer How much to randomize the particle direction [0-1]
   */
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the cylinder to emit from
   * @param height The height of the emission cylinder
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
   */
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
   * @param radius The radius of the cone to emit from
   * @param angle The base angle of the cone
   */
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    throw new Error("Method not implemented.");
  }
  createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
   */
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    throw new Error("Method not implemented.");
  }
};
BaseParticleSystem.BLENDMODE_ONEONE = 0;
BaseParticleSystem.BLENDMODE_STANDARD = 1;
BaseParticleSystem.BLENDMODE_ADD = 2;
BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;
BaseParticleSystem.BLENDMODE_SUBTRACT = -1;
RegisterClass("BABYLON.BaseParticleSystem", BaseParticleSystem);

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ColorSplitterBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ColorSplitterBlock";
  }
  /**
   * Gets the rgba component (input)
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb component (input)
   */
  get rgbIn() {
    return this._inputs[1];
  }
  /**
   * Gets the rgb component (output)
   */
  get rgbOut() {
    return this._outputs[0];
  }
  /**
   * Gets the r component (output)
   */
  get r() {
    return this._outputs[1];
  }
  /**
   * Gets the g component (output)
   */
  get g() {
    return this._outputs[2];
  }
  /**
   * Gets the b component (output)
   */
  get b() {
    return this._outputs[3];
  }
  /**
   * Gets the a component (output)
   */
  get a() {
    return this._outputs[4];
  }
  _inputRename(name) {
    if (name === "rgb ") {
      return "rgbIn";
    }
    return name;
  }
  _outputRename(name) {
    if (name === "rgb") {
      return "rgbOut";
    }
    return name;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.rgba.isConnected ? this.rgba : this.rgbIn;
    if (!input.isConnected) {
      return;
    }
    const rgbOutput = this._outputs[0];
    const rOutput = this._outputs[1];
    const gOutput = this._outputs[2];
    const bOutput = this._outputs[3];
    const aOutput = this._outputs[4];
    if (rgbOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(rgbOutput) + ` = ${input.associatedVariableName}.rgb;
`;
    }
    if (rOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(rOutput) + ` = ${input.associatedVariableName}.r;
`;
    }
    if (gOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(gOutput) + ` = ${input.associatedVariableName}.g;
`;
    }
    if (bOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(bOutput) + ` = ${input.associatedVariableName}.b;
`;
    }
    if (aOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(aOutput) + ` = ${input.associatedVariableName}.a;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ColorSplitterBlock", ColorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
  }
  _beforeClear() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = class _ProceduralTexture extends Texture {
  /**
   * Gets the shader language type used to generate vertex and fragment source code.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Instantiates a new procedural texture.
   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
   * This is the base class of any Procedural texture and contains most of the shareable code.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures
   * @param name  Define the name of the texture
   * @param size Define the size of the texture to create
   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:
   *  * object: \{ fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ fragmentSource: "fragment shader code string" \}, the string contains the shader code
   *  * string: the string contains a name "XXX" to lookup in Effect.ShadersStore["XXXFragmentShader"]
   * @param scene Define the scene the texture belongs to
   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
   * @param generateMipMaps Define if the texture should creates mip maps or not
   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
   * @param textureType The FBO internal texture type
   */
  constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
    super(null, scene, !generateMipMaps);
    this.isEnabled = true;
    this.autoClear = true;
    this.onGeneratedObservable = new Observable();
    this.onBeforeGenerationObservable = new Observable();
    this.nodeMaterialSource = null;
    this.defines = "";
    this._textures = {};
    this._currentRefreshId = -1;
    this._frameId = -1;
    this._refreshRate = 1;
    this._vertexBuffers = {};
    this._uniforms = new Array();
    this._samplers = new Array();
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors4 = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._matrices = {};
    this._fallbackTextureUsed = false;
    this._cachedDefines = null;
    this._contentUpdateId = -1;
    this._rtWrapper = null;
    if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {
      this._options = fallbackTexture;
      this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;
    } else {
      this._options = {};
      this._fallbackTexture = fallbackTexture;
    }
    this._shaderLanguage = this._options.shaderLanguage ?? 0;
    scene = this.getScene() || EngineStore.LastCreatedScene;
    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(this);
    this._fullEngine = scene.getEngine();
    this.name = name;
    this.isRenderTarget = true;
    this._size = size;
    this._textureType = textureType;
    this._generateMipMaps = generateMipMaps;
    this._drawWrapper = new DrawWrapper(this._fullEngine);
    this.setFragment(fragment);
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
    this._texture = rtWrapper.texture;
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  _createRtWrapper(isCube, size, generateMipMaps, textureType) {
    if (isCube) {
      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      this.setFloat("face", 0);
    } else {
      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      if (this._rtWrapper.is3D) {
        this.setFloat("layer", 0);
        this.setInt("layerNum", 0);
      }
    }
    return this._rtWrapper;
  }
  /**
   * The effect that is created when initializing the post process.
   * @returns The created effect corresponding the postprocess.
   */
  getEffect() {
    return this._drawWrapper.effect;
  }
  /**
   * @internal
   */
  _setEffect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Gets texture content (Use this function wisely as reading from a texture can be slow)
   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)
   */
  getContent() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    if (this._contentData) {
      this._contentData.then((buffer) => {
        this._contentData = this.readPixels(0, 0, buffer);
        this._contentUpdateId = this._frameId;
      });
    } else {
      this._contentData = this.readPixels(0, 0);
      this._contentUpdateId = this._frameId;
    }
    return this._contentData;
  }
  _createIndexBuffer() {
    const engine = this._fullEngine;
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  }
  /**
   * Resets the texture in order to recreate its associated resources.
   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code
   */
  reset() {
    this._drawWrapper.effect?.dispose();
    this._drawWrapper.effect = null;
    this._cachedDefines = null;
  }
  _getDefines() {
    return this.defines;
  }
  /**
   * Executes a function when the texture will be ready to be drawn.
   * @param func The callback to be used.
   */
  executeWhenReady(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    const effect = this.getEffect();
    if (effect) {
      effect.executeWhenCompiled(() => {
        func(this);
      });
    }
  }
  /**
   * Is the texture ready to be used ? (rendered at least once)
   * @returns true if ready, otherwise, false.
   */
  isReady() {
    const engine = this._fullEngine;
    if (this.nodeMaterialSource) {
      return this._drawWrapper.effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    if (!this._texture) {
      return false;
    }
    const defines = this._getDefines();
    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
      return true;
    }
    const shaders = {
      vertex: "procedural",
      fragmentElement: this._fragment.fragmentElement,
      fragmentSource: this._fragment.fragmentSource,
      fragment: typeof this._fragment === "string" ? this._fragment : void 0
    };
    if (this._cachedDefines !== defines) {
      this._cachedDefines = defines;
      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
        this._rtWrapper?.dispose();
        this._rtWrapper = this._texture = null;
        if (this._fallbackTexture) {
          this._texture = this._fallbackTexture._texture;
          if (this._texture) {
            this._texture.incrementReferences();
          }
        }
        this._fallbackTextureUsed = true;
      }, void 0, this._shaderLanguage, async () => {
        if (this._options.extraInitializationsAsync) {
          if (this.shaderLanguage === 1) {
            await Promise.all([import("./procedural.vertex-VNRRVKM3.js"), this._options.extraInitializationsAsync()]);
          } else {
            await Promise.all([import("./procedural.vertex-OCNRADYZ.js"), this._options.extraInitializationsAsync()]);
          }
        } else {
          if (this.shaderLanguage === 1) {
            await import("./procedural.vertex-VNRRVKM3.js");
          } else {
            await import("./procedural.vertex-OCNRADYZ.js");
          }
        }
      });
    }
    return this._drawWrapper.effect.isReady();
  }
  /**
   * Resets the refresh counter of the texture and start bak from scratch.
   * Could be useful to regenerate the texture if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  /**
   * Set the fragment shader to use in order to render the texture.
   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
   */
  setFragment(fragment) {
    this._fragment = fragment;
  }
  /**
   * Define the refresh rate of the texture or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  /** @internal */
  _shouldRender() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  /**
   * Get the size the texture is rendering at.
   * @returns the size (on cube texture it is always squared)
   */
  getRenderSize() {
    return this._size;
  }
  /**
   * Resize the texture to new value.
   * @param size Define the new size the texture should have
   * @param generateMipMaps Define whether the new texture should create mip maps
   */
  resize(size, generateMipMaps) {
    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
      return;
    }
    const isCube = this._texture.isCube;
    this._rtWrapper.dispose();
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
    this._texture = rtWrapper.texture;
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  }
  _checkUniform(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader program used to render.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setTexture(name, texture) {
    if (this._samplers.indexOf(name) === -1) {
      this._samplers.push(name);
    }
    this._textures[name] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloat(name, value) {
    this._checkUniform(name);
    this._floats[name] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setInt(name, value) {
    this._checkUniform(name);
    this._ints[name] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloats(name, value) {
    this._checkUniform(name);
    this._floatsArrays[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor3(name, value) {
    this._checkUniform(name);
    this._colors3[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor4(name, value) {
    this._checkUniform(name);
    this._colors4[name] = value;
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector2(name, value) {
    this._checkUniform(name);
    this._vectors2[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector3(name, value) {
    this._checkUniform(name);
    this._vectors3[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector4(name, value) {
    this._checkUniform(name);
    this._vectors4[name] = value;
    return this;
  }
  /**
   * Set a mat4 in the shader from a MAtrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setMatrix(name, value) {
    this._checkUniform(name);
    this._matrices[name] = value;
    return this;
  }
  /**
   * Render the texture to its associated render target.
   * @param useCameraPostProcess Define if camera post process should be applied to the texture
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(useCameraPostProcess) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this._fullEngine;
    engine.enableEffect(this._drawWrapper);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (const name in this._textures) {
        this._drawWrapper.effect.setTexture(name, this._textures[name]);
      }
      for (const name in this._ints) {
        this._drawWrapper.effect.setInt(name, this._ints[name]);
      }
      for (const name in this._floats) {
        this._drawWrapper.effect.setFloat(name, this._floats[name]);
      }
      for (const name in this._floatsArrays) {
        this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);
      }
      for (const name in this._colors3) {
        this._drawWrapper.effect.setColor3(name, this._colors3[name]);
      }
      for (const name in this._colors4) {
        const color = this._colors4[name];
        this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);
      }
      for (const name in this._vectors2) {
        this._drawWrapper.effect.setVector2(name, this._vectors2[name]);
      }
      for (const name in this._vectors3) {
        this._drawWrapper.effect.setVector3(name, this._vectors3[name]);
      }
      for (const name in this._vectors4) {
        this._drawWrapper.effect.setVector4(name, this._vectors4[name]);
      }
      for (const name in this._matrices) {
        this._drawWrapper.effect.setMatrix(name, this._matrices[name]);
      }
    }
    if (!this._texture || !this._rtWrapper) {
      return;
    }
    engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);
    const viewPort = engine.currentViewport;
    if (this.isCube) {
      for (let face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        this._drawWrapper.effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, true);
      }
    } else {
      let numLayers = 1;
      if (this._rtWrapper.is3D) {
        numLayers = this._rtWrapper.depth;
      } else if (this._rtWrapper.is2DArray) {
        numLayers = this._rtWrapper.layers;
      }
      for (let layer = 0; layer < numLayers; layer++) {
        engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true, 0, layer);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {
          this._drawWrapper.effect?.setFloat("layer", numLayers !== 1 ? layer / (numLayers - 1) : 0);
          this._drawWrapper.effect?.setInt("layerNum", layer);
          for (const name in this._textures) {
            this._drawWrapper.effect.setTexture(name, this._textures[name]);
          }
        }
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);
      }
    }
    if (viewPort) {
      engine.setViewport(viewPort);
    }
    if (this.isCube) {
      engine.generateMipMapsForCubemap(this._texture, true);
    }
    engine._debugPopGroup?.(1);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  }
  /**
   * Clone the texture.
   * @returns the cloned texture
   */
  clone() {
    const textureSize = this.getSize();
    const newTexture = new _ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    super.dispose();
  }
};
__decorate([
  serialize()
], ProceduralTexture.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "autoClear", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_generateMipMaps", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_size", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "refreshRate", null);
RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations;
(function(TrigonometryBlockOperations2) {
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Set"] = 18] = "Set";
})(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
var TrigonometryBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new TrigonometryBlock
   * @param name defines the block name
   */
  constructor(name) {
    super(name, NodeMaterialBlockTargets.Neutral);
    this.operation = TrigonometryBlockOperations.Cos;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TrigonometryBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    let operation = "";
    switch (this.operation) {
      case TrigonometryBlockOperations.Cos: {
        operation = "cos";
        break;
      }
      case TrigonometryBlockOperations.Sin: {
        operation = "sin";
        break;
      }
      case TrigonometryBlockOperations.Abs: {
        operation = "abs";
        break;
      }
      case TrigonometryBlockOperations.Exp: {
        operation = "exp";
        break;
      }
      case TrigonometryBlockOperations.Exp2: {
        operation = "exp2";
        break;
      }
      case TrigonometryBlockOperations.Round: {
        operation = "round";
        break;
      }
      case TrigonometryBlockOperations.Floor: {
        operation = "floor";
        break;
      }
      case TrigonometryBlockOperations.Ceiling: {
        operation = "ceil";
        break;
      }
      case TrigonometryBlockOperations.Sqrt: {
        operation = "sqrt";
        break;
      }
      case TrigonometryBlockOperations.Log: {
        operation = "log";
        break;
      }
      case TrigonometryBlockOperations.Tan: {
        operation = "tan";
        break;
      }
      case TrigonometryBlockOperations.ArcTan: {
        operation = "atan";
        break;
      }
      case TrigonometryBlockOperations.ArcCos: {
        operation = "acos";
        break;
      }
      case TrigonometryBlockOperations.ArcSin: {
        operation = "asin";
        break;
      }
      case TrigonometryBlockOperations.Fract: {
        operation = "fract";
        break;
      }
      case TrigonometryBlockOperations.Sign: {
        operation = "sign";
        break;
      }
      case TrigonometryBlockOperations.Radians: {
        operation = "radians";
        break;
      }
      case TrigonometryBlockOperations.Degrees: {
        operation = "degrees";
        break;
      }
      case TrigonometryBlockOperations.Set: {
        operation = "";
        break;
      }
    }
    state.compilationString += state._declareOutput(output) + ` = ${operation}(${this.input.associatedVariableName});
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.operation = serializationObject.operation;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Operation", 4, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "Cos", value: TrigonometryBlockOperations.Cos },
      { label: "Sin", value: TrigonometryBlockOperations.Sin },
      { label: "Abs", value: TrigonometryBlockOperations.Abs },
      { label: "Exp", value: TrigonometryBlockOperations.Exp },
      { label: "Exp2", value: TrigonometryBlockOperations.Exp2 },
      { label: "Round", value: TrigonometryBlockOperations.Round },
      { label: "Floor", value: TrigonometryBlockOperations.Floor },
      { label: "Ceiling", value: TrigonometryBlockOperations.Ceiling },
      { label: "Sqrt", value: TrigonometryBlockOperations.Sqrt },
      { label: "Log", value: TrigonometryBlockOperations.Log },
      { label: "Tan", value: TrigonometryBlockOperations.Tan },
      { label: "ArcTan", value: TrigonometryBlockOperations.ArcTan },
      { label: "ArcCos", value: TrigonometryBlockOperations.ArcCos },
      { label: "ArcSin", value: TrigonometryBlockOperations.ArcSin },
      { label: "Fract", value: TrigonometryBlockOperations.Fract },
      { label: "Sign", value: TrigonometryBlockOperations.Sign },
      { label: "Radians", value: TrigonometryBlockOperations.Radians },
      { label: "Degrees", value: TrigonometryBlockOperations.Degrees },
      { label: "Set", value: TrigonometryBlockOperations.Set }
    ]
  })
], TrigonometryBlock.prototype, "operation", void 0);
RegisterClass("BABYLON.TrigonometryBlock", TrigonometryBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var NodeMaterialDefines = class extends MaterialDefines {
  /**
   * Creates a new NodeMaterialDefines
   */
  constructor() {
    super();
    this.NORMAL = false;
    this.TANGENT = false;
    this.VERTEXCOLOR_NME = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.PREPASS = false;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_WORLD_NORMAL = false;
    this.PREPASS_WORLD_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_LOCAL_POSITION = false;
    this.PREPASS_LOCAL_POSITION_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_SCREENSPACE_DEPTH = false;
    this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_POSITION = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.MORPHTARGETS_UV2 = false;
    this.MORPHTARGETS_COLOR = false;
    this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
    this.MORPHTARGETTEXTURE_HASNORMALS = false;
    this.MORPHTARGETTEXTURE_HASTANGENTS = false;
    this.MORPHTARGETTEXTURE_HASUVS = false;
    this.MORPHTARGETTEXTURE_HASUV2S = false;
    this.MORPHTARGETTEXTURE_HASCOLORS = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = 0;
    this.CONTRAST = false;
    this.EXPOSURE = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.BUMPDIRECTUV = 0;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.AREALIGHTSUPPORTED = true;
    this.AREALIGHTNOROUGHTNESS = true;
    this.rebuild();
  }
  /**
   * Set the value of a specific key
   * @param name defines the name of the key to set
   * @param value defines the value to set
   * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing
   */
  setValue(name, value, markAsUnprocessedIfDirty = false) {
    if (this[name] === void 0) {
      this._keys.push(name);
    }
    if (markAsUnprocessedIfDirty && this[name] !== value) {
      this.markAsUnprocessed();
    }
    this[name] = value;
  }
};
var NodeMaterial = class _NodeMaterial extends PushMaterial {
  /**
   * Checks if a block is a texture block
   * @param block The block to check
   * @returns True if the block is a texture block
   */
  static _BlockIsTextureBlock(block) {
    return block.getClassName() === "TextureBlock" || block.getClassName() === "ReflectionTextureBaseBlock" || block.getClassName() === "ReflectionTextureBlock" || block.getClassName() === "ReflectionBlock" || block.getClassName() === "RefractionBlock" || block.getClassName() === "CurrentScreenBlock" || block.getClassName() === "SmartFilterTextureBlock" || block.getClassName() === "ParticleTextureBlock" || block.getClassName() === "ImageSourceBlock" || block.getClassName() === "TriPlanarBlock" || block.getClassName() === "BiPlanarBlock" || block.getClassName() === "PrePassTextureBlock";
  }
  set _glowModeEnabled(value) {
    this._useAdditionalColor = value;
  }
  /** Get the inspector from bundle or global
   * @returns the global NME
   */
  _getGlobalNodeMaterialEditor() {
    if (typeof NODEEDITOR !== "undefined") {
      return NODEEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  /** Gets or sets the active shader language */
  get shaderLanguage() {
    return this._options?.shaderLanguage || _NodeMaterial.DefaultShaderLanguage;
  }
  set shaderLanguage(value) {
    this._options.shaderLanguage = value;
  }
  /** Gets or sets options to control the node material overall behavior */
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets or sets the mode property
   */
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
  }
  /** Gets or sets the unique identifier used to identified the effect associated with the material */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Create a new node based material
   * @param name defines the material name
   * @param scene defines the hosting scene
   * @param options defines creation option
   */
  constructor(name, scene, options = {}) {
    super(name, scene || EngineStore.LastCreatedScene);
    this._buildId = _NodeMaterial._BuildIdGenerator++;
    this._buildWasSuccessful = false;
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._optimizers = new Array();
    this._animationFrame = -1;
    this._buildIsInProgress = false;
    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();
    this._useAdditionalColor = false;
    this.editorData = null;
    this.ignoreAlpha = false;
    this.maxSimultaneousLights = 4;
    this.onBuildObservable = new Observable();
    this.onBuildErrorObservable = new Observable();
    this._vertexOutputNodes = new Array();
    this._fragmentOutputNodes = new Array();
    this.attachedBlocks = [];
    this._mode = NodeMaterialModes.Material;
    this.forceAlphaBlending = false;
    if (!_NodeMaterial.UseNativeShaderLanguageOfEngine && options && options.shaderLanguage === 1 && !this.getScene().getEngine().isWebGPU) {
      throw new Error("WebGPU shader language is only supported with WebGPU engine");
    }
    this._options = {
      emitComments: false,
      shaderLanguage: _NodeMaterial.DefaultShaderLanguage,
      ...options
    };
    if (_NodeMaterial.UseNativeShaderLanguageOfEngine) {
      this._options.shaderLanguage = this.getScene().getEngine().isWebGPU ? 1 : 0;
    }
    this._attachImageProcessingConfiguration(null);
  }
  /**
   * Gets the current class name of the material e.g. "NodeMaterial"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterial";
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  /**
   * Get a block by its name
   * @param name defines the name of the block to retrieve
   * @returns the required block or null if not found
   */
  getBlockByName(name) {
    let result = null;
    for (const block of this.attachedBlocks) {
      if (block.name === name) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name + "`");
          return result;
        }
      }
    }
    return result;
  }
  /**
   * Get a block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required block or null if not found
   */
  getBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Get an input block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required input block or null if not found
   */
  getInputBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (block.isInput && predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Gets the list of input blocks attached to this material
   * @returns an array of InputBlocks
   */
  getInputBlocks() {
    const blocks = [];
    for (const block of this.attachedBlocks) {
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  }
  /**
   * Adds a new optimizer to the list of optimizers
   * @param optimizer defines the optimizers to add
   * @returns the current material
   */
  registerOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index > -1) {
      return;
    }
    this._optimizers.push(optimizer);
    return this;
  }
  /**
   * Remove an optimizer from the list of optimizers
   * @param optimizer defines the optimizers to remove
   * @returns the current material
   */
  unregisterOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index === -1) {
      return;
    }
    this._optimizers.splice(index, 1);
    return this;
  }
  /**
   * Add a new block to the list of output nodes
   * @param node defines the node to add
   * @returns the current material
   */
  addOutputNode(node) {
    if (node.target === null) {
      throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._addVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._addFragmentOutputNode(node);
    }
    return this;
  }
  /**
   * Remove a block from the list of root nodes
   * @param node defines the node to remove
   * @returns the current material
   */
  removeOutputNode(node) {
    if (node.target === null) {
      return this;
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._removeVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._removeFragmentOutputNode(node);
    }
    return this;
  }
  _addVertexOutputNode(node) {
    if (this._vertexOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Vertex;
    this._vertexOutputNodes.push(node);
    return this;
  }
  _removeVertexOutputNode(node) {
    const index = this._vertexOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._vertexOutputNodes.splice(index, 1);
    return this;
  }
  _addFragmentOutputNode(node) {
    if (this._fragmentOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Fragment;
    this._fragmentOutputNodes.push(node);
    return this;
  }
  _removeFragmentOutputNode(node) {
    const index = this._fragmentOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._fragmentOutputNodes.splice(index, 1);
    return this;
  }
  get _supportGlowLayer() {
    if (this._fragmentOutputNodes.length === 0) {
      return false;
    }
    if (this._fragmentOutputNodes.some((f) => f.additionalColor && f.additionalColor.isConnected)) {
      return true;
    }
    return false;
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    if (this.ignoreAlpha) {
      return false;
    }
    return this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._sharedData && this._sharedData.hints.needAlphaTesting;
  }
  _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
      nodesToProcessForOtherBuildState.push(block);
    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
      nodesToProcessForOtherBuildState.push(block);
    }
    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);
  }
  _attachBlock(node) {
    if (this.attachedBlocks.indexOf(node) === -1) {
      if (node.isUnique) {
        const className = node.getClassName();
        for (const other of this.attachedBlocks) {
          if (other.getClassName() === className) {
            this._sharedData.raiseBuildError(`Cannot have multiple blocks of type ${className} in the same NodeMaterial`);
            return;
          }
        }
      }
      this.attachedBlocks.push(node);
    }
  }
  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    node.initialize(state);
    if (autoConfigure) {
      node.autoConfigure(this);
    }
    node._preparationId = this._buildId;
    this._attachBlock(node);
    for (const input of node.inputs) {
      input.associatedVariableName = "";
      const connectedPoint = input.connectedPoint;
      if (connectedPoint && !connectedPoint._preventBubbleUp) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    }
    if (node.isLoop) {
      const loopBlock = node;
      if (loopBlock.loopID.hasEndpoints) {
        for (const endpoint of loopBlock.loopID.endpoints) {
          const block = endpoint.ownerBlock;
          if (block.outputs.length !== 0) {
            continue;
          }
          state._terminalBlocks.add(block);
          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    } else if (node.isTeleportOut) {
      const teleport = node;
      if (teleport.entryPoint) {
        this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);
      }
    }
    for (const output of node.outputs) {
      output.associatedVariableName = "";
    }
  }
  _resetDualBlocks(node, id) {
    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
      node.buildId = id;
    }
    for (const input of node.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint && !connectedPoint._preventBubbleUp) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._resetDualBlocks(block, id);
        }
      }
    }
    if (node.isTeleportOut) {
      const teleportOut = node;
      if (teleportOut.entryPoint) {
        this._resetDualBlocks(teleportOut.entryPoint, id);
      }
    } else if (node.isLoop) {
      const loopBlock = node;
      if (loopBlock.loopID.hasEndpoints) {
        for (const endpoint of loopBlock.loopID.endpoints) {
          const block = endpoint.ownerBlock;
          if (block.outputs.length !== 0) {
            continue;
          }
          this._resetDualBlocks(block, id);
        }
      }
    }
  }
  /**
   * Remove a block from the current node material
   * @param block defines the block to remove
   */
  removeBlock(block) {
    const attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block.isFinalMerger) {
      this.removeOutputNode(block);
    }
  }
  /**
   * Build the material and generates the inner effect
   * @param verbose defines if the build should log activity
   * @param updateBuildId defines if the internal build Id should be updated (default is true)
   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)
   */
  build(verbose = false, updateBuildId = true, autoConfigure = false) {
    if (this._buildIsInProgress) {
      Logger.Warn("Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.");
      return;
    }
    this._buildIsInProgress = true;
    if (!this._vertexCompilationState && !autoConfigure) {
      autoConfigure = true;
    }
    this._buildWasSuccessful = false;
    const engine = this.getScene().getEngine();
    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle || this._mode === NodeMaterialModes.SFE;
    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
      this.onBuildErrorObservable.notifyObservers("You must define at least one vertexOutputNode");
      this._buildIsInProgress = false;
      return;
    }
    if (this._fragmentOutputNodes.length === 0) {
      this.onBuildErrorObservable.notifyObservers("You must define at least one fragmentOutputNode");
      this._buildIsInProgress = false;
      return;
    }
    this._vertexCompilationState = new NodeMaterialBuildState();
    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
    this._fragmentCompilationState = new NodeMaterialBuildState();
    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
    const needToPurgeList = this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive).length > 1;
    let fragmentOutputNodes = this._fragmentOutputNodes;
    if (needToPurgeList) {
      fragmentOutputNodes = this._fragmentOutputNodes.filter((n) => !n._isFinalOutputAndActive);
      fragmentOutputNodes.push(this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive && n._hasPrecedence)[0]);
    }
    this._sharedData = new NodeMaterialBuildStateSharedData();
    this._sharedData.nodeMaterial = this;
    this._sharedData.fragmentOutputNodes = fragmentOutputNodes;
    this._vertexCompilationState.sharedData = this._sharedData;
    this._fragmentCompilationState.sharedData = this._sharedData;
    this._sharedData.buildId = this._buildId;
    this._sharedData.emitComments = this._options.emitComments;
    this._sharedData.verbose = verbose;
    this._sharedData.scene = this.getScene();
    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
    const vertexNodes = [];
    const fragmentNodes = [];
    for (const vertexOutputNode of this._vertexOutputNodes) {
      vertexNodes.push(vertexOutputNode);
      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);
    }
    for (const fragmentOutputNode of fragmentOutputNodes) {
      fragmentNodes.push(fragmentOutputNode);
      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);
    }
    let waitingNodeCount = 0;
    for (const node of this.attachedBlocks) {
      if (!node.codeIsReady) {
        waitingNodeCount++;
        node.onCodeIsReadyObservable.addOnce(() => {
          waitingNodeCount--;
          if (waitingNodeCount === 0) {
            this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
          }
        });
      }
    }
    if (waitingNodeCount !== 0) {
      return;
    }
    this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
  }
  _finishBuildProcess(verbose = false, updateBuildId = true, vertexNodes, fragmentNodes) {
    this.optimize();
    for (const vertexOutputNode of vertexNodes) {
      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
    }
    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
    this._fragmentCompilationState._vertexState = this._vertexCompilationState;
    for (const fragmentOutputNode of fragmentNodes) {
      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
    }
    for (const fragmentOutputNode of fragmentNodes) {
      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
    }
    this._vertexCompilationState.finalize(this._vertexCompilationState);
    this._fragmentCompilationState.finalize(this._fragmentCompilationState);
    if (updateBuildId) {
      this._buildId = _NodeMaterial._BuildIdGenerator++;
    }
    if (verbose) {
      Logger.Log("Vertex shader:");
      Logger.Log(this._vertexCompilationState.compilationString);
      Logger.Log("Fragment shader:");
      Logger.Log(this._fragmentCompilationState.compilationString);
    }
    const noError = this._sharedData.emitErrors();
    this._buildIsInProgress = false;
    if (noError) {
      this._buildWasSuccessful = true;
      this.onBuildObservable.notifyObservers(this);
    }
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.materialDefines) {
          continue;
        }
        const defines = subMesh.materialDefines;
        defines.markAllAsDirty();
        defines.reset();
      }
    }
    if (this.prePassTextureInputs.length) {
      this.getScene().enablePrePassRenderer();
    }
    const prePassRenderer = this.getScene().prePassRenderer;
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  }
  /**
   * Runs an optimization phase to try to improve the shader code
   */
  optimize() {
    for (const optimizer of this._optimizers) {
      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
    }
  }
  _prepareDefinesForAttributes(mesh, defines) {
    const oldNormal = defines["NORMAL"];
    const oldTangent = defines["TANGENT"];
    const oldColor = defines["VERTEXCOLOR_NME"];
    defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
    defines["VERTEXCOLOR_NME"] = hasVertexColors;
    let uvChanged = false;
    for (let i = 1; i <= 6; ++i) {
      const oldUV = defines["UV" + i];
      defines["UV" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`);
      uvChanged = uvChanged || defines["UV" + i] !== oldUV;
    }
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(this.getScene(), defines, !oit);
    MaterialHelperGeometryRendering.PrepareDefines(this.getScene().getEngine().currentRenderPassId, mesh, defines);
    if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || oldColor !== defines["VERTEXCOLOR_NME"] || uvChanged) {
      defines.markAsAttributesDirty();
    }
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return true;
  }
  /**
   * Outputs written to the prepass
   */
  get prePassTextureOutputs() {
    const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === "PrePassOutputBlock");
    const result = [4];
    if (!prePassOutputBlock) {
      return result;
    }
    if (this.prePassTextureInputs.length) {
      return result;
    }
    if (prePassOutputBlock.viewDepth.isConnected) {
      result.push(5);
    }
    if (prePassOutputBlock.screenDepth.isConnected) {
      result.push(10);
    }
    if (prePassOutputBlock.viewNormal.isConnected) {
      result.push(6);
    }
    if (prePassOutputBlock.worldNormal.isConnected) {
      result.push(8);
    }
    if (prePassOutputBlock.worldPosition.isConnected) {
      result.push(1);
    }
    if (prePassOutputBlock.localPosition.isConnected) {
      result.push(9);
    }
    if (prePassOutputBlock.reflectivity.isConnected) {
      result.push(3);
    }
    if (prePassOutputBlock.velocity.isConnected) {
      result.push(2);
    }
    if (prePassOutputBlock.velocityLinear.isConnected) {
      result.push(11);
    }
    return result;
  }
  /**
   * Gets the list of prepass texture required
   */
  get prePassTextureInputs() {
    const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === "PrePassTextureBlock");
    const result = [];
    for (const block of prePassTextureBlocks) {
      if (block.position.isConnected && !result.includes(1)) {
        result.push(1);
      }
      if (block.localPosition.isConnected && !result.includes(9)) {
        result.push(9);
      }
      if (block.depth.isConnected && !result.includes(5)) {
        result.push(5);
      }
      if (block.screenDepth.isConnected && !result.includes(10)) {
        result.push(10);
      }
      if (block.normal.isConnected && !result.includes(6)) {
        result.push(6);
      }
      if (block.worldNormal.isConnected && !result.includes(8)) {
        result.push(8);
      }
    }
    return result;
  }
  /**
   * Sets the required values to the prepass renderer.
   * @param prePassRenderer defines the prepass renderer to set
   * @returns true if the pre pass is needed
   */
  setPrePassRenderer(prePassRenderer) {
    const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);
    if (prePassRenderer && prePassTexturesRequired.length > 1) {
      let cfg = prePassRenderer.getEffectConfiguration("nodeMaterial");
      if (!cfg) {
        cfg = prePassRenderer.addEffectConfiguration({
          enabled: true,
          needsImageProcessing: false,
          name: "nodeMaterial",
          texturesRequired: []
        });
      }
      for (const prePassTexture of prePassTexturesRequired) {
        if (!cfg.texturesRequired.includes(prePassTexture)) {
          cfg.texturesRequired.push(prePassTexture);
        }
      }
      cfg.enabled = true;
    }
    return prePassTexturesRequired.length > 1;
  }
  /**
   * Create a post process from the material
   * @param camera The camera to apply the render pass to.
   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType Type of textures used when performing the post process. (default: 0)
   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
   * @returns the post process created
   */
  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    if (this.mode !== NodeMaterialModes.PostProcess && this.mode !== NodeMaterialModes.SFE) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
  }
  /**
   * Create the post process effect from the material
   * @param postProcess The post process to create the effect for
   */
  createEffectForPostProcess(postProcess) {
    this._createEffectForPostProcess(postProcess);
  }
  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    let tempName = this.name + this._buildId;
    const defines = new NodeMaterialDefines();
    let buildId = this._buildId;
    this._processDefines(defines);
    const vertexCode = this._sharedData.checks.emitVertex ? this._vertexCompilationState._builtCompilationString : void 0;
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, vertexCode, this.shaderLanguage);
    if (!postProcess) {
      postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, vertexCode ? tempName : "postprocess", { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat, this.shaderLanguage);
    } else {
      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
    }
    postProcess.nodeMaterialSource = this;
    postProcess.onApplyObservable.add((effect) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result = this._processDefines(defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName));
      }
      this._checkInternals(effect);
    });
    return postProcess;
  }
  /**
   * Create a new procedural texture based on this node material
   * @param size defines the size of the texture
   * @param scene defines the hosting scene
   * @returns the new procedural texture attached to this node material
   */
  createProceduralTexture(size, scene) {
    if (this.mode !== NodeMaterialModes.ProceduralTexture) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    let tempName = this.name + this._buildId;
    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
    const defines = new NodeMaterialDefines();
    const result = this._processDefines(defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
    let effect = this.getScene().getEngine().createEffect({
      vertexElement: tempName,
      fragmentElement: tempName
    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result?.fallbacks, void 0, void 0, void 0, this.shaderLanguage);
    proceduralTexture.nodeMaterialSource = this;
    proceduralTexture._setEffect(effect);
    let buildId = this._buildId;
    const refreshEffect = () => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result2 = this._processDefines(defines);
      if (result2) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
        TimingTools.SetImmediate(() => {
          effect = this.getScene().getEngine().createEffect({
            vertexElement: tempName,
            fragmentElement: tempName
          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result2?.fallbacks, void 0);
          proceduralTexture._setEffect(effect);
        });
      }
      this._checkInternals(effect);
    };
    proceduralTexture.onBeforeGenerationObservable.add(() => {
      refreshEffect();
    });
    this.onBuildObservable.add(() => {
      refreshEffect();
    });
    return proceduralTexture;
  }
  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, particleSystemDefinesJoined = "") {
    let tempName = this.name + this._buildId + "_" + blendMode;
    if (!defines) {
      defines = new NodeMaterialDefines();
    }
    let buildId = this._buildId;
    const particleSystemDefines = [];
    let join = particleSystemDefinesJoined;
    if (!effect) {
      const result = this._processDefines(defines);
      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
      particleSystem.fillDefines(particleSystemDefines, blendMode, false);
      join = particleSystemDefines.join("\n");
      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem, this.shaderLanguage);
      particleSystem.setCustomEffect(effect, blendMode);
    }
    effect.onBindObservable.add((effect2) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId + "_" + blendMode;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      particleSystemDefines.length = 0;
      particleSystem.fillDefines(particleSystemDefines, blendMode, false);
      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
      if (particleSystemDefinesJoinedCurrent !== join) {
        defines.markAllAsDirty();
        join = particleSystemDefinesJoinedCurrent;
      }
      const result = this._processDefines(defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
        effect2 = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem);
        particleSystem.setCustomEffect(effect2, blendMode);
        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, particleSystemDefinesJoined);
        return;
      }
      this._checkInternals(effect2);
    });
  }
  _checkInternals(effect) {
    if (this._sharedData.animatedInputs) {
      const scene = this.getScene();
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    for (const block of this._sharedData.bindableBlocks) {
      block.bind(effect, this);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmit(effect, this.getScene(), this);
    }
  }
  /**
   * Create the effect to be used as the custom effect for a particle system
   * @param particleSystem Particle system to create the effect for
   * @param onCompiled defines a function to call when the effect creation is successful
   * @param onError defines a function to call when the effect creation has failed
   */
  createEffectForParticles(particleSystem, onCompiled, onError) {
    if (this.mode !== NodeMaterialModes.Particle) {
      Logger.Log("Incompatible material mode");
      return;
    }
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
  }
  /**
   * Use this material as the shadow depth wrapper of a target material
   * @param targetMaterial defines the target material
   */
  createAsShadowDepthWrapper(targetMaterial) {
    if (this.mode !== NodeMaterialModes.Material) {
      Logger.Log("Incompatible material mode");
      return;
    }
    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());
  }
  _processDefines(defines, mesh, useInstances = false, subMesh) {
    let result = null;
    const scene = this.getScene();
    if (PrepareDefinesForCamera(scene, defines)) {
      defines.markAsMiscDirty();
    }
    for (const b of this._sharedData.blocksWithDefines) {
      b.initializeDefines(defines);
    }
    for (const b of this._sharedData.blocksWithDefines) {
      b.prepareDefines(defines, this, mesh, useInstances, subMesh);
    }
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
      for (const b of this._sharedData.repeatableContentBlocks) {
        b.replaceRepeatableContent(this._vertexCompilationState, defines, mesh);
      }
      const uniformBuffers = [];
      for (const b of this._sharedData.dynamicUniformBlocks) {
        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);
      }
      const mergedUniforms = this._vertexCompilationState.uniforms;
      for (const u of this._fragmentCompilationState.uniforms) {
        const index = mergedUniforms.indexOf(u);
        if (index === -1) {
          mergedUniforms.push(u);
        }
      }
      const mergedSamplers = this._vertexCompilationState.samplers;
      for (const s of this._fragmentCompilationState.samplers) {
        const index = mergedSamplers.indexOf(s);
        if (index === -1) {
          mergedSamplers.push(s);
        }
      }
      const fallbacks = new EffectFallbacks();
      for (const b of this._sharedData.blocksWithFallbacks) {
        b.provideFallbacks(fallbacks, mesh);
      }
      result = {
        lightDisposed,
        uniformBuffers,
        mergedUniforms,
        mergedSamplers,
        fallbacks
      };
    }
    return result;
  }
  /**
   * Get if the submesh is ready to be used and all its information available.
   * Child classes can use it to update shaders
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._buildWasSuccessful) {
      return false;
    }
    const scene = this.getScene();
    if (this._sharedData.animatedInputs) {
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines || typeof subMesh.materialDefines === "string") {
      subMesh.materialDefines = new NodeMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    this._prepareDefinesForAttributes(mesh, defines);
    if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {
      return false;
    }
    const result = this._processDefines(defines, mesh, useInstances, subMesh);
    if (result) {
      const previousEffect = subMesh.effect;
      const join = defines.toString();
      let effect = engine.createEffect({
        vertex: "nodeMaterial" + this._buildId,
        fragment: "nodeMaterial" + this._buildId,
        vertexSource: this._vertexCompilationState.compilationString,
        fragmentSource: this._fragmentCompilationState.compilationString
      }, {
        attributes: this._vertexCompilationState.attributes,
        uniformsNames: result.mergedUniforms,
        uniformBuffersNames: result.uniformBuffers,
        samplers: result.mergedSamplers,
        defines: join,
        fallbacks: result.fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        multiTarget: defines.PREPASS,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
        shaderLanguage: this.shaderLanguage
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (result.lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (defines["AREALIGHTUSED"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Get a string representing the shaders built by the current node graph
   */
  get compiledShaders() {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    return `// Vertex shader
${this._vertexCompilationState.compilationString}

// Fragment shader
${this._fragmentCompilationState.compilationString}`;
  }
  /**
   * Get a string representing the fragment shader used by the engine for the current node graph
   * @internal
   */
  async _getProcessedFragmentAsync() {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    const defines = new NodeMaterialDefines();
    this._processDefines(defines);
    let processingDefines = defines.toString();
    if (this.mode === NodeMaterialModes.SFE) {
      processingDefines += `#define ${SfeModeDefine}
`;
    }
    return await this._fragmentCompilationState.getProcessedShaderAsync(processingDefines);
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   */
  bindOnlyWorldMatrix(world) {
    const scene = this.getScene();
    if (!this._activeEffect) {
      return;
    }
    const hints = this._sharedData.hints;
    if (hints.needWorldViewMatrix) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
    }
    if (hints.needWorldViewProjectionMatrix) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    const sharedData = this._sharedData;
    if (mustRebind) {
      for (const block of sharedData.bindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const inputBlock of sharedData.inputBlocks) {
        inputBlock._transmit(effect, scene, this);
      }
    } else if (!this.isFrozen) {
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._sharedData) {
      activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture));
    }
    return activeTextures;
  }
  /**
   * Gets the list of texture blocks
   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!
   * @returns an array of texture blocks
   */
  getTextureBlocks() {
    if (!this._sharedData) {
      return [];
    }
    return this._sharedData.textureBlocks;
  }
  /**
   * Gets the list of all texture blocks
   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks
   * @returns
   */
  getAllTextureBlocks() {
    const textureBlocks = [];
    for (const block of this.attachedBlocks) {
      if (_NodeMaterial._BlockIsTextureBlock(block)) {
        textureBlocks.push(block);
      }
    }
    return textureBlocks;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (!this._sharedData) {
      return false;
    }
    for (const t of this._sharedData.textureBlocks) {
      if (t.texture === texture) {
        return true;
      }
    }
    return false;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      for (const texture of this.getTextureBlocks().filter((tb) => tb.texture).map((tb) => tb.texture)) {
        texture.dispose();
      }
    }
    for (const block of this.attachedBlocks) {
      block.dispose();
    }
    this.attachedBlocks.length = 0;
    this._sharedData = null;
    this._vertexCompilationState = null;
    this._fragmentCompilationState = null;
    this.onBuildObservable.clear();
    this.onBuildErrorObservable.clear();
    if (this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
      this._imageProcessingObserver = null;
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /** Creates the node editor window.
   * @param additionalConfig Define the configuration of the editor
   */
  _createNodeEditor(additionalConfig) {
    const nodeEditorConfig = {
      nodeMaterial: this,
      ...additionalConfig
    };
    this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);
  }
  /**
   * Launch the node material editor
   * @param config Define the configuration of the editor
   * @returns a promise fulfilled when the node editor is visible
   */
  async edit(config) {
    return await new Promise((resolve) => {
      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
      if (typeof this.BJSNODEMATERIALEDITOR == "undefined") {
        const editorUrl = config && config.editorURL ? config.editorURL : _NodeMaterial.EditorURL;
        Tools.LoadBabylonScript(editorUrl, () => {
          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
          this._createNodeEditor(config?.nodeEditorConfig);
          resolve();
        });
      } else {
        this._createNodeEditor(config?.nodeEditorConfig);
        resolve();
      }
    });
  }
  /**
   * Clear the current material
   */
  clear() {
    this._vertexOutputNodes.length = 0;
    this._fragmentOutputNodes.length = 0;
    this.attachedBlocks.length = 0;
    this._buildIsInProgress = false;
  }
  /**
   * Clear the current material and set it to a default state
   */
  setToDefault() {
    this.clear();
    this.editorData = null;
    const positionInput = new InputBlock("Position");
    positionInput.setAsAttribute("position");
    const worldInput = new InputBlock("World");
    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
    const worldPos = new TransformBlock("WorldPos");
    positionInput.connectTo(worldPos);
    worldInput.connectTo(worldPos);
    const viewProjectionInput = new InputBlock("ViewProjection");
    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);
    const worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
    worldPos.connectTo(worldPosdMultipliedByViewProjection);
    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
    const pixelColor = new InputBlock("color");
    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    pixelColor.connectTo(fragmentOutput);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Material;
  }
  /**
   * Clear the current material and set it to a default state for post process
   */
  setToDefaultPostProcess() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const scale = new InputBlock("Scale");
    scale.visibleInInspector = true;
    scale.value = new Vector2(1, 1);
    const uv0 = new RemapBlock("uv0");
    position.connectTo(uv0);
    const uv = new MultiplyBlock("UV scale");
    uv0.connectTo(uv);
    scale.connectTo(uv);
    const currentScreen = new CurrentScreenBlock("CurrentScreen");
    uv.connectTo(currentScreen);
    const textureUrl = Tools.GetAssetUrl("https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png");
    currentScreen.texture = new Texture(textureUrl, this.getScene());
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    currentScreen.connectTo(fragmentOutput, { output: "rgba" });
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.PostProcess;
  }
  /**
   * Clear the current material and set it to a default state for procedural texture
   */
  setToDefaultProceduralTexture() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const time = new InputBlock("Time");
    time.value = 0;
    time.min = 0;
    time.max = 0;
    time.isBoolean = false;
    time.matrixMode = 0;
    time.animationType = AnimatedInputBlockTypes.Time;
    time.isConstant = false;
    const color = new InputBlock("Color3");
    color.value = new Color3(1, 1, 1);
    color.isConstant = false;
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    const vectorMerger = new VectorMergerBlock("VectorMerger");
    vectorMerger.visibleInInspector = false;
    const cos = new TrigonometryBlock("Cos");
    cos.operation = TrigonometryBlockOperations.Cos;
    position.connectTo(vectorMerger);
    time.output.connectTo(cos.input);
    cos.output.connectTo(vectorMerger.z);
    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.ProceduralTexture;
  }
  /**
   * Clear the current material and set it to a default state for particle
   */
  setToDefaultParticle() {
    this.clear();
    this.editorData = null;
    const uv = new InputBlock("uv");
    uv.setAsAttribute("particle_uv");
    const texture = new ParticleTextureBlock("ParticleTexture");
    uv.connectTo(texture);
    const color = new InputBlock("Color");
    color.setAsAttribute("particle_color");
    const multiply = new MultiplyBlock("Texture * Color");
    texture.connectTo(multiply);
    color.connectTo(multiply);
    const rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
    multiply.connectTo(rampGradient);
    const cSplitter = new ColorSplitterBlock("ColorSplitter");
    color.connectTo(cSplitter);
    const blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
    rampGradient.connectTo(blendMultiply);
    texture.connectTo(blendMultiply, { output: "a" });
    cSplitter.connectTo(blendMultiply, { output: "a" });
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    blendMultiply.connectTo(fragmentOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Particle;
  }
  /**
   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead
   * @param url defines the url to load from
   * @param rootUrl defines the root URL for nested url in the node material
   * @returns a promise that will fulfil when the material is fully loaded
   */
  async loadAsync(url, rootUrl = "") {
    return await _NodeMaterial.ParseFromFileAsync("", url, this.getScene(), rootUrl, true, this);
  }
  _gatherBlocks(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (const input of rootNode.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
    if (rootNode.isTeleportOut) {
      const block = rootNode;
      if (block.entryPoint) {
        this._gatherBlocks(block.entryPoint, list);
      }
    }
  }
  /**
   * Generate a string containing the code declaration required to create an equivalent of this material
   * @returns a string
   */
  generateCode() {
    let alreadyDumped = [];
    const vertexBlocks = [];
    const uniqueNames = ["const", "var", "let"];
    for (const outputNode of this._vertexOutputNodes) {
      this._gatherBlocks(outputNode, vertexBlocks);
    }
    const fragmentBlocks = [];
    for (const outputNode of this._fragmentOutputNodes) {
      this._gatherBlocks(outputNode, fragmentBlocks);
    }
    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name || "node material"}");
`;
    codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};
`;
    for (const node of vertexBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const node of fragmentBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    alreadyDumped = [];
    codeString += "\n// Connections\n";
    for (const node of this._vertexOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    codeString += "\n// Output nodes\n";
    for (const node of this._vertexOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    codeString += `nodeMaterial.build();
`;
    return codeString;
  }
  /**
   * Serializes this material in a JSON representation
   * @param selectedBlocks defines an optional list of blocks to serialize
   * @returns the serialized material object
   */
  serialize(selectedBlocks) {
    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    serializationObject.alphaMode = this._alphaMode;
    let blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeMaterial";
      serializationObject.outputNodes = [];
      for (const outputNode of this._vertexOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        serializationObject.outputNodes.push(outputNode.uniqueId);
      }
      for (const outputNode of this._fragmentOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
          serializationObject.outputNodes.push(outputNode.uniqueId);
        }
      }
    }
    serializationObject.blocks = [];
    for (const block of blocks) {
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (const block of this.attachedBlocks) {
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    serializationObject.uniqueId = this.uniqueId;
    return serializationObject;
  }
  _restoreConnections(block, source, map) {
    for (const outputPoint of block.outputs) {
      for (const candidate of source.blocks) {
        const target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (const input of candidate.inputs) {
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            const inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   * @param urlRewriter defines a function used to rewrite urls
   */
  parseSerializedObject(source, rootUrl = "", merge = false, urlRewriter) {
    if (!merge) {
      this.clear();
    }
    const map = {};
    for (const parsedBlock of source.blocks) {
      const blockType = GetClass(parsedBlock.customType);
      if (blockType) {
        const block = new blockType();
        block._deserialize(parsedBlock, this.getScene(), rootUrl, urlRewriter);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (const block of this.attachedBlocks) {
      if (block.isTeleportOut) {
        const teleportOut = block;
        const id = teleportOut._tempEntryPointUniqueId;
        if (id) {
          const source2 = map[id];
          source2.attachToEndpoint(teleportOut);
        }
      }
    }
    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      const parsedBlock = source.blocks[blockIndex];
      const block = map[parsedBlock.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodes) {
      for (const outputNodeId of source.outputNodes) {
        this.addOutputNode(map[outputNodeId]);
      }
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      const locations = source.locations || source.editorData.locations;
      for (const location of locations) {
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      const blockMap = [];
      for (const key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    this.comment = source.comment;
    if (source.forceAlphaBlending !== void 0) {
      this.forceAlphaBlending = source.forceAlphaBlending;
    }
    if (source.alphaMode !== void 0) {
      this.alphaMode = source.alphaMode;
    }
    if (!Array.isArray(source.alphaMode)) {
      this._alphaMode = [source.alphaMode ?? 2];
    } else {
      this._alphaMode = source.alphaMode;
    }
    if (!merge) {
      this._mode = source.mode ?? NodeMaterialModes.Material;
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   * @deprecated Please use the parseSerializedObject method instead
   */
  loadFromSerialization(source, rootUrl = "", merge = false) {
    this.parseSerializedObject(source, rootUrl, merge);
  }
  /**
   * Makes a duplicate of the current material.
   * @param name defines the name to use for the new material
   * @param shareEffect defines if the clone material should share the same effect (default is false)
   * @returns the cloned material
   */
  clone(name, shareEffect = false) {
    const serializationObject = this.serialize();
    const clone = SerializationHelper.Clone(() => new _NodeMaterial(name, this.getScene(), this.options), this);
    clone.id = name;
    clone.name = name;
    clone.parseSerializedObject(serializationObject);
    clone._buildId = this._buildId;
    clone.build(false, !shareEffect);
    return clone;
  }
  /**
   * Awaits for all the material textures to be ready before resolving the returned promise.
   * @returns A promise that resolves when the textures are ready.
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  whenTexturesReadyAsync() {
    const textureReadyPromises = [];
    const activeTextures = this.getActiveTextures();
    for (const texture of activeTextures) {
      const internalTexture = texture.getInternalTexture();
      if (internalTexture && !internalTexture.isReady) {
        textureReadyPromises.push(new Promise((textureResolve, textureReject) => {
          internalTexture.onLoadedObservable.addOnce(() => {
            textureResolve();
          });
          internalTexture.onErrorObservable.addOnce((e) => {
            textureReject(e);
          });
        }));
      }
    }
    return Promise.all(textureReadyPromises);
  }
  /**
   * Creates a node material from parsed material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param shaderLanguage defines the language to use (GLSL by default)
   * @returns a new node material
   */
  static Parse(source, scene, rootUrl = "", shaderLanguage = 0) {
    const nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(source.name, scene, { shaderLanguage }), source, scene, rootUrl);
    nodeMaterial.parseSerializedObject(source, rootUrl);
    nodeMaterial.build();
    return nodeMaterial;
  }
  /**
   * Creates a node material from a snippet saved in a remote file
   * @param name defines the name of the material to create
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL for nested url in the node material
   * @param skipBuild defines whether to build the node material
   * @param targetMaterial defines a material to use instead of creating a new one
   * @param urlRewriter defines a function used to rewrite urls
   * @param options defines options to be used with the node material
   * @returns a promise that will resolve to the new node material
   */
  static async ParseFromFileAsync(name, url, scene, rootUrl = "", skipBuild = false, targetMaterial, urlRewriter, options) {
    const material = targetMaterial ?? new _NodeMaterial(name, scene, options);
    const data = await scene._loadFileAsync(url);
    const serializationObject = JSON.parse(data);
    material.parseSerializedObject(serializationObject, rootUrl, void 0, urlRewriter);
    if (!skipBuild) {
      material.build();
    }
    return material;
  }
  /**
   * Creates a node material from a snippet saved by the node material editor
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param nodeMaterial defines a node material to update (instead of creating a new one)
   * @param skipBuild defines whether to build the node material
   * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)
   * @param urlRewriter defines a function used to rewrite urls
   * @param options defines options to be used with the node material
   * @returns a promise that will resolve to the new node material
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = "", nodeMaterial, skipBuild = false, waitForTextureReadyness = false, urlRewriter, options) {
    if (snippetId === "_BLANK") {
      return Promise.resolve(_NodeMaterial.CreateDefault("blank", scene));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.nodeMaterial);
            if (!nodeMaterial) {
              nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(snippetId, scene, options), serializationObject, scene, rootUrl);
              nodeMaterial.uniqueId = scene.getUniqueId();
            }
            nodeMaterial.parseSerializedObject(serializationObject, void 0, void 0, urlRewriter);
            nodeMaterial.snippetId = snippetId;
            nodeMaterial.sideOrientation = null;
            try {
              if (!skipBuild) {
                nodeMaterial.build();
              }
            } catch (err) {
              reject(err);
            }
            if (waitForTextureReadyness) {
              nodeMaterial.whenTexturesReadyAsync().then(() => {
                resolve(nodeMaterial);
              }).catch((err) => {
                reject(err);
              });
            } else {
              resolve(nodeMaterial);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
  /**
   * Creates a new node material set to default basic configuration
   * @param name defines the name of the material
   * @param scene defines the hosting scene
   * @returns a new NodeMaterial
   */
  static CreateDefault(name, scene) {
    const newMaterial = new _NodeMaterial(name, scene);
    newMaterial.setToDefault();
    newMaterial.build();
    return newMaterial;
  }
};
NodeMaterial._BuildIdGenerator = 0;
NodeMaterial.EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeEditor/babylon.nodeEditor.js`;
NodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
NodeMaterial.IgnoreTexturesAtLoadTime = false;
NodeMaterial.AllowSerializationOfRenderTargetTextures = false;
NodeMaterial.DefaultShaderLanguage = 0;
NodeMaterial.UseNativeShaderLanguageOfEngine = false;
__decorate([
  serialize()
], NodeMaterial.prototype, "ignoreAlpha", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("mode")
], NodeMaterial.prototype, "_mode", void 0);
__decorate([
  serialize("comment")
], NodeMaterial.prototype, "comment", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "forceAlphaBlending", void 0);
RegisterClass("BABYLON.NodeMaterial", NodeMaterial);

// node_modules/@babylonjs/core/Meshes/subMesh.project.js
SubMesh.prototype._projectOnTrianglesToRef = function(vector, positions, indices, step, checkStopper, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
    const indexA = indices[index];
    const indexB = indices[index + 1];
    const indexC = indices[index + 2];
    if (checkStopper && indexC === 4294967295) {
      index += 2;
      continue;
    }
    const p0 = positions[indexA];
    const p1 = positions[indexB];
    const p2 = positions[indexC];
    if (!p0 || !p1 || !p2) {
      continue;
    }
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype._projectOnUnIndexedTrianglesToRef = function(vector, positions, indices, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
    const p0 = positions[index];
    const p1 = positions[index + 1];
    const p2 = positions[index + 2];
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype.projectToRef = function(vector, positions, indices, ref) {
  const material = this.getMaterial();
  if (!material) {
    return -1;
  }
  let step = 3;
  let checkStopper = false;
  switch (material.fillMode) {
    case 3:
    case 5:
    case 6:
    case 8:
      return -1;
    case 7:
      step = 1;
      checkStopper = true;
      break;
    default:
      break;
  }
  if (material.fillMode === 4) {
    return -1;
  } else {
    if (!indices.length && this._mesh._unIndexed) {
      return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);
    }
    return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);
  }
};

// node_modules/@babylonjs/core/XR/features/WebXRNearInteraction.js
var ControllerOrbAnimationState;
(function(ControllerOrbAnimationState2) {
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["DEHYDRATED"] = 0] = "DEHYDRATED";
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["HOVER"] = 1] = "HOVER";
  ControllerOrbAnimationState2[ControllerOrbAnimationState2["TOUCH"] = 2] = "TOUCH";
})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));
var WebXRNearControllerMode;
(function(WebXRNearControllerMode2) {
  WebXRNearControllerMode2[WebXRNearControllerMode2["DISABLED"] = 0] = "DISABLED";
  WebXRNearControllerMode2[WebXRNearControllerMode2["CENTERED_ON_CONTROLLER"] = 1] = "CENTERED_ON_CONTROLLER";
  WebXRNearControllerMode2[WebXRNearControllerMode2["CENTERED_IN_FRONT"] = 2] = "CENTERED_IN_FRONT";
})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));
var LocalTempVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
var WebXRNearInteraction = class _WebXRNearInteraction extends WebXRAbstractFeature {
  /**
   * constructs a new background remover module
   * @param _xrSessionManager the session manager for this module
   * @param _options read-only options to be used in this module
   */
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._tmpRay = new Ray(new Vector3(), new Vector3());
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId]) {
        return;
      }
      const { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction } = this._generateNewTouchPointMesh();
      const selectionMesh = this._generateVisualCue();
      this._controllers[xrController.uniqueId] = {
        xrController,
        meshUnderPointer: null,
        nearInteractionTargetMesh: null,
        pick: null,
        stalePick: null,
        touchCollisionMesh,
        touchCollisionMeshFunction,
        hydrateCollisionMeshFunction,
        currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,
        grabRay: new Ray(new Vector3(), new Vector3()),
        hoverInteraction: false,
        nearInteraction: false,
        grabInteraction: false,
        downTriggered: false,
        id: _WebXRNearInteraction._IdCounter++,
        pickedPointVisualCue: selectionMesh
      };
      this._controllers[xrController.uniqueId]._worldScaleObserver = this._controllers[xrController.uniqueId]._worldScaleObserver || this._xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {
        if (values.newScaleFactor !== values.previousScaleFactor) {
          this._controllers[xrController.uniqueId].touchCollisionMesh.dispose();
          this._controllers[xrController.uniqueId].pickedPointVisualCue.dispose();
          const { touchCollisionMesh: touchCollisionMesh2, touchCollisionMeshFunction: touchCollisionMeshFunction2, hydrateCollisionMeshFunction: hydrateCollisionMeshFunction2 } = this._generateNewTouchPointMesh();
          this._controllers[xrController.uniqueId].touchCollisionMesh = touchCollisionMesh2;
          this._controllers[xrController.uniqueId].touchCollisionMeshFunction = touchCollisionMeshFunction2;
          this._controllers[xrController.uniqueId].hydrateCollisionMeshFunction = hydrateCollisionMeshFunction2;
          this._controllers[xrController.uniqueId].pickedPointVisualCue = this._generateVisualCue();
        }
      });
      if (this._attachedController) {
        if (!this._options.enableNearInteractionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {
          this._attachedController = xrController.uniqueId;
        }
      } else {
        if (!this._options.enableNearInteractionOnAllControllers) {
          this._attachedController = xrController.uniqueId;
        }
      }
      switch (xrController.inputSource.targetRayMode) {
        case "tracked-pointer":
          return this._attachNearInteractionMode(xrController);
        case "gaze":
          return null;
        case "screen":
          return null;
      }
    };
    this._controllers = {};
    this._farInteractionFeature = null;
    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);
    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1);
    this.alwaysHideSelectionMesh = false;
    this._hoverRadius = 0.1;
    this._pickRadius = 0.02;
    this._controllerPickRadius = 0.03;
    this._nearGrabLengthScale = 5;
    this._scene = this._xrSessionManager.scene;
    if (this._options.nearInteractionControllerMode === void 0) {
      this._options.nearInteractionControllerMode = 2;
    }
    if (this._options.farInteractionFeature) {
      this._farInteractionFeature = this._options.farInteractionFeature;
    }
  }
  /**
   * Attach this feature
   * Will usually be called by the features manager
   *
   * @returns true if successful.
   */
  attach() {
    if (!super.attach()) {
      return false;
    }
    for (const controller of this._options.xrInput.controllers) {
      this._attachController(controller);
    }
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    this._scene.constantlyUpdateMeshUnderPointer = true;
    return true;
  }
  /**
   * Detach this feature.
   * Will usually be called by the features manager
   *
   * @returns true if successful.
   */
  detach() {
    if (!super.detach()) {
      return false;
    }
    const keys = Object.keys(this._controllers);
    for (const controllerId of keys) {
      this._detachController(controllerId);
    }
    return true;
  }
  /**
   * Will get the mesh under a specific pointer.
   * `scene.meshUnderPointer` will only return one mesh - either left or right.
   * @param controllerId the controllerId to check
   * @returns The mesh under pointer or null if no mesh is under the pointer
   */
  getMeshUnderPointer(controllerId) {
    if (this._controllers[controllerId]) {
      return this._controllers[controllerId].meshUnderPointer;
    } else {
      return null;
    }
  }
  /**
   * Get the xr controller that correlates to the pointer id in the pointer event
   *
   * @param id the pointer id to search for
   * @returns the controller that correlates to this id or null if not found
   */
  getXRControllerByPointerId(id) {
    const keys = Object.keys(this._controllers);
    for (let i = 0; i < keys.length; ++i) {
      if (this._controllers[keys[i]].id === id) {
        return this._controllers[keys[i]].xrController || null;
      }
    }
    return null;
  }
  /**
   * This function sets webXRControllerPointerSelection feature that will be disabled when
   * the hover range is reached for a mesh and will be reattached when not in hover range.
   * This is used to remove the selection rays when moving.
   * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh
   */
  setFarInteractionFeature(farInteractionFeature) {
    this._farInteractionFeature = farInteractionFeature;
  }
  /**
   * Filter used for near interaction pick and hover
   * @param mesh the mesh candidate to be pick-filtered
   * @returns if the mesh should be included in the list of candidate meshes for near interaction
   */
  _nearPickPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;
  }
  /**
   * Filter used for near interaction grab
   * @param mesh the mesh candidate to be pick-filtered
   * @returns if the mesh should be included in the list of candidate meshes for near interaction
   */
  _nearGrabPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;
  }
  /**
   * Filter used for any near interaction
   * @param mesh the mesh candidate to be pick-filtered
   * @returns if the mesh should be included in the list of candidate meshes for near interaction
   */
  _nearInteractionPredicate(mesh) {
    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);
  }
  _controllerAvailablePredicate(mesh, controllerId) {
    let parent = mesh;
    while (parent) {
      if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  }
  _handleTransitionAnimation(controllerData, newState) {
    if (controllerData.currentAnimationState === newState || this._options.nearInteractionControllerMode !== 2 || !!controllerData.xrController?.inputSource.hand) {
      return;
    }
    if (newState > controllerData.currentAnimationState) {
      switch (controllerData.currentAnimationState) {
        case ControllerOrbAnimationState.DEHYDRATED: {
          controllerData.hydrateCollisionMeshFunction(true);
          if (newState === ControllerOrbAnimationState.HOVER) {
            break;
          }
        }
        case ControllerOrbAnimationState.HOVER: {
          controllerData.touchCollisionMeshFunction(true);
          if (newState === ControllerOrbAnimationState.TOUCH) {
            break;
          }
        }
      }
    } else {
      switch (controllerData.currentAnimationState) {
        case ControllerOrbAnimationState.TOUCH: {
          controllerData.touchCollisionMeshFunction(false);
          if (newState === ControllerOrbAnimationState.HOVER) {
            break;
          }
        }
        case ControllerOrbAnimationState.HOVER: {
          controllerData.hydrateCollisionMeshFunction(false);
          if (newState === ControllerOrbAnimationState.DEHYDRATED) {
            break;
          }
        }
      }
    }
    controllerData.currentAnimationState = newState;
  }
  _processTouchPoint(id, position, orientation) {
    const controllerData = this._controllers[id];
    controllerData.grabRay.origin.copyFrom(position);
    orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);
    controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);
    if (this._options.nearInteractionControllerMode === 2 && !controllerData.xrController?.inputSource.hand) {
      controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);
      controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));
    }
    controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius * this._xrSessionManager.worldScalingFactor;
    controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor);
  }
  _onXRFrame(_xrFrame) {
    const keys = Object.keys(this._controllers);
    for (const id of keys) {
      const controllerData = this._controllers[id];
      const handData = controllerData.xrController?.inputSource.hand;
      if (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController || !controllerData.xrController || !handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {
        controllerData.pick = null;
        return;
      }
      controllerData.hoverInteraction = false;
      controllerData.nearInteraction = false;
      if (controllerData.xrController) {
        if (handData) {
          const xrIndexTip = handData.get("index-finger-tip");
          if (xrIndexTip) {
            const indexTipPose = _xrFrame.getJointPose(xrIndexTip, this._xrSessionManager.referenceSpace);
            if (indexTipPose && indexTipPose.transform) {
              const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;
              TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);
              TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);
              this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);
            }
          }
        } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== 0) {
          let controllerPose = controllerData.xrController.pointer;
          if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === 1) {
            controllerPose = controllerData.xrController.grip;
          }
          this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);
        }
      } else {
        return;
      }
      const accuratePickInfo = (originalScenePick, utilityScenePick) => {
        let pick = null;
        if (!utilityScenePick || !utilityScenePick.hit) {
          pick = originalScenePick;
        } else if (!originalScenePick || !originalScenePick.hit) {
          pick = utilityScenePick;
        } else if (utilityScenePick.distance < originalScenePick.distance) {
          pick = utilityScenePick;
        } else {
          pick = originalScenePick;
        }
        return pick;
      };
      const populateNearInteractionInfo = (nearInteractionInfo) => {
        let result = new PickingInfo();
        let nearInteractionAtOrigin = false;
        const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;
        if (nearInteractionInfo?.pickedPoint) {
          nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;
        }
        if (nearInteraction && !nearInteractionAtOrigin) {
          result = nearInteractionInfo;
        }
        return result;
      };
      if (!controllerData.grabInteraction) {
        let pick = null;
        let utilitySceneHoverPick = null;
        if (this._options.useUtilityLayer && this._utilityLayerScene) {
          utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius * this._xrSessionManager.worldScalingFactor, this._utilityLayerScene, (mesh) => this._nearInteractionPredicate(mesh));
        }
        const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius * this._xrSessionManager.worldScalingFactor, this._scene, (mesh) => this._nearInteractionPredicate(mesh));
        const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);
        if (hoverPickInfo && hoverPickInfo.hit) {
          pick = populateNearInteractionInfo(hoverPickInfo);
          if (pick.hit) {
            controllerData.hoverInteraction = true;
          }
        }
        if (controllerData.hoverInteraction) {
          let utilitySceneNearPick = null;
          const radius = (handData ? this._pickRadius : this._controllerPickRadius) * this._xrSessionManager.worldScalingFactor;
          if (this._options.useUtilityLayer && this._utilityLayerScene) {
            utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, (mesh) => this._nearPickPredicate(mesh));
          }
          const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, (mesh) => this._nearPickPredicate(mesh));
          const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);
          const nearPick = populateNearInteractionInfo(pickInfo);
          if (nearPick.hit) {
            pick = nearPick;
            controllerData.nearInteraction = true;
          }
        }
        controllerData.stalePick = controllerData.pick;
        controllerData.pick = pick;
        if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {
          controllerData.meshUnderPointer = controllerData.pick.pickedMesh;
          controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);
          controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;
          if (this._farInteractionFeature && this._farInteractionFeature.attached) {
            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);
          }
        } else {
          controllerData.meshUnderPointer = null;
          controllerData.pickedPointVisualCue.isVisible = false;
          if (this._farInteractionFeature && this._farInteractionFeature.attached) {
            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);
          }
        }
      }
      let state = ControllerOrbAnimationState.DEHYDRATED;
      if (controllerData.grabInteraction || controllerData.nearInteraction) {
        state = ControllerOrbAnimationState.TOUCH;
      } else if (controllerData.hoverInteraction) {
        state = ControllerOrbAnimationState.HOVER;
      }
      this._handleTransitionAnimation(controllerData, state);
    }
  }
  get _utilityLayerScene() {
    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;
  }
  _generateVisualCue() {
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const selectionMesh = CreateSphere("nearInteraction", {
      diameter: 35e-4 * 3 * this._xrSessionManager.worldScalingFactor
    }, sceneToRenderTo);
    selectionMesh.bakeCurrentTransformIntoVertices();
    selectionMesh.isPickable = false;
    selectionMesh.isVisible = false;
    selectionMesh.rotationQuaternion = Quaternion.Identity();
    const targetMat = new StandardMaterial("targetMat", sceneToRenderTo);
    targetMat.specularColor = Color3.Black();
    targetMat.emissiveColor = this.selectionMeshDefaultColor;
    targetMat.backFaceCulling = false;
    selectionMesh.material = targetMat;
    return selectionMesh;
  }
  _isControllerReadyForNearInteraction(id) {
    if (this._farInteractionFeature) {
      return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);
    }
    return true;
  }
  _attachNearInteractionMode(xrController) {
    const controllerData = this._controllers[xrController.uniqueId];
    const pointerEventInit = {
      pointerId: controllerData.id,
      pointerType: "xr-near"
    };
    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {
      if (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController || !controllerData.xrController || !controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {
        return;
      }
      if (controllerData.pick) {
        controllerData.pick.ray = controllerData.grabRay;
      }
      if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {
        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);
      }
      if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {
        if (!controllerData.nearInteractionTargetMesh) {
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
          controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;
          controllerData.downTriggered = true;
        }
      } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {
        this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);
        controllerData.downTriggered = false;
        controllerData.nearInteractionTargetMesh = null;
      }
    });
    const grabCheck = (pressed) => {
      if (this._options.enableNearInteractionOnAllControllers || xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id)) {
        if (controllerData.pick) {
          controllerData.pick.ray = controllerData.grabRay;
        }
        if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {
          controllerData.grabInteraction = true;
          controllerData.pickedPointVisualCue.isVisible = false;
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
          controllerData.downTriggered = true;
        } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.downTriggered = false;
          controllerData.grabInteraction = false;
          controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;
        }
      } else {
        if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {
          this._attachedController = xrController.uniqueId;
        }
      }
    };
    if (xrController.inputSource.gamepad) {
      const init = (motionController) => {
        controllerData.squeezeComponent = motionController.getComponent("grasp");
        if (controllerData.squeezeComponent) {
          controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add((component) => {
            if (component.changes.pressed) {
              const pressed = component.changes.pressed.current;
              grabCheck(pressed);
            }
          });
        } else {
          controllerData.selectionComponent = motionController.getMainComponent();
          controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {
            if (component.changes.pressed) {
              const pressed = component.changes.pressed.current;
              grabCheck(pressed);
            }
          });
        }
      };
      if (xrController.motionController) {
        init(xrController.motionController);
      } else {
        xrController.onMotionControllerInitObservable.add(init);
      }
    } else {
      const selectStartListener = (event) => {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id) && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {
          controllerData.grabInteraction = true;
          controllerData.pickedPointVisualCue.isVisible = false;
          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);
          controllerData.downTriggered = true;
        }
      };
      const selectEndListener = (event) => {
        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {
          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);
          controllerData.grabInteraction = false;
          controllerData.pickedPointVisualCue.isVisible = !this.alwaysHideSelectionMesh;
          controllerData.downTriggered = false;
        }
      };
      controllerData.eventListeners = {
        selectend: selectEndListener,
        selectstart: selectStartListener
      };
      this._xrSessionManager.session.addEventListener("selectstart", selectStartListener);
      this._xrSessionManager.session.addEventListener("selectend", selectEndListener);
    }
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.squeezeComponent) {
      if (controllerData.onSqueezeButtonChangedObserver) {
        controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);
      }
    }
    if (controllerData.selectionComponent) {
      if (controllerData.onButtonChangedObserver) {
        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    if (controllerData.onFrameObserver) {
      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);
    }
    if (controllerData.eventListeners) {
      const keys = Object.keys(controllerData.eventListeners);
      for (const eventName of keys) {
        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];
        if (func) {
          this._xrSessionManager.session.removeEventListener(eventName, func);
        }
      }
    }
    controllerData.touchCollisionMesh.dispose();
    controllerData.pickedPointVisualCue.dispose();
    this._xrSessionManager.runInXRFrame(() => {
      if (!controllerData.downTriggered) {
        return;
      }
      const pointerEventInit = {
        pointerId: controllerData.id,
        pointerType: "xr-near"
      };
      this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);
    });
    if (controllerData._worldScaleObserver) {
      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(controllerData._worldScaleObserver);
    }
    delete this._controllers[xrControllerUniqueId];
    if (this._attachedController === xrControllerUniqueId) {
      const keys = Object.keys(this._controllers);
      if (keys.length) {
        this._attachedController = keys[0];
      } else {
        this._attachedController = "";
      }
    }
  }
  _generateNewTouchPointMesh() {
    const worldScale = this._xrSessionManager.worldScalingFactor;
    const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;
    const touchCollisionMesh = CreateSphere("PickSphere", { diameter: 1 * worldScale }, meshCreationScene);
    touchCollisionMesh.isVisible = false;
    if (this._options.motionControllerOrbMaterial) {
      touchCollisionMesh.material = this._options.motionControllerOrbMaterial;
    } else {
      let parsePromise;
      if (this._options.motionControllerTouchMaterialSnippetUrl) {
        parsePromise = NodeMaterial.ParseFromFileAsync("motionControllerTouchMaterial", this._options.motionControllerTouchMaterialSnippetUrl, meshCreationScene);
      } else {
        parsePromise = NodeMaterial.ParseFromSnippetAsync("8RUNKL#3", meshCreationScene);
      }
      parsePromise.then((mat) => {
        touchCollisionMesh.material = mat;
      }).catch((err) => {
        Logger.Warn(`Error creating touch material in WebXRNearInteraction: ${err}`);
      });
    }
    const easingFunction = new QuadraticEase();
    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
    const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius).scaleInPlace(worldScale);
    const touchSize = this._controllerPickRadius * (4 / 3);
    const touchSizeVec = new Vector3(touchSize, touchSize, touchSize).scaleInPlace(worldScale);
    const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);
    const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize).scaleInPlace(worldScale);
    const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);
    const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize).scaleInPlace(worldScale);
    const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);
    const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize).scaleInPlace(worldScale);
    const touchKeys = [
      { frame: 0, value: hoverSizeVec },
      { frame: 10, value: hoverTouchTransitionSizeVec },
      { frame: 18, value: touchSizeVec }
    ];
    const releaseKeys = [
      { frame: 0, value: touchSizeVec },
      { frame: 10, value: touchHoverTransitionSizeVec },
      { frame: 18, value: hoverSizeVec }
    ];
    const hydrateKeys = [
      { frame: 0, value: Vector3.ZeroReadOnly },
      { frame: 12, value: hydrateTransitionSizeVec },
      { frame: 15, value: hoverSizeVec }
    ];
    const dehydrateKeys = [
      { frame: 0, value: hoverSizeVec },
      { frame: 10, value: Vector3.ZeroReadOnly },
      { frame: 15, value: Vector3.ZeroReadOnly }
    ];
    const touchAction = new Animation("touch", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const releaseAction = new Animation("release", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const hydrateAction = new Animation("hydrate", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    const dehydrateAction = new Animation("dehydrate", "scaling", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
    touchAction.setEasingFunction(easingFunction);
    releaseAction.setEasingFunction(easingFunction);
    hydrateAction.setEasingFunction(easingFunction);
    dehydrateAction.setEasingFunction(easingFunction);
    touchAction.setKeys(touchKeys);
    releaseAction.setKeys(releaseKeys);
    hydrateAction.setKeys(hydrateKeys);
    dehydrateAction.setKeys(dehydrateKeys);
    const touchCollisionMeshFunction = (isTouch) => {
      const action = isTouch ? touchAction : releaseAction;
      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);
    };
    const hydrateCollisionMeshFunction = (isHydration) => {
      const action = isHydration ? hydrateAction : dehydrateAction;
      if (isHydration) {
        touchCollisionMesh.isVisible = true;
      }
      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {
        if (!isHydration) {
          touchCollisionMesh.isVisible = false;
        }
      });
    };
    return { touchCollisionMesh, touchCollisionMeshFunction, hydrateCollisionMeshFunction };
  }
  _pickWithSphere(controllerData, radius, sceneToUse, predicate) {
    const pickingInfo = new PickingInfo();
    pickingInfo.distance = Infinity;
    if (controllerData.touchCollisionMesh && controllerData.xrController) {
      const position = controllerData.touchCollisionMesh.position;
      const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);
      for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {
        const mesh = sceneToUse.meshes[meshIndex];
        if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {
          continue;
        }
        const result = _WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);
        if (result && result.hit && result.distance < pickingInfo.distance) {
          pickingInfo.hit = result.hit;
          pickingInfo.pickedMesh = mesh;
          pickingInfo.pickedPoint = result.pickedPoint;
          pickingInfo.aimTransform = controllerData.xrController.pointer;
          pickingInfo.gripTransform = controllerData.xrController.grip || null;
          pickingInfo.originMesh = controllerData.touchCollisionMesh;
          pickingInfo.distance = result.distance;
          pickingInfo.bu = result.bu;
          pickingInfo.bv = result.bv;
          pickingInfo.faceId = result.faceId;
          pickingInfo.subMeshId = result.subMeshId;
        }
      }
    }
    return pickingInfo;
  }
  /**
   * Picks a mesh with a sphere
   * @param mesh the mesh to pick
   * @param sphere picking sphere in world coordinates
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns the picking info
   */
  static PickMeshWithSphere(mesh, sphere, skipBoundingInfo = false) {
    const subMeshes = mesh.subMeshes;
    const pi = new PickingInfo();
    const boundingInfo = mesh.getBoundingInfo();
    if (!mesh._generatePointsArray()) {
      return pi;
    }
    if (!mesh.subMeshes || !boundingInfo) {
      return pi;
    }
    if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {
      return pi;
    }
    const result = LocalTempVectors[0];
    const tmpVec = LocalTempVectors[1];
    LocalTempVectors[2].setAll(0);
    LocalTempVectors[3].setAll(0);
    const tmpRay = new Ray(LocalTempVectors[2], LocalTempVectors[3], 1);
    let distance = Infinity;
    let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter, intersectionInfo;
    const center = TmpVectors.Vector3[2];
    const worldToMesh = TmpVectors.Matrix[0];
    worldToMesh.copyFrom(mesh.getWorldMatrix());
    worldToMesh.invert();
    Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);
    for (let index = 0; index < subMeshes.length; index++) {
      const subMesh = subMeshes[index];
      subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);
      Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);
      tmp = Vector3.Distance(tmpVec, sphere.center);
      tmpDistanceSurfaceToCenter = Vector3.DistanceSquared(tmpVec, mesh.getAbsolutePosition());
      tmpDistanceSphereToCenter = Vector3.DistanceSquared(sphere.center, mesh.getAbsolutePosition());
      if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {
        tmp = 0;
        tmpVec.copyFrom(sphere.center);
      }
      if (tmp !== -1 && tmp < distance) {
        distance = tmp;
        Ray.CreateFromToToRef(sphere.center, tmpVec, tmpRay);
        tmpRay.length = distance * 2;
        intersectionInfo = tmpRay.intersectsMesh(mesh);
        result.copyFrom(tmpVec);
      }
    }
    if (distance < sphere.radius) {
      pi.hit = true;
      pi.distance = distance;
      pi.pickedMesh = mesh;
      pi.pickedPoint = result.clone();
      if (intersectionInfo && intersectionInfo.bu !== null && intersectionInfo.bv !== null) {
        pi.faceId = intersectionInfo.faceId;
        pi.subMeshId = intersectionInfo.subMeshId;
        pi.bu = intersectionInfo.bu;
        pi.bv = intersectionInfo.bv;
      }
    }
    return pi;
  }
};
WebXRNearInteraction._IdCounter = 200;
WebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;
WebXRNearInteraction.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, (xrSessionManager, options) => {
  return () => new WebXRNearInteraction(xrSessionManager, options);
}, WebXRNearInteraction.Version, true);

// node_modules/@babylonjs/core/XR/webXREnterExitUI.js
var WebXREnterExitUIButton = class {
  /**
   * Creates a WebXREnterExitUIButton
   * @param element button element
   * @param sessionMode XR initialization session mode
   * @param referenceSpaceType the type of reference space to be used
   */
  constructor(element, sessionMode, referenceSpaceType) {
    this.element = element;
    this.sessionMode = sessionMode;
    this.referenceSpaceType = referenceSpaceType;
  }
  /**
   * Extendable function which can be used to update the button's visuals when the state changes
   * @param activeButton the current active button in the UI
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  update(activeButton) {
  }
};
var WebXREnterExitUI = class _WebXREnterExitUI {
  /**
   * Construct a new EnterExit UI class
   *
   * @param _scene babylon scene object to use
   * @param options (read-only) version of the options passed to this UI
   */
  constructor(_scene, options) {
    this._scene = _scene;
    this.options = options;
    this._activeButton = null;
    this._buttons = [];
    this.activeButtonChangedObservable = new Observable();
    this._onSessionGranted = (evt) => {
      if (this._helper) {
        this._enterXRWithButtonIndexAsync(0);
      }
    };
    this.overlay = document.createElement("div");
    this.overlay.classList.add("xr-button-overlay");
    if (!options.ignoreSessionGrantedEvent && navigator.xr) {
      navigator.xr.addEventListener("sessiongranted", this._onSessionGranted);
    }
    if (typeof window !== "undefined") {
      if (window.location && window.location.protocol === "http:" && window.location.hostname !== "localhost") {
        Tools.Warn("WebXR can only be served over HTTPS");
        throw new Error("WebXR can only be served over HTTPS");
      }
    }
    if (options.customButtons) {
      this._buttons = options.customButtons;
    } else {
      this.overlay.style.cssText = "z-index:11;position: absolute; right: 20px;bottom: 50px;";
      const sessionMode = options.sessionMode || "immersive-vr";
      const referenceSpaceType = options.referenceSpaceType || "local-floor";
      const url = typeof SVGSVGElement === "undefined" ? "https://cdn.babylonjs.com/Assets/vrButton.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A";
      let css = ".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(" + url + "); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";
      css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: "EXIT"} .xr-error::after { content: "ERROR"}';
      const style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      document.getElementsByTagName("head")[0].appendChild(style);
      const hmdBtn = document.createElement("button");
      hmdBtn.className = "babylonVRicon";
      hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;
      this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));
      this._buttons[this._buttons.length - 1].update = function(activeButton) {
        this.element.style.display = activeButton === null || activeButton === this ? "" : "none";
        hmdBtn.className = "babylonVRicon" + (activeButton === this ? " vrdisplaypresenting" : "");
      };
      this._updateButtons(null);
    }
    const renderCanvas = _scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode) {
      renderCanvas.parentNode.appendChild(this.overlay);
      _scene.onDisposeObservable.addOnce(() => {
        this.dispose();
      });
    }
  }
  /**
   * Set the helper to be used with this UI component.
   * The UI is bound to an experience helper. If not provided the UI can still be used but the events should be registered by the developer.
   *
   * @param helper the experience helper to attach
   * @param renderTarget an optional render target (in case it is created outside of the helper scope)
   * @returns a promise that resolves when the ui is ready
   */
  async setHelperAsync(helper, renderTarget) {
    this._helper = helper;
    this._renderTarget = renderTarget;
    const supportedPromises = this._buttons.map(async (btn) => {
      return await helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);
    });
    helper.onStateChangedObservable.add((state) => {
      if (state == 3) {
        this._updateButtons(null);
      }
    });
    const results = await Promise.all(supportedPromises);
    for (let i = 0; i < results.length; i++) {
      const supported = results[i];
      if (supported) {
        this.overlay.appendChild(this._buttons[i].element);
        this._buttons[i].element.onclick = this._enterXRWithButtonIndexAsync.bind(this, i);
      } else {
        Tools.Warn(`Session mode "${this._buttons[i].sessionMode}" not supported in browser`);
      }
    }
  }
  /**
   * Creates UI to allow the user to enter/exit XR mode
   * @param scene the scene to add the ui to
   * @param helper the xr experience helper to enter/exit xr with
   * @param options options to configure the UI
   * @returns the created ui
   */
  static async CreateAsync(scene, helper, options) {
    const ui = new _WebXREnterExitUI(scene, options);
    await ui.setHelperAsync(helper, options.renderTarget || void 0);
    return ui;
  }
  async _enterXRWithButtonIndexAsync(idx = 0) {
    if (this._helper.state == 2) {
      await this._helper.exitXRAsync();
      this._updateButtons(null);
    } else if (this._helper.state == 3) {
      try {
        await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {
          optionalFeatures: this.options.optionalFeatures,
          requiredFeatures: this.options.requiredFeatures
        });
        this._updateButtons(this._buttons[idx]);
      } catch (e) {
        this._updateButtons(null);
        const element = this._buttons[idx].element;
        const prevTitle = element.title;
        element.title = "Error entering XR session : " + prevTitle;
        element.classList.add("xr-error");
        if (this.options.onError) {
          this.options.onError(e);
        }
      }
    }
  }
  /**
   * Disposes of the XR UI component
   */
  dispose() {
    const renderCanvas = this._scene.getEngine().getInputElement();
    if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {
      renderCanvas.parentNode.removeChild(this.overlay);
    }
    this.activeButtonChangedObservable.clear();
    navigator.xr.removeEventListener("sessiongranted", this._onSessionGranted);
  }
  _updateButtons(activeButton) {
    this._activeButton = activeButton;
    for (const b of this._buttons) {
      b.update(this._activeButton);
    }
    this.activeButtonChangedObservable.notifyObservers(this._activeButton);
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsJoint.js
var PhysicsJoint = class {
  /**
   * Initializes the physics joint
   * @param type The type of the physics joint
   * @param jointData The data for the physics joint
   */
  constructor(type, jointData) {
    this.type = type;
    this.jointData = jointData;
    jointData.nativeParams = jointData.nativeParams || {};
  }
  /**
   * Gets the physics joint
   */
  get physicsJoint() {
    return this._physicsJoint;
  }
  /**
   * Sets the physics joint
   */
  set physicsJoint(newJoint) {
    this._physicsJoint = newJoint;
  }
  /**
   * Sets the physics plugin
   */
  set physicsPlugin(physicsPlugin) {
    this._physicsPlugin = physicsPlugin;
  }
  /**
   * Execute a function that is physics-plugin specific.
   * @param {Function} func the function that will be executed.
   *                        It accepts two parameters: the physics world and the physics joint
   */
  executeNativeFunction(func) {
    func(this._physicsPlugin.world, this._physicsJoint);
  }
};
PhysicsJoint.DistanceJoint = 0;
PhysicsJoint.HingeJoint = 1;
PhysicsJoint.BallAndSocketJoint = 2;
PhysicsJoint.WheelJoint = 3;
PhysicsJoint.SliderJoint = 4;
PhysicsJoint.PrismaticJoint = 5;
PhysicsJoint.UniversalJoint = 6;
PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
PhysicsJoint.PointToPointJoint = 8;
PhysicsJoint.SpringJoint = 9;
PhysicsJoint.LockJoint = 10;

// node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js
Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
    mass: jsonObject.physicsMass,
    friction: jsonObject.physicsFriction,
    restitution: jsonObject.physicsRestitution
  }, scene);
};
var PhysicsImpostor = class _PhysicsImpostor {
  /**
   * Specifies if the physics imposter is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets the mass of the physics imposter
   */
  get mass() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
  }
  set mass(value) {
    this.setMass(value);
  }
  /**
   * Gets the coefficient of friction
   */
  get friction() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
  }
  /**
   * Sets the coefficient of friction
   */
  set friction(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
  }
  /**
   * Gets the coefficient of restitution
   */
  get restitution() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
  }
  /**
   * Sets the coefficient of restitution
   */
  set restitution(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
  }
  /**
   * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  get pressure() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return 0;
    }
    return plugin.getBodyPressure(this);
  }
  /**
   * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  set pressure(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return;
    }
    plugin.setBodyPressure(this, value);
  }
  /**
   * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  get stiffness() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyStiffness) {
      return 0;
    }
    return plugin.getBodyStiffness(this);
  }
  /**
   * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  set stiffness(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyStiffness) {
      return;
    }
    plugin.setBodyStiffness(this, value);
  }
  /**
   * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get velocityIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyVelocityIterations) {
      return 0;
    }
    return plugin.getBodyVelocityIterations(this);
  }
  /**
   * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set velocityIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyVelocityIterations) {
      return;
    }
    plugin.setBodyVelocityIterations(this, value);
  }
  /**
   * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get positionIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyPositionIterations) {
      return 0;
    }
    return plugin.getBodyPositionIterations(this);
  }
  /**
   * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set positionIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPositionIterations) {
      return;
    }
    plugin.setBodyPositionIterations(this, value);
  }
  /**
   * Initializes the physics imposter
   * @param object The physics-enabled object used as the physics imposter
   * @param type The type of the physics imposter. Types are available as static members of this class.
   * @param _options The options for the physics imposter
   * @param _scene The Babylon scene
   */
  constructor(object, type, _options = { mass: 0 }, _scene) {
    this.object = object;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._pluginData = {};
    this._bodyUpdateRequired = false;
    this._onBeforePhysicsStepCallbacks = new Array();
    this._onAfterPhysicsStepCallbacks = new Array();
    this._onPhysicsCollideCallbacks = [];
    this._deltaPosition = Vector3.Zero();
    this._isDisposed = false;
    this.soft = false;
    this.segments = 0;
    this._tmpQuat = new Quaternion();
    this._tmpQuat2 = new Quaternion();
    this.beforeStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this.object.translate(this._deltaPosition, -1);
      if (this._deltaRotationConjugated && this.object.rotationQuaternion) {
        this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
      }
      this.object.computeWorldMatrix(false);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
      } else {
        this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
      }
      if (!this._options.disableBidirectionalTransformation) {
        if (this.object.rotationQuaternion) {
          this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(
            this,
            /*bInfo.boundingBox.centerWorld*/
            this.object.getAbsolutePosition(),
            this._tmpQuat
          );
        }
      }
      for (const func of this._onBeforePhysicsStepCallbacks) {
        func(this);
      }
    };
    this.afterStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      for (const func of this._onAfterPhysicsStepCallbacks) {
        func(this);
      }
      this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.conjugateInPlace();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
      }
      this.object.setAbsolutePosition(this.object.position);
      if (this._deltaRotation) {
        if (this.object.rotationQuaternion) {
          this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
        }
        this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, _PhysicsImpostor._TmpVecs[0]);
        this.object.translate(_PhysicsImpostor._TmpVecs[0], 1);
      } else {
        this.object.translate(this._deltaPosition, 1);
      }
      this.object.computeWorldMatrix(true);
    };
    this.onCollideEvent = null;
    this.onCollide = (e) => {
      if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {
        return;
      }
      if (!this._physicsEngine) {
        return;
      }
      const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);
      if (otherImpostor) {
        if (this.onCollideEvent) {
          this.onCollideEvent(this, otherImpostor);
        }
        const callbacks = this._onPhysicsCollideCallbacks.filter((obj) => {
          return obj.otherImpostors.indexOf(otherImpostor) !== -1;
        });
        for (const obj of callbacks) {
          obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);
        }
      }
    };
    if (!this.object) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.object.parent && _options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && object.getScene) {
      this._scene = object.getScene();
    }
    if (!this._scene) {
      return;
    }
    if (this.type > 100) {
      this.soft = true;
    }
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
    } else {
      if (!this.object.rotationQuaternion) {
        if (this.object.rotation) {
          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
        } else {
          this.object.rotationQuaternion = new Quaternion();
        }
      }
      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
      if (this.soft) {
        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
        this._options.path = _options.path === void 0 ? null : _options.path;
        this._options.shape = _options.shape === void 0 ? null : _options.shape;
      }
      this._joints = [];
      if (!this.object.parent || this._options.ignoreParent) {
        this._init();
      } else if (this.object.parent.physicsImpostor) {
        Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
      }
    }
  }
  /**
   * This function will completely initialize this impostor.
   * It will create a new body - but only if this mesh has no parent.
   * If it has, this impostor will not be used other than to define the impostor
   * of the child mesh.
   * @internal
   */
  _init() {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.removeImpostor(this);
    this.physicsBody = null;
    this._parent = this._parent || this._getPhysicsParent();
    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
      this._physicsEngine.addImpostor(this);
    }
  }
  _getPhysicsParent() {
    if (this.object.parent instanceof AbstractMesh) {
      const parentMesh = this.object.parent;
      return parentMesh.physicsImpostor;
    }
    return null;
  }
  /**
   * Should a new body be generated.
   * @returns boolean specifying if body initialization is required
   */
  isBodyInitRequired() {
    return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);
  }
  /**
   * Sets the updated scaling
   */
  setScalingUpdated() {
    this.forceUpdate();
  }
  /**
   * Force a regeneration of this or the parent's impostor's body.
   * Use with caution - This will remove all previously-instantiated joints.
   */
  forceUpdate() {
    this._init();
    if (this.parent && !this._options.ignoreParent) {
      this.parent.forceUpdate();
    }
  }
  /*public get mesh(): AbstractMesh {
      return this._mesh;
  }*/
  /**
   * Gets the body that holds this impostor. Either its own, or its parent.
   */
  get physicsBody() {
    return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
  }
  /**
   * Get the parent of the physics imposter
   * @returns Physics imposter or null
   */
  get parent() {
    return !this._options.ignoreParent && this._parent ? this._parent : null;
  }
  /**
   * Sets the parent of the physics imposter
   */
  set parent(value) {
    this._parent = value;
  }
  /**
   * Set the physics body. Used mainly by the physics engine/plugin
   */
  set physicsBody(physicsBody) {
    if (this._physicsBody && this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
    }
    this._physicsBody = physicsBody;
    this.resetUpdateFlags();
  }
  /**
   * Resets the update flags
   */
  resetUpdateFlags() {
    this._bodyUpdateRequired = false;
  }
  /**
   * Gets the object extents
   * @returns the object extents
   */
  getObjectExtents() {
    if (this.object.getBoundingInfo) {
      const q = this.object.rotationQuaternion;
      const scaling = this.object.scaling.clone();
      this.object.rotationQuaternion = _PhysicsImpostor.IDENTITY_QUATERNION;
      const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      if (worldMatrix) {
        worldMatrix.decompose(scaling, void 0, void 0);
      }
      const boundingInfo = this.object.getBoundingInfo();
      const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
      size.x = Math.abs(size.x);
      size.y = Math.abs(size.y);
      size.z = Math.abs(size.z);
      this.object.rotationQuaternion = q;
      if (this.object.computeWorldMatrix) {
        this.object.computeWorldMatrix(true);
      }
      return size;
    } else {
      return _PhysicsImpostor.DEFAULT_OBJECT_SIZE;
    }
  }
  /**
   * Gets the object center
   * @returns The object center
   */
  getObjectCenter() {
    if (this.object.getBoundingInfo) {
      const boundingInfo = this.object.getBoundingInfo();
      return boundingInfo.boundingBox.centerWorld;
    } else {
      return this.object.position;
    }
  }
  /**
   * Get a specific parameter from the options parameters
   * @param paramName The object parameter name
   * @returns The object parameter
   */
  getParam(paramName) {
    return this._options[paramName];
  }
  /**
   * Sets a specific parameter in the options given to the physics plugin
   * @param paramName The parameter name
   * @param value The value of the parameter
   */
  setParam(paramName, value) {
    this._options[paramName] = value;
    this._bodyUpdateRequired = true;
  }
  /**
   * Specifically change the body's mass. Won't recreate the physics body object
   * @param mass The mass of the physics imposter
   */
  setMass(mass) {
    if (this.getParam("mass") !== mass) {
      this.setParam("mass", mass);
    }
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
    }
  }
  /**
   * Gets the linear velocity
   * @returns  linear velocity or null
   */
  getLinearVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the linear velocity
   * @param velocity  linear velocity or null
   */
  setLinearVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
    }
  }
  /**
   * Gets the angular velocity
   * @returns angular velocity or null
   */
  getAngularVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the angular velocity
   * @param velocity The velocity or null
   */
  setAngularVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
    }
  }
  /**
   * Execute a function with the physics plugin native code
   * Provide a function the will have two variables - the world object and the physics body object
   * @param func The function to execute with the physics plugin native code
   */
  executeNativeFunction(func) {
    if (this._physicsEngine) {
      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
    }
  }
  /**
   * Register a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  registerBeforePhysicsStep(func) {
    this._onBeforePhysicsStepCallbacks.push(func);
  }
  /**
   * Unregister a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  unregisterBeforePhysicsStep(func) {
    const index = this._onBeforePhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onBeforePhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Register a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  registerAfterPhysicsStep(func) {
    this._onAfterPhysicsStepCallbacks.push(func);
  }
  /**
   * Unregisters a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  unregisterAfterPhysicsStep(func) {
    const index = this._onAfterPhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onAfterPhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * register a function that will be executed when this impostor collides against a different body
   * @param collideAgainst Physics imposter, or array of physics imposters to collide against
   * @param func Callback that is executed on collision
   */
  registerOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
  }
  /**
   * Unregisters the physics imposter's collision callback
   * @param collideAgainst The physics object to collide against
   * @param func Callback to execute on collision
   */
  unregisterOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    let index = -1;
    const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {
      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
        const sameList = cbDef.otherImpostors.every((impostor) => {
          return collidedAgainstList.indexOf(impostor) > -1;
        });
        if (sameList) {
          index = idx;
        }
        return sameList;
      }
      return false;
    });
    if (found) {
      this._onPhysicsCollideCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Get the parent rotation
   * @returns The parent rotation
   */
  getParentsRotation() {
    let parent = this.object.parent;
    this._tmpQuat.copyFromFloats(0, 0, 0, 1);
    while (parent) {
      if (parent.rotationQuaternion) {
        this._tmpQuat2.copyFrom(parent.rotationQuaternion);
      } else {
        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
      }
      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
      parent = parent.parent;
    }
    return this._tmpQuat;
  }
  /**
   * Apply a force
   * @param force The force to apply
   * @param contactPoint The contact point for the force
   * @returns The physics imposter
   */
  applyForce(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
    }
    return this;
  }
  /**
   * Apply an impulse
   * @param force The impulse force
   * @param contactPoint The contact point for the impulse force
   * @returns The physics imposter
   */
  applyImpulse(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
    }
    return this;
  }
  /**
   * A help function to create a joint
   * @param otherImpostor A physics imposter used to create a joint
   * @param jointType The type of joint
   * @param jointData The data for the joint
   * @returns The physics imposter
   */
  createJoint(otherImpostor, jointType, jointData) {
    const joint = new PhysicsJoint(jointType, jointData);
    this.addJoint(otherImpostor, joint);
    return this;
  }
  /**
   * Add a joint to this impostor with a different impostor
   * @param otherImpostor A physics imposter used to add a joint
   * @param joint The joint to add
   * @returns The physics imposter
   */
  addJoint(otherImpostor, joint) {
    this._joints.push({
      otherImpostor,
      joint
    });
    if (this._physicsEngine) {
      this._physicsEngine.addJoint(this, otherImpostor, joint);
    }
    return this;
  }
  /**
   * Add an anchor to a cloth impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param width ratio across width from 0 to 1
   * @param height ratio up height from 0 to 1
   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
   * @returns impostor the soft imposter
   */
  addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Add a hook to a rope impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param length ratio across rope from 0 to 1
   * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
   * @returns impostor the rope imposter
   */
  addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Will keep this body still, in a sleep mode.
   * @returns the physics imposter
   */
  sleep() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().sleepBody(this);
    }
    return this;
  }
  /**
   * Wake the body up.
   * @returns The physics imposter
   */
  wakeUp() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
    }
    return this;
  }
  /**
   * Clones the physics imposter
   * @param newObject The physics imposter clones to this physics-enabled object
   * @returns A nullable physics imposter
   */
  clone(newObject) {
    if (!newObject) {
      return null;
    }
    return new _PhysicsImpostor(newObject, this.type, this._options, this._scene);
  }
  /**
   * Disposes the physics imposter
   */
  dispose() {
    if (!this._physicsEngine) {
      return;
    }
    for (const j of this._joints) {
      if (this._physicsEngine) {
        this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);
      }
    }
    this._physicsEngine.removeImpostor(this);
    if (this.parent) {
      this.parent.forceUpdate();
    }
    this._isDisposed = true;
  }
  /**
   * Sets the delta position
   * @param position The delta position amount
   */
  setDeltaPosition(position) {
    this._deltaPosition.copyFrom(position);
  }
  /**
   * Sets the delta rotation
   * @param rotation The delta rotation amount
   */
  setDeltaRotation(rotation) {
    if (!this._deltaRotation) {
      this._deltaRotation = new Quaternion();
    }
    this._deltaRotation.copyFrom(rotation);
    this._deltaRotationConjugated = this._deltaRotation.conjugate();
  }
  /**
   * Gets the box size of the physics imposter and stores the result in the input parameter
   * @param result Stores the box size
   * @returns The physics imposter
   */
  getBoxSizeToRef(result) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
    }
    return this;
  }
  /**
   * Gets the radius of the physics imposter
   * @returns Radius of the physics imposter
   */
  getRadius() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
  }
  /**
   * Sync a bone with this impostor
   * @param bone The bone to sync to the impostor.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   */
  syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
    const tempVec = _PhysicsImpostor._TmpVecs[0];
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
        bone.setRotationQuaternion(tempQuat, 1, boneMesh);
      } else {
        bone.setRotationQuaternion(mesh.rotationQuaternion, 1, boneMesh);
      }
    }
    tempVec.x = 0;
    tempVec.y = 0;
    tempVec.z = 0;
    if (jointPivot) {
      tempVec.x = jointPivot.x;
      tempVec.y = jointPivot.y;
      tempVec.z = jointPivot.z;
      bone.getDirectionToRef(tempVec, boneMesh, tempVec);
      if (distToJoint === void 0 || distToJoint === null) {
        distToJoint = jointPivot.length();
      }
      tempVec.x *= distToJoint;
      tempVec.y *= distToJoint;
      tempVec.z *= distToJoint;
    }
    if (bone.getParent()) {
      tempVec.addInPlace(mesh.getAbsolutePosition());
      bone.setAbsolutePosition(tempVec, boneMesh);
    } else {
      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
      boneMesh.position.x -= tempVec.x;
      boneMesh.position.y -= tempVec.y;
      boneMesh.position.z -= tempVec.z;
    }
  }
  /**
   * Sync impostor to a bone
   * @param bone The bone that the impostor will be synced to.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   * @param boneAxis Optional vector3 axis the bone is aligned with
   */
  syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        bone.getRotationQuaternionToRef(1, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(1, boneMesh, mesh.rotationQuaternion);
      }
    }
    const pos = _PhysicsImpostor._TmpVecs[0];
    const boneDir = _PhysicsImpostor._TmpVecs[1];
    if (!boneAxis) {
      boneAxis = _PhysicsImpostor._TmpVecs[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  }
};
PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
PhysicsImpostor._TmpVecs = BuildArray(3, Vector3.Zero);
PhysicsImpostor._TmpQuat = Quaternion.Identity();
PhysicsImpostor.NoImpostor = 0;
PhysicsImpostor.SphereImpostor = 1;
PhysicsImpostor.BoxImpostor = 2;
PhysicsImpostor.PlaneImpostor = 3;
PhysicsImpostor.MeshImpostor = 4;
PhysicsImpostor.CapsuleImpostor = 6;
PhysicsImpostor.CylinderImpostor = 7;
PhysicsImpostor.ParticleImpostor = 8;
PhysicsImpostor.HeightmapImpostor = 9;
PhysicsImpostor.ConvexHullImpostor = 10;
PhysicsImpostor.CustomImpostor = 100;
PhysicsImpostor.RopeImpostor = 101;
PhysicsImpostor.ClothImpostor = 102;
PhysicsImpostor.SoftbodyImpostor = 103;

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
function CreateIcoSphereVertexData(options) {
  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  const radius = options.radius || 1;
  const flat = options.flat === void 0 ? true : options.flat;
  const subdivisions = (options.subdivisions || 4) | 0;
  const radiusX = options.radiusX || radius;
  const radiusY = options.radiusY || radius;
  const radiusZ = options.radiusZ || radius;
  const t = (1 + Math.sqrt(5)) / 2;
  const icoVertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    // v0-3
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    // v4-7
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
    // v8-11
  ];
  const icoIndices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  const verticesUnaliasId = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    // vertex alias
    0,
    // 12: 0 + 12
    2,
    // 13: 2 + 11
    3,
    // 14: 3 + 11
    3,
    // 15: 3 + 12
    3,
    // 16: 3 + 13
    4,
    // 17: 4 + 13
    7,
    // 18: 7 + 11
    8,
    // 19: 8 + 11
    9,
    // 20: 9 + 11
    9,
    // 21: 9 + 12
    10,
    // 22: A + 12
    11
    // 23: B + 12
  ];
  const icoVertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    // v0-3
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    // v4-7
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    // v8-11
    // vertex alias (for same vertex on different faces)
    0,
    4,
    // 12: 0 + 12
    3,
    3,
    // 13: 2 + 11
    4,
    4,
    // 14: 3 + 11
    3,
    1,
    // 15: 3 + 12
    4,
    2,
    // 16: 3 + 13
    4,
    4,
    // 17: 4 + 13
    0,
    2,
    // 18: 7 + 11
    1,
    1,
    // 19: 8 + 11
    2,
    2,
    // 20: 9 + 11
    3,
    3,
    // 21: 9 + 12
    1,
    3,
    // 22: A + 12
    2,
    4
    // 23: B + 12
  ];
  const ustep = 138 / 1024;
  const vstep = 239 / 1024;
  const uoffset = 60 / 1024;
  const voffset = 26 / 1024;
  const islandUoffset = -40 / 1024;
  const islandVoffset = 20 / 1024;
  const island = [
    0,
    0,
    0,
    0,
    1,
    //  0 - 4
    0,
    0,
    1,
    1,
    0,
    //  5 - 9
    0,
    0,
    1,
    1,
    0,
    //  10 - 14
    0,
    1,
    1,
    1,
    0
    //  15 - 19
  ];
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let currentIndice = 0;
  const faceVertexPos = new Array(3);
  const faceVertexUv = new Array(3);
  let v012;
  for (v012 = 0; v012 < 3; v012++) {
    faceVertexPos[v012] = Vector3.Zero();
    faceVertexUv[v012] = Vector2.Zero();
  }
  for (let face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      const vId = icoIndices[3 * face + v012];
      faceVertexPos[v012].copyFromFloats(icoVertices[3 * verticesUnaliasId[vId]], icoVertices[3 * verticesUnaliasId[vId] + 1], icoVertices[3 * verticesUnaliasId[vId] + 2]);
      faceVertexPos[v012].normalize();
      faceVertexUv[v012].copyFromFloats(icoVertexuv[2 * vId] * ustep + uoffset + island[face] * islandUoffset, icoVertexuv[2 * vId + 1] * vstep + voffset + island[face] * islandVoffset);
    }
    const interpVertex = (i1, i2, c1, c2) => {
      const posX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], i2 / subdivisions);
      const posX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], i2 / subdivisions);
      const posInterp = subdivisions === i2 ? faceVertexPos[2] : Vector3.Lerp(posX0, posX1, i1 / (subdivisions - i2));
      posInterp.normalize();
      let vertexNormal;
      if (flat) {
        const centroidX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], c2 / subdivisions);
        const centroidX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], c2 / subdivisions);
        vertexNormal = Vector3.Lerp(centroidX0, centroidX1, c1 / (subdivisions - c2));
      } else {
        vertexNormal = new Vector3(posInterp.x, posInterp.y, posInterp.z);
      }
      vertexNormal.x /= radiusX;
      vertexNormal.y /= radiusY;
      vertexNormal.z /= radiusZ;
      vertexNormal.normalize();
      const uvX0 = Vector2.Lerp(faceVertexUv[0], faceVertexUv[2], i2 / subdivisions);
      const uvX1 = Vector2.Lerp(faceVertexUv[1], faceVertexUv[2], i2 / subdivisions);
      const uvInterp = subdivisions === i2 ? faceVertexUv[2] : Vector2.Lerp(uvX0, uvX1, i1 / (subdivisions - i2));
      positions.push(posInterp.x * radiusX, posInterp.y * radiusY, posInterp.z * radiusZ);
      normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
      uvs.push(uvInterp.x, useOpenGLOrientationForUV ? 1 - uvInterp.y : uvInterp.y);
      indices.push(currentIndice);
      currentIndice++;
    };
    for (let i2 = 0; i2 < subdivisions; i2++) {
      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {
        interpVertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interpVertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interpVertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interpVertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interpVertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interpVertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateIcoSphere(name, options = {}, scene = null) {
  const sphere = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateIcoSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
VertexData.CreateIcoSphere = CreateIcoSphereVertexData;
Mesh.CreateIcoSphere = (name, options, scene) => {
  return CreateIcoSphere(name, options, scene);
};

// node_modules/@babylonjs/core/XR/features/WebXRHandTracking.js
var HandPart;
(function(HandPart2) {
  HandPart2["WRIST"] = "wrist";
  HandPart2["THUMB"] = "thumb";
  HandPart2["INDEX"] = "index";
  HandPart2["MIDDLE"] = "middle";
  HandPart2["RING"] = "ring";
  HandPart2["LITTLE"] = "little";
})(HandPart || (HandPart = {}));
var WebXRHandJoint;
(function(WebXRHandJoint2) {
  WebXRHandJoint2["WRIST"] = "wrist";
  WebXRHandJoint2["THUMB_METACARPAL"] = "thumb-metacarpal";
  WebXRHandJoint2["THUMB_PHALANX_PROXIMAL"] = "thumb-phalanx-proximal";
  WebXRHandJoint2["THUMB_PHALANX_DISTAL"] = "thumb-phalanx-distal";
  WebXRHandJoint2["THUMB_TIP"] = "thumb-tip";
  WebXRHandJoint2["INDEX_FINGER_METACARPAL"] = "index-finger-metacarpal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_PROXIMAL"] = "index-finger-phalanx-proximal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_INTERMEDIATE"] = "index-finger-phalanx-intermediate";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_DISTAL"] = "index-finger-phalanx-distal";
  WebXRHandJoint2["INDEX_FINGER_TIP"] = "index-finger-tip";
  WebXRHandJoint2["MIDDLE_FINGER_METACARPAL"] = "middle-finger-metacarpal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_PROXIMAL"] = "middle-finger-phalanx-proximal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_INTERMEDIATE"] = "middle-finger-phalanx-intermediate";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_DISTAL"] = "middle-finger-phalanx-distal";
  WebXRHandJoint2["MIDDLE_FINGER_TIP"] = "middle-finger-tip";
  WebXRHandJoint2["RING_FINGER_METACARPAL"] = "ring-finger-metacarpal";
  WebXRHandJoint2["RING_FINGER_PHALANX_PROXIMAL"] = "ring-finger-phalanx-proximal";
  WebXRHandJoint2["RING_FINGER_PHALANX_INTERMEDIATE"] = "ring-finger-phalanx-intermediate";
  WebXRHandJoint2["RING_FINGER_PHALANX_DISTAL"] = "ring-finger-phalanx-distal";
  WebXRHandJoint2["RING_FINGER_TIP"] = "ring-finger-tip";
  WebXRHandJoint2["PINKY_FINGER_METACARPAL"] = "pinky-finger-metacarpal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_PROXIMAL"] = "pinky-finger-phalanx-proximal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_INTERMEDIATE"] = "pinky-finger-phalanx-intermediate";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_DISTAL"] = "pinky-finger-phalanx-distal";
  WebXRHandJoint2["PINKY_FINGER_TIP"] = "pinky-finger-tip";
})(WebXRHandJoint || (WebXRHandJoint = {}));
var HandJointReferenceArray = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
var HandPartsDefinition = {
  [
    "wrist"
    /* HandPart.WRIST */
  ]: [
    "wrist"
    /* WebXRHandJoint.WRIST */
  ],
  [
    "thumb"
    /* HandPart.THUMB */
  ]: [
    "thumb-metacarpal",
    "thumb-phalanx-proximal",
    "thumb-phalanx-distal",
    "thumb-tip"
    /* WebXRHandJoint.THUMB_TIP */
  ],
  [
    "index"
    /* HandPart.INDEX */
  ]: [
    "index-finger-metacarpal",
    "index-finger-phalanx-proximal",
    "index-finger-phalanx-intermediate",
    "index-finger-phalanx-distal",
    "index-finger-tip"
  ],
  [
    "middle"
    /* HandPart.MIDDLE */
  ]: [
    "middle-finger-metacarpal",
    "middle-finger-phalanx-proximal",
    "middle-finger-phalanx-intermediate",
    "middle-finger-phalanx-distal",
    "middle-finger-tip"
  ],
  [
    "ring"
    /* HandPart.RING */
  ]: [
    "ring-finger-metacarpal",
    "ring-finger-phalanx-proximal",
    "ring-finger-phalanx-intermediate",
    "ring-finger-phalanx-distal",
    "ring-finger-tip"
  ],
  [
    "little"
    /* HandPart.LITTLE */
  ]: [
    "pinky-finger-metacarpal",
    "pinky-finger-phalanx-proximal",
    "pinky-finger-phalanx-intermediate",
    "pinky-finger-phalanx-distal",
    "pinky-finger-tip"
  ]
};
var WebXRHand = class {
  /**
   * Get the hand mesh.
   */
  get handMesh() {
    return this._handMesh;
  }
  /**
   * Get meshes of part of the hand.
   * @param part The part of hand to get.
   * @returns An array of meshes that correlate to the hand part requested.
   */
  getHandPartMeshes(part) {
    return HandPartsDefinition[part].map((name) => this._jointMeshes[HandJointReferenceArray.indexOf(name)]);
  }
  /**
   * Retrieves a mesh linked to a named joint in the hand.
   * @param jointName The name of the joint.
   * @returns An AbstractMesh whose position corresponds with the joint position.
   */
  getJointMesh(jointName) {
    return this._jointMeshes[HandJointReferenceArray.indexOf(jointName)];
  }
  /**
   * Construct a new hand object
   * @param xrController The controller to which the hand correlates.
   * @param _jointMeshes The meshes to be used to track the hand joints.
   * @param _handMesh An optional hand mesh.
   * @param rigMapping An optional rig mapping for the hand mesh.
   *                   If not provided (but a hand mesh is provided),
   *                   it will be assumed that the hand mesh's bones are named
   *                   directly after the WebXR bone names.
   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes
   * @param _jointsInvisible Are the tracked joint meshes visible
   * @param _jointScaleFactor Scale factor for all joint meshes
   */
  constructor(xrController, _jointMeshes, _handMesh, rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {
    this.xrController = xrController;
    this._jointMeshes = _jointMeshes;
    this._handMesh = _handMesh;
    this.rigMapping = rigMapping;
    this._leftHandedMeshes = _leftHandedMeshes;
    this._jointsInvisible = _jointsInvisible;
    this._jointScaleFactor = _jointScaleFactor;
    this.onHandMeshSetObservable = new Observable();
    this._jointTransforms = new Array(HandJointReferenceArray.length);
    this._jointTransformMatrices = new Float32Array(HandJointReferenceArray.length * 16);
    this._tempJointMatrix = new Matrix();
    this._jointRadii = new Float32Array(HandJointReferenceArray.length);
    this._handMeshRoot = null;
    this._scene = _jointMeshes[0].getScene();
    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {
      this._jointTransforms[jointIdx] = new TransformNode(HandJointReferenceArray[jointIdx], this._scene);
      this._jointTransforms[jointIdx].rotationQuaternion = new Quaternion();
      if (_jointMeshes[jointIdx].rotationQuaternion) {
        _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();
      } else {
        _jointMeshes[jointIdx].rotationQuaternion?.set(0, 0, 0, 1);
      }
    }
    if (_handMesh) {
      this.setHandMesh(_handMesh, rigMapping);
    }
    if (this.xrController.motionController) {
      if (this.xrController.motionController.rootMesh) {
        this.xrController.motionController.rootMesh.dispose(false, true);
      }
    }
    this.xrController.onMotionControllerInitObservable.add((motionController) => {
      motionController._doNotLoadControllerMesh = true;
    });
  }
  /**
   * Sets the current hand mesh to render for the WebXRHand.
   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.
   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.
   * @param _xrSessionManager The XRSessionManager used to initialize the hand mesh.
   */
  setHandMesh(handMesh, rigMapping, _xrSessionManager) {
    this._handMesh = handMesh;
    this._handMeshRoot = this._handMesh;
    while (this._handMeshRoot.parent) {
      this._handMeshRoot = this._handMeshRoot.parent;
    }
    handMesh.alwaysSelectAsActiveMesh = true;
    const children = handMesh.getChildMeshes();
    for (const mesh of children) {
      mesh.alwaysSelectAsActiveMesh = true;
    }
    if (this._handMesh.skeleton) {
      const handMeshSkeleton = this._handMesh.skeleton;
      for (let jointIdx = 0; jointIdx < HandJointReferenceArray.length; jointIdx++) {
        const jointName = HandJointReferenceArray[jointIdx];
        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);
        if (jointBoneIdx !== -1) {
          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);
        }
      }
    }
    this.onHandMeshSetObservable.notifyObservers(this);
  }
  /**
   * Update this hand from the latest xr frame.
   * @param xrFrame The latest frame received from WebXR.
   * @param referenceSpace The current viewer reference space.
   * @param xrCamera the xr camera, used for parenting
   */
  updateFromXRFrame(xrFrame, referenceSpace, xrCamera) {
    const hand = this.xrController.inputSource.hand;
    if (!hand) {
      return;
    }
    const anyHand = hand;
    const jointSpaces = HandJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));
    let trackingSuccessful = false;
    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {
      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);
    } else if (xrFrame.getJointPose) {
      trackingSuccessful = true;
      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {
        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);
        if (jointPose) {
          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);
          this._jointRadii[jointIdx] = jointPose.radius || 8e-3;
        } else {
          trackingSuccessful = false;
          break;
        }
      }
    }
    if (!trackingSuccessful) {
      return;
    }
    for (let jointIdx = 0; jointIdx < HandJointReferenceArray.length; jointIdx++) {
      const jointTransform = this._jointTransforms[jointIdx];
      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);
      this._tempJointMatrix.decompose(void 0, jointTransform.rotationQuaternion, jointTransform.position);
      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;
      const jointMesh = this._jointMeshes[jointIdx];
      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;
      jointMesh.position.copyFrom(jointTransform.position);
      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);
      jointMesh.scaling.setAll(scaledJointRadius);
      jointMesh.parent = xrCamera.parent;
      if (!this._scene.useRightHandedSystem) {
        jointMesh.position.z *= -1;
        jointMesh.rotationQuaternion.z *= -1;
        jointMesh.rotationQuaternion.w *= -1;
        if (this._leftHandedMeshes && this._handMesh) {
          jointTransform.position.z *= -1;
          jointTransform.rotationQuaternion.z *= -1;
          jointTransform.rotationQuaternion.w *= -1;
        }
      }
    }
    if (this._handMesh) {
      this._handMesh.isVisible = true;
      if (this._handMeshRoot) {
        this._handMeshRoot.parent = xrCamera.parent;
      }
    }
    this.xrController.pointer.parent = xrCamera.parent;
  }
  /**
   * Dispose this Hand object
   * @param disposeMeshes Should the meshes be disposed as well
   */
  dispose(disposeMeshes = false) {
    if (this._handMesh) {
      if (disposeMeshes) {
        this._handMesh.skeleton?.dispose();
        this._handMesh.dispose(false, true);
      } else {
        this._handMesh.isVisible = false;
      }
    }
    for (const transform of this._jointTransforms) {
      transform.dispose();
    }
    this._jointTransforms.length = 0;
    this.onHandMeshSetObservable.clear();
  }
};
var WebXRHandTracking = class _WebXRHandTracking extends WebXRAbstractFeature {
  static _GenerateTrackedJointMeshes(featureOptions, originalMesh = CreateIcoSphere("jointParent", _WebXRHandTracking._ICOSPHERE_PARAMS)) {
    const meshes = {};
    ["left", "right"].map((handedness) => {
      const trackedMeshes = [];
      originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;
      for (let i = 0; i < HandJointReferenceArray.length; ++i) {
        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);
        if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {
          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);
          if (returnedMesh) {
            if (returnedMesh !== newInstance) {
              newInstance.dispose();
              newInstance = returnedMesh;
            }
          }
        }
        newInstance.isPickable = false;
        if (featureOptions.jointMeshes?.enablePhysics) {
          const props = featureOptions.jointMeshes?.physicsProps || {};
          newInstance.scaling.setAll(0.02);
          const type = props.impostorType !== void 0 ? props.impostorType : PhysicsImpostor.SphereImpostor;
          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });
        }
        newInstance.rotationQuaternion = new Quaternion();
        newInstance.isVisible = false;
        trackedMeshes.push(newInstance);
      }
      meshes[handedness] = trackedMeshes;
    });
    return { left: meshes.left, right: meshes.right };
  }
  static async _GenerateDefaultHandMeshesAsync(scene, xrSessionManager, options) {
    return await new Promise(async (resolve) => {
      const riggedMeshes = {};
      if (_WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {
        _WebXRHandTracking._RightHandGLB = null;
      }
      if (_WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {
        _WebXRHandTracking._LeftHandGLB = null;
      }
      const handsDefined = !!(_WebXRHandTracking._RightHandGLB && _WebXRHandTracking._LeftHandGLB);
      const defaulrHandGLBUrl = Tools.GetAssetUrl(_WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL);
      const handGLBs = await Promise.all([
        _WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync("", defaulrHandGLBUrl, _WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),
        _WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync("", defaulrHandGLBUrl, _WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)
      ]);
      _WebXRHandTracking._RightHandGLB = handGLBs[0];
      _WebXRHandTracking._LeftHandGLB = handGLBs[1];
      const shaderUrl = Tools.GetAssetUrl(_WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);
      const handShader = await NodeMaterial.ParseFromFileAsync("handShader", shaderUrl, scene, void 0, true);
      handShader.needDepthPrePass = true;
      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;
      handShader.alphaMode = 2;
      handShader.build(false);
      const handColors = {
        base: Color3.FromInts(116, 63, 203),
        fresnel: Color3.FromInts(149, 102, 229),
        fingerColor: Color3.FromInts(177, 130, 255),
        tipFresnel: Color3.FromInts(220, 200, 255),
        ...options?.handMeshes?.customColors
      };
      const handNodes = {
        base: handShader.getBlockByName("baseColor"),
        fresnel: handShader.getBlockByName("fresnelColor"),
        fingerColor: handShader.getBlockByName("fingerColor"),
        tipFresnel: handShader.getBlockByName("tipFresnelColor")
      };
      handNodes.base.value = handColors.base;
      handNodes.fresnel.value = handColors.fresnel;
      handNodes.fingerColor.value = handColors.fingerColor;
      handNodes.tipFresnel.value = handColors.tipFresnel;
      const isMultiview = xrSessionManager._getBaseLayerWrapper()?.isMultiview;
      const hd = ["left", "right"];
      for (const handedness of hd) {
        const handGLB = handedness == "left" ? _WebXRHandTracking._LeftHandGLB : _WebXRHandTracking._RightHandGLB;
        if (!handGLB) {
          throw new Error("Could not load hand model");
        }
        const handMesh = handGLB.meshes[1];
        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;
        if (!isMultiview && !options?.handMeshes?.disableHandShader) {
          handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);
        }
        handMesh.isVisible = false;
        riggedMeshes[handedness] = handMesh;
        if (!handsDefined && !scene.useRightHandedSystem) {
          handGLB.meshes[1].rotate(Axis.Y, Math.PI);
        }
      }
      handShader.dispose();
      resolve({ left: riggedMeshes.left, right: riggedMeshes.right });
    });
  }
  /**
   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.
   * @param handedness The handedness being mapped for.
   * @returns A mapping from XRHandJoint to bone name.
   */
  static _GenerateDefaultHandMeshRigMapping(handedness) {
    const h = handedness == "right" ? "R" : "L";
    return {
      [
        "wrist"
        /* WebXRHandJoint.WRIST */
      ]: `wrist_${h}`,
      [
        "thumb-metacarpal"
        /* WebXRHandJoint.THUMB_METACARPAL */
      ]: `thumb_metacarpal_${h}`,
      [
        "thumb-phalanx-proximal"
        /* WebXRHandJoint.THUMB_PHALANX_PROXIMAL */
      ]: `thumb_proxPhalanx_${h}`,
      [
        "thumb-phalanx-distal"
        /* WebXRHandJoint.THUMB_PHALANX_DISTAL */
      ]: `thumb_distPhalanx_${h}`,
      [
        "thumb-tip"
        /* WebXRHandJoint.THUMB_TIP */
      ]: `thumb_tip_${h}`,
      [
        "index-finger-metacarpal"
        /* WebXRHandJoint.INDEX_FINGER_METACARPAL */
      ]: `index_metacarpal_${h}`,
      [
        "index-finger-phalanx-proximal"
        /* WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL */
      ]: `index_proxPhalanx_${h}`,
      [
        "index-finger-phalanx-intermediate"
        /* WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE */
      ]: `index_intPhalanx_${h}`,
      [
        "index-finger-phalanx-distal"
        /* WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL */
      ]: `index_distPhalanx_${h}`,
      [
        "index-finger-tip"
        /* WebXRHandJoint.INDEX_FINGER_TIP */
      ]: `index_tip_${h}`,
      [
        "middle-finger-metacarpal"
        /* WebXRHandJoint.MIDDLE_FINGER_METACARPAL */
      ]: `middle_metacarpal_${h}`,
      [
        "middle-finger-phalanx-proximal"
        /* WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL */
      ]: `middle_proxPhalanx_${h}`,
      [
        "middle-finger-phalanx-intermediate"
        /* WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE */
      ]: `middle_intPhalanx_${h}`,
      [
        "middle-finger-phalanx-distal"
        /* WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL */
      ]: `middle_distPhalanx_${h}`,
      [
        "middle-finger-tip"
        /* WebXRHandJoint.MIDDLE_FINGER_TIP */
      ]: `middle_tip_${h}`,
      [
        "ring-finger-metacarpal"
        /* WebXRHandJoint.RING_FINGER_METACARPAL */
      ]: `ring_metacarpal_${h}`,
      [
        "ring-finger-phalanx-proximal"
        /* WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL */
      ]: `ring_proxPhalanx_${h}`,
      [
        "ring-finger-phalanx-intermediate"
        /* WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE */
      ]: `ring_intPhalanx_${h}`,
      [
        "ring-finger-phalanx-distal"
        /* WebXRHandJoint.RING_FINGER_PHALANX_DISTAL */
      ]: `ring_distPhalanx_${h}`,
      [
        "ring-finger-tip"
        /* WebXRHandJoint.RING_FINGER_TIP */
      ]: `ring_tip_${h}`,
      [
        "pinky-finger-metacarpal"
        /* WebXRHandJoint.PINKY_FINGER_METACARPAL */
      ]: `little_metacarpal_${h}`,
      [
        "pinky-finger-phalanx-proximal"
        /* WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL */
      ]: `little_proxPhalanx_${h}`,
      [
        "pinky-finger-phalanx-intermediate"
        /* WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE */
      ]: `little_intPhalanx_${h}`,
      [
        "pinky-finger-phalanx-distal"
        /* WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL */
      ]: `little_distPhalanx_${h}`,
      [
        "pinky-finger-tip"
        /* WebXRHandJoint.PINKY_FINGER_TIP */
      ]: `little_tip_${h}`
    };
  }
  /**
   * Check if the needed objects are defined.
   * This does not mean that the feature is enabled, but that the objects needed are well defined.
   * @returns true if the needed objects for this feature are defined
   */
  isCompatible() {
    return typeof XRHand !== "undefined";
  }
  /**
   * Get the hand object according to the controller id
   * @param controllerId the controller id to which we want to get the hand
   * @returns null if not found or the WebXRHand object if found
   */
  getHandByControllerId(controllerId) {
    return this._attachedHands[controllerId];
  }
  /**
   * Get a hand object according to the requested handedness
   * @param handedness the handedness to request
   * @returns null if not found or the WebXRHand object if found
   */
  getHandByHandedness(handedness) {
    if (handedness == "none") {
      return null;
    }
    return this._trackingHands[handedness];
  }
  /**
   * Creates a new instance of the XR hand tracking feature.
   * @param _xrSessionManager An instance of WebXRSessionManager.
   * @param options Options to use when constructing this feature.
   */
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this._attachedHands = {};
    this._trackingHands = { left: null, right: null };
    this._handResources = { jointMeshes: null, handMeshes: null, rigMappings: null };
    this._worldScaleObserver = null;
    this.onHandAddedObservable = new Observable();
    this.onHandRemovedObservable = new Observable();
    this._attachHand = (xrController) => {
      if (!xrController.inputSource.hand || xrController.inputSource.handedness == "none" || !this._handResources.jointMeshes) {
        return;
      }
      const handedness = xrController.inputSource.handedness;
      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], this.options.handMeshes?.meshesUseLeftHandedCoordinates, this.options.jointMeshes?.invisible, this.options.jointMeshes?.scaleFactor);
      this._attachedHands[xrController.uniqueId] = webxrHand;
      this._trackingHands[handedness] = webxrHand;
      this.onHandAddedObservable.notifyObservers(webxrHand);
    };
    this._detachHand = (xrController) => {
      this._detachHandById(xrController.uniqueId);
    };
    this.xrNativeFeatureName = "hand-tracking";
    const anyOptions = options;
    const anyJointMeshOptions = anyOptions.jointMeshes;
    if (anyJointMeshOptions) {
      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;
      }
      if (typeof anyJointMeshOptions.handMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;
      }
      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;
      }
      if (typeof anyJointMeshOptions.rigMapping !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        const leftRigMapping = {};
        const rightRigMapping = {};
        const rigMappingTuples = [
          [anyJointMeshOptions.rigMapping.left, leftRigMapping],
          [anyJointMeshOptions.rigMapping.right, rightRigMapping]
        ];
        for (const rigMappingTuple of rigMappingTuples) {
          const legacyRigMapping = rigMappingTuple[0];
          const rigMapping = rigMappingTuple[1];
          for (let index = 0; index < legacyRigMapping.length; index++) {
            const modelJointName = legacyRigMapping[index];
            rigMapping[HandJointReferenceArray[index]] = modelJointName;
          }
        }
        options.handMeshes.customRigMappings = {
          left: leftRigMapping,
          right: rightRigMapping
        };
      }
    }
  }
  /**
   * Attach this feature.
   * Will usually be called by the features manager.
   *
   * @returns true if successful.
   */
  attach() {
    if (!super.attach()) {
      return false;
    }
    if (!this._handResources.jointMeshes) {
      this._originalMesh = this._originalMesh || this.options.jointMeshes?.sourceMesh || CreateIcoSphere("jointParent", _WebXRHandTracking._ICOSPHERE_PARAMS);
      this._originalMesh.isVisible = false;
      this._handResources.jointMeshes = _WebXRHandTracking._GenerateTrackedJointMeshes(this.options, this._originalMesh);
    }
    this._handResources.handMeshes = this.options.handMeshes?.customMeshes || null;
    this._handResources.rigMappings = this.options.handMeshes?.customRigMappings || null;
    if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {
      _WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this._xrSessionManager, this.options).then((defaultHandMeshes) => {
        this._handResources.handMeshes = defaultHandMeshes;
        this._handResources.rigMappings = {
          left: _WebXRHandTracking._GenerateDefaultHandMeshRigMapping("left"),
          right: _WebXRHandTracking._GenerateDefaultHandMeshRigMapping("right")
        };
        this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left, this._xrSessionManager);
        this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right, this._xrSessionManager);
        this._handResources.handMeshes.left.scaling.setAll(this._xrSessionManager.worldScalingFactor);
        this._handResources.handMeshes.right.scaling.setAll(this._xrSessionManager.worldScalingFactor);
      });
      this._worldScaleObserver = this._xrSessionManager.onWorldScaleFactorChangedObservable.add((scalingFactors) => {
        if (this._handResources.handMeshes) {
          this._handResources.handMeshes.left.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);
          this._handResources.handMeshes.right.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);
        }
      });
    }
    for (const controller of this.options.xrInput.controllers) {
      this._attachHand(controller);
    }
    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);
    return true;
  }
  _onXRFrame(_xrFrame) {
    this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace, this.options.xrInput.xrCamera);
    this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace, this.options.xrInput.xrCamera);
  }
  _detachHandById(controllerId, disposeMesh) {
    const hand = this.getHandByControllerId(controllerId);
    if (hand) {
      const handedness = hand.xrController.inputSource.handedness == "left" ? "left" : "right";
      if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {
        this._trackingHands[handedness] = null;
      }
      this.onHandRemovedObservable.notifyObservers(hand);
      hand.dispose(disposeMesh);
      delete this._attachedHands[controllerId];
    }
  }
  /**
   * Detach this feature.
   * Will usually be called by the features manager.
   *
   * @returns true if successful.
   */
  detach() {
    if (!super.detach()) {
      return false;
    }
    const keys = Object.keys(this._attachedHands);
    for (const uniqueId of keys) {
      this._detachHandById(uniqueId, this.options.handMeshes?.disposeOnSessionEnd);
    }
    if (this.options.handMeshes?.disposeOnSessionEnd) {
      if (this._handResources.jointMeshes) {
        for (const trackedMesh of this._handResources.jointMeshes.left) {
          trackedMesh.dispose();
        }
        for (const trackedMesh of this._handResources.jointMeshes.right) {
          trackedMesh.dispose();
        }
        this._handResources.jointMeshes = null;
      }
      if (this._handResources.handMeshes) {
        this._handResources.handMeshes.left.dispose();
        this._handResources.handMeshes.right.dispose();
        this._handResources.handMeshes = null;
      }
      if (_WebXRHandTracking._RightHandGLB) {
        for (const mesh of _WebXRHandTracking._RightHandGLB.meshes) {
          mesh.dispose();
        }
      }
      if (_WebXRHandTracking._LeftHandGLB) {
        for (const mesh of _WebXRHandTracking._LeftHandGLB.meshes) {
          mesh.dispose();
        }
      }
      _WebXRHandTracking._RightHandGLB = null;
      _WebXRHandTracking._LeftHandGLB = null;
      this._originalMesh?.dispose();
      this._originalMesh = void 0;
    }
    if (this._worldScaleObserver) {
      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);
    }
    return true;
  }
  /**
   * Dispose this feature and all of the resources attached.
   */
  dispose() {
    super.dispose();
    this.onHandAddedObservable.clear();
    this.onHandRemovedObservable.clear();
    if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {
      this._handResources.handMeshes.left.dispose();
      this._handResources.handMeshes.right.dispose();
      if (_WebXRHandTracking._RightHandGLB) {
        for (const mesh of _WebXRHandTracking._RightHandGLB.meshes) {
          mesh.dispose();
        }
      }
      if (_WebXRHandTracking._LeftHandGLB) {
        for (const mesh of _WebXRHandTracking._LeftHandGLB.meshes) {
          mesh.dispose();
        }
      }
      _WebXRHandTracking._RightHandGLB = null;
      _WebXRHandTracking._LeftHandGLB = null;
    }
    if (this._handResources.jointMeshes) {
      for (const trackedMesh of this._handResources.jointMeshes.left) {
        trackedMesh.dispose();
      }
      for (const trackedMesh of this._handResources.jointMeshes.right) {
        trackedMesh.dispose();
      }
    }
  }
};
WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;
WebXRHandTracking.Version = 1;
WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = "https://assets.babylonjs.com/core/HandMeshes/";
WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = "r_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = "l_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = "https://assets.babylonjs.com/core/HandMeshes/handsShader.json";
WebXRHandTracking._ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };
WebXRHandTracking._RightHandGLB = null;
WebXRHandTracking._LeftHandGLB = null;
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {
  return () => new WebXRHandTracking(xrSessionManager, options);
}, WebXRHandTracking.Version, false);

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
  const texture = new InternalTexture(
    this,
    4
    /* InternalTextureSource.Dynamic */
  );
  texture.baseWidth = width;
  texture.baseHeight = height;
  if (generateMipMaps) {
    width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
    height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
  }
  texture.width = width;
  texture.height = height;
  texture.isReady = false;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  this.updateTextureSamplingMode(samplingMode, texture);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
  if (!texture) {
    return;
  }
  const gl = this._gl;
  const target = gl.TEXTURE_2D;
  const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
  this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
  }
  const textureType = this._getWebGLTextureType(texture.type);
  const glformat = this._getInternalFormat(format ? format : texture.format);
  const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
  gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
  if (texture.generateMipMaps) {
    gl.generateMipmap(target);
  }
  if (!wasPreviouslyBound) {
    this._bindTextureDirectly(target, null);
  }
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
  }
  if (format) {
    texture.format = format;
  }
  texture._dynamicTextureSource = source;
  texture._premulAlpha = premulAlpha;
  texture.invertY = invertY || false;
  texture.isReady = true;
};

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture = class _DynamicTexture extends Texture {
  /** @internal */
  constructor(name, canvasOrSize, sceneOrOptions, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
    const isScene = !sceneOrOptions || sceneOrOptions._isScene;
    const scene = isScene ? sceneOrOptions : sceneOrOptions?.scene;
    const noMipmap = isScene ? !generateMipMaps : sceneOrOptions;
    super(null, scene, noMipmap, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
    this.name = name;
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._generateMipMaps = generateMipMaps;
    const engine = this._getEngine();
    if (!engine) {
      return;
    }
    if (canvasOrSize.getContext) {
      this._canvas = canvasOrSize;
      this._ownCanvas = false;
      this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);
    } else {
      this._canvas = engine.createCanvas(1, 1);
      this._ownCanvas = true;
      const optionsAsSize = canvasOrSize;
      if (optionsAsSize.width || optionsAsSize.width === 0) {
        this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);
      } else {
        this._texture = engine.createDynamicTexture(canvasOrSize, canvasOrSize, generateMipMaps, samplingMode);
      }
    }
    const textureSize = this.getSize();
    if (this._canvas.width !== textureSize.width) {
      this._canvas.width = textureSize.width;
    }
    if (this._canvas.height !== textureSize.height) {
      this._canvas.height = textureSize.height;
    }
    this._context = this._canvas.getContext("2d");
  }
  /**
   * Get the current class name of the texture useful for serialization or dynamic coding.
   * @returns "DynamicTexture"
   */
  getClassName() {
    return "DynamicTexture";
  }
  /**
   * Gets the current state of canRescale
   */
  get canRescale() {
    return true;
  }
  _recreate(textureSize) {
    this._canvas.width = textureSize.width;
    this._canvas.height = textureSize.height;
    this.releaseInternalTexture();
    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
  }
  /**
   * Scales the texture
   * @param ratio the scale factor to apply to both width and height
   */
  scale(ratio) {
    const textureSize = this.getSize();
    textureSize.width *= ratio;
    textureSize.height *= ratio;
    this._recreate(textureSize);
  }
  /**
   * Resizes the texture
   * @param width the new width
   * @param height the new height
   */
  scaleTo(width, height) {
    const textureSize = this.getSize();
    textureSize.width = width;
    textureSize.height = height;
    this._recreate(textureSize);
  }
  /**
   * Gets the context of the canvas used by the texture
   * @returns the canvas context of the dynamic texture
   */
  getContext() {
    return this._context;
  }
  /**
   * Clears the texture
   * @param clearColor Defines the clear color to use
   */
  clear(clearColor) {
    const size = this.getSize();
    if (clearColor) {
      this._context.fillStyle = clearColor;
    }
    this._context.clearRect(0, 0, size.width, size.height);
  }
  /**
   * Updates the texture
   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
   * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
   */
  update(invertY, premulAlpha = false, allowGPUOptimization = false) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
  }
  /**
   * Draws text onto the texture
   * @param text defines the text to be drawn
   * @param x defines the placement of the text from the left
   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
   * @param font defines the font to be used with font-style, font-size, font-name
   * @param color defines the color used for the text
   * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)
   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
   * @param update defines whether texture is immediately update (default is true)
   */
  drawText(text, x, y, font, color, fillColor, invertY, update = true) {
    const size = this.getSize();
    if (fillColor) {
      this._context.fillStyle = fillColor;
      this._context.fillRect(0, 0, size.width, size.height);
    }
    this._context.font = font;
    if (x === null || x === void 0) {
      const textSize = this._context.measureText(text);
      x = (size.width - textSize.width) / 2;
    }
    if (y === null || y === void 0) {
      const fontSize = parseInt(font.replace(/\D/g, ""));
      y = size.height / 2 + fontSize / 3.65;
    }
    this._context.fillStyle = color || "";
    this._context.fillText(text, x, y);
    if (update) {
      this.update(invertY);
    }
  }
  /**
   * Disposes the dynamic texture.
   */
  dispose() {
    super.dispose();
    if (this._ownCanvas) {
      this._canvas?.remove?.();
    }
    this._canvas = null;
    this._context = null;
  }
  /**
   * Clones the texture
   * @returns the clone of the texture.
   */
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const textureSize = this.getSize();
    const newTexture = new _DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    return newTexture;
  }
  /**
   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
   * @returns a serialized dynamic texture object
   */
  serialize() {
    const scene = this.getScene();
    if (scene && !scene.isReady()) {
      Logger.Warn("The scene must be ready before serializing the dynamic texture");
    }
    const serializationObject = super.serialize();
    if (_DynamicTexture._IsCanvasElement(this._canvas)) {
      serializationObject.base64String = this._canvas.toDataURL();
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    return serializationObject;
  }
  static _IsCanvasElement(canvas) {
    return canvas.toDataURL !== void 0;
  }
  /** @internal */
  _rebuild() {
    this.update();
  }
};

// node_modules/@babylonjs/core/Meshes/groundMesh.js
Mesh._GroundMeshParser = (parsedMesh, scene) => {
  return GroundMesh.Parse(parsedMesh, scene);
};
var GroundMesh = class _GroundMesh extends Mesh {
  constructor(name, scene) {
    super(name, scene);
    this.generateOctree = false;
  }
  /**
   * "GroundMesh"
   * @returns "GroundMesh"
   */
  getClassName() {
    return "GroundMesh";
  }
  /**
   * The minimum of x and y subdivisions
   */
  get subdivisions() {
    return Math.min(this._subdivisionsX, this._subdivisionsY);
  }
  /**
   * X subdivisions
   */
  get subdivisionsX() {
    return this._subdivisionsX;
  }
  /**
   * Y subdivisions
   */
  get subdivisionsY() {
    return this._subdivisionsY;
  }
  /**
   * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes
   * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes
   * to get performance improvements when using an octree.
   * @param chunksCount the number of submeshes the mesh will be divided into
   * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)
   */
  optimize(chunksCount, octreeBlocksSize = 32) {
    this._subdivisionsX = chunksCount;
    this._subdivisionsY = chunksCount;
    this.subdivide(chunksCount);
    const thisAsAny = this;
    if (thisAsAny.createOrUpdateSubmeshesOctree) {
      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
    }
  }
  /**
   * Returns a height (y) value in the World system :
   * the ground altitude at the coordinates (x, z) expressed in the World system.
   * @param x x coordinate
   * @param z z coordinate
   * @returns the ground y position if (x, z) are outside the ground surface.
   */
  getHeightAtCoordinates(x, z) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
      return this.position.y;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
    Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
    return tmpVect.y;
  }
  /**
   * Returns a normalized vector (Vector3) orthogonal to the ground
   * at the ground coordinates (x, z) expressed in the World system.
   * @param x x coordinate
   * @param z z coordinate
   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
   */
  getNormalAtCoordinates(x, z) {
    const normal = new Vector3(0, 1, 0);
    this.getNormalAtCoordinatesToRef(x, z, normal);
    return normal;
  }
  /**
   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
   * at the ground coordinates (x, z) expressed in the World system.
   * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.
   * @param x x coordinate
   * @param z z coordinate
   * @param ref vector to store the result
   * @returns the GroundMesh.
   */
  getNormalAtCoordinatesToRef(x, z, ref) {
    const world = this.getWorldMatrix();
    const tmpMat = TmpVectors.Matrix[5];
    world.invertToRef(tmpMat);
    const tmpVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
    x = tmpVect.x;
    z = tmpVect.z;
    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
      return this;
    }
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
      this._computeHeightQuads();
    }
    const facet = this._getFacetAt(x, z);
    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
    return this;
  }
  /**
   * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
   * if the ground has been updated.
   * This can be used in the render loop.
   * @returns the GroundMesh.
   */
  updateCoordinateHeights() {
    if (!this._heightQuads || this._heightQuads.length == 0) {
      this._initHeightQuads();
    }
    this._computeHeightQuads();
    return this;
  }
  // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
  _getFacetAt(x, z) {
    const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
    const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
    const quad = this._heightQuads[row * this._subdivisionsX + col];
    let facet;
    if (z < quad.slope.x * x + quad.slope.y) {
      facet = quad.facet1;
    } else {
      facet = quad.facet2;
    }
    return facet;
  }
  //  Creates and populates the heightMap array with "facet" elements :
  // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
  // Returns the GroundMesh.
  _initHeightQuads() {
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    this._heightQuads = [];
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        const quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
        this._heightQuads[row * subdivisionsX + col] = quad;
      }
    }
    return this;
  }
  // Compute each quad element values and update the heightMap array :
  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
  // Returns the GroundMesh.
  _computeHeightQuads() {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    const v1 = TmpVectors.Vector3[3];
    const v2 = TmpVectors.Vector3[2];
    const v3 = TmpVectors.Vector3[1];
    const v4 = TmpVectors.Vector3[0];
    const v1v2 = TmpVectors.Vector3[4];
    const v1v3 = TmpVectors.Vector3[5];
    const v1v4 = TmpVectors.Vector3[6];
    const norm1 = TmpVectors.Vector3[7];
    const norm2 = TmpVectors.Vector3[8];
    let i = 0;
    let j = 0;
    let k = 0;
    let cd = 0;
    let h = 0;
    let d1 = 0;
    let d2 = 0;
    const subdivisionsX = this._subdivisionsX;
    const subdivisionsY = this._subdivisionsY;
    for (let row = 0; row < subdivisionsY; row++) {
      for (let col = 0; col < subdivisionsX; col++) {
        i = col * 3;
        j = row * (subdivisionsX + 1) * 3;
        k = (row + 1) * (subdivisionsX + 1) * 3;
        v1.x = positions[j + i];
        v1.y = positions[j + i + 1];
        v1.z = positions[j + i + 2];
        v2.x = positions[j + i + 3];
        v2.y = positions[j + i + 4];
        v2.z = positions[j + i + 5];
        v3.x = positions[k + i];
        v3.y = positions[k + i + 1];
        v3.z = positions[k + i + 2];
        v4.x = positions[k + i + 3];
        v4.y = positions[k + i + 4];
        v4.z = positions[k + i + 5];
        cd = (v4.z - v1.z) / (v4.x - v1.x);
        h = v1.z - cd * v1.x;
        v2.subtractToRef(v1, v1v2);
        v3.subtractToRef(v1, v1v3);
        v4.subtractToRef(v1, v1v4);
        Vector3.CrossToRef(v1v4, v1v3, norm1);
        Vector3.CrossToRef(v1v2, v1v4, norm2);
        norm1.normalize();
        norm2.normalize();
        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
        const quad = this._heightQuads[row * subdivisionsX + col];
        quad.slope.copyFromFloats(cd, h);
        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
      }
    }
    return this;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.subdivisionsX = this._subdivisionsX;
    serializationObject.subdivisionsY = this._subdivisionsY;
    serializationObject.minX = this._minX;
    serializationObject.maxX = this._maxX;
    serializationObject.minZ = this._minZ;
    serializationObject.maxZ = this._maxZ;
    serializationObject.width = this._width;
    serializationObject.height = this._height;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _GroundMesh(parsedMesh.name, scene);
    result._subdivisionsX = parsedMesh.subdivisionsX || 1;
    result._subdivisionsY = parsedMesh.subdivisionsY || 1;
    result._minX = parsedMesh.minX;
    result._maxX = parsedMesh.maxX;
    result._minZ = parsedMesh.minZ;
    result._maxZ = parsedMesh.maxZ;
    result._width = parsedMesh.width;
    result._height = parsedMesh.height;
    return result;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
function CreateGroundVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const subdivisionsX = (options.subdivisionsX || options.subdivisions || 1) | 0;
  const subdivisionsY = (options.subdivisionsY || options.subdivisions || 1) | 0;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      const position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      const normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTiledGroundVertexData(options) {
  const xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  const zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  const xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  const zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  const subdivisions = options.subdivisions || { w: 1, h: 1 };
  const precision = options.precision || { w: 1, h: 1 };
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  const tileSize = {
    w: (xmax - xmin) / subdivisions.w,
    h: (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    const base = positions.length / 3;
    const rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    const position = Vector3.Zero();
    const normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGroundFromHeightMapVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  let invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    const temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      const heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      let r = options.buffer[pos] / 255;
      let g = options.buffer[pos + 1] / 255;
      let b = options.buffer[pos + 2] / 255;
      const a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      const gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      if (options.heightBuffer) {
        options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      const idx2 = col + 1 + row * (options.subdivisions + 1);
      const idx3 = col + row * (options.subdivisions + 1);
      const idx4 = col + (row + 1) * (options.subdivisions + 1);
      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGround(name, options = {}, scene) {
  const ground = new GroundMesh(name, scene);
  ground._setReady(false);
  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  ground._width = options.width || 1;
  ground._height = options.height || 1;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  const vertexData = CreateGroundVertexData(options);
  vertexData.applyToMesh(ground, options.updatable);
  ground._setReady(true);
  return ground;
}
function CreateTiledGround(name, options, scene = null) {
  const tiledGround = new Mesh(name, scene);
  const vertexData = CreateTiledGroundVertexData(options);
  vertexData.applyToMesh(tiledGround, options.updatable);
  return tiledGround;
}
function CreateGroundFromHeightMap(name, url, options = {}, scene = null) {
  const width = options.width || 10;
  const height = options.height || 10;
  const subdivisions = options.subdivisions || 1 | 0;
  const minHeight = options.minHeight || 0;
  const maxHeight = options.maxHeight || 1;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  const updatable = options.updatable;
  const onReady = options.onReady;
  scene = scene || EngineStore.LastCreatedScene;
  const ground = new GroundMesh(name, scene);
  ground._subdivisionsX = subdivisions;
  ground._subdivisionsY = subdivisions;
  ground._width = width;
  ground._height = height;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  ground._setReady(false);
  let heightBuffer;
  if (options.passHeightBufferInCallback) {
    heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));
  }
  const onBufferLoaded = (buffer, bufferWidth, bufferHeight) => {
    const vertexData = CreateGroundFromHeightMapVertexData({
      width,
      height,
      subdivisions,
      minHeight,
      maxHeight,
      colorFilter: filter,
      buffer,
      bufferWidth,
      bufferHeight,
      alphaFilter,
      heightBuffer
    });
    vertexData.applyToMesh(ground, updatable);
    if (onReady) {
      onReady(ground, heightBuffer);
    }
    ground._setReady(true);
  };
  if (typeof url === "string") {
    const onload = (img) => {
      const bufferWidth = img.width;
      const bufferHeight = img.height;
      if (scene.isDisposed) {
        return;
      }
      const buffer = scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);
      onBufferLoaded(buffer, bufferWidth, bufferHeight);
    };
    Tools.LoadImage(url, onload, options.onError ? options.onError : () => {
    }, scene.offlineProvider);
  } else {
    onBufferLoaded(url.data, url.width, url.height);
  }
  return ground;
}
VertexData.CreateGround = CreateGroundVertexData;
VertexData.CreateTiledGround = CreateTiledGroundVertexData;
VertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;
Mesh.CreateGround = (name, width, height, subdivisions, scene, updatable) => {
  const options = {
    width,
    height,
    subdivisions,
    updatable
  };
  return CreateGround(name, options, scene);
};
Mesh.CreateTiledGround = (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {
  const options = {
    xmin,
    zmin,
    xmax,
    zmax,
    subdivisions,
    precision,
    updatable
  };
  return CreateTiledGround(name, options, scene);
};
Mesh.CreateGroundFromHeightMap = (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {
  const options = {
    width,
    height,
    subdivisions,
    minHeight,
    maxHeight,
    updatable,
    onReady,
    alphaFilter
  };
  return CreateGroundFromHeightMap(name, url, options, scene);
};

// node_modules/@babylonjs/core/Meshes/linesMesh.js
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  return LinesMesh.Parse(parsedMesh, scene);
};
var LinesMesh = class _LinesMesh extends Mesh {
  _isShaderMaterial(shader) {
    if (!shader) {
      return false;
    }
    return shader.getClassName() === "ShaderMaterial";
  }
  /**
   * Creates a new LinesMesh
   * @param name defines the name
   * @param scene defines the hosting scene
   * @param parent defines the parent mesh if any
   * @param source defines the optional source LinesMesh used to clone data from
   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
   * When false, achieved by calling a clone(), also passing False.
   * This will make creation of children, recursive.
   * @param useVertexColor defines if this LinesMesh supports vertex color
   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
   * @param material material to use to draw the line. If not provided, will create a new one
   */
  constructor(name, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
    super(name, scene, parent, source, doNotCloneChildren);
    this.useVertexColor = useVertexColor;
    this.useVertexAlpha = useVertexAlpha;
    this.color = new Color3(1, 1, 1);
    this.alpha = 1;
    this._shaderLanguage = 0;
    if (source) {
      this.color = source.color.clone();
      this.alpha = source.alpha;
      this.useVertexColor = source.useVertexColor;
      this.useVertexAlpha = source.useVertexAlpha;
    }
    this.intersectionThreshold = 0.1;
    const defines = [];
    const options = {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection"],
      needAlphaBlending: true,
      defines,
      useClipPlane: null,
      shaderLanguage: 0
    };
    if (!this.useVertexAlpha) {
      options.needAlphaBlending = false;
    } else {
      options.defines.push("#define VERTEXALPHA");
    }
    if (!this.useVertexColor) {
      options.uniforms.push("color");
      this._color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    if (material) {
      this.material = material;
    } else {
      const engine = this.getScene().getEngine();
      if (engine.isWebGPU && !_LinesMesh.ForceGLSL) {
        this._shaderLanguage = 1;
      }
      options.shaderLanguage = this._shaderLanguage;
      options.extraInitializationsAsync = async () => {
        if (this._shaderLanguage === 1) {
          await Promise.all([import("./color.vertex-5RAMHJC2.js"), import("./color.fragment-DNDYWFR4.js")]);
        } else {
          await Promise.all([import("./color.vertex-2YLQQVBO.js"), import("./color.fragment-5QSMY6A2.js")]);
        }
      };
      this.material = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
      this.material.doNotSerialize = true;
    }
  }
  /**
   * @returns the string "LineMesh"
   */
  getClassName() {
    return "LinesMesh";
  }
  /**
   * @internal
   */
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  /**
   * @internal
   */
  set material(value) {
    this._setMaterial(value);
    if (this.material) {
      this.material.fillMode = Material.LineListDrawMode;
    }
  }
  /**
   * @internal
   */
  get checkCollisions() {
    return false;
  }
  set checkCollisions(value) {
  }
  /**
   * @internal
   */
  _bind(_subMesh, colorEffect) {
    if (!this._geometry) {
      return this;
    }
    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(colorEffect, indexToBind);
    } else {
      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    if (!this.useVertexColor && this._isShaderMaterial(this.material)) {
      const { r, g, b } = this.color;
      this._color4.set(r, g, b, this.alpha);
      this.material.setColor4("color", this._color4);
    }
    return this;
  }
  /**
   * @internal
   */
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  }
  /**
   * Disposes of the line mesh
   * @param doNotRecurse If children should be disposed
   * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class
   * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
    if (!doNotDisposeMaterial) {
      this.material?.dispose(false, false, true);
    }
    super.dispose(doNotRecurse);
  }
  /**
   * Returns a new LineMesh object cloned from the current one.
   * @param name defines the cloned mesh name
   * @param newParent defines the new mesh parent
   * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)
   * @returns the new mesh
   */
  clone(name, newParent = null, doNotCloneChildren) {
    if (newParent && newParent._addToSceneRootNodes === void 0) {
      const createOptions = newParent;
      createOptions.source = this;
      return new _LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source, createOptions.doNotCloneChildren);
    }
    return new _LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);
  }
  /**
   * Creates a new InstancedLinesMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedLinesMesh
   */
  createInstance(name) {
    const instance = new InstancedLinesMesh(name, this);
    if (this.instancedBuffers) {
      instance.instancedBuffers = {};
      for (const key in this.instancedBuffers) {
        instance.instancedBuffers[key] = this.instancedBuffers[key];
      }
    }
    return instance;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.color = this.color.asArray();
    serializationObject.alpha = this.alpha;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _LinesMesh(parsedMesh.name, scene);
    result.color = Color3.FromArray(parsedMesh.color);
    result.alpha = parsedMesh.alpha;
    return result;
  }
};
LinesMesh.ForceGLSL = false;
var InstancedLinesMesh = class extends InstancedMesh {
  constructor(name, source) {
    super(name, source);
    this.intersectionThreshold = source.intersectionThreshold;
  }
  /**
   * @returns the string "InstancedLinesMesh".
   */
  getClassName() {
    return "InstancedLinesMesh";
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
function CreateLineSystemVertexData(options) {
  const indices = [];
  const positions = [];
  const lines = options.lines;
  const colors = options.colors;
  const vertexColors = [];
  let idx = 0;
  for (let l = 0; l < lines.length; l++) {
    const points = lines[l];
    for (let index = 0; index < points.length; index++) {
      const { x, y, z } = points[index];
      positions.push(x, y, z);
      if (colors) {
        const color = colors[l];
        const { r, g, b, a } = color[index];
        vertexColors.push(r, g, b, a);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
}
function CreateDashedLinesVertexData(options) {
  const dashSize = options.dashSize || 3;
  const gapSize = options.gapSize || 1;
  const dashNb = options.dashNb || 200;
  const points = options.points;
  const positions = [];
  const indices = [];
  const curvect = Vector3.Zero();
  let lg = 0;
  let nb = 0;
  let shft = 0;
  let dashshft = 0;
  let curshft = 0;
  let idx = 0;
  let i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (let j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
}
function CreateLineSystem(name, options, scene = null) {
  const instance = options.instance;
  const lines = options.lines;
  const colors = options.colors;
  if (instance) {
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    let vertexColor;
    let lineColors;
    if (colors) {
      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
    }
    let i = 0;
    let c = 0;
    for (let l = 0; l < lines.length; l++) {
      const points = lines[l];
      for (let p = 0; p < points.length; p++) {
        positions[i] = points[p].x;
        positions[i + 1] = points[p].y;
        positions[i + 2] = points[p].z;
        if (colors && vertexColor) {
          lineColors = colors[l];
          vertexColor[c] = lineColors[p].r;
          vertexColor[c + 1] = lineColors[p].g;
          vertexColor[c + 2] = lineColors[p].b;
          vertexColor[c + 3] = lineColors[p].a;
          c += 4;
        }
        i += 3;
      }
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (colors && vertexColor) {
      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
    }
    instance.refreshBoundingInfo();
    return instance;
  }
  const useVertexColor = colors ? true : false;
  const lineSystem = new LinesMesh(name, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha, options.material);
  const vertexData = CreateLineSystemVertexData(options);
  vertexData.applyToMesh(lineSystem, options.updatable);
  return lineSystem;
}
function CreateLines(name, options, scene = null) {
  const colors = options.colors ? [options.colors] : null;
  const lines = CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);
  return lines;
}
function CreateDashedLines(name, options, scene = null) {
  const points = options.points;
  const instance = options.instance;
  const gapSize = options.gapSize || 1;
  const dashSize = options.dashSize || 3;
  if (instance) {
    const positionFunction = (positions) => {
      const curvect = Vector3.Zero();
      const nbSeg = positions.length / 6;
      let lg = 0;
      let nb = 0;
      let shft = 0;
      let dashshft = 0;
      let curshft = 0;
      let p = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
      }
      shft = lg / nbSeg;
      const dashSize2 = instance._creationDataStorage.dashSize;
      const gapSize2 = instance._creationDataStorage.gapSize;
      dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        j = 0;
        while (j < nb && p < positions.length) {
          curshft = shft * j;
          positions[p] = points[i].x + curshft * curvect.x;
          positions[p + 1] = points[i].y + curshft * curvect.y;
          positions[p + 2] = points[i].z + curshft * curvect.z;
          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
          p += 6;
          j++;
        }
      }
      while (p < positions.length) {
        positions[p] = points[i].x;
        positions[p + 1] = points[i].y;
        positions[p + 2] = points[i].z;
        p += 3;
      }
    };
    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {
      Logger.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored.");
    }
    instance.updateMeshPositions(positionFunction, false);
    return instance;
  }
  const dashedLines = new LinesMesh(name, scene, null, void 0, void 0, void 0, options.useVertexAlpha, options.material);
  const vertexData = CreateDashedLinesVertexData(options);
  vertexData.applyToMesh(dashedLines, options.updatable);
  dashedLines._creationDataStorage = new _CreationDataStorage();
  dashedLines._creationDataStorage.dashSize = dashSize;
  dashedLines._creationDataStorage.gapSize = gapSize;
  return dashedLines;
}
VertexData.CreateLineSystem = CreateLineSystemVertexData;
VertexData.CreateDashedLines = CreateDashedLinesVertexData;
Mesh.CreateLines = (name, points, scene = null, updatable = false, instance = null) => {
  const options = {
    points,
    updatable,
    instance
  };
  return CreateLines(name, options, scene);
};
Mesh.CreateDashedLines = (name, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {
  const options = {
    points,
    dashSize,
    gapSize,
    dashNb,
    updatable,
    instance
  };
  return CreateDashedLines(name, options, scene);
};

// node_modules/@babylonjs/core/XR/features/WebXRControllerTeleportation.js
var WebXRMotionControllerTeleportation = class extends WebXRAbstractFeature {
  /**
   * Is rotation enabled when moving forward?
   * Disabling this feature will prevent the user from deciding the direction when teleporting
   */
  get rotationEnabled() {
    return this._rotationEnabled;
  }
  /**
   * Sets whether rotation is enabled or not
   * @param enabled is rotation enabled when teleportation is shown
   */
  set rotationEnabled(enabled) {
    this._rotationEnabled = enabled;
    if (this._options.teleportationTargetMesh) {
      const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === "rotationCone");
      if (children[0]) {
        children[0].setEnabled(enabled);
      }
    }
  }
  /**
   * Exposes the currently set teleportation target mesh.
   */
  get teleportationTargetMesh() {
    return this._options.teleportationTargetMesh || null;
  }
  /**
   * constructs a new teleportation system
   * @param _xrSessionManager an instance of WebXRSessionManager
   * @param _options configuration object for this feature
   */
  constructor(_xrSessionManager, _options) {
    super(_xrSessionManager);
    this._options = _options;
    this._controllers = {};
    this._snappedToPoint = false;
    this._cachedColor4White = new Color4(1, 1, 1, 1);
    this._tmpRay = new Ray(new Vector3(), new Vector3());
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this._worldScaleObserver = null;
    this.skipNextTeleportation = false;
    this.backwardsMovementEnabled = true;
    this.backwardsTeleportationDistance = 0.7;
    this.parabolicCheckRadius = 5;
    this.parabolicRayEnabled = true;
    this.straightRayEnabled = true;
    this.rotationAngle = Math.PI / 8;
    this.onTargetMeshPositionUpdatedObservable = new Observable();
    this.teleportationEnabled = true;
    this._rotationEnabled = true;
    this.onBeforeCameraTeleportRotation = new Observable();
    this.onAfterCameraTeleportRotation = new Observable();
    this._attachController = (xrController) => {
      if (this._controllers[xrController.uniqueId] || this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness) {
        return;
      }
      this._controllers[xrController.uniqueId] = {
        xrController,
        teleportationState: {
          forward: false,
          backwards: false,
          rotating: false,
          currentRotation: 0,
          baseRotation: 0,
          blocked: false,
          initialHit: false,
          mainComponentUsed: false
        }
      };
      const controllerData = this._controllers[xrController.uniqueId];
      if (controllerData.xrController.inputSource.targetRayMode === "tracked-pointer" && controllerData.xrController.inputSource.gamepad) {
        const initMotionController = () => {
          if (xrController.motionController) {
            const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);
            if (!movementController || this._options.useMainComponentOnly) {
              const mainComponent = xrController.motionController.getMainComponent();
              if (!mainComponent) {
                return;
              }
              controllerData.teleportationState.mainComponentUsed = true;
              controllerData.teleportationComponent = mainComponent;
              controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {
                if (!this.teleportationEnabled) {
                  return;
                }
                const teleportLocal = () => {
                  controllerData.teleportationState.forward = true;
                  controllerData.teleportationState.initialHit = false;
                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                  controllerData.teleportationState.currentRotation = 0;
                  const timeToSelect = this._options.timeToTeleport || 3e3;
                  setAndStartTimer({
                    timeout: timeToSelect,
                    contextObservable: this._xrSessionManager.onXRFrameObservable,
                    breakCondition: () => !mainComponent.pressed,
                    onEnded: () => {
                      if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                        this._teleportForward(xrController.uniqueId);
                      }
                    }
                  });
                };
                if (mainComponent.changes.pressed) {
                  if (mainComponent.changes.pressed.current) {
                    if (this._options.timeToTeleportStart) {
                      setAndStartTimer({
                        timeout: this._options.timeToTeleportStart,
                        contextObservable: this._xrSessionManager.onXRFrameObservable,
                        onEnded: () => {
                          if (mainComponent.pressed) {
                            teleportLocal();
                          }
                        }
                      });
                    } else {
                      teleportLocal();
                    }
                  } else {
                    controllerData.teleportationState.forward = false;
                    this._currentTeleportationControllerId = "";
                  }
                }
              });
            } else {
              controllerData.teleportationComponent = movementController;
              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {
                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {
                  controllerData.teleportationState.backwards = false;
                }
                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {
                  if (!controllerData.teleportationState.backwards) {
                    controllerData.teleportationState.backwards = true;
                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);
                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);
                    this._tmpVector.x = 0;
                    this._tmpVector.z = 0;
                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);
                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);
                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);
                    this._tmpRay.origin.copyFrom(this._tmpVector);
                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;
                    this._tmpRay.direction.set(0, -1, 0);
                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {
                      return this._floorMeshes.indexOf(o) !== -1;
                    });
                    if (pick && pick.pickedPoint) {
                      this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;
                      this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;
                    }
                  }
                }
                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {
                  controllerData.teleportationState.forward = true;
                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
                }
                if (axesData.x) {
                  if (!controllerData.teleportationState.forward) {
                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {
                      controllerData.teleportationState.rotating = true;
                      const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);
                      this.onBeforeCameraTeleportRotation.notifyObservers(rotation);
                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);
                      this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion);
                    }
                  } else {
                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {
                      if (this.rotationEnabled) {
                        setTimeout(() => {
                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));
                        });
                      } else {
                        controllerData.teleportationState.currentRotation = 0;
                      }
                    }
                  }
                } else {
                  controllerData.teleportationState.rotating = false;
                }
                if (axesData.x === 0 && axesData.y === 0) {
                  if (controllerData.teleportationState.blocked) {
                    controllerData.teleportationState.blocked = false;
                    this._setTargetMeshVisibility(false);
                  }
                  if (controllerData.teleportationState.forward) {
                    this._teleportForward(xrController.uniqueId);
                  }
                }
              });
            }
          }
        };
        if (xrController.motionController) {
          initMotionController();
        } else {
          xrController.onMotionControllerInitObservable.addOnce(() => {
            initMotionController();
          });
        }
      } else {
        controllerData.teleportationState.mainComponentUsed = true;
        let breakObserver = false;
        const teleportLocal = () => {
          this._currentTeleportationControllerId = controllerData.xrController.uniqueId;
          controllerData.teleportationState.forward = true;
          controllerData.teleportationState.initialHit = false;
          controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;
          controllerData.teleportationState.currentRotation = 0;
          const timeToSelect = this._options.timeToTeleport || 3e3;
          setAndStartTimer({
            timeout: timeToSelect,
            contextObservable: this._xrSessionManager.onXRFrameObservable,
            onEnded: () => {
              if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {
                this._teleportForward(xrController.uniqueId);
              }
            }
          });
        };
        this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {
          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
            breakObserver = false;
            if (this._options.timeToTeleportStart) {
              setAndStartTimer({
                timeout: this._options.timeToTeleportStart,
                contextObservable: this._xrSessionManager.onXRFrameObservable,
                onEnded: () => {
                  if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {
                    teleportLocal();
                  }
                },
                breakCondition: () => {
                  if (breakObserver) {
                    breakObserver = false;
                    return true;
                  }
                  return false;
                }
              });
            } else {
              teleportLocal();
            }
          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {
            breakObserver = true;
            controllerData.teleportationState.forward = false;
            this._currentTeleportationControllerId = "";
          }
        });
      }
    };
    this._colorArray = Array(24).fill(this._cachedColor4White);
    if (!this._options.teleportationTargetMesh) {
      this._createDefaultTargetMesh();
    }
    this._floorMeshes = this._options.floorMeshes || [];
    this._snapToPositions = this._options.snapPositions || [];
    this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);
    this._setTargetMeshVisibility(false);
    this.onBeforeCameraTeleport = _options.xrInput.xrCamera.onBeforeCameraTeleport;
    this.onAfterCameraTeleport = _options.xrInput.xrCamera.onAfterCameraTeleport;
    this.parabolicCheckRadius *= this._xrSessionManager.worldScalingFactor;
    this._worldScaleObserver = _xrSessionManager.onWorldScaleFactorChangedObservable.add((values) => {
      this.parabolicCheckRadius = this.parabolicCheckRadius / values.previousScaleFactor * values.newScaleFactor;
      this._options.teleportationTargetMesh?.scaling.scaleInPlace(values.newScaleFactor / values.previousScaleFactor);
    });
  }
  /**
   * Get the snapPointsOnly flag
   */
  get snapPointsOnly() {
    return !!this._options.snapPointsOnly;
  }
  /**
   * Sets the snapPointsOnly flag
   * @param snapToPoints should teleportation be exclusively to snap points
   */
  set snapPointsOnly(snapToPoints) {
    this._options.snapPointsOnly = snapToPoints;
  }
  /**
   * Add a new mesh to the floor meshes array
   * @param mesh the mesh to use as floor mesh
   */
  addFloorMesh(mesh) {
    this._floorMeshes.push(mesh);
  }
  /**
   * Add a mesh to the list of meshes blocking the teleportation ray
   * @param mesh The mesh to add to the teleportation-blocking meshes
   */
  addBlockerMesh(mesh) {
    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];
    this._options.pickBlockerMeshes.push(mesh);
  }
  /**
   * Add a new snap-to point to fix teleportation to this position
   * @param newSnapPoint The new Snap-To point
   */
  addSnapPoint(newSnapPoint) {
    this._snapToPositions.push(newSnapPoint);
  }
  attach() {
    if (!super.attach()) {
      return false;
    }
    this._currentTeleportationControllerId = "";
    for (const controller of this._options.xrInput.controllers) {
      this._attachController(controller);
    }
    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);
    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {
      this._detachController(controller.uniqueId);
    });
    return true;
  }
  detach() {
    if (!super.detach()) {
      return false;
    }
    const keys = Object.keys(this._controllers);
    for (const controllerId of keys) {
      this._detachController(controllerId);
    }
    this._setTargetMeshVisibility(false);
    this._currentTeleportationControllerId = "";
    this._controllers = {};
    return true;
  }
  dispose() {
    super.dispose();
    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);
    if (this._worldScaleObserver) {
      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);
    }
    this.onTargetMeshPositionUpdatedObservable.clear();
    this.onTargetMeshPositionUpdatedObservable.clear();
    this.onBeforeCameraTeleportRotation.clear();
    this.onAfterCameraTeleportRotation.clear();
    this.onBeforeCameraTeleport.clear();
    this.onAfterCameraTeleport.clear();
  }
  /**
   * Remove a mesh from the floor meshes array
   * @param mesh the mesh to remove
   */
  removeFloorMesh(mesh) {
    const index = this._floorMeshes.indexOf(mesh);
    if (index !== -1) {
      this._floorMeshes.splice(index, 1);
    }
  }
  /**
   * Remove a mesh from the blocker meshes array
   * @param mesh the mesh to remove
   */
  removeBlockerMesh(mesh) {
    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];
    const index = this._options.pickBlockerMeshes.indexOf(mesh);
    if (index !== -1) {
      this._options.pickBlockerMeshes.splice(index, 1);
    }
  }
  /**
   * Remove a mesh from the floor meshes array using its name
   * @param name the mesh name to remove
   */
  removeFloorMeshByName(name) {
    const mesh = this._xrSessionManager.scene.getMeshByName(name);
    if (mesh) {
      this.removeFloorMesh(mesh);
    }
  }
  /**
   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array
   * @param snapPointToRemove the point (or a clone of it) to be removed from the array
   * @returns was the point found and removed or not
   */
  removeSnapPoint(snapPointToRemove) {
    let index = this._snapToPositions.indexOf(snapPointToRemove);
    if (index === -1) {
      for (let i = 0; i < this._snapToPositions.length; ++i) {
        if (this._snapToPositions[i].equals(snapPointToRemove)) {
          index = i;
          break;
        }
      }
    }
    if (index !== -1) {
      this._snapToPositions.splice(index, 1);
      return true;
    }
    return false;
  }
  /**
   * This function sets a selection feature that will be disabled when
   * the forward ray is shown and will be reattached when hidden.
   * This is used to remove the selection rays when moving.
   * @param selectionFeature the feature to disable when forward movement is enabled
   */
  setSelectionFeature(selectionFeature) {
    this._selectionFeature = selectionFeature;
  }
  _onXRFrame(_xrFrame) {
    const frame = this._xrSessionManager.currentFrame;
    const scene = this._xrSessionManager.scene;
    if (!this.attach || !frame) {
      return;
    }
    const targetMesh = this._options.teleportationTargetMesh;
    if (this._currentTeleportationControllerId) {
      if (!targetMesh) {
        return;
      }
      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();
      const controllerData = this._controllers[this._currentTeleportationControllerId];
      if (controllerData && controllerData.teleportationState.forward) {
        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);
        let hitPossible = false;
        const controlSelectionFeature = controllerData.xrController.inputSource.targetRayMode !== "transient-pointer";
        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);
        if (this.straightRayEnabled) {
          const pick = scene.pickWithRay(this._tmpRay, (o) => {
            if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {
              return true;
            }
            if (this._options.blockAllPickableMeshes && o.isPickable) {
              return true;
            }
            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            const index = this._floorMeshes.indexOf(o);
            if (index === -1) {
              return false;
            }
            return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;
          });
          const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;
          if (pick && pick.pickedMesh && !floorMeshPicked) {
            if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {
              controllerData.teleportationState.forward = false;
              return;
            }
            controllerData.teleportationState.blocked = true;
            this._setTargetMeshVisibility(false, false, controlSelectionFeature);
            this._showParabolicPath(pick);
            return;
          } else if (pick && pick.pickedPoint) {
            controllerData.teleportationState.initialHit = true;
            controllerData.teleportationState.blocked = false;
            hitPossible = true;
            this._setTargetMeshPosition(pick);
            this._setTargetMeshVisibility(true, false, controlSelectionFeature);
            this._showParabolicPath(pick);
          }
        }
        if (this.parabolicRayEnabled && !hitPossible) {
          const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;
          const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));
          const radius = this.parabolicCheckRadius * compensation;
          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);
          this._tmpVector.y = this._tmpRay.origin.y;
          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));
          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);
          this._tmpRay.direction.normalize();
          const pick = scene.pickWithRay(this._tmpRay, (o) => {
            if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {
              return true;
            }
            if (this._options.blockAllPickableMeshes && o.isPickable) {
              return true;
            }
            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {
              return true;
            }
            return this._floorMeshes.indexOf(o) !== -1;
          });
          const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;
          if (pick && pick.pickedMesh && !floorMeshPicked) {
            if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {
              controllerData.teleportationState.forward = false;
              return;
            }
            controllerData.teleportationState.blocked = true;
            this._setTargetMeshVisibility(false, false, controlSelectionFeature);
            this._showParabolicPath(pick);
            return;
          } else if (pick && pick.pickedPoint) {
            controllerData.teleportationState.initialHit = true;
            controllerData.teleportationState.blocked = false;
            hitPossible = true;
            this._setTargetMeshPosition(pick);
            this._setTargetMeshVisibility(true, false, controlSelectionFeature);
            this._showParabolicPath(pick);
          }
        }
        this._setTargetMeshVisibility(hitPossible, false, controlSelectionFeature);
      } else {
        this._setTargetMeshVisibility(false, false, true);
      }
    } else {
      this._disposeBezierCurve();
      this._setTargetMeshVisibility(false, false, true);
    }
  }
  _createDefaultTargetMesh() {
    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;
    const teleportationTarget = CreateGround("teleportationTarget", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);
    teleportationTarget.isPickable = false;
    if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {
      teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;
    } else {
      const length = 512;
      const dynamicTexture = new DynamicTexture("teleportationPlaneDynamicTexture", length, sceneToRenderTo, true);
      dynamicTexture.hasAlpha = true;
      const context = dynamicTexture.getContext();
      const centerX = length / 2;
      const centerY = length / 2;
      const radius = 200;
      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || "#444444";
      context.fill();
      context.lineWidth = 10;
      context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || "#FFFFFF";
      context.stroke();
      context.closePath();
      dynamicTexture.update();
      const teleportationCircleMaterial = new StandardMaterial("teleportationPlaneMaterial", sceneToRenderTo);
      teleportationCircleMaterial.diffuseTexture = dynamicTexture;
      teleportationTarget.material = teleportationCircleMaterial;
    }
    const torus = CreateTorus("torusTeleportation", {
      diameter: 0.75,
      thickness: 0.1,
      tessellation: 20
    }, sceneToRenderTo);
    torus.isPickable = false;
    torus.parent = teleportationTarget;
    if (!this._options.defaultTargetMeshOptions.disableAnimation) {
      const animationInnerCircle = new Animation("animationInnerCircle", "position.y", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const keys = [];
      keys.push({
        frame: 0,
        value: 0
      });
      keys.push({
        frame: 30,
        value: 0.4
      });
      keys.push({
        frame: 60,
        value: 0
      });
      animationInnerCircle.setKeys(keys);
      const easingFunction = new SineEase();
      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);
      animationInnerCircle.setEasingFunction(easingFunction);
      torus.animations = [];
      torus.animations.push(animationInnerCircle);
      sceneToRenderTo.beginAnimation(torus, 0, 60, true);
    }
    const cone = CreateCylinder("rotationCone", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);
    cone.isPickable = false;
    cone.scaling.set(0.5, 0.12, 0.2);
    cone.rotate(Axis.X, Math.PI / 2);
    cone.position.z = 0.6;
    cone.parent = torus;
    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {
      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;
    } else {
      const torusConeMaterial = new StandardMaterial("torusConsMat", sceneToRenderTo);
      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;
      if (torusConeMaterial.disableLighting) {
        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1);
      } else {
        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1);
      }
      torusConeMaterial.alpha = 0.9;
      torus.material = torusConeMaterial;
      cone.material = torusConeMaterial;
      this._teleportationRingMaterial = torusConeMaterial;
    }
    if (this._options.renderingGroupId !== void 0) {
      teleportationTarget.renderingGroupId = this._options.renderingGroupId;
      torus.renderingGroupId = this._options.renderingGroupId;
      cone.renderingGroupId = this._options.renderingGroupId;
    }
    this._options.teleportationTargetMesh = teleportationTarget;
    this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor);
    this._setTargetMeshVisibility(false);
  }
  _detachController(xrControllerUniqueId) {
    const controllerData = this._controllers[xrControllerUniqueId];
    if (!controllerData) {
      return;
    }
    if (controllerData.teleportationComponent) {
      if (controllerData.onAxisChangedObserver) {
        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);
      }
      if (controllerData.onButtonChangedObserver) {
        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);
      }
    }
    delete this._controllers[xrControllerUniqueId];
  }
  _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {
    let closestPoint = null;
    let closestDistance = Number.MAX_VALUE;
    if (this._snapToPositions.length) {
      const radiusSquared = radius * radius;
      for (const position of this._snapToPositions) {
        const dist = Vector3.DistanceSquared(position, realPosition);
        if (dist <= radiusSquared && dist < closestDistance) {
          closestDistance = dist;
          closestPoint = position;
        }
      }
    }
    return closestPoint;
  }
  _setTargetMeshPosition(pickInfo) {
    const newPosition = pickInfo.pickedPoint;
    if (!this._options.teleportationTargetMesh || !newPosition) {
      return;
    }
    const snapPosition = this._findClosestSnapPointWithRadius(newPosition);
    this._snappedToPoint = !!snapPosition;
    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(1, 0.3, 0.3);
    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {
      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1);
    }
    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);
    this._options.teleportationTargetMesh.position.y += 0.01;
    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);
  }
  _setTargetMeshVisibility(visible, force, controlSelectionFeature) {
    if (!this._options.teleportationTargetMesh) {
      return;
    }
    if (this._options.teleportationTargetMesh.isVisible === visible && !force) {
      return;
    }
    this._options.teleportationTargetMesh.isVisible = visible;
    const children = this._options.teleportationTargetMesh.getChildren(void 0, false);
    for (const m of children) {
      m.isVisible = visible;
    }
    if (!visible) {
      if (this._quadraticBezierCurve) {
        this._quadraticBezierCurve.dispose();
        this._quadraticBezierCurve = null;
      }
      if (this._selectionFeature && controlSelectionFeature) {
        this._selectionFeature.attach();
      }
    } else {
      if (this._selectionFeature && controlSelectionFeature) {
        this._selectionFeature.detach();
      }
    }
  }
  _disposeBezierCurve() {
    if (this._quadraticBezierCurve) {
      this._quadraticBezierCurve.dispose();
      this._quadraticBezierCurve = null;
    }
  }
  _showParabolicPath(pickInfo) {
    if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {
      return;
    }
    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;
    const controllerData = this._controllers[this._currentTeleportationControllerId];
    const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);
    const color = controllerData.teleportationState.blocked ? this._blockedRayColor : void 0;
    const colorsArray = this._colorArray.fill(color || this._cachedColor4White);
    const points = quadraticBezierVectors.getPoints();
    points.shift();
    points.shift();
    if (!this._options.generateRayPathMesh) {
      this._quadraticBezierCurve = CreateLines("teleportation path line", { points, instance: this._quadraticBezierCurve, updatable: true, colors: colorsArray }, sceneToRenderTo);
    } else {
      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);
    }
    this._quadraticBezierCurve.isPickable = false;
    if (this._options.renderingGroupId !== void 0) {
      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;
    }
  }
  _teleportForward(controllerId) {
    const controllerData = this._controllers[controllerId];
    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {
      return;
    }
    controllerData.teleportationState.forward = false;
    this._currentTeleportationControllerId = "";
    if (this.snapPointsOnly && !this._snappedToPoint) {
      return;
    }
    if (this.skipNextTeleportation) {
      this.skipNextTeleportation = false;
      return;
    }
    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {
      const height = this._options.xrInput.xrCamera.realWorldHeight;
      this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);
      this._options.xrInput.xrCamera.position.y += height;
      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);
      this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);
    }
  }
};
WebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;
WebXRMotionControllerTeleportation.Version = 1;
WebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {
  return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);
}, WebXRMotionControllerTeleportation.Version, true);

// node_modules/@babylonjs/core/XR/webXRDefaultExperience.js
var WebXRDefaultExperienceOptions = class {
};
var WebXRDefaultExperience = class _WebXRDefaultExperience {
  constructor() {
  }
  /**
   * Creates the default xr experience
   * @param scene scene
   * @param options options for basic configuration
   * @returns resulting WebXRDefaultExperience
   */
  static async CreateAsync(scene, options = {}) {
    const result = new _WebXRDefaultExperience();
    scene.onDisposeObservable.addOnce(() => {
      result.dispose();
    });
    if (!options.disableDefaultUI) {
      const uiOptions = {
        renderTarget: result.renderTarget,
        ...options.uiOptions || {}
      };
      if (options.optionalFeatures) {
        if (typeof options.optionalFeatures === "boolean") {
          uiOptions.optionalFeatures = ["hit-test", "anchors", "plane-detection", "hand-tracking"];
        } else {
          uiOptions.optionalFeatures = options.optionalFeatures;
        }
      }
      result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);
    }
    try {
      const xrHelper = await WebXRExperienceHelper.CreateAsync(scene);
      result.baseExperience = xrHelper;
      if (options.ignoreNativeCameraTransformation) {
        result.baseExperience.camera.compensateOnFirstFrame = false;
      }
      result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {
        controllerOptions: {
          renderingGroupId: options.renderingGroupId
        },
        ...options.inputOptions || {}
      });
      if (!options.disablePointerSelection) {
        const pointerSelectionOptions = {
          ...options.pointerSelectionOptions,
          xrInput: result.input,
          renderingGroupId: options.renderingGroupId
        };
        result.pointerSelection = result.baseExperience.featuresManager.enableFeature(WebXRControllerPointerSelection.Name, options.useStablePlugins ? "stable" : "latest", pointerSelectionOptions);
        if (!options.disableTeleportation) {
          result.teleportation = result.baseExperience.featuresManager.enableFeature(WebXRMotionControllerTeleportation.Name, options.useStablePlugins ? "stable" : "latest", {
            floorMeshes: options.floorMeshes,
            xrInput: result.input,
            renderingGroupId: options.renderingGroupId,
            ...options.teleportationOptions
          });
          result.teleportation.setSelectionFeature(result.pointerSelection);
        }
      }
      if (!options.disableNearInteraction) {
        result.nearInteraction = result.baseExperience.featuresManager.enableFeature(WebXRNearInteraction.Name, options.useStablePlugins ? "stable" : "latest", {
          xrInput: result.input,
          farInteractionFeature: result.pointerSelection,
          renderingGroupId: options.renderingGroupId,
          useUtilityLayer: true,
          enableNearInteractionOnAllControllers: true,
          ...options.nearInteractionOptions
        });
      }
      if (!options.disableHandTracking) {
        result.baseExperience.featuresManager.enableFeature(WebXRHandTracking.Name, options.useStablePlugins ? "stable" : "latest", {
          xrInput: result.input,
          ...options.handSupportOptions
        }, void 0, false);
      }
      result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);
      if (!options.disableDefaultUI) {
        await result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);
      }
      return result;
    } catch (error) {
      Logger.Error("Error initializing XR");
      Logger.Error(error);
      return result;
    }
  }
  /**
   * Disposes of the experience helper
   */
  dispose() {
    if (this.baseExperience) {
      this.baseExperience.dispose();
    }
    if (this.input) {
      this.input.dispose();
    }
    if (this.enterExitUI) {
      this.enterExitUI.dispose();
    }
    if (this.renderTarget) {
      this.renderTarget.dispose();
    }
  }
};
export {
  WebXRDefaultExperience,
  WebXRDefaultExperienceOptions
};
//# sourceMappingURL=@babylonjs_core_XR_webXRDefaultExperience.js.map
