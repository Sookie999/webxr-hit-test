import {
  FlowGraphAsyncExecutionBlock
} from "./chunk-AD2B6VDG.js";
import "./chunk-5JDKVHAP.js";
import "./chunk-7AIW3QXJ.js";
import {
  FlowGraphInteger,
  RichTypeFlowGraphInteger,
  RichTypeNumber
} from "./chunk-4JKITRJZ.js";
import {
  AdvancedTimer
} from "./chunk-A3ATWUDS.js";
import "./chunk-TROWLGN2.js";
import "./chunk-7XY2OFQB.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import "./chunk-SAE7R3H2.js";
import {
  RegisterClass
} from "./chunk-MIVJKRRS.js";
import "./chunk-NTQN2BXV.js";
import "./chunk-DDXCXL26.js";
import "./chunk-GCT36VBF.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.js
var FlowGraphSetDelayBlock = class _FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {
  constructor(config) {
    super(config);
    this.cancel = this._registerSignalInput("cancel");
    this.duration = this.registerDataInput("duration", RichTypeNumber);
    this.lastDelayIndex = this.registerDataOutput("lastDelayIndex", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));
  }
  _preparePendingTasks(context) {
    const duration = this.duration.getValue(context);
    if (duration < 0 || isNaN(duration) || !isFinite(duration)) {
      return this._reportError(context, "Invalid duration in SetDelay block");
    }
    const activeDelays = context._getGlobalContextVariable("activeDelays", 0);
    if (activeDelays >= _FlowGraphSetDelayBlock.MaxParallelDelayCount) {
      return this._reportError(context, "Max parallel delays reached");
    }
    const lastDelayIndex = context._getGlobalContextVariable("lastDelayIndex", -1);
    const timers = context._getExecutionVariable(this, "pendingDelays", []);
    const scene = context.configuration.scene;
    const timer = new AdvancedTimer({
      timeout: duration * 1e3,
      // duration is in seconds
      contextObservable: scene.onBeforeRenderObservable,
      onEnded: () => this._onEnded(timer, context)
    });
    timer.start();
    const newIndex = lastDelayIndex + 1;
    this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);
    context._setGlobalContextVariable("lastDelayIndex", newIndex);
    timers[newIndex] = timer;
    context._setExecutionVariable(this, "pendingDelays", timers);
    this._updateGlobalTimers(context);
  }
  _cancelPendingTasks(context) {
    const timers = context._getExecutionVariable(this, "pendingDelays", []);
    for (const timer of timers) {
      timer?.dispose();
    }
    context._deleteExecutionVariable(this, "pendingDelays");
    this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);
    this._updateGlobalTimers(context);
  }
  _execute(context, callingSignal) {
    if (callingSignal === this.cancel) {
      this._cancelPendingTasks(context);
      return;
    } else {
      this._preparePendingTasks(context);
      this.out._activateSignal(context);
    }
  }
  getClassName() {
    return "FlowGraphSetDelayBlock";
  }
  _onEnded(timer, context) {
    const timers = context._getExecutionVariable(this, "pendingDelays", []);
    const index = timers.indexOf(timer);
    if (index !== -1) {
      timers.splice(index, 1);
    } else {
      Logger.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list");
    }
    context._removePendingBlock(this);
    this.done._activateSignal(context);
    this._updateGlobalTimers(context);
  }
  _updateGlobalTimers(context) {
    const timers = context._getExecutionVariable(this, "pendingDelays", []);
    const globalTimers = context._getGlobalContextVariable("pendingDelays", []);
    for (let i = 0; i < timers.length; i++) {
      if (!timers[i]) {
        continue;
      }
      const timer = timers[i];
      if (globalTimers[i] && globalTimers[i] !== timer) {
        Logger.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list");
      } else {
        globalTimers[i] = timer;
      }
    }
    context._setGlobalContextVariable("pendingDelays", globalTimers);
  }
};
FlowGraphSetDelayBlock.MaxParallelDelayCount = 100;
RegisterClass("FlowGraphSetDelayBlock", FlowGraphSetDelayBlock);
export {
  FlowGraphSetDelayBlock
};
//# sourceMappingURL=flowGraphSetDelayBlock-PEBEKBEH.js.map
