{
  "version": 3,
  "sources": ["../../../dev/core/src/assetContainer.ts", "../../../dev/core/src/Misc/dataReader.ts", "../../../dev/loaders/src/glTF/glTFValidation.ts", "../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts", "../../../dev/loaders/src/glTF/glTFFileLoader.ts", "../../../dev/loaders/src/glTF/1.0/index.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts", "../../../dev/core/src/Materials/Textures/rawTexture.ts", "../../../dev/core/src/Bones/skeleton.ts", "../../../dev/core/src/Lights/pointLight.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts", "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts", "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts", "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts", "../../../dev/loaders/src/glTF/2.0/index.ts", "../../../dev/core/src/Misc/deferred.ts", "../../../dev/core/src/Misc/brdfTextureTools.ts", "../../../dev/core/src/Materials/PBR/pbrBRDFConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrClearCoatConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrIridescenceConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrAnisotropicConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrSheenConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrSubSurfaceConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrBaseMaterial.ts", "../../../dev/core/src/Materials/PBR/pbrMaterial.ts", "../../../dev/core/src/Morph/morphTarget.ts", "../../../dev/core/src/Materials/Textures/rawTexture2DArray.ts", "../../../dev/core/src/Morph/morphTargetManager.ts", "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts", "../../../dev/core/src/Misc/deepMerger.ts", "../../../dev/core/src/Misc/lazy.ts", "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts", "../../../dev/core/src/Materials/Textures/cubeTexture.ts", "../../../dev/core/src/Materials/Textures/rawCubeTexture.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts", "../../../dev/core/src/Meshes/thinInstanceMesh.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts", "../../../dev/core/src/Meshes/Compression/meshoptCompression.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts", "../../../dev/core/src/Meshes/Compression/dracoCompressionWorker.ts", "../../../dev/core/src/Meshes/Compression/dracoCodec.ts", "../../../dev/core/src/Meshes/Compression/dracoDecoder.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts", "../../../dev/core/src/Animations/animationEvent.ts", "../../../dev/core/src/Audio/sound.ts", "../../../dev/core/src/Audio/weightedsound.ts", "../../../dev/core/src/Audio/soundTrack.ts", "../../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts", "../../../dev/core/src/Audio/audioSceneComponent.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts", "../../../dev/core/src/FlowGraph/Blocks/flowGraphBlockFactory.ts", "../../../dev/core/src/FlowGraph/flowGraphParser.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts"],
  "sourcesContent": ["import type { Scene } from \"./scene\";\r\nimport { Mesh } from \"./Meshes/mesh\";\r\nimport { TransformNode } from \"./Meshes/transformNode\";\r\nimport type { Skeleton } from \"./Bones/skeleton\";\r\nimport type { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport { type Animatable } from \"./Animations/animatable.core\";\r\nimport { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport type { Material } from \"./Materials/material\";\r\nimport { Logger } from \"./Misc/logger\";\r\nimport { EngineStore } from \"./Engines/engineStore\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { Node } from \"./node\";\r\nimport type { Observer } from \"./Misc/observable\";\r\nimport type { AbstractEngine } from \"./Engines/abstractEngine\";\r\nimport { InstancedMesh } from \"./Meshes/instancedMesh\";\r\nimport { Light } from \"./Lights/light\";\r\nimport { Camera } from \"./Cameras/camera\";\r\nimport { Tools } from \"./Misc/tools\";\r\nimport type { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport type { IAssetContainer } from \"./IAssetContainer\";\r\nimport type { Animation } from \"./Animations/animation\";\r\nimport type { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport type { Geometry } from \"./Meshes/geometry\";\r\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport type { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport type { PostProcess } from \"./PostProcesses/postProcess\";\r\nimport type { Sound } from \"./Audio/sound\";\r\nimport type { Layer } from \"./Layers/layer\";\r\nimport type { EffectLayer } from \"./Layers/effectLayer\";\r\nimport type { ReflectionProbe } from \"./Probes/reflectionProbe\";\r\nimport type { LensFlareSystem } from \"./LensFlares/lensFlareSystem\";\r\nimport type { ProceduralTexture } from \"./Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { Tags } from \"./Misc/tags\";\r\n\r\n/**\r\n * Root class for AssetContainer and KeepAssets\r\n */\r\nexport class AbstractAssetContainer implements IAssetContainer {\r\n    /**\r\n     * Gets the list of root nodes (ie. nodes with no parent)\r\n     */\r\n    public rootNodes: Node[] = [];\r\n\r\n    /** All of the cameras added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     */\r\n    public cameras: Camera[] = [];\r\n\r\n    /**\r\n     * All of the lights added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     */\r\n    public lights: Light[] = [];\r\n\r\n    /**\r\n     * All of the (abstract) meshes added to this scene\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * The list of skeletons added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n     */\r\n    public skeletons: Skeleton[] = [];\r\n\r\n    /**\r\n     * All of the particle systems added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n     */\r\n    public particleSystems: IParticleSystem[] = [];\r\n\r\n    /**\r\n     * Gets a list of Animations associated with the scene\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * All of the animation groups added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     */\r\n    public animationGroups: AnimationGroup[] = [];\r\n\r\n    /**\r\n     * All of the multi-materials added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     */\r\n    public multiMaterials: MultiMaterial[] = [];\r\n\r\n    /**\r\n     * All of the materials added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\r\n     * Note also that the order of the Material within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n     */\r\n    public materials: Material[] = [];\r\n\r\n    /**\r\n     * The list of morph target managers added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph\r\n     */\r\n    public morphTargetManagers: MorphTargetManager[] = [];\r\n\r\n    /**\r\n     * The list of geometries used in the scene.\r\n     */\r\n    public geometries: Geometry[] = [];\r\n\r\n    /**\r\n     * All of the transform nodes added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\r\n     * Note also that the order of the TransformNode within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\r\n     */\r\n    public transformNodes: TransformNode[] = [];\r\n\r\n    /**\r\n     * ActionManagers available on the scene.\r\n     * @deprecated\r\n     */\r\n    public actionManagers: AbstractActionManager[] = [];\r\n\r\n    /**\r\n     * Textures to keep.\r\n     */\r\n    public textures: BaseTexture[] = [];\r\n\r\n    /** @internal */\r\n    protected _environmentTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        this._environmentTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The list of postprocesses added to the scene\r\n     */\r\n    public postProcesses: PostProcess[] = [];\r\n\r\n    /**\r\n     * The list of sounds\r\n     */\r\n    public sounds: Nullable<Sound[]> = null;\r\n\r\n    /**\r\n     * The list of effect layers added to the scene\r\n     */\r\n    public effectLayers: EffectLayer[] = [];\r\n\r\n    /**\r\n     * The list of layers added to the scene\r\n     */\r\n    public layers: Layer[] = [];\r\n\r\n    /**\r\n     * The list of reflection probes added to the scene\r\n     */\r\n    public reflectionProbes: ReflectionProbe[] = [];\r\n\r\n    /**\r\n     * The list of lens flare systems added to the scene\r\n     */\r\n    public lensFlareSystems: LensFlareSystem[];\r\n\r\n    /**\r\n     * The list of procedural textures added to the scene\r\n     */\r\n    public proceduralTextures: ProceduralTexture[];\r\n\r\n    /**\r\n     * @returns all meshes, lights, cameras, transformNodes and bones\r\n     */\r\n    public getNodes(): Array<Node> {\r\n        let nodes: Node[] = [];\r\n        nodes = nodes.concat(this.meshes);\r\n        nodes = nodes.concat(this.lights);\r\n        nodes = nodes.concat(this.cameras);\r\n        nodes = nodes.concat(this.transformNodes); // dummies\r\n        for (const skeleton of this.skeletons) {\r\n            nodes = nodes.concat(skeleton.bones);\r\n        }\r\n        return nodes;\r\n    }\r\n}\r\n\r\n/**\r\n * Set of assets to keep when moving a scene into an asset container.\r\n */\r\nexport class KeepAssets extends AbstractAssetContainer {}\r\n\r\n/**\r\n * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function\r\n */\r\nexport class InstantiatedEntries {\r\n    /**\r\n     * List of new root nodes (eg. nodes with no parent)\r\n     */\r\n    public rootNodes: Node[] = [];\r\n\r\n    /**\r\n     * List of new skeletons\r\n     */\r\n    public skeletons: Skeleton[] = [];\r\n\r\n    /**\r\n     * List of new animation groups\r\n     */\r\n    public animationGroups: AnimationGroup[] = [];\r\n\r\n    /**\r\n     * Disposes the instantiated entries from the scene\r\n     */\r\n    public dispose() {\r\n        const rootNodes = this.rootNodes;\r\n        for (const rootNode of rootNodes) {\r\n            rootNode.dispose();\r\n        }\r\n        rootNodes.length = 0;\r\n\r\n        const skeletons = this.skeletons;\r\n        for (const skeleton of skeletons) {\r\n            skeleton.dispose();\r\n        }\r\n        skeletons.length = 0;\r\n\r\n        const animationGroups = this.animationGroups;\r\n        for (const animationGroup of animationGroups) {\r\n            animationGroup.dispose();\r\n        }\r\n        animationGroups.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Container with a set of assets that can be added or removed from a scene.\r\n */\r\nexport class AssetContainer extends AbstractAssetContainer {\r\n    private _wasAddedToScene = false;\r\n    private _onContextRestoredObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    /**\r\n     * The scene the AssetContainer belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Instantiates an AssetContainer.\r\n     * @param scene The scene the AssetContainer belongs to.\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        super();\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n        this[\"proceduralTextures\"] = [];\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            if (!this._wasAddedToScene) {\r\n                this.dispose();\r\n            }\r\n        });\r\n\r\n        this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {\r\n            for (const geometry of this.geometries) {\r\n                geometry._rebuild();\r\n            }\r\n\r\n            for (const mesh of this.meshes) {\r\n                mesh._rebuild();\r\n            }\r\n\r\n            for (const system of this.particleSystems) {\r\n                system.rebuild();\r\n            }\r\n\r\n            for (const texture of this.textures) {\r\n                texture._rebuild();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Given a list of nodes, return a topological sorting of them.\r\n     * @param nodes\r\n     * @returns a sorted array of nodes\r\n     */\r\n    private _topologicalSort(nodes: Node[]): Node[] {\r\n        const nodesUidMap = new Map<number, Node>();\r\n\r\n        for (const node of nodes) {\r\n            nodesUidMap.set(node.uniqueId, node);\r\n        }\r\n\r\n        const dependencyGraph = {\r\n            dependsOn: new Map<number, Set<number>>(), // given a node id, what are the ids of the nodes it depends on\r\n            dependedBy: new Map<number, Set<number>>(), // given a node id, what are the ids of the nodes that depend on it\r\n        };\r\n\r\n        // Build the dependency graph given the list of nodes\r\n\r\n        // First pass: Initialize the empty dependency graph\r\n        for (const node of nodes) {\r\n            const nodeId = node.uniqueId;\r\n            dependencyGraph.dependsOn.set(nodeId, new Set<number>());\r\n            dependencyGraph.dependedBy.set(nodeId, new Set<number>());\r\n        }\r\n\r\n        // Second pass: Populate the dependency graph. We assume that we\r\n        // don't need to check for cycles here, as the scene graph cannot\r\n        // contain cycles. Our graph also already contains all transitive\r\n        // dependencies because getDescendants returns the transitive\r\n        // dependencies by default.\r\n        for (const node of nodes) {\r\n            const nodeId = node.uniqueId;\r\n            const dependsOn = dependencyGraph.dependsOn.get(nodeId)!;\r\n            if (node instanceof InstancedMesh) {\r\n                const masterMesh = node.sourceMesh;\r\n                if (nodesUidMap.has(masterMesh.uniqueId)) {\r\n                    dependsOn.add(masterMesh.uniqueId);\r\n                    dependencyGraph.dependedBy.get(masterMesh.uniqueId)!.add(nodeId);\r\n                }\r\n            }\r\n            const dependedBy = dependencyGraph.dependedBy.get(nodeId)!;\r\n\r\n            for (const child of node.getDescendants()) {\r\n                const childId = child.uniqueId;\r\n                if (nodesUidMap.has(childId)) {\r\n                    dependedBy.add(childId);\r\n\r\n                    const childDependsOn = dependencyGraph.dependsOn.get(childId)!;\r\n                    childDependsOn.add(nodeId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Third pass: Topological sort\r\n        const sortedNodes: Node[] = [];\r\n\r\n        // First: Find all nodes that have no dependencies\r\n        const leaves: Node[] = [];\r\n        for (const node of nodes) {\r\n            const nodeId = node.uniqueId;\r\n            if (dependencyGraph.dependsOn.get(nodeId)!.size === 0) {\r\n                leaves.push(node);\r\n                nodesUidMap.delete(nodeId);\r\n            }\r\n        }\r\n\r\n        const visitList = leaves;\r\n        while (visitList.length > 0) {\r\n            const nodeToVisit = visitList.shift()!;\r\n\r\n            sortedNodes.push(nodeToVisit);\r\n\r\n            // Remove the node from the dependency graph\r\n            // When a node is visited, we know that dependsOn is empty.\r\n            // So we only need to remove the node from dependedBy.\r\n            const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId)!;\r\n            // Array.from(x.values()) is to make the TS compiler happy\r\n            for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {\r\n                const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId)!;\r\n                dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);\r\n\r\n                if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {\r\n                    visitList.push(nodesUidMap.get(dependedByVisitedNodeId)!);\r\n                    nodesUidMap.delete(dependedByVisitedNodeId);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nodesUidMap.size > 0) {\r\n            Logger.Error(\"SceneSerializer._topologicalSort: There were unvisited nodes:\");\r\n            nodesUidMap.forEach((node) => {\r\n                Logger.Error(node.name);\r\n            });\r\n        }\r\n\r\n        return sortedNodes;\r\n    }\r\n\r\n    private _addNodeAndDescendantsToList(list: Node[], addedIds: Set<number>, rootNode?: Node, predicate?: (entity: any) => boolean) {\r\n        if (!rootNode || (predicate && !predicate(rootNode)) || addedIds.has(rootNode.uniqueId)) {\r\n            return;\r\n        }\r\n\r\n        list.push(rootNode);\r\n        addedIds.add(rootNode.uniqueId);\r\n\r\n        for (const child of rootNode.getDescendants(true)) {\r\n            this._addNodeAndDescendantsToList(list, addedIds, child, predicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a specific node is contained in this asset container.\r\n     * @param node the node to check\r\n     * @returns true if the node is contained in this container, otherwise false.\r\n     */\r\n    private _isNodeInContainer(node: Node) {\r\n        if (node instanceof AbstractMesh && this.meshes.indexOf(node) !== -1) {\r\n            return true;\r\n        }\r\n        if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {\r\n            return true;\r\n        }\r\n        if (node instanceof Light && this.lights.indexOf(node) !== -1) {\r\n            return true;\r\n        }\r\n        if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * For every node in the scene, check if its parent node is also in the scene.\r\n     * @returns true if every node's parent is also in the scene, otherwise false.\r\n     */\r\n    private _isValidHierarchy() {\r\n        for (const node of this.meshes) {\r\n            if (node.parent && !this._isNodeInContainer(node.parent)) {\r\n                Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);\r\n                return false;\r\n            }\r\n        }\r\n        for (const node of this.transformNodes) {\r\n            if (node.parent && !this._isNodeInContainer(node.parent)) {\r\n                Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);\r\n                return false;\r\n            }\r\n        }\r\n        for (const node of this.lights) {\r\n            if (node.parent && !this._isNodeInContainer(node.parent)) {\r\n                Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);\r\n                return false;\r\n            }\r\n        }\r\n        for (const node of this.cameras) {\r\n            if (node.parent && !this._isNodeInContainer(node.parent)) {\r\n                Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Instantiate or clone all meshes and add the new ones to the scene.\r\n     * Skeletons and animation groups will all be cloned\r\n     * @param nameFunction defines an optional function used to get new names for clones\r\n     * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)\r\n     * @param options defines an optional list of options to control how to instantiate / clone models\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone\r\n     * @returns a list of rootNodes, skeletons and animation groups that were duplicated\r\n     */\r\n    public instantiateModelsToScene(\r\n        nameFunction?: (sourceName: string) => string,\r\n        cloneMaterials = false,\r\n        options?: { doNotInstantiate?: boolean | ((node: Node) => boolean); predicate?: (entity: any) => boolean }\r\n    ): InstantiatedEntries {\r\n        if (!this._isValidHierarchy()) {\r\n            Tools.Warn(\"SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.\");\r\n        }\r\n        const conversionMap: { [key: number]: number } = {};\r\n        const storeMap: { [key: number]: any } = {};\r\n        const result = new InstantiatedEntries();\r\n        const alreadySwappedSkeletons: Skeleton[] = [];\r\n        const alreadySwappedMaterials: Material[] = [];\r\n\r\n        const localOptions = {\r\n            doNotInstantiate: true,\r\n            ...options,\r\n        };\r\n\r\n        const onClone = (source: Node, clone: Node) => {\r\n            conversionMap[source.uniqueId] = clone.uniqueId;\r\n            storeMap[clone.uniqueId] = clone;\r\n\r\n            if (nameFunction) {\r\n                clone.name = nameFunction(source.name);\r\n            }\r\n\r\n            if (clone instanceof Mesh) {\r\n                const clonedMesh = clone;\r\n\r\n                if (clonedMesh.morphTargetManager) {\r\n                    const oldMorphTargetManager = (source as Mesh).morphTargetManager!;\r\n                    clonedMesh.morphTargetManager = oldMorphTargetManager.clone();\r\n\r\n                    for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {\r\n                        const oldTarget = oldMorphTargetManager.getTarget(index);\r\n                        const newTarget = clonedMesh.morphTargetManager.getTarget(index);\r\n\r\n                        conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;\r\n                        storeMap[newTarget.uniqueId] = newTarget;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        const nodesToSort: Node[] = [];\r\n        const idsOnSortList = new Set<number>();\r\n\r\n        for (const transformNode of this.transformNodes) {\r\n            if (transformNode.parent === null) {\r\n                this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);\r\n            }\r\n        }\r\n\r\n        for (const mesh of this.meshes) {\r\n            if (mesh.parent === null) {\r\n                this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);\r\n            }\r\n        }\r\n\r\n        // Topologically sort nodes by parenting/instancing relationships so that all resources are in place\r\n        // when a given node is instantiated.\r\n        const sortedNodes = this._topologicalSort(nodesToSort);\r\n\r\n        const onNewCreated = (source: Node, clone: Node) => {\r\n            onClone(source, clone);\r\n\r\n            if (source.parent) {\r\n                const replicatedParentId = conversionMap[source.parent.uniqueId];\r\n                const replicatedParent = storeMap[replicatedParentId];\r\n\r\n                if (replicatedParent) {\r\n                    clone.parent = replicatedParent;\r\n                } else {\r\n                    clone.parent = source.parent;\r\n                }\r\n            }\r\n\r\n            if ((clone as any).position && (source as any).position) {\r\n                (clone as any).position.copyFrom((source as any).position);\r\n            }\r\n            if ((clone as any).rotationQuaternion && (source as any).rotationQuaternion) {\r\n                (clone as any).rotationQuaternion.copyFrom((source as any).rotationQuaternion);\r\n            }\r\n            if ((clone as any).rotation && (source as any).rotation) {\r\n                (clone as any).rotation.copyFrom((source as any).rotation);\r\n            }\r\n            if ((clone as any).scaling && (source as any).scaling) {\r\n                (clone as any).scaling.copyFrom((source as any).scaling);\r\n            }\r\n\r\n            if ((clone as any).material) {\r\n                const mesh = clone as AbstractMesh;\r\n\r\n                if (mesh.material) {\r\n                    if (cloneMaterials) {\r\n                        const sourceMaterial = (source as AbstractMesh).material!;\r\n\r\n                        if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {\r\n                            let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : \"Clone of \" + sourceMaterial.name)!;\r\n                            alreadySwappedMaterials.push(sourceMaterial);\r\n                            conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;\r\n                            storeMap[swap.uniqueId] = swap;\r\n\r\n                            if (sourceMaterial.getClassName() === \"MultiMaterial\") {\r\n                                const multi = sourceMaterial as MultiMaterial;\r\n\r\n                                for (const material of multi.subMaterials) {\r\n                                    if (!material) {\r\n                                        continue;\r\n                                    }\r\n                                    swap = material.clone(nameFunction ? nameFunction(material.name) : \"Clone of \" + material.name)!;\r\n                                    alreadySwappedMaterials.push(material);\r\n                                    conversionMap[material.uniqueId] = swap.uniqueId;\r\n                                    storeMap[swap.uniqueId] = swap;\r\n                                }\r\n\r\n                                multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);\r\n                            }\r\n                        }\r\n\r\n                        if (mesh.getClassName() !== \"InstancedMesh\") {\r\n                            mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];\r\n                        }\r\n                    } else {\r\n                        if (mesh.material.getClassName() === \"MultiMaterial\") {\r\n                            if (this.scene.multiMaterials.indexOf(mesh.material as MultiMaterial) === -1) {\r\n                                this.scene.addMultiMaterial(mesh.material as MultiMaterial);\r\n                            }\r\n                        } else {\r\n                            if (this.scene.materials.indexOf(mesh.material) === -1) {\r\n                                this.scene.addMaterial(mesh.material);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (clone.parent === null) {\r\n                result.rootNodes.push(clone);\r\n            }\r\n        };\r\n\r\n        for (const node of sortedNodes) {\r\n            if (node.getClassName() === \"InstancedMesh\") {\r\n                const instancedNode = node as InstancedMesh;\r\n                const sourceMesh = instancedNode.sourceMesh;\r\n                const replicatedSourceId = conversionMap[sourceMesh.uniqueId];\r\n                const replicatedSource = typeof replicatedSourceId === \"number\" ? storeMap[replicatedSourceId] : sourceMesh;\r\n                const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);\r\n                onNewCreated(instancedNode, replicatedInstancedNode);\r\n            } else {\r\n                // Mesh or TransformNode\r\n                let canInstance = true;\r\n                if (\r\n                    node.getClassName() === \"TransformNode\" ||\r\n                    node.getClassName() === \"Node\" ||\r\n                    (node as Mesh).skeleton ||\r\n                    !(node as any).getTotalVertices ||\r\n                    (node as Mesh).getTotalVertices() === 0\r\n                ) {\r\n                    // Transform nodes, skinned meshes, and meshes with no vertices can never be instanced!\r\n                    canInstance = false;\r\n                } else if (localOptions.doNotInstantiate) {\r\n                    if (typeof localOptions.doNotInstantiate === \"function\") {\r\n                        canInstance = !localOptions.doNotInstantiate(node);\r\n                    } else {\r\n                        canInstance = !localOptions.doNotInstantiate;\r\n                    }\r\n                }\r\n                const replicatedNode = canInstance ? (node as Mesh).createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);\r\n                if (!replicatedNode) {\r\n                    throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);\r\n                }\r\n                onNewCreated(node, replicatedNode);\r\n            }\r\n        }\r\n\r\n        for (const s of this.skeletons) {\r\n            if (localOptions.predicate && !localOptions.predicate(s)) {\r\n                continue;\r\n            }\r\n\r\n            const clone = s.clone(nameFunction ? nameFunction(s.name) : \"Clone of \" + s.name);\r\n\r\n            for (const m of this.meshes) {\r\n                if (m.skeleton === s && !m.isAnInstance) {\r\n                    const copy = storeMap[conversionMap[m.uniqueId]] as Mesh;\r\n                    if (!copy || copy.isAnInstance) {\r\n                        continue;\r\n                    }\r\n                    copy.skeleton = clone;\r\n\r\n                    if (alreadySwappedSkeletons.indexOf(clone) !== -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    alreadySwappedSkeletons.push(clone);\r\n\r\n                    // Check if bones are mesh linked\r\n                    for (const bone of clone.bones) {\r\n                        if (bone._linkedTransformNode) {\r\n                            bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            result.skeletons.push(clone);\r\n        }\r\n\r\n        for (const o of this.animationGroups) {\r\n            if (localOptions.predicate && !localOptions.predicate(o)) {\r\n                continue;\r\n            }\r\n\r\n            const clone = o.clone(nameFunction ? nameFunction(o.name) : \"Clone of \" + o.name, (oldTarget) => {\r\n                const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];\r\n\r\n                return newTarget || oldTarget;\r\n            });\r\n\r\n            result.animationGroups.push(clone);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds all the assets from the container to the scene.\r\n     */\r\n    public addAllToScene() {\r\n        if (this._wasAddedToScene) {\r\n            return;\r\n        }\r\n        if (!this._isValidHierarchy()) {\r\n            Tools.Warn(\"SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.\");\r\n        }\r\n\r\n        this._wasAddedToScene = true;\r\n\r\n        this.addToScene(null);\r\n\r\n        if (this.environmentTexture) {\r\n            this.scene.environmentTexture = this.environmentTexture;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.addFromContainer(this);\r\n        }\r\n\r\n        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n        this._onContextRestoredObserver = null;\r\n    }\r\n\r\n    /**\r\n     * Adds assets from the container to the scene.\r\n     * @param predicate defines a predicate used to select which entity will be added (can be null)\r\n     */\r\n    public addToScene(predicate: Nullable<(entity: any) => boolean> = null) {\r\n        const addedNodes: Node[] = [];\r\n        for (const o of this.cameras) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addCamera(o);\r\n            addedNodes.push(o);\r\n        }\r\n        for (const o of this.lights) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addLight(o);\r\n            addedNodes.push(o);\r\n        }\r\n        for (const o of this.meshes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addMesh(o);\r\n            addedNodes.push(o);\r\n        }\r\n        for (const o of this.skeletons) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addSkeleton(o);\r\n        }\r\n        for (const o of this.animations) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addAnimation(o);\r\n        }\r\n        for (const o of this.animationGroups) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addAnimationGroup(o);\r\n        }\r\n        for (const o of this.multiMaterials) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addMultiMaterial(o);\r\n        }\r\n        for (const o of this.materials) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addMaterial(o);\r\n        }\r\n        for (const o of this.morphTargetManagers) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addMorphTargetManager(o);\r\n        }\r\n        for (const o of this.geometries) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addGeometry(o);\r\n        }\r\n        for (const o of this.transformNodes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addTransformNode(o);\r\n            addedNodes.push(o);\r\n        }\r\n        for (const o of this.actionManagers) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addActionManager(o);\r\n        }\r\n        for (const o of this.textures) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addTexture(o);\r\n        }\r\n        for (const o of this.reflectionProbes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.addReflectionProbe(o);\r\n        }\r\n\r\n        // No more nodes added to scene after this line, so it's safe to make a \"snapshot\" of nodes\r\n        if (addedNodes.length) {\r\n            // build the nodeSet only if needed\r\n            const nodeSet = new Set<Node>(this.scene.meshes);\r\n            // benchmark shows Set constructor and Set.add have similar performance,\r\n            // but using Set.add here avoids another allocate in scene.getNodes().\r\n            for (const light of this.scene.lights) {\r\n                nodeSet.add(light);\r\n            }\r\n            for (const camera of this.scene.cameras) {\r\n                nodeSet.add(camera);\r\n            }\r\n            for (const transformNode of this.scene.transformNodes) {\r\n                nodeSet.add(transformNode);\r\n            }\r\n            for (const skeleton of this.skeletons) {\r\n                for (const bone of skeleton.bones) {\r\n                    nodeSet.add(bone);\r\n                }\r\n            }\r\n            for (const addedNode of addedNodes) {\r\n                // If node was added to the scene, but parent is not in the scene, break the relationship\r\n                if (addedNode.parent && !nodeSet.has(addedNode.parent)) {\r\n                    // Use setParent to keep transform if possible\r\n                    if ((addedNode as TransformNode).setParent) {\r\n                        (addedNode as TransformNode).setParent(null);\r\n                    } else {\r\n                        addedNode.parent = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets in the container from the scene\r\n     */\r\n    public removeAllFromScene() {\r\n        if (!this._isValidHierarchy()) {\r\n            Tools.Warn(\"SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.\");\r\n        }\r\n\r\n        this._wasAddedToScene = false;\r\n\r\n        this.removeFromScene(null);\r\n\r\n        if (this.environmentTexture === this.scene.environmentTexture) {\r\n            this.scene.environmentTexture = null;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes assets in the container from the scene\r\n     * @param predicate defines a predicate used to select which entity will be added (can be null)\r\n     */\r\n    public removeFromScene(predicate: Nullable<(entity: any) => boolean> = null) {\r\n        for (const o of this.cameras) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeCamera(o);\r\n        }\r\n        for (const o of this.lights) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeLight(o);\r\n        }\r\n        for (const o of this.meshes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeMesh(o, true);\r\n        }\r\n        for (const o of this.skeletons) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeSkeleton(o);\r\n        }\r\n        for (const o of this.animations) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeAnimation(o);\r\n        }\r\n        for (const o of this.animationGroups) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeAnimationGroup(o);\r\n        }\r\n        for (const o of this.multiMaterials) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeMultiMaterial(o);\r\n        }\r\n        for (const o of this.materials) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeMaterial(o);\r\n        }\r\n        for (const o of this.morphTargetManagers) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeMorphTargetManager(o);\r\n        }\r\n        for (const o of this.geometries) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeGeometry(o);\r\n        }\r\n        for (const o of this.transformNodes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeTransformNode(o);\r\n        }\r\n        for (const o of this.actionManagers) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeActionManager(o);\r\n        }\r\n        for (const o of this.textures) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeTexture(o);\r\n        }\r\n        for (const o of this.reflectionProbes) {\r\n            if (predicate && !predicate(o)) {\r\n                continue;\r\n            }\r\n            this.scene.removeReflectionProbe(o);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes all the assets in the container\r\n     */\r\n    public dispose() {\r\n        const cameras = this.cameras.slice(0);\r\n        for (const camera of cameras) {\r\n            camera.dispose();\r\n        }\r\n        this.cameras.length = 0;\r\n\r\n        const lights = this.lights.slice(0);\r\n        for (const light of lights) {\r\n            light.dispose();\r\n        }\r\n        this.lights.length = 0;\r\n\r\n        const meshes = this.meshes.slice(0);\r\n        for (const mesh of meshes) {\r\n            mesh.dispose();\r\n        }\r\n        this.meshes.length = 0;\r\n\r\n        const skeletons = this.skeletons.slice(0);\r\n        for (const skeleton of skeletons) {\r\n            skeleton.dispose();\r\n        }\r\n        this.skeletons.length = 0;\r\n\r\n        const animationGroups = this.animationGroups.slice(0);\r\n        for (const animationGroup of animationGroups) {\r\n            animationGroup.dispose();\r\n        }\r\n        this.animationGroups.length = 0;\r\n\r\n        const multiMaterials = this.multiMaterials.slice(0);\r\n        for (const multiMaterial of multiMaterials) {\r\n            multiMaterial.dispose();\r\n        }\r\n        this.multiMaterials.length = 0;\r\n\r\n        const materials = this.materials.slice(0);\r\n        for (const material of materials) {\r\n            material.dispose();\r\n        }\r\n        this.materials.length = 0;\r\n\r\n        const geometries = this.geometries.slice(0);\r\n        for (const geometry of geometries) {\r\n            geometry.dispose();\r\n        }\r\n        this.geometries.length = 0;\r\n\r\n        const transformNodes = this.transformNodes.slice(0);\r\n        for (const transformNode of transformNodes) {\r\n            transformNode.dispose();\r\n        }\r\n        this.transformNodes.length = 0;\r\n\r\n        const actionManagers = this.actionManagers.slice(0);\r\n        for (const actionManager of actionManagers) {\r\n            actionManager.dispose();\r\n        }\r\n        this.actionManagers.length = 0;\r\n\r\n        const textures = this.textures.slice(0);\r\n        for (const texture of textures) {\r\n            texture.dispose();\r\n        }\r\n        this.textures.length = 0;\r\n\r\n        const reflectionProbes = this.reflectionProbes.slice(0);\r\n        for (const reflectionProbe of reflectionProbes) {\r\n            reflectionProbe.dispose();\r\n        }\r\n        this.reflectionProbes.length = 0;\r\n\r\n        const morphTargetManagers = this.morphTargetManagers.slice(0);\r\n        for (const morphTargetManager of morphTargetManagers) {\r\n            morphTargetManager.dispose();\r\n        }\r\n        this.morphTargetManagers.length = 0;\r\n\r\n        if (this.environmentTexture) {\r\n            this.environmentTexture.dispose();\r\n            this.environmentTexture = null;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this, true);\r\n        }\r\n\r\n        if (this._onContextRestoredObserver) {\r\n            this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n    }\r\n\r\n    private _moveAssets<T>(sourceAssets: T[], targetAssets: T[], keepAssets: T[]): void {\r\n        if (!sourceAssets || !targetAssets) {\r\n            return;\r\n        }\r\n\r\n        for (const asset of sourceAssets) {\r\n            let move = true;\r\n            if (keepAssets) {\r\n                for (const keepAsset of keepAssets) {\r\n                    if (asset === keepAsset) {\r\n                        move = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (move) {\r\n                targetAssets.push(asset);\r\n                (asset as any)._parentContainer = this;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets contained in the scene and adds them to the container.\r\n     * @param keepAssets Set of assets to keep in the scene. (default: empty)\r\n     */\r\n    public moveAllFromScene(keepAssets?: KeepAssets): void {\r\n        this._wasAddedToScene = false;\r\n\r\n        if (keepAssets === undefined) {\r\n            keepAssets = new KeepAssets();\r\n        }\r\n\r\n        for (const key in this) {\r\n            if (Object.prototype.hasOwnProperty.call(this, key)) {\r\n                (<any>this)[key] = (<any>this)[key] || (key === \"_environmentTexture\" ? null : []);\r\n                this._moveAssets((<any>this.scene)[key], (<any>this)[key], (<any>keepAssets)[key]);\r\n            }\r\n        }\r\n\r\n        this.environmentTexture = this.scene.environmentTexture;\r\n\r\n        this.removeAllFromScene();\r\n    }\r\n\r\n    /**\r\n     * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.\r\n     * @returns the root mesh\r\n     */\r\n    public createRootMesh() {\r\n        const rootMesh = new Mesh(\"assetContainerRootMesh\", this.scene);\r\n        for (const m of this.meshes) {\r\n            if (!m.parent) {\r\n                rootMesh.addChild(m);\r\n            }\r\n        }\r\n        this.meshes.unshift(rootMesh);\r\n        return rootMesh;\r\n    }\r\n\r\n    /**\r\n     * Merge animations (direct and animation groups) from this asset container into a scene\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param animatables set of animatables to retarget to a node from the scene\r\n     * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)\r\n     * @returns an array of the new AnimationGroup added to the scene (empty array if none)\r\n     */\r\n    public mergeAnimationsTo(\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        animatables: Animatable[],\r\n        targetConverter: Nullable<(target: any) => Nullable<Node>> = null\r\n    ): AnimationGroup[] {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to merge animations to\");\r\n            return [];\r\n        }\r\n\r\n        const _targetConverter = targetConverter\r\n            ? targetConverter\r\n            : (target: any) => {\r\n                  let node = null;\r\n\r\n                  const targetProperty = target.animations.length ? target.animations[0].targetProperty : \"\";\r\n                  /*\r\n              BabylonJS adds special naming to targets that are children of nodes.\r\n              This name attempts to remove that special naming to get the parent nodes name in case the target\r\n              can't be found in the node tree\r\n\r\n              Ex: Torso_primitive0 likely points to a Mesh primitive. We take away primitive0 and are left with \"Torso\" which is the name\r\n              of the primitive's parent.\r\n          */\r\n                  const name = target.name.split(\".\").join(\"\").split(\"_primitive\")[0];\r\n\r\n                  switch (targetProperty) {\r\n                      case \"position\":\r\n                      case \"rotationQuaternion\":\r\n                          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);\r\n                          break;\r\n                      case \"influence\":\r\n                          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);\r\n                          break;\r\n                      default:\r\n                          node = scene.getNodeByName(target.name) || scene.getNodeByName(name);\r\n                  }\r\n\r\n                  return node;\r\n              };\r\n\r\n        // Copy new node animations\r\n        const nodesInAC = this.getNodes();\r\n        for (const nodeInAC of nodesInAC) {\r\n            const nodeInScene = _targetConverter(nodeInAC);\r\n            if (nodeInScene !== null) {\r\n                // Remove old animations with same target property as a new one\r\n                for (const animationInAC of nodeInAC.animations) {\r\n                    // Doing treatment on an array for safety measure\r\n                    const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {\r\n                        return animationInScene.targetProperty === animationInAC.targetProperty;\r\n                    });\r\n                    for (const animationWithSameProperty of animationsWithSameProperty) {\r\n                        const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);\r\n                        if (index > -1) {\r\n                            nodeInScene.animations.splice(index, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Append new animations\r\n                nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);\r\n            }\r\n        }\r\n\r\n        const newAnimationGroups: AnimationGroup[] = [];\r\n\r\n        // Copy new animation groups\r\n        const animationGroups = this.animationGroups.slice();\r\n        for (const animationGroupInAC of animationGroups) {\r\n            // Clone the animation group and all its animatables\r\n            newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));\r\n\r\n            // Remove animatables related to the asset container\r\n            for (const animatable of animationGroupInAC.animatables) {\r\n                animatable.stop();\r\n            }\r\n        }\r\n\r\n        // Retarget animatables\r\n        for (const animatable of animatables) {\r\n            const target = _targetConverter(animatable.target);\r\n\r\n            if (target) {\r\n                // Clone the animatable and retarget it\r\n                scene.beginAnimation(\r\n                    target,\r\n                    animatable.fromFrame,\r\n                    animatable.toFrame,\r\n                    animatable.loopAnimation,\r\n                    animatable.speedRatio,\r\n                    animatable.onAnimationEnd ? animatable.onAnimationEnd : undefined,\r\n                    undefined,\r\n                    true,\r\n                    undefined,\r\n                    animatable.onAnimationLoop ? animatable.onAnimationLoop : undefined\r\n                );\r\n\r\n                // Stop animation for the target in the asset container\r\n                scene.stopAnimation(animatable.target);\r\n            }\r\n        }\r\n\r\n        return newAnimationGroups;\r\n    }\r\n\r\n    /**\r\n     * @since 6.15.0\r\n     * This method checks for any node that has no parent\r\n     * and is not in the rootNodes array, and adds the node\r\n     * there, if so.\r\n     */\r\n    public populateRootNodes() {\r\n        this.rootNodes.length = 0;\r\n        for (const m of this.meshes) {\r\n            if (!m.parent && this.rootNodes.indexOf(m) === -1) {\r\n                this.rootNodes.push(m);\r\n            }\r\n        }\r\n        for (const t of this.transformNodes) {\r\n            if (!t.parent && this.rootNodes.indexOf(t) === -1) {\r\n                this.rootNodes.push(t);\r\n            }\r\n        }\r\n        for (const l of this.lights) {\r\n            if (!l.parent && this.rootNodes.indexOf(l) === -1) {\r\n                this.rootNodes.push(l);\r\n            }\r\n        }\r\n        for (const c of this.cameras) {\r\n            if (!c.parent && this.rootNodes.indexOf(c) === -1) {\r\n                this.rootNodes.push(c);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @since 6.26.0\r\n     * Given a root asset, this method will traverse its hierarchy and add it, its children and any materials/skeletons/animation groups to the container.\r\n     * @param root root node\r\n     */\r\n    public addAllAssetsToContainer(root: Node) {\r\n        if (!root) {\r\n            return;\r\n        }\r\n\r\n        const nodesToVisit: Node[] = [];\r\n        const visitedNodes = new Set<Node>();\r\n\r\n        nodesToVisit.push(root);\r\n\r\n        while (nodesToVisit.length > 0) {\r\n            const nodeToVisit = nodesToVisit.pop()!;\r\n\r\n            if (nodeToVisit instanceof Mesh) {\r\n                if (nodeToVisit.geometry && this.geometries.indexOf(nodeToVisit.geometry) === -1) {\r\n                    this.geometries.push(nodeToVisit.geometry);\r\n                }\r\n                this.meshes.push(nodeToVisit);\r\n            } else if (nodeToVisit instanceof InstancedMesh) {\r\n                this.meshes.push(nodeToVisit);\r\n            } else if (nodeToVisit instanceof TransformNode) {\r\n                this.transformNodes.push(nodeToVisit);\r\n            } else if (nodeToVisit instanceof Light) {\r\n                this.lights.push(nodeToVisit);\r\n            } else if (nodeToVisit instanceof Camera) {\r\n                this.cameras.push(nodeToVisit);\r\n            }\r\n\r\n            if (nodeToVisit instanceof AbstractMesh) {\r\n                if (nodeToVisit.material && this.materials.indexOf(nodeToVisit.material) === -1) {\r\n                    this.materials.push(nodeToVisit.material);\r\n                    for (const texture of nodeToVisit.material.getActiveTextures()) {\r\n                        if (this.textures.indexOf(texture) === -1) {\r\n                            this.textures.push(texture);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (nodeToVisit.skeleton && this.skeletons.indexOf(nodeToVisit.skeleton) === -1) {\r\n                    this.skeletons.push(nodeToVisit.skeleton);\r\n                }\r\n\r\n                if (nodeToVisit.morphTargetManager && this.morphTargetManagers.indexOf(nodeToVisit.morphTargetManager) === -1) {\r\n                    this.morphTargetManagers.push(nodeToVisit.morphTargetManager);\r\n                }\r\n            }\r\n\r\n            for (const child of nodeToVisit.getChildren()) {\r\n                if (!visitedNodes.has(child)) {\r\n                    nodesToVisit.push(child);\r\n                }\r\n            }\r\n\r\n            visitedNodes.add(nodeToVisit);\r\n        }\r\n\r\n        this.populateRootNodes();\r\n    }\r\n\r\n    /**\r\n     * Get from a list of objects by tags\r\n     * @param list the list of objects to use\r\n     * @param tagsQuery the query to use\r\n     * @param filter a predicate to filter for tags\r\n     * @returns\r\n     */\r\n    private _getByTags<T>(list: T[], tagsQuery: string, filter?: (item: T) => boolean): T[] {\r\n        if (tagsQuery === undefined) {\r\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\r\n            return list;\r\n        }\r\n\r\n        const listByTags = [];\r\n\r\n        for (const i in list) {\r\n            const item = list[i];\r\n            if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {\r\n                listByTags.push(item);\r\n            }\r\n        }\r\n\r\n        return listByTags;\r\n    }\r\n\r\n    /**\r\n     * Get a list of meshes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Mesh\r\n     */\r\n    public getMeshesByTags(tagsQuery: string, filter?: (mesh: AbstractMesh) => boolean): AbstractMesh[] {\r\n        return this._getByTags(this.meshes, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of cameras by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Camera\r\n     */\r\n    public getCamerasByTags(tagsQuery: string, filter?: (camera: Camera) => boolean): Camera[] {\r\n        return this._getByTags(this.cameras, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of lights by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Light\r\n     */\r\n    public getLightsByTags(tagsQuery: string, filter?: (light: Light) => boolean): Light[] {\r\n        return this._getByTags(this.lights, tagsQuery, filter);\r\n    }\r\n\r\n    /**\r\n     * Get a list of materials by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of Material\r\n     */\r\n    public getMaterialsByTags(tagsQuery: string, filter?: (material: Material) => boolean): Material[] {\r\n        return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));\r\n    }\r\n\r\n    /**\r\n     * Get a list of transform nodes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param filter defines a predicate used to filter results\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getTransformNodesByTags(tagsQuery: string, filter?: (transform: TransformNode) => boolean): TransformNode[] {\r\n        return this._getByTags(this.transformNodes, tagsQuery, filter);\r\n    }\r\n}\r\n", "import { Decode } from \"./stringTools\";\r\n\r\n/**\r\n * Interface for a data buffer\r\n */\r\nexport interface IDataBuffer {\r\n    /**\r\n     * Reads bytes from the data buffer.\r\n     * @param byteOffset The byte offset to read\r\n     * @param byteLength The byte length to read\r\n     * @returns A promise that resolves when the bytes are read\r\n     */\r\n    readAsync(byteOffset: number, byteLength: number): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * The byte length of the buffer.\r\n     */\r\n    readonly byteLength: number;\r\n}\r\n\r\n/**\r\n * Utility class for reading from a data buffer\r\n */\r\nexport class DataReader {\r\n    /**\r\n     * The data buffer associated with this data reader.\r\n     */\r\n    public readonly buffer: IDataBuffer;\r\n\r\n    /**\r\n     * The current byte offset from the beginning of the data buffer.\r\n     */\r\n    public byteOffset = 0;\r\n\r\n    private _dataView: DataView;\r\n    private _dataByteOffset: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param buffer The buffer to read\r\n     */\r\n    constructor(buffer: IDataBuffer) {\r\n        this.buffer = buffer;\r\n    }\r\n\r\n    /**\r\n     * Loads the given byte length.\r\n     * @param byteLength The byte length to load\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public async loadAsync(byteLength: number): Promise<void> {\r\n        const data = await this.buffer.readAsync(this.byteOffset, byteLength);\r\n        this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        this._dataByteOffset = 0;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._dataByteOffset, true);\r\n        this._dataByteOffset += 4;\r\n        this.byteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a byte array from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The byte array read\r\n     */\r\n    public readUint8Array(byteLength: number): Uint8Array {\r\n        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a string from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The string read\r\n     */\r\n    public readString(byteLength: number): string {\r\n        return Decode(this.readUint8Array(byteLength));\r\n    }\r\n\r\n    /**\r\n     * Skips the given byte length the currently loaded data range.\r\n     * @param byteLength The byte length to skip\r\n     */\r\n    public skipBytes(byteLength: number): void {\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n    }\r\n}\r\n", "/* eslint-disable github/no-then */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction ValidateAsync(\r\n    data: string | Uint8Array,\r\n    rootUrl: string,\r\n    fileName: string,\r\n    getExternalResource: (uri: string) => Promise<Uint8Array>\r\n): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: getExternalResource,\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction WorkerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void; reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                ValidateAsync(\r\n                    data.data,\r\n                    data.rootUrl,\r\n                    data.fileName,\r\n                    (uri) =>\r\n                        new Promise((resolve, reject) => {\r\n                            const index = pendingExternalResources.length;\r\n                            pendingExternalResources.push({ resolve, reject });\r\n                            postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                        })\r\n                ).then(\r\n                    (value) => {\r\n                        postMessage({ id: \"validate.resolve\", value: value });\r\n                    },\r\n                    (reason) => {\r\n                        postMessage({ id: \"validate.reject\", reason: reason });\r\n                    }\r\n                );\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://cdn.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: `${Tools._DefaultCdnUrl}/gltf_validator.js`,\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(\r\n        data: string | Uint8Array,\r\n        rootUrl: string,\r\n        fileName: string,\r\n        getExternalResource: (uri: string) => Promise<Uint8Array>\r\n    ): Promise<GLTF2.IGLTFValidationResults> {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${ValidateAsync}(${WorkerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then(\r\n                                (value) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value.buffer]);\r\n                                },\r\n                                (reason) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                                }\r\n                            );\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            worker.terminate();\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(data.reason);\r\n                            worker.terminate();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: Tools.GetBabylonScriptURL(this.Configuration.url) });\r\n\r\n                if (ArrayBuffer.isView(data)) {\r\n                    // Slice the data to avoid copying the whole array buffer.\r\n                    const slicedData = data.slice();\r\n                    worker.postMessage({ id: \"validate\", data: slicedData, rootUrl: rootUrl, fileName: fileName }, [slicedData.buffer]);\r\n                } else {\r\n                    worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n                }\r\n            });\r\n        } else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadBabylonScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return ValidateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n", "import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const GLTFMagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\r\n\r\nexport const GLTFFileLoaderMetadata = {\r\n    name: \"gltf\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".gltf\": { isBinary: false, mimeType: \"model/gltf+json\" },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".glb\": { isBinary: true, mimeType: \"model/gltf-binary\" },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n\r\n    canDirectLoad(data: string): boolean {\r\n        return (\r\n            (data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\r\n            data.startsWith(\"data:base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\"data:;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        );\r\n    },\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n", "/* eslint-disable github/no-then */\r\n/* eslint-disable @typescript-eslint/no-floating-promises */\r\n/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginFactory, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport { GLTFFileLoaderMetadata, GLTFMagicBase64Encoded } from \"./glTFFileLoader.metadata\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n/**\r\n * Defines options for glTF loader extensions. This interface is extended by specific extensions.\r\n */\r\nexport interface GLTFLoaderExtensionOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the glTF loader.\r\n         */\r\n        [GLTFFileLoaderMetadata.name]: Partial<GLTFLoaderOptions>;\r\n    }\r\n}\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\nfunction readViewAsync(arrayBufferView: ArrayBufferView, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Offset is out of range.\");\r\n        }\r\n\r\n        if (byteOffset + byteLength > arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Length is out of range.\");\r\n        }\r\n\r\n        return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Adds default/implicit options to extension specific options.\r\n */\r\ntype DefaultExtensionOptions<BaseExtensionOptions> = {\r\n    /**\r\n     * Defines if the extension is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BaseExtensionOptions;\r\n\r\nabstract class GLTFLoaderOptions {\r\n    // eslint-disable-next-line babylonjs/available\r\n    protected copyFrom(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        if (options) {\r\n            this.alwaysComputeBoundingBox = options.alwaysComputeBoundingBox ?? this.alwaysComputeBoundingBox;\r\n            this.alwaysComputeSkeletonRootNode = options.alwaysComputeSkeletonRootNode ?? this.alwaysComputeSkeletonRootNode;\r\n            this.animationStartMode = options.animationStartMode ?? this.animationStartMode;\r\n            this.capturePerformanceCounters = options.capturePerformanceCounters ?? this.capturePerformanceCounters;\r\n            this.compileMaterials = options.compileMaterials ?? this.compileMaterials;\r\n            this.compileShadowGenerators = options.compileShadowGenerators ?? this.compileShadowGenerators;\r\n            this.coordinateSystemMode = options.coordinateSystemMode ?? this.coordinateSystemMode;\r\n            this.createInstances = options.createInstances ?? this.createInstances;\r\n            this.customRootNode = options.customRootNode;\r\n            this.extensionOptions = options.extensionOptions ?? this.extensionOptions;\r\n            this.loadAllMaterials = options.loadAllMaterials ?? this.loadAllMaterials;\r\n            this.loadMorphTargets = options.loadMorphTargets ?? this.loadMorphTargets;\r\n            this.loadNodeAnimations = options.loadNodeAnimations ?? this.loadNodeAnimations;\r\n            this.loadOnlyMaterials = options.loadOnlyMaterials ?? this.loadOnlyMaterials;\r\n            this.loadSkins = options.loadSkins ?? this.loadSkins;\r\n            this.loggingEnabled = options.loggingEnabled ?? this.loggingEnabled;\r\n            this.onCameraLoaded = options.onCameraLoaded;\r\n            this.onMaterialLoaded = options.onMaterialLoaded;\r\n            this.onMeshLoaded = options.onMeshLoaded;\r\n            this.onParsed = options.onParsed;\r\n            this.onSkinLoaded = options.onSkinLoaded;\r\n            this.onTextureLoaded = options.onTextureLoaded;\r\n            this.onValidated = options.onValidated;\r\n            this.preprocessUrlAsync = options.preprocessUrlAsync ?? this.preprocessUrlAsync;\r\n            this.skipMaterials = options.skipMaterials ?? this.skipMaterials;\r\n            this.targetFps = options.targetFps ?? this.targetFps;\r\n            this.transparencyAsCoverage = options.transparencyAsCoverage ?? this.transparencyAsCoverage;\r\n            this.useClipPlane = options.useClipPlane ?? this.useClipPlane;\r\n            this.useGltfTextureNames = options.useGltfTextureNames ?? this.useGltfTextureNames;\r\n            this.useRangeRequests = options.useRangeRequests ?? this.useRangeRequests;\r\n            this.useSRGBBuffers = options.useSRGBBuffers ?? this.useSRGBBuffers;\r\n            this.validate = options.validate ?? this.validate;\r\n        }\r\n    }\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public abstract onParsed?: ((loaderData: IGLTFLoaderData) => void) | undefined;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public abstract capturePerformanceCounters: boolean;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * Defines the node to use as the root of the hierarchy when loading the scene (default: undefined). If not defined, a root node will be automatically created.\r\n     * You can also pass null if you don't want a root node to be created.\r\n     */\r\n    public customRootNode?: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines options for glTF extensions.\r\n     */\r\n    public extensionOptions: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each extension.\r\n        // 2. Creating a mapped type of all the options of all the extensions to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Extension in keyof GLTFLoaderExtensionOptions]?: {\r\n            [Option in keyof DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>]: DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>[Option];\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load morph targets. Defaults to true.\r\n     */\r\n    public loadMorphTargets = true;\r\n\r\n    /**\r\n     * Defines if the loader should load node animations. Defaults to true.\r\n     * NOTE: The animation of this node will still load if the node is also a joint of a skin and `loadSkins` is true.\r\n     */\r\n    public loadNodeAnimations = true;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load skins. Defaults to true.\r\n     */\r\n    public loadSkins = true;\r\n\r\n    /**\r\n     * If true, enable logging for the loader. Defaults to false.\r\n     */\r\n    public abstract loggingEnabled: boolean;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public abstract onCameraLoaded?: (camera: Camera) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public abstract onMaterialLoaded?: (material: Material) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public abstract onMeshLoaded?: (mesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public abstract onSkinLoaded?: (node: TransformNode, skinnedNode: TransformNode) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public abstract onTextureLoaded?: (texture: BaseTexture) => void;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public abstract onValidated?: (results: GLTF2.IGLTFValidationResults) => void;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url url referenced by the asset\r\n     * @returns Async url to load\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * If true, the loader will derive the name for Babylon textures from the glTF texture name, image name, or image url. Defaults to false.\r\n     * Note that it is possible for multiple Babylon textures to share the same name when the Babylon textures load from the same glTF texture or image.\r\n     */\r\n    public useGltfTextureNames = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader extends GLTFLoaderOptions implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @internal */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @internal */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /**\r\n     * Creates a new glTF file loader.\r\n     * @param options The options for the loader\r\n     */\r\n    public constructor(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        super();\r\n        this.copyFrom(options);\r\n    }\r\n\r\n    // --------------------\r\n    // Begin Common options\r\n    // --------------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: ((loaderData: IGLTFLoaderData) => void) | undefined) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onParsedObserver = this.onParsedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    // ------------------\r\n    // End Common options\r\n    // ------------------\r\n\r\n    // ----------------\r\n    // Begin V1 options\r\n    // ----------------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @internal\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @internal\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // --------------\r\n    // End V1 options\r\n    // --------------\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: ((mesh: AbstractMesh) => void) | undefined) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     * @param node - the transform node that corresponds to the original glTF skin node used for animations\r\n     * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\r\n     */\r\n    public readonly onSkinLoadedObservable = new Observable<{ node: TransformNode; skinnedNode: TransformNode }>();\r\n\r\n    private _onSkinLoadedObserver: Nullable<Observer<{ node: TransformNode; skinnedNode: TransformNode }>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public set onSkinLoaded(callback: ((node: TransformNode, skinnedNode: TransformNode) => void) | undefined) {\r\n        if (this._onSkinLoadedObserver) {\r\n            this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((data) => callback(data.node, data.skinnedNode));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: ((texture: BaseTexture) => void) | undefined) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: ((material: Material) => void) | undefined) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: ((camera: Camera) => void) | undefined) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public readonly name = GLTFFileLoaderMetadata.name;\r\n\r\n    /** @internal */\r\n    public readonly extensions = GLTFFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onSkinLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest> {\r\n        if (ArrayBuffer.isView(fileOrUrl)) {\r\n            this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);\r\n            return null;\r\n        }\r\n\r\n        this._progressCallback = onProgress;\r\n\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, new Uint8Array(data as ArrayBuffer, 0, (data as ArrayBuffer).byteLength), rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        } else {\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    try {\r\n                        this._validate(scene, data as string, rootUrl, fileName);\r\n                        onSuccess({ json: this._parseJson(data as string) });\r\n                    } catch {\r\n                        if (onError) {\r\n                            onError();\r\n                        }\r\n                    }\r\n                },\r\n                false,\r\n                onError\r\n            );\r\n        }\r\n    }\r\n\r\n    private _loadBinary(\r\n        scene: Scene,\r\n        data: ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        fileName?: string\r\n    ): void {\r\n        this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);\r\n        this._unpackBinaryAsync(\r\n            new DataReader({\r\n                readAsync: (byteOffset, byteLength) => readViewAsync(data, byteOffset, byteLength),\r\n                byteLength: data.byteLength,\r\n            })\r\n        ).then(\r\n            (loaderData) => {\r\n                onSuccess(loaderData);\r\n            },\r\n            onError ? (error) => onError(undefined, error) : undefined\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAssetContainerAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            const morphTargetManagers: Array<MorphTargetManager> = [];\r\n            this.onMeshLoadedObservable.add((mesh) => {\r\n                if (mesh.morphTargetManager) {\r\n                    morphTargetManagers.push(mesh.morphTargetManager);\r\n                }\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return GLTFFileLoaderMetadata.canDirectLoad(data);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<object> {\r\n        if (\r\n            data.startsWith(\"base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\";base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @internal */\r\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader(options[GLTFFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add(() => {\r\n            // Force the length computable to be true since we can guarantee the data is loaded.\r\n            request._lengthComputable = true;\r\n            request._total = request._loaded;\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | Uint8Array, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => {\r\n                return scene._loadFileAsync(url, undefined, true, true).then((data) => {\r\n                    return new Uint8Array(data, 0, data.byteLength);\r\n                });\r\n            });\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\r\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @internal */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @internal */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @internal */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @internal */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new GLTFFileLoader());\r\n", "export * from \"./glTFBinaryExtension\";\r\nexport * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderUtils\";\r\nexport * from \"./glTFMaterialsCommonExtension\";\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Skeleton } from \"core/Bones/skeleton\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Enums\r\n * @internal\r\n */\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126,\r\n}\r\n\r\n/** @internal */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633,\r\n}\r\n\r\n/** @internal */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410,\r\n}\r\n\r\n/** @internal */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032,\r\n}\r\n\r\n/** @internal */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: object;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    assetContainer: Nullable<AssetContainer>;\r\n}\r\n\r\n/** @internal */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    private _waitingForData: boolean;\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean,\r\n        waitDataToBeReady?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._waitingForData = !!waitDataToBeReady && !data;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n        this._waitingForData = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        if (!this._texture) {\r\n            return super.clone();\r\n        }\r\n\r\n        const rawTexture = new RawTexture(\r\n            null,\r\n            this.getSize().width,\r\n            this.getSize().height,\r\n            this.format,\r\n            this.getScene(),\r\n            this._texture.generateMipMaps,\r\n            this._invertY,\r\n            this.samplingMode,\r\n            this._texture.type,\r\n            this._texture._creationFlags,\r\n            this._useSRGBBuffer\r\n        );\r\n\r\n        rawTexture._texture = this._texture;\r\n        this._texture.incrementReferences();\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        return super.isReady() && !this._waitingForData;\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false,\r\n        waitDataToBeReady: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            creationFlags,\r\n            useSRGBBuffer,\r\n            waitDataToBeReady\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n", "import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable.core\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones: Bone[] = [];\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n    private _currentRenderId = -1;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _absoluteTransformIsDirty = true;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @internal */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @internal */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the skeleton\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: Nullable<AbstractMesh>): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh) {\r\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\r\n            }\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare(true);\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices || this._isDirty) {\r\n            this.prepare(!this._transformMatrices);\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @returns the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n        this._absoluteTransformIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\r\n                } else {\r\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\r\n     */\r\n    public prepare(dontCheckFrameId = false): void {\r\n        if (!dontCheckFrameId) {\r\n            const currentRenderId = this.getScene().getRenderId();\r\n            if (this._currentRenderId === currentRenderId) {\r\n                return;\r\n            }\r\n            this._currentRenderId = currentRenderId;\r\n        }\r\n\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    const node = bone._linkedTransformNode;\r\n                    bone.position = node.position;\r\n                    if (node.rotationQuaternion) {\r\n                        bone.rotationQuaternion = node.rotationQuaternion;\r\n                    } else {\r\n                        bone.rotation = node.rotation;\r\n                    }\r\n                    bone.scaling = node.scaling;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBindMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n        result.metadata = this.metadata;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        result.prepare(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        for (const bone of this.bones) {\r\n            for (const animation of bone.animations) {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix.length = 0;\r\n        this.metadata = null;\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBindMatrix().asArray(),\r\n                rest: bone.getRestMatrix().asArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        if (parsedSkeleton.metadata) {\r\n            skeleton.metadata = parsedSkeleton.metadata;\r\n        }\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteMatrices(forceUpdate = false): void {\r\n        if (this._absoluteTransformIsDirty || forceUpdate) {\r\n            this.bones[0].computeAbsoluteMatrices();\r\n            this._absoluteTransformIsDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        this.computeAbsoluteMatrices(forceUpdate);\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones: Bone[] = [];\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) {\r\n            return;\r\n        }\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        for (const b of this.bones) {\r\n            b.setCurrentPoseAsRest();\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\r\n    return () => new PointLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A point light is a light defined by an unique point in world space.\r\n * The light is emitted in every direction from this point.\r\n * A good example of a point light is a standard light bulb.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class PointLight extends ShadowLight {\r\n    private _shadowAngle = Math.PI / 2;\r\n    /**\r\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    @serialize()\r\n    public get shadowAngle(): number {\r\n        return this._shadowAngle;\r\n    }\r\n    /**\r\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    public set shadowAngle(value: number) {\r\n        this._shadowAngle = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Gets the direction if it has been set.\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override set direction(value: Vector3) {\r\n        const previousNeedCube = this.needCube();\r\n        this._direction = value;\r\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.recreateShadowMap();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\r\n     * A PointLight emits the light in every direction.\r\n     * It can cast shadows.\r\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\r\n     * ```javascript\r\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\r\n     * ```\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the point light in the scene\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointLight\"\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PointLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 0.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_POINTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the shadowmap should be a cube texture.\r\n     * @returns true if the shadowmap needs to be a cube texture.\r\n     */\r\n    public override needCube(): boolean {\r\n        return !this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    public override getShadowDirection(faceIndex?: number): Vector3 {\r\n        if (this.direction) {\r\n            return super.getShadowDirection(faceIndex);\r\n        } else {\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    return new Vector3(1.0, 0.0, 0.0);\r\n                case 1:\r\n                    return new Vector3(-1.0, 0.0, 0.0);\r\n                case 2:\r\n                    return new Vector3(0.0, -1.0, 0.0);\r\n                case 3:\r\n                    return new Vector3(0.0, 1.0, 0.0);\r\n                case 4:\r\n                    return new Vector3(0.0, 0.0, 1.0);\r\n                case 5:\r\n                    return new Vector3(0.0, 0.0, -1.0);\r\n            }\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\r\n     * - fov = PI / 2\r\n     * - aspect ratio : 1.0\r\n     * - z-near and far equal to the active camera minZ and maxZ.\r\n     * Returns the PointLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this.shadowAngle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The point light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): PointLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0.0, lightIndex);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, lightIndex);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"POINTLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.PointLight\", PointLight);\r\n", "import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     * @returns true if set, else false\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     * @returns the byte stride\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     * @returns the filter mode (TODO - needs to be a type?)\r\n     */\r\n    public static GetTextureFilterMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     * @returns an array buffer view\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     * @returns a string\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     * @returns the default Babylon material\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst BabylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst BabylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst ParseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst ParseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst ParseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst NormalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst GetAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst LoadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = BabylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst ConfigureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n * @returns the parent bone\r\n */\r\nconst GetParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = ConfigureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n * @returns the root node\r\n */\r\nconst GetNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n * @returns the node with the joint name\r\n */\r\nconst GetJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n * @returns true if the node is in joints, else false\r\n */\r\nconst NodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst GetNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n * @returns the bone name\r\n */\r\nconst ImportSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = GetJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = GetNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n * @returns the new mesh\r\n */\r\nconst ImportMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts: number[] = [];\r\n    const verticesCounts: number[] = [];\r\n    const indexStarts: number[] = [];\r\n    const indexCounts: number[] = [];\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    NormalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        material.subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst ConfigureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst ConfigureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        ConfigureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n * @returns the newly imported node\r\n */\r\nconst ImportNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            ConfigureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst TraverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = ImportNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst PostLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    LoadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst OnBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                shaderMaterial.getEffect().setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst PrepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n * @param unTreatedUniforms\r\n * @returns the name of the uniform handled by babylon\r\n */\r\nconst ParseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return BabylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst ImportMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            ParseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            ParseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            ParseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            ParseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            ParseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            ParseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            ParseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            ParseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            ParseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            ParseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            ParseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            ParseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            ParseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            ParseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            ParseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            ParseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            ParseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            ParseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(BabylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = GetAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += GetAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes: AbstractMesh[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        ImportMaterials(gltfRuntime);\r\n                        PostLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                        spriteManagers: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                ImportMaterials(gltfRuntime);\r\n                                PostLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return await new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from creating the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     * @returns true to stop further extensions from loading this buffer\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this shader data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n", "import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport type { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean {\r\n        const extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\r\n", "import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n", "/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nexport * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderExtension\";\r\nexport * from \"./glTFLoaderExtensionRegistry\";\r\nexport * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderAnimation\";\r\nexport * from \"./Extensions/index\";\r\n", "/**\r\n * Wrapper class for promise with external resolve and reject.\r\n */\r\nexport class Deferred<T> {\r\n    /**\r\n     * The promise associated with this deferred object.\r\n     */\r\n    public readonly promise: Promise<T>;\r\n\r\n    private _resolve: (value: T | PromiseLike<T>) => void;\r\n    private _reject: (reason?: any) => void;\r\n\r\n    /**\r\n     * The resolve method of the promise associated with this deferred object.\r\n     */\r\n    public get resolve() {\r\n        return this._resolve;\r\n    }\r\n\r\n    /**\r\n     * The reject method of the promise associated with this deferred object.\r\n     */\r\n    public get reject() {\r\n        return this._reject;\r\n    }\r\n\r\n    /**\r\n     * Constructor for this deferred object.\r\n     */\r\n    constructor() {\r\n        this.promise = new Promise((resolve: (value: T | PromiseLike<T>) => void, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n}\r\n", "import type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst _environmentBRDFBase64Texture =\r\n    \"data:image/png;base64,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\";\r\n\r\nlet InstanceNumber = 0;\r\n\r\n/**\r\n * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n * @param scene defines the hosting scene\r\n * @returns the environment BRDF texture\r\n */\r\nexport const GetEnvironmentBRDFTexture = (scene: Scene): BaseTexture => {\r\n    if (!scene.environmentBRDFTexture) {\r\n        // Forces Delayed Texture Loading to prevent undefined error whilst setting RGBD values.\r\n        const useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const previousState = scene._blockEntityCollection;\r\n        scene._blockEntityCollection = false;\r\n        const texture = Texture.CreateFromBase64String(\r\n            _environmentBRDFBase64Texture,\r\n            \"EnvironmentBRDFTexture\" + InstanceNumber++,\r\n            scene,\r\n            true,\r\n            false,\r\n            Texture.BILINEAR_SAMPLINGMODE\r\n        );\r\n        scene._blockEntityCollection = previousState;\r\n        // BRDF Texture should not be cached here due to pre processing and redundant scene caches.\r\n        const texturesCache = scene.getEngine().getLoadedTexturesCache();\r\n        const index = texturesCache.indexOf(texture.getInternalTexture()!);\r\n        if (index !== -1) {\r\n            texturesCache.splice(index, 1);\r\n        }\r\n\r\n        texture.isRGBD = true;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        scene.environmentBRDFTexture = texture;\r\n\r\n        scene.useDelayedTextureLoading = useDelayedTextureLoading;\r\n\r\n        RGBDTextureTools.ExpandRGBDTexture(texture);\r\n\r\n        const observer = scene.getEngine().onContextRestoredObservable.add(() => {\r\n            texture.isRGBD = true;\r\n            /**\r\n             * Using scene.onBeforeRenderObservable instead of Tools.SetImmediate to check the texture's state of readiness allows us to check before any rendering occurs.\r\n             * When a context restore occurs, it gives ExpandRGBDTexture the ability to reset the state to false, preventing the texture from being used in any rendering.\r\n             * In WebGPU, not doing so would generate an error because ExpandRGBDTexture performs a _swapAndDie on the texture, which causes WebGPU caches to fail if the texture has already been used for rendering.\r\n             * Only when ExpandRGBDTexture has finished its work, the texture is ready to be used again.\r\n             */\r\n            const oo = scene.onBeforeRenderObservable.add(() => {\r\n                if (texture.isReady()) {\r\n                    scene.onBeforeRenderObservable.remove(oo);\r\n                    RGBDTextureTools.ExpandRGBDTexture(texture);\r\n                }\r\n            });\r\n        });\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            scene.getEngine().onContextRestoredObservable.remove(observer);\r\n        });\r\n    }\r\n\r\n    return scene.environmentBRDFTexture;\r\n};\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const BRDFTextureTools = {\r\n    /**\r\n     * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n     * @param scene defines the hosting scene\r\n     * @returns the environment BRDF texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GetEnvironmentBRDFTexture,\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { serialize, expandToProperty } from \"../../Misc/decorators\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialBRDFDefines extends MaterialDefines {\r\n    BRDF_V_HEIGHT_CORRELATED = false;\r\n    MS_BRDF_ENERGY_CONSERVATION = false;\r\n    SPHERICAL_HARMONICS = false;\r\n    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\r\n    MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;\r\n    LEGACY_SPECULAR_ENERGY_CONSERVATION = false;\r\n    BASE_DIFFUSE_MODEL = 0;\r\n    DIELECTRIC_SPECULAR_MODEL = 0;\r\n    CONDUCTOR_SPECULAR_MODEL = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the BRDF component of the PBR material\r\n */\r\nexport class PBRBRDFConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for the energy conservation.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value used for the Smith Visibility Height Correlated mode.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;\r\n\r\n    /**\r\n     * Default value used for the IBL diffuse part.\r\n     * This can help switching back to the polynomials mode globally which is a tiny bit\r\n     * less GPU intensive at the drawback of a lower quality.\r\n     */\r\n    public static DEFAULT_USE_SPHERICAL_HARMONICS = true;\r\n\r\n    /**\r\n     * Default value used for activating energy conservation for the specular workflow.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     */\r\n    public static DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value for whether IBL irradiance is used to augment rough radiance.\r\n     * If activated, irradiance is blended into the radiance contribution when the material is rough.\r\n     * This better approximates raytracing results for rough surfaces.\r\n     */\r\n    public static DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;\r\n\r\n    /**\r\n     * Default value for whether the legacy specular energy conservation is used.\r\n     */\r\n    public static DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Defines the default diffuse model used by the material.\r\n     */\r\n    public static DEFAULT_DIFFUSE_MODEL = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n\r\n    /**\r\n     * Defines the default dielectric specular model used by the material.\r\n     */\r\n    public static DEFAULT_DIELECTRIC_SPECULAR_MODEL: number = Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_GLTF;\r\n\r\n    /**\r\n     * Defines the default conductor specular model used by the material.\r\n     */\r\n    public static DEFAULT_CONDUCTOR_SPECULAR_MODEL: number = Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_GLTF;\r\n\r\n    private _useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n\r\n    private _useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses height smith correlated visibility term.\r\n     * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR\r\n     * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png\r\n     * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision\r\n     * Not relying on height correlated will also disable energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n\r\n    private _useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     * The harmonics despite a tiny bigger cost has been proven to provide closer results\r\n     * to the ground truth.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n\r\n    private _useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation, when the specular workflow is active.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n\r\n    private _mixIblRadianceWithIrradiance = PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;\r\n    /**\r\n     * Defines if IBL irradiance is used to augment rough radiance.\r\n     * If activated, irradiance is blended into the radiance contribution when the material is rough.\r\n     * This better approximates raytracing results for rough surfaces.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public mixIblRadianceWithIrradiance = PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;\r\n\r\n    private _useLegacySpecularEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the legacy specular energy conservation is used.\r\n     * If activated, the specular color is multiplied with (1. - maxChannel(albedo color)).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useLegacySpecularEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;\r\n\r\n    private _baseDiffuseModel: number = PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;\r\n    /**\r\n     * Defines the base diffuse roughness model of the material.\r\n     */\r\n    @serialize(\"baseDiffuseModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public baseDiffuseModel: number = PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;\r\n\r\n    private _dielectricSpecularModel: number = PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;\r\n    /**\r\n     * The material model to use for specular lighting of dielectric materials.\r\n     */\r\n    @serialize(\"dielectricSpecularModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public dielectricSpecularModel: number = PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;\r\n\r\n    private _conductorSpecularModel: number = PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;\r\n    /**\r\n     * The material model to use for specular lighting.\r\n     */\r\n    @serialize(\"conductorSpecularModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public conductorSpecularModel: number = PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRBRDF\", 90, new MaterialBRDFDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n        this._enable(true);\r\n    }\r\n\r\n    public override prepareDefines(defines: MaterialBRDFDefines): void {\r\n        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;\r\n        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;\r\n        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;\r\n        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;\r\n        defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;\r\n        defines.LEGACY_SPECULAR_ENERGY_CONSERVATION = this._useLegacySpecularEnergyConservation;\r\n        defines.BASE_DIFFUSE_MODEL = this._baseDiffuseModel;\r\n        defines.DIELECTRIC_SPECULAR_MODEL = this._dielectricSpecularModel;\r\n        defines.CONDUCTOR_SPECULAR_MODEL = this._conductorSpecularModel;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRBRDFConfiguration\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialClearCoatDefines extends MaterialDefines {\r\n    public CLEARCOAT = false;\r\n    public CLEARCOAT_DEFAULTIOR = false;\r\n    public CLEARCOAT_TEXTURE = false;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n    public CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public CLEARCOAT_BUMP = false;\r\n    public CLEARCOAT_BUMPDIRECTUV = 0;\r\n    public CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n    public CLEARCOAT_REMAP_F0 = false;\r\n\r\n    public CLEARCOAT_TINT = false;\r\n    public CLEARCOAT_TINT_TEXTURE = false;\r\n    public CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the clear coat component of the PBR material\r\n */\r\nexport class PBRClearCoatConfiguration extends MaterialPluginBase {\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.5;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the clear coat is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer roughness.\r\n     */\r\n    @serialize()\r\n    public roughness: number = 0;\r\n\r\n    private _indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n    /**\r\n     * Defines the index of refraction of the clear coat.\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * Changing the default value is more performance intensive.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat values in a texture (red channel is intensity and green channel is roughness)\r\n     * If useRoughnessFromMainTexture is false, the green channel of texture is not used and the green channel of textureRoughness is used instead\r\n     * if textureRoughness is not empty, else no texture roughness is used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the green channel of the texture property will be used for roughness (default: true)\r\n     * If false, the green channel from textureRoughness is used for roughness\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat roughness in a texture (green channel)\r\n     * Not used if useRoughnessFromMainTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _remapF0OnInterfaceChange = true;\r\n    /**\r\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public remapF0OnInterfaceChange = true;\r\n\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the clear coat specific bump texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _isTintEnabled = false;\r\n    /**\r\n     * Defines if the clear coat tint is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTintEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat tint of the material.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the\r\n     * clear coat media.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer thickness.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintThickness: number = 1;\r\n\r\n    private _tintTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear tint values in a texture.\r\n     * rgb is tint\r\n     * a is a thickness factor\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public tintTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRClearCoat\", 100, new MaterialClearCoatDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialClearCoatDefines, scene: Scene, engine: Engine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                    if (!this._tintTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialClearCoatDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.CLEARCOAT = true;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n            defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"CLEARCOAT_TEXTURE\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._textureRoughness, defines, \"CLEARCOAT_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n\r\n                    if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._bumpTexture, defines, \"CLEARCOAT_BUMP\");\r\n                    } else {\r\n                        defines.CLEARCOAT_BUMP = false;\r\n                    }\r\n\r\n                    defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n                    if (this._isTintEnabled) {\r\n                        defines.CLEARCOAT_TINT = true;\r\n                        if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                            PrepareDefinesForMergedUV(this._tintTexture, defines, \"CLEARCOAT_TINT_TEXTURE\");\r\n                            defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;\r\n                        } else {\r\n                            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                        }\r\n                    } else {\r\n                        defines.CLEARCOAT_TINT = false;\r\n                        defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.CLEARCOAT = false;\r\n            defines.CLEARCOAT_TEXTURE = false;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n            defines.CLEARCOAT_BUMP = false;\r\n            defines.CLEARCOAT_TINT = false;\r\n            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.CLEARCOAT_DEFAULTIOR = false;\r\n            defines.CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n            defines.CLEARCOAT_BUMPDIRECTUV = 0;\r\n            defines.CLEARCOAT_REMAP_F0 = false;\r\n            defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialClearCoatDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        const invertNormalMapX = this._material._invertNormalMapX;\r\n        const invertNormalMapY = this._material._invertNormalMapY;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vClearCoatInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"clearCoat\");\r\n                }\r\n                if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    BindTextureMatrix(this._textureRoughness, uniformBuffer, \"clearCoatRoughness\");\r\n                }\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);\r\n                BindTextureMatrix(this._bumpTexture, uniformBuffer, \"clearCoatBump\");\r\n\r\n                if (scene._mirroredCameraPosition) {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? 1.0 : -1.0, invertNormalMapY ? 1.0 : -1.0);\r\n                } else {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? -1.0 : 1.0, invertNormalMapY ? -1.0 : 1.0);\r\n                }\r\n            }\r\n\r\n            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatTintInfos\", this._tintTexture.coordinatesIndex, this._tintTexture.level);\r\n                BindTextureMatrix(this._tintTexture, uniformBuffer, \"clearCoatTint\");\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat2(\"vClearCoatParams\", this.intensity, this.roughness);\r\n\r\n            // Clear Coat Refraction params\r\n            const a = 1 - this._indexOfRefraction;\r\n            const b = 1 + this._indexOfRefraction;\r\n            const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\r\n            const eta = 1 / this._indexOfRefraction;\r\n            uniformBuffer.updateFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\r\n\r\n            if (this._isTintEnabled) {\r\n                uniformBuffer.updateFloat4(\"vClearCoatTintParams\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintThickness));\r\n                uniformBuffer.updateFloat(\"clearCoatColorAtDistance\", Math.max(0.00001, this.tintColorAtDistance));\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatRoughnessSampler\", this._textureRoughness);\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.setTexture(\"clearCoatBumpSampler\", this._bumpTexture);\r\n            }\r\n\r\n            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatTintSampler\", this._tintTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._tintTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture) {\r\n            activeTextures.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            animatables.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {\r\n            animatables.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._tintTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRClearCoatConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialClearCoatDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.CLEARCOAT_BUMP) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_BUMP\");\r\n        }\r\n        if (defines.CLEARCOAT_TINT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_TINT\");\r\n        }\r\n        if (defines.CLEARCOAT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"clearCoatSampler\", \"clearCoatRoughnessSampler\", \"clearCoatBumpSampler\", \"clearCoatTintSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vClearCoatParams\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatRefractionParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vClearCoatInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"clearCoatRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatBumpInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatTangentSpaceParams\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatBumpMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatTintParams\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatColorAtDistance\", size: 1, type: \"float\" },\r\n                { name: \"vClearCoatTintInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatTintMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty } from \"../../Misc/decorators\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialIridescenceDefines extends MaterialDefines {\r\n    public IRIDESCENCE = false;\r\n    public IRIDESCENCE_TEXTURE = false;\r\n    public IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n    public IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n    public IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the iridescence (thin film) component of the PBR material\r\n */\r\nexport class PBRIridescenceConfiguration extends MaterialPluginBase {\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * The default minimum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 100 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMinimumThickness = 100;\r\n\r\n    /**\r\n     * The default maximum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 400 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMaximumThickness = 400;\r\n\r\n    /**\r\n     * The default index of refraction of the thin-film layer.\r\n     * Defaults to 1.3\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.3;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the iridescence is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the iridescence layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the minimum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = PBRIridescenceConfiguration._DefaultMinimumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm). This will be the thickness used if not thickness texture has been set.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = PBRIridescenceConfiguration._DefaultMaximumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction: number = PBRIridescenceConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence intensity in a texture (red channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence thickness in a texture (green channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRIridescence\", 110, new MaterialIridescenceDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialIridescenceDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialIridescenceDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.IRIDESCENCE = true;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"IRIDESCENCE_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"IRIDESCENCE_THICKNESS_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.IRIDESCENCE = false;\r\n            defines.IRIDESCENCE_TEXTURE = false;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n            defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vIridescenceInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._thicknessTexture?.coordinatesIndex ?? 0,\r\n                    this._thicknessTexture?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"iridescence\");\r\n                }\r\n                if (this._thicknessTexture) {\r\n                    BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"iridescenceThickness\");\r\n                }\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat4(\"vIridescenceParams\", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceSampler\", this._texture);\r\n            }\r\n\r\n            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceThicknessSampler\", this._thicknessTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._thicknessTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRIridescenceConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialIridescenceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.IRIDESCENCE) {\r\n            fallbacks.addFallback(currentRank++, \"IRIDESCENCE\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"iridescenceSampler\", \"iridescenceThicknessSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vIridescenceParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vIridescenceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"iridescenceMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"iridescenceThicknessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public ANISOTROPIC_LEGACY = false;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    /**\r\n     * Sets the anisotropy direction as an angle.\r\n     */\r\n    public set angle(value: number) {\r\n        this.direction.x = Math.cos(value);\r\n        this.direction.y = Math.sin(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy angle value in radians.\r\n     * @returns the anisotropy angle value in radians.\r\n     */\r\n    public get angle(): number {\r\n        return Math.atan2(this.direction.y, this.direction.x);\r\n    }\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _legacy = false;\r\n    /**\r\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public legacy: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (defines._areMiscDirty) {\r\n                defines.ANISOTROPIC_LEGACY = this._legacy;\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n            defines.ANISOTROPIC_LEGACY = false;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public override parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n\r\n        // Backward compatibility\r\n        if (source.legacy === undefined) {\r\n            this.legacy = true;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSheenDefines extends MaterialDefines {\r\n    public SHEEN = false;\r\n    public SHEEN_TEXTURE = false;\r\n    public SHEEN_GAMMATEXTURE = false;\r\n    public SHEEN_TEXTURE_ROUGHNESS = false;\r\n    public SHEEN_TEXTUREDIRECTUV = 0;\r\n    public SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public SHEEN_LINKWITHALBEDO = false;\r\n    public SHEEN_ROUGHNESS = false;\r\n    public SHEEN_ALBEDOSCALING = false;\r\n    public SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sheen component of the PBR material.\r\n */\r\nexport class PBRSheenConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    private _linkSheenWithAlbedo = false;\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkSheenWithAlbedo = false;\r\n\r\n    /**\r\n     * Defines the sheen intensity.\r\n     */\r\n    @serialize()\r\n    public intensity = 1;\r\n\r\n    /**\r\n     * Defines the sheen color.\r\n     */\r\n    @serializeAsColor3()\r\n    public color = Color3.White();\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _roughness: Nullable<number> = null;\r\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number> = null;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _albedoScaling = false;\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoScaling = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"Sheen\", 120, new MaterialSheenDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialSheenDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialSheenDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.SHEEN = true;\r\n            defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\r\n            defines.SHEEN_ROUGHNESS = this._roughness !== null;\r\n            defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\r\n                        defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.SHEEN = false;\r\n            defines.SHEEN_TEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n            defines.SHEEN_LINKWITHALBEDO = false;\r\n            defines.SHEEN_ROUGHNESS = false;\r\n            defines.SHEEN_ALBEDOSCALING = false;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.SHEEN_GAMMATEXTURE = false;\r\n            defines.SHEEN_TEXTUREDIRECTUV = 0;\r\n            defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialSheenDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vSheenInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\r\n                }\r\n                if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\r\n                }\r\n            }\r\n\r\n            // Sheen\r\n            uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\r\n\r\n            if (this._roughness !== null) {\r\n                uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRSheenConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialSheenDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SHEEN) {\r\n            fallbacks.addFallback(currentRank++, \"SHEEN\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"sheenSampler\", \"sheenRoughnessSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vSheenColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSheenRoughness\", size: 1, type: \"float\" },\r\n                { name: \"vSheenInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"sheenMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"sheenRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n    public SS_SCATTERING = false;\r\n    public SS_DISPERSION = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n    public SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;\r\n    public SS_TRANSLUCENCY_LEGACY = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for applyAlbedoAfterSubSurface.\r\n     *\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface properties (transmission, refraction, etc.). Default is false.\r\n     * Note however that the PBR calculation is wrong when this property is set to true, so only use it if you want to mimic the 7.0 behavior.\r\n     */\r\n    public static DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE = false;\r\n\r\n    /**\r\n     * Default value used for legacyTranslucency.\r\n     *\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface translucency. Default is false.\r\n     */\r\n    public static DEFAULT_LEGACY_TRANSLUCENCY = false;\r\n\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isDispersionEnabled = false;\r\n    /**\r\n     * Defines if dispersion is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isDispersionEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @internal */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the Abbe number for the volume.\r\n     */\r\n    @serialize()\r\n    public dispersion = 0;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue (alpha if useGltfStyleTextures = true) channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue (alpha if useGltfStyleTextures = true) channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Defines the translucency tint of the material.\r\n     * If not set, the tint color will be used instead.\r\n     */\r\n    @serializeAsColor3()\r\n    public translucencyColor: Nullable<Color3> = null;\r\n\r\n    private _translucencyColorTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the translucency tint color of the material as a texture.\r\n     * This is multiplied against the translucency color to add variety and realism to the material.\r\n     * If translucencyColor is not set, the tint color will be used instead.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyColorTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _useGltfStyleTextures = true;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: the alpha (instead of blue) channel is the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = true;\r\n\r\n    /**\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface properties (transmission, refraction, etc.). Default is false.\r\n     * Note however that the PBR calculation is wrong when this property is set to true, so only use it if you want to mimic the 7.0 behavior.\r\n     */\r\n    @serialize()\r\n    public applyAlbedoAfterSubSurface = PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;\r\n\r\n    /**\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface translucency. Default is false.\r\n     */\r\n    @serialize()\r\n    public legacyTranslucency = PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY;\r\n\r\n    /**\r\n     * Keeping for backward compatibility... Should not be used anymore. It has been replaced by\r\n     * the property with the correct spelling.\r\n     * @see legacyTranslucency\r\n     */\r\n    public get legacyTransluceny(): boolean {\r\n        return this.legacyTranslucency;\r\n    }\r\n    public set legacyTransluceny(value: boolean) {\r\n        this.legacyTranslucency = value;\r\n    }\r\n\r\n    private _scene: Scene;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @internal */\r\n    public _markScenePrePassDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {\r\n                    if (!this._refractionIntensityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {\r\n                    if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {\r\n                    if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_DISPERSION = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;\r\n            defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_DISPERSION = this._isDispersionEnabled;\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_TRANSLUCENCY_LEGACY = this.legacyTranslucency;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n            defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = this.applyAlbedoAfterSubSurface;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, \"SS_TRANSLUCENCYCOLOR_TEXTURE\");\r\n                        defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public override hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        // If min/max thickness is 0, avoid decompising to determine the scaled thickness (it's always zero).\r\n        if (this.maximumThickness === 0.0 && this.minimumThickness === 0.0) {\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", 0, 0);\r\n        } else {\r\n            subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n            const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyColorInfos\", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);\r\n                BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, \"translucencyColor\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Math.log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n            uniformBuffer.updateColor4(\"vTranslucencyColor\", this.translucencyColor ?? this.tintColor, 0);\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n\r\n            uniformBuffer.updateFloat(\"dispersion\", this.dispersion);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyColorSampler\", this._translucencyColorTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public override fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionIntensityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._translucencyColorTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n\r\n        if (this._refractionIntensityTexture) {\r\n            activeTextures.push(this._refractionIntensityTexture);\r\n        }\r\n\r\n        if (this._translucencyColorTexture) {\r\n            activeTextures.push(this._translucencyColorTexture);\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture) {\r\n            activeTextures.push(this._translucencyIntensityTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n\r\n        if (this._refractionIntensityTexture && this._refractionIntensityTexture.animations && this._refractionIntensityTexture.animations.length > 0) {\r\n            animatables.push(this._refractionIntensityTexture);\r\n        }\r\n\r\n        if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {\r\n            animatables.push(this._translucencyColorTexture);\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {\r\n            animatables.push(this._translucencyIntensityTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionIntensityTexture) {\r\n                this._refractionIntensityTexture.dispose();\r\n            }\r\n\r\n            if (this._translucencyColorTexture) {\r\n                this._translucencyColorTexture.dispose();\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture) {\r\n                this._translucencyIntensityTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\r\n            \"thicknessSampler\",\r\n            \"refractionIntensitySampler\",\r\n            \"translucencyIntensitySampler\",\r\n            \"refractionSampler\",\r\n            \"refractionSamplerLow\",\r\n            \"refractionSamplerHigh\",\r\n            \"translucencyColorSampler\"\r\n        );\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n                { name: \"dispersion\", size: 1, type: \"float\" },\r\n\r\n                { name: \"vTranslucencyColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vTranslucencyColorInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"translucencyColorMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsImageProcessingConfiguration, expandToProperty } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration\";\r\nimport { PrePassConfiguration } from \"../prePassConfiguration\";\r\nimport { Color3, TmpColors } from \"../../Maths/math.color\";\r\n\r\nimport type { IImageProcessingConfigurationDefines } from \"../../Materials/imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { IMaterialCompilationOptions, ICustomShaderNameResolveOptions } from \"../../Materials/material\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MaterialPluginEvent } from \"../materialPluginEvent\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\n\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\n\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\n\r\nimport \"../../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration\";\r\nimport { PBRIridescenceConfiguration } from \"./pbrIridescenceConfiguration\";\r\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration\";\r\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration\";\r\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration\";\r\nimport { DetailMapConfiguration } from \"../material.detailMapConfiguration\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindTextureMatrix,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { MaterialHelperGeometryRendering } from \"../materialHelper.geometryrendering\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Manages the defines for the PBR Material.\r\n * @internal\r\n */\r\nexport class PBRMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public PBR = true;\r\n\r\n    public NUM_SAMPLES = \"0\";\r\n    public REALTIME_FILTERING = false;\r\n    public IBL_CDF_FILTERING = false;\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public MAINUV3 = false;\r\n    public MAINUV4 = false;\r\n    public MAINUV5 = false;\r\n    public MAINUV6 = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    public ALBEDO = false;\r\n    public GAMMAALBEDO = false;\r\n    public ALBEDODIRECTUV = 0;\r\n    public VERTEXCOLOR = false;\r\n\r\n    public BASE_WEIGHT = false;\r\n    public BASE_WEIGHTDIRECTUV = 0;\r\n    public BASE_DIFFUSE_ROUGHNESS = false;\r\n    public BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;\r\n\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public AMBIENTINGRAYSCALE = false;\r\n\r\n    public OPACITY = false;\r\n    public VERTEXALPHA = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHABLEND = false;\r\n    public ALPHAFROMALBEDO = false;\r\n    public ALPHATESTVALUE = \"0.5\";\r\n    public SPECULAROVERALPHA = false;\r\n    public RADIANCEOVERALPHA = false;\r\n    public ALPHAFRESNEL = false;\r\n    public LINEARALPHAFRESNEL = false;\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public GAMMAEMISSIVE = false;\r\n\r\n    public REFLECTIVITY = false;\r\n    public REFLECTIVITY_GAMMA = false;\r\n    public REFLECTIVITYDIRECTUV = 0;\r\n    public SPECULARTERM = false;\r\n\r\n    public MICROSURFACEFROMREFLECTIVITYMAP = false;\r\n    public MICROSURFACEAUTOMATIC = false;\r\n    public LODBASEDMICROSFURACE = false;\r\n    public MICROSURFACEMAP = false;\r\n    public MICROSURFACEMAPDIRECTUV = 0;\r\n\r\n    public METALLICWORKFLOW = false;\r\n    public ROUGHNESSSTOREINMETALMAPALPHA = false;\r\n    public ROUGHNESSSTOREINMETALMAPGREEN = false;\r\n    public METALLNESSSTOREINMETALMAPBLUE = false;\r\n    public AOSTOREINMETALMAPRED = false;\r\n    public METALLIC_REFLECTANCE = false;\r\n    public METALLIC_REFLECTANCE_GAMMA = false;\r\n    public METALLIC_REFLECTANCEDIRECTUV = 0;\r\n    public METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;\r\n    public REFLECTANCE = false;\r\n    public REFLECTANCE_GAMMA = false;\r\n    public REFLECTANCEDIRECTUV = 0;\r\n\r\n    public ENVIRONMENTBRDF = false;\r\n    public ENVIRONMENTBRDF_RGBD = false;\r\n\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public NORMALXYSCALE = true;\r\n\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public GAMMALIGHTMAP = false;\r\n    public RGBDLIGHTMAP = false;\r\n\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public USESPHERICALFROMREFLECTIONMAP = false;\r\n    public USEIRRADIANCEMAP = false;\r\n    public USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n    public USESPHERICALINVERTEX = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public LINEARSPECULARREFLECTION = false;\r\n    public RADIANCEOCCLUSION = false;\r\n    public HORIZONOCCLUSION = false;\r\n\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_COLOR = false;\r\n    public PREPASS_COLOR_INDEX = -1;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO = false;\r\n    public PREPASS_ALBEDO_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_SCREENSPACE_DEPTH = false;\r\n    public PREPASS_SCREENSPACE_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH = false;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_WORLD_NORMAL = false;\r\n    public PREPASS_WORLD_NORMAL_INDEX = -1;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_LOCAL_POSITION = false;\r\n    public PREPASS_LOCAL_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_VELOCITY_LINEAR = false;\r\n    public PREPASS_VELOCITY_LINEAR_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n\r\n    public NONUNIFORMSCALING = false;\r\n\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_POSITION = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public MORPHTARGETS_UV2 = false;\r\n    public MORPHTARGETS_COLOR = false;\r\n    public MORPHTARGETTEXTURE_HASPOSITIONS = false;\r\n    public MORPHTARGETTEXTURE_HASNORMALS = false;\r\n    public MORPHTARGETTEXTURE_HASTANGENTS = false;\r\n    public MORPHTARGETTEXTURE_HASUVS = false;\r\n    public MORPHTARGETTEXTURE_HASUV2S = false;\r\n    public MORPHTARGETTEXTURE_HASCOLORS = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = 0;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public EXPOSURE = false;\r\n    public MULTIVIEW = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\r\n\r\n    public USEPHYSICALLIGHTFALLOFF = false;\r\n    public USEGLTFLIGHTFALLOFF = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public MIRRORED = false;\r\n    public SHADOWFLOAT = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n\r\n    public FORCENORMALFORWARD = false;\r\n\r\n    public SPECULARAA = false;\r\n\r\n    public UNLIT = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    public DEBUGMODE = 0;\r\n    public USE_VERTEX_PULLING = false;\r\n\r\n    /**\r\n     * Initializes the PBR Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Resets the PBR Material defines.\r\n     */\r\n    public override reset(): void {\r\n        super.reset();\r\n        this.ALPHATESTVALUE = \"0.5\";\r\n        this.PBR = true;\r\n        this.NORMALXYSCALE = true;\r\n    }\r\n}\r\n\r\n/**\r\n * The Physically based material base class of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n * @see [WebGL](https://playground.babylonjs.com/#CGHTSM#1)\r\n * @see [WebGPU](https://playground.babylonjs.com/#CGHTSM#2)\r\n */\r\nexport abstract class PBRBaseMaterial extends PushMaterial {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly LIGHTFALLOFF_PHYSICAL = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly LIGHTFALLOFF_GLTF = 1;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly LIGHTFALLOFF_STANDARD = 2;\r\n\r\n    /**\r\n     * Force all the PBR materials to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     * @internal\r\n     */\r\n    public _directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     * @internal\r\n     */\r\n    public _emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     * @internal\r\n     */\r\n    public _environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     * @internal\r\n     */\r\n    public _specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\r\n     */\r\n    private _lightingInfos: Vector4 = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     * @internal\r\n     */\r\n    public _disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Base Weight texture (multiplier to the diffuse and metal lobes).\r\n     * @internal\r\n     */\r\n    public _baseWeightTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Base Diffuse Roughness texture (roughness of the diffuse lobe).\r\n     * @internal\r\n     */\r\n    public _baseDiffuseRoughnessTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     * @internal\r\n     */\r\n    public _ambientTextureImpactOnAnalyticalLights: number = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture.\r\n     * @internal\r\n     */\r\n    public _opacityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     * @internal\r\n     */\r\n    public _reflectionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     * @internal\r\n     */\r\n    public _emissiveTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     * @internal\r\n     */\r\n    public _metallicTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _metallic: Nullable<number> = null;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _roughness: Nullable<number> = null;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     * @internal\r\n     */\r\n    public _metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from _metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     * @internal\r\n     */\r\n    public _useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiply against the scalar values defined in the material.\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both _reflectanceTexture and _metallicReflectanceTexture textures are provided and _useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, _metallicReflectanceTexture takes precedence and _reflectanceTexture is not used\r\n     * @internal\r\n     */\r\n    public _reflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     * @internal\r\n     */\r\n    public _microSurfaceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _lightmapTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     * @internal\r\n     */\r\n    public _ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Base Weight (multiplier to the diffuse and metal lobes).\r\n     * @internal\r\n     */\r\n    public _baseWeight = 1;\r\n\r\n    /**\r\n     * Base Diffuse Roughness (roughness of the diffuse lobe).\r\n     * Can also be used to scale the corresponding texture.\r\n     * @internal\r\n     */\r\n    public _baseDiffuseRoughness: Nullable<number> = null;\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is reflected from a material.\r\n     * @internal\r\n     */\r\n    public _reflectionColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is emitted from a material.\r\n     * @internal\r\n     */\r\n    public _emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _microSurface = 0.9;\r\n\r\n    /**\r\n     * Specifies that the material will use the light map as a show map.\r\n     * @internal\r\n     */\r\n    public _useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     * @internal\r\n     */\r\n    public _useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     * @internal\r\n     */\r\n    public _useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     * @internal\r\n     */\r\n    public _useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     * @internal\r\n     */\r\n    public _useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     * @internal\r\n     */\r\n    public _useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     * @internal\r\n     */\r\n    public _useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     * @internal\r\n     */\r\n    public _useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     * @internal\r\n     */\r\n    public _lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     * @internal\r\n     */\r\n    public _useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     * @internal\r\n     */\r\n    public _useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     * @internal\r\n     */\r\n    public _useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     * @internal\r\n     */\r\n    public _parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     * @internal\r\n     */\r\n    public _disableLighting = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     * @internal\r\n     */\r\n    public _maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     * @internal\r\n     */\r\n    public _twoSidedLighting = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     * @internal\r\n     */\r\n    public _alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\r\n     * from cos theta and roughness:\r\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n     * @internal\r\n     */\r\n    public _environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     * @internal\r\n     */\r\n    public _forceIrradianceInFragment = false;\r\n\r\n    private _realTimeFiltering: boolean = false;\r\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\r\n    public get realTimeFiltering() {\r\n        return this._realTimeFiltering;\r\n    }\r\n    public set realTimeFiltering(b: boolean) {\r\n        this._realTimeFiltering = b;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private _realTimeFilteringQuality: number = Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\r\n    public get realTimeFilteringQuality(): number {\r\n        return this._realTimeFilteringQuality;\r\n    }\r\n    public set realTimeFilteringQuality(n: number) {\r\n        this._realTimeFilteringQuality = n;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public override get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     * @internal\r\n     */\r\n    public _forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     * @internal\r\n     */\r\n    public _enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the PBR Material.\r\n     */\r\n    @serializeAsImageProcessingConfiguration()\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the available render targets.\r\n     */\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /**\r\n     * Sets the global ambient color for the material used in lighting calculations.\r\n     */\r\n    private _globalAmbientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    private _unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    private _applyDecalMapAfterDetailMap = false;\r\n\r\n    private _debugMode = 0;\r\n\r\n    private _shadersLoaded = false;\r\n    private _breakShaderLoadedCheck = false;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public debugMode = 0;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to -1\r\n     */\r\n    public debugLimit = -1;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\r\n    public debugFactor = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer parameters for the material.\r\n     */\r\n    public readonly clearCoat: PBRClearCoatConfiguration;\r\n\r\n    /**\r\n     * Defines the iridescence layer parameters for the material.\r\n     */\r\n    public readonly iridescence: PBRIridescenceConfiguration;\r\n\r\n    /**\r\n     * Defines the anisotropic parameters for the material.\r\n     */\r\n    public readonly anisotropy: PBRAnisotropicConfiguration;\r\n\r\n    /**\r\n     * Defines the BRDF parameters for the material.\r\n     */\r\n    public readonly brdf: PBRBRDFConfiguration;\r\n\r\n    /**\r\n     * Defines the Sheen parameters for the material.\r\n     */\r\n    public readonly sheen: PBRSheenConfiguration;\r\n\r\n    /**\r\n     * Defines the SubSurface parameters for the material.\r\n     */\r\n    public readonly subSurface: PBRSubSurfaceConfiguration;\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap: DetailMapConfiguration;\r\n\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Scene, forceGLSL = false) {\r\n        super(name, scene, undefined, forceGLSL || PBRBaseMaterial.ForceGLSL);\r\n\r\n        this.brdf = new PBRBRDFConfiguration(this);\r\n        this.clearCoat = new PBRClearCoatConfiguration(this);\r\n        this.iridescence = new PBRIridescenceConfiguration(this);\r\n        this.anisotropy = new PBRAnisotropicConfiguration(this);\r\n        this.sheen = new PBRSheenConfiguration(this);\r\n        this.subSurface = new PBRSubSurfaceConfiguration(this);\r\n        this.detailMap = new DetailMapConfiguration(this);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public override get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * @returns the name of the material class.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PBRBaseMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected override get _disableAlphaBlending(): boolean {\r\n        return (\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE ||\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST ||\r\n            this.subSurface?.disableAlphaBlending\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not this material should be rendered in alpha blend mode.\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not this material should be rendered in alpha test mode.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        if (this.subSurface?.disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromAlbedoTexture(): boolean {\r\n        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this._albedoTexture != null && this._albedoTexture.hasAlpha) || this._opacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * @returns the texture used for the alpha test.\r\n     */\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._albedoTexture;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param mesh - BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\r\n     * @param useInstances - Specifies that instances should be used.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n        }\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._albedoTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    if (!this._baseWeightTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    if (!this._baseDiffuseRoughnessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    if (reflectionTexture.irradianceTexture) {\r\n                        if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        // Not ready until spherical are ready too.\r\n                        if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        if (!this._metallicTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else if (this._reflectivityTexture) {\r\n                        if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._reflectanceTexture) {\r\n                        if (!this._reflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    // This is blocking.\r\n                    if (!this._environmentBRDFTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"] || defines[\"CLUSTLIGHT_BATCH\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            mesh.createNormals(true);\r\n            Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n        }\r\n\r\n        const previousEffect = subMesh.effect;\r\n        const lightDisposed = defines._areLightsDisposed;\r\n        let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);\r\n\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (effect) {\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n\r\n            // Use previous effect while new one is compiling\r\n            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                effect = previousEffect;\r\n                defines.markAsUnprocessed();\r\n\r\n                forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                if (lightDisposed) {\r\n                    // re register in case it takes more than one frame.\r\n                    defines._areLightsDisposed = true;\r\n                    return false;\r\n                }\r\n            } else {\r\n                scene.resetCachedMaterial();\r\n                subMesh.setEffect(effect, defines, this._materialContext);\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses metallic roughness workflow.\r\n     * @returns boolean specifying if the material uses metallic roughness workflow.\r\n     */\r\n    public isMetallicWorkflow(): boolean {\r\n        if (this._metallic != null || this._roughness != null || this._metallicTexture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _prepareEffect(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): Nullable<Effect> {\r\n        this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);\r\n\r\n        if (!defines.isDirty) {\r\n            return null;\r\n        }\r\n\r\n        defines.markAsProcessed();\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Fallbacks\r\n        const fallbacks = new EffectFallbacks();\r\n        let fallbackRank = 0;\r\n        if (defines.USESPHERICALINVERTEX) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\r\n        }\r\n\r\n        if (defines.FOG) {\r\n            fallbacks.addFallback(fallbackRank, \"FOG\");\r\n        }\r\n        if (defines.SPECULARAA) {\r\n            fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\r\n        }\r\n        if (defines.POINTSIZE) {\r\n            fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\r\n        }\r\n        if (defines.LOGARITHMICDEPTH) {\r\n            fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\r\n        }\r\n        if (defines.PARALLAX) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX\");\r\n        }\r\n        if (defines.PARALLAX_RHS) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX_RHS\");\r\n        }\r\n        if (defines.PARALLAXOCCLUSION) {\r\n            fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\r\n        }\r\n\r\n        if (defines.ENVIRONMENTBRDF) {\r\n            fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"TANGENT\");\r\n        }\r\n\r\n        if (defines.BUMP) {\r\n            fallbacks.addFallback(fallbackRank++, \"BUMP\");\r\n        }\r\n\r\n        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\r\n        }\r\n\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\r\n        }\r\n\r\n        if (defines.USEIRRADIANCEMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\r\n        }\r\n\r\n        if (defines.LIGHTMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\r\n        }\r\n\r\n        if (defines.NORMAL) {\r\n            fallbacks.addFallback(fallbackRank++, \"NORMAL\");\r\n        }\r\n\r\n        if (defines.AMBIENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\r\n        }\r\n\r\n        if (defines.EMISSIVE) {\r\n            fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\r\n        }\r\n\r\n        if (defines.MORPHTARGETS) {\r\n            fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\r\n        }\r\n\r\n        if (defines.MULTIVIEW) {\r\n            fallbacks.addFallback(0, \"MULTIVIEW\");\r\n        }\r\n\r\n        //Attributes\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        if (defines.NORMAL) {\r\n            attribs.push(VertexBuffer.NormalKind);\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            attribs.push(VertexBuffer.TangentKind);\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            if (defines[\"UV\" + i]) {\r\n                attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n            }\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n        PrepareAttributesForInstances(attribs, defines);\r\n        PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n        let shaderName = \"pbr\";\r\n\r\n        const uniforms = [\r\n            \"world\",\r\n            \"view\",\r\n            \"viewProjection\",\r\n            \"vEyePosition\",\r\n            \"vLightsType\",\r\n            \"vAmbientColor\",\r\n            \"vAlbedoColor\",\r\n            \"baseWeight\",\r\n            \"baseDiffuseRoughness\",\r\n            \"vReflectivityColor\",\r\n            \"vMetallicReflectanceFactors\",\r\n            \"vEmissiveColor\",\r\n            \"visibility\",\r\n            \"vReflectionColor\",\r\n            \"vFogInfos\",\r\n            \"vFogColor\",\r\n            \"pointSize\",\r\n            \"vAlbedoInfos\",\r\n            \"vBaseWeightInfos\",\r\n            \"vBaseDiffuseRoughnessInfos\",\r\n            \"vAmbientInfos\",\r\n            \"vOpacityInfos\",\r\n            \"vReflectionInfos\",\r\n            \"vReflectionPosition\",\r\n            \"vReflectionSize\",\r\n            \"vEmissiveInfos\",\r\n            \"vReflectivityInfos\",\r\n            \"vReflectionFilteringInfo\",\r\n            \"vMetallicReflectanceInfos\",\r\n            \"vReflectanceInfos\",\r\n            \"vMicroSurfaceSamplerInfos\",\r\n            \"vBumpInfos\",\r\n            \"vLightmapInfos\",\r\n            \"mBones\",\r\n            \"albedoMatrix\",\r\n            \"baseWeightMatrix\",\r\n            \"baseDiffuseRoughnessMatrix\",\r\n            \"ambientMatrix\",\r\n            \"opacityMatrix\",\r\n            \"reflectionMatrix\",\r\n            \"emissiveMatrix\",\r\n            \"reflectivityMatrix\",\r\n            \"normalMatrix\",\r\n            \"microSurfaceSamplerMatrix\",\r\n            \"bumpMatrix\",\r\n            \"lightmapMatrix\",\r\n            \"metallicReflectanceMatrix\",\r\n            \"reflectanceMatrix\",\r\n            \"vLightingIntensity\",\r\n            \"logarithmicDepthConstant\",\r\n            \"vSphericalX\",\r\n            \"vSphericalY\",\r\n            \"vSphericalZ\",\r\n            \"vSphericalXX_ZZ\",\r\n            \"vSphericalYY_ZZ\",\r\n            \"vSphericalZZ\",\r\n            \"vSphericalXY\",\r\n            \"vSphericalYZ\",\r\n            \"vSphericalZX\",\r\n            \"vSphericalL00\",\r\n            \"vSphericalL1_1\",\r\n            \"vSphericalL10\",\r\n            \"vSphericalL11\",\r\n            \"vSphericalL2_2\",\r\n            \"vSphericalL2_1\",\r\n            \"vSphericalL20\",\r\n            \"vSphericalL21\",\r\n            \"vSphericalL22\",\r\n            \"vReflectionMicrosurfaceInfos\",\r\n            \"vReflectionDominantDirection\",\r\n            \"vTangentSpaceParams\",\r\n            \"boneTextureWidth\",\r\n            \"vDebugMode\",\r\n            \"morphTargetTextureInfo\",\r\n            \"morphTargetTextureIndices\",\r\n            \"cameraInfo\",\r\n        ];\r\n\r\n        const samplers = [\r\n            \"albedoSampler\",\r\n            \"baseWeightSampler\",\r\n            \"baseDiffuseRoughnessSampler\",\r\n            \"reflectivitySampler\",\r\n            \"ambientSampler\",\r\n            \"emissiveSampler\",\r\n            \"bumpSampler\",\r\n            \"lightmapSampler\",\r\n            \"opacitySampler\",\r\n            \"reflectionSampler\",\r\n            \"reflectionSamplerLow\",\r\n            \"reflectionSamplerHigh\",\r\n            \"irradianceSampler\",\r\n            \"microSurfaceSampler\",\r\n            \"environmentBrdfSampler\",\r\n            \"boneSampler\",\r\n            \"metallicReflectanceSampler\",\r\n            \"reflectanceSampler\",\r\n            \"morphTargets\",\r\n            \"oitDepthSampler\",\r\n            \"oitFrontColorSampler\",\r\n            \"icdfSampler\",\r\n            \"areaLightsLTC1Sampler\",\r\n            \"areaLightsLTC2Sampler\",\r\n        ];\r\n\r\n        const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n        this._eventInfo.fallbacks = fallbacks;\r\n        this._eventInfo.fallbackRank = fallbackRank;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.uniforms = uniforms;\r\n        this._eventInfo.attributes = attribs;\r\n        this._eventInfo.samplers = samplers;\r\n        this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n        this._eventInfo.customCode = undefined;\r\n        this._eventInfo.mesh = mesh;\r\n        this._eventInfo.indexParameters = indexParameters;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);\r\n\r\n        PrePassConfiguration.AddUniforms(uniforms);\r\n        PrePassConfiguration.AddSamplers(samplers);\r\n        AddClipPlaneUniforms(uniforms);\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n        }\r\n\r\n        PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n            uniformsNames: uniforms,\r\n            uniformBuffersNames: uniformBuffers,\r\n            samplers: samplers,\r\n            defines: defines,\r\n            maxSimultaneousLights: this._maxSimultaneousLights,\r\n        });\r\n\r\n        const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n        if (this.customShaderNameResolve) {\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n        }\r\n\r\n        const join = defines.toString();\r\n        const effect = engine.createEffect(\r\n            shaderName,\r\n            <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: onCompiled,\r\n                onError: onError,\r\n                indexParameters,\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                processCodeAfterIncludes: this._eventInfo.customCode,\r\n                multiTarget: defines.PREPASS,\r\n                shaderLanguage: this._shaderLanguage,\r\n                extraInitializationsAsync: this._shadersLoaded\r\n                    ? undefined\r\n                    : async () => {\r\n                          if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                              await Promise.all([import(\"../../ShadersWGSL/pbr.vertex\"), import(\"../../ShadersWGSL/pbr.fragment\")]);\r\n                          } else {\r\n                              await Promise.all([import(\"../../Shaders/pbr.vertex\"), import(\"../../Shaders/pbr.fragment\")]);\r\n                          }\r\n\r\n                          this._shadersLoaded = true;\r\n                      },\r\n            },\r\n            engine\r\n        );\r\n\r\n        this._eventInfo.customCode = undefined;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _prepareDefines(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): void {\r\n        const useThinInstances = renderingMesh.hasThinInstances;\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);\r\n\r\n        // Textures\r\n        defines.METALLICWORKFLOW = this.isMetallicWorkflow();\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                defines.ALBEDODIRECTUV = 0;\r\n                defines.BASE_WEIGHTDIRECTUV = 0;\r\n                defines.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;\r\n                defines.AMBIENTDIRECTUV = 0;\r\n                defines.OPACITYDIRECTUV = 0;\r\n                defines.EMISSIVEDIRECTUV = 0;\r\n                defines.REFLECTIVITYDIRECTUV = 0;\r\n                defines.MICROSURFACEMAPDIRECTUV = 0;\r\n                defines.METALLIC_REFLECTANCEDIRECTUV = 0;\r\n                defines.REFLECTANCEDIRECTUV = 0;\r\n                defines.BUMPDIRECTUV = 0;\r\n                defines.LIGHTMAPDIRECTUV = 0;\r\n\r\n                if (engine.getCaps().textureLOD) {\r\n                    defines.LODBASEDMICROSFURACE = true;\r\n                }\r\n\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\r\n                    defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\r\n                } else {\r\n                    defines.ALBEDO = false;\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._baseWeightTexture, defines, \"BASE_WEIGHT\");\r\n                } else {\r\n                    defines.BASE_WEIGHT = false;\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._baseDiffuseRoughnessTexture, defines, \"BASE_DIFFUSE_ROUGHNESS\");\r\n                } else {\r\n                    defines.BASE_DIFFUSE_ROUGHNESS = false;\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                    defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.REFLECTION = true;\r\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\r\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\r\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\r\n                    defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\r\n                    defines.USEIRRADIANCEMAP = false;\r\n\r\n                    if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {\r\n                        defines.NUM_SAMPLES = \"\" + this.realTimeFilteringQuality;\r\n                        if (engine._features.needTypeSuffixInShaderConstants) {\r\n                            defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\r\n                        }\r\n\r\n                        defines.REALTIME_FILTERING = true;\r\n                        if (this.getScene().iblCdfGenerator) {\r\n                            defines.IBL_CDF_FILTERING = true;\r\n                        }\r\n                    } else {\r\n                        defines.REALTIME_FILTERING = false;\r\n                    }\r\n\r\n                    defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\r\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\r\n\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n\r\n                    switch (reflectionTexture.coordinatesMode) {\r\n                        case Texture.EXPLICIT_MODE:\r\n                            defines.REFLECTIONMAP_EXPLICIT = true;\r\n                            break;\r\n                        case Texture.PLANAR_MODE:\r\n                            defines.REFLECTIONMAP_PLANAR = true;\r\n                            break;\r\n                        case Texture.PROJECTION_MODE:\r\n                            defines.REFLECTIONMAP_PROJECTION = true;\r\n                            break;\r\n                        case Texture.SKYBOX_MODE:\r\n                            defines.REFLECTIONMAP_SKYBOX = true;\r\n                            break;\r\n                        case Texture.SPHERICAL_MODE:\r\n                            defines.REFLECTIONMAP_SPHERICAL = true;\r\n                            break;\r\n                        case Texture.EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.CUBIC_MODE:\r\n                        case Texture.INVCUBIC_MODE:\r\n                        default:\r\n                            defines.REFLECTIONMAP_CUBIC = true;\r\n                            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>reflectionTexture).boundingBoxSize ? true : false;\r\n                            break;\r\n                    }\r\n\r\n                    if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n                        if (reflectionTexture.irradianceTexture) {\r\n                            defines.USEIRRADIANCEMAP = true;\r\n                            defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n                            defines.USESPHERICALINVERTEX = false;\r\n                            if (reflectionTexture.irradianceTexture._dominantDirection) {\r\n                                defines.USE_IRRADIANCE_DOMINANT_DIRECTION = true;\r\n                            }\r\n                        }\r\n                        // Assume using spherical polynomial if the reflection texture is a cube map\r\n                        else if (reflectionTexture.isCube) {\r\n                            defines.USESPHERICALFROMREFLECTIONMAP = true;\r\n                            defines.USEIRRADIANCEMAP = false;\r\n                            defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n                            if (\r\n                                this._forceIrradianceInFragment ||\r\n                                this.realTimeFiltering ||\r\n                                this._twoSidedLighting ||\r\n                                engine.getCaps().maxVaryingVectors <= 8 ||\r\n                                this._baseDiffuseRoughnessTexture\r\n                            ) {\r\n                                defines.USESPHERICALINVERTEX = false;\r\n                            } else {\r\n                                defines.USESPHERICALINVERTEX = true;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONMAP_3D = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n                    defines.INVERTCUBICMAP = false;\r\n                    defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n                    defines.USEIRRADIANCEMAP = false;\r\n                    defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n                    defines.USESPHERICALINVERTEX = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                    defines.LODINREFLECTIONALPHA = false;\r\n                    defines.GAMMAREFLECTION = false;\r\n                    defines.RGBDREFLECTION = false;\r\n                    defines.LINEARSPECULARREFLECTION = false;\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                    defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                    defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\r\n                    defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\r\n                        defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\r\n                        defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\r\n                        defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\r\n                        defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\r\n                        defines.REFLECTIVITY_GAMMA = false;\r\n                    } else if (this._reflectivityTexture) {\r\n                        PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\r\n                        defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\r\n                        defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\r\n                        defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;\r\n                    } else {\r\n                        defines.REFLECTIVITY = false;\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture || this._reflectanceTexture) {\r\n                        defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;\r\n                        if (this._metallicReflectanceTexture) {\r\n                            PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\r\n                            defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.METALLIC_REFLECTANCE = false;\r\n                        }\r\n                        if (\r\n                            this._reflectanceTexture &&\r\n                            (!this._metallicReflectanceTexture || (this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture))\r\n                        ) {\r\n                            PrepareDefinesForMergedUV(this._reflectanceTexture, defines, \"REFLECTANCE\");\r\n                            defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.REFLECTANCE = false;\r\n                        }\r\n                    } else {\r\n                        defines.METALLIC_REFLECTANCE = false;\r\n                        defines.REFLECTANCE = false;\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\r\n                    } else {\r\n                        defines.MICROSURFACEMAP = false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTIVITY = false;\r\n                    defines.MICROSURFACEMAP = false;\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                    if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        defines.PARALLAX = true;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\r\n                    } else {\r\n                        defines.PARALLAX = false;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                    defines.OBJECTSPACE_NORMALMAP = false;\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.ENVIRONMENTBRDF = true;\r\n                    defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\r\n                } else {\r\n                    defines.ENVIRONMENTBRDF = false;\r\n                    defines.ENVIRONMENTBRDF_RGBD = false;\r\n                }\r\n\r\n                if (this._shouldUseAlphaFromAlbedoTexture()) {\r\n                    defines.ALPHAFROMALBEDO = true;\r\n                } else {\r\n                    defines.ALPHAFROMALBEDO = false;\r\n                }\r\n            }\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = true;\r\n            } else {\r\n                defines.USEPHYSICALLIGHTFALLOFF = true;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            }\r\n\r\n            defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\r\n\r\n            if (!this.backFaceCulling && this._twoSidedLighting) {\r\n                defines.TWOSIDEDLIGHTING = true;\r\n            } else {\r\n                defines.TWOSIDEDLIGHTING = false;\r\n            }\r\n\r\n            // We need it to not invert normals in two sided lighting mode (based on the winding of the face)\r\n            defines.MIRRORED = !!scene._mirroredCameraPosition;\r\n\r\n            defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\r\n        }\r\n\r\n        if (defines._areTexturesDirty || defines._areMiscDirty) {\r\n            defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\r\n            defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\r\n            defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        defines.FORCENORMALFORWARD = this._forceNormalForward;\r\n\r\n        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\r\n\r\n        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            PrepareDefinesForMisc(\r\n                mesh,\r\n                scene,\r\n                this._useLogarithmicDepth,\r\n                this.pointsCloud,\r\n                this.fogEnabled,\r\n                this.needAlphaTestingForMesh(mesh),\r\n                defines,\r\n                this._applyDecalMapAfterDetailMap,\r\n                this._useVertexPulling,\r\n                renderingMesh\r\n            );\r\n            defines.UNLIT = this._unlit || ((this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n            defines.DEBUGMODE = this._debugMode;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh - Define the mesh we want to force the compilation for\r\n     * @param onCompiled - Define a callback triggered when the compilation completes\r\n     * @param options - Define the options used to create the compilation\r\n     */\r\n    public override forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n        const checkReady = () => {\r\n            if (this._breakShaderLoadedCheck) {\r\n                return;\r\n            }\r\n            const defines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n            const effect = this._prepareEffect(mesh, mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane)!;\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n            if (effect.isReady()) {\r\n                if (onCompiled) {\r\n                    onCompiled(this);\r\n                }\r\n            } else {\r\n                effect.onCompileObservable.add(() => {\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public override buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"vAlbedoInfos\", 2);\r\n        ubo.addUniform(\"vBaseWeightInfos\", 2);\r\n        ubo.addUniform(\"vBaseDiffuseRoughnessInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 4);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vReflectivityInfos\", 3);\r\n        ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionFilteringInfo\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n        ubo.addUniform(\"albedoMatrix\", 16);\r\n        ubo.addUniform(\"baseWeightMatrix\", 16);\r\n        ubo.addUniform(\"baseDiffuseRoughnessMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"reflectivityMatrix\", 16);\r\n        ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n\r\n        ubo.addUniform(\"vReflectionColor\", 3);\r\n        ubo.addUniform(\"vAlbedoColor\", 4);\r\n        ubo.addUniform(\"baseWeight\", 1);\r\n        ubo.addUniform(\"baseDiffuseRoughness\", 1);\r\n        ubo.addUniform(\"vLightingIntensity\", 4);\r\n\r\n        ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\r\n        ubo.addUniform(\"vReflectionDominantDirection\", 3);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"vReflectivityColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"vAmbientColor\", 3);\r\n\r\n        ubo.addUniform(\"vDebugMode\", 2);\r\n\r\n        ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\r\n        ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\r\n        ubo.addUniform(\"metallicReflectanceMatrix\", 16);\r\n        ubo.addUniform(\"vReflectanceInfos\", 2);\r\n        ubo.addUniform(\"reflectanceMatrix\", 16);\r\n\r\n        ubo.addUniform(\"vSphericalL00\", 3);\r\n        ubo.addUniform(\"vSphericalL1_1\", 3);\r\n        ubo.addUniform(\"vSphericalL10\", 3);\r\n        ubo.addUniform(\"vSphericalL11\", 3);\r\n        ubo.addUniform(\"vSphericalL2_2\", 3);\r\n        ubo.addUniform(\"vSphericalL2_1\", 3);\r\n        ubo.addUniform(\"vSphericalL20\", 3);\r\n        ubo.addUniform(\"vSphericalL21\", 3);\r\n        ubo.addUniform(\"vSphericalL22\", 3);\r\n\r\n        ubo.addUniform(\"vSphericalX\", 3);\r\n        ubo.addUniform(\"vSphericalY\", 3);\r\n        ubo.addUniform(\"vSphericalZ\", 3);\r\n        ubo.addUniform(\"vSphericalXX_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalYY_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalZZ\", 3);\r\n        ubo.addUniform(\"vSphericalXY\", 3);\r\n        ubo.addUniform(\"vSphericalYZ\", 3);\r\n        ubo.addUniform(\"vSphericalZX\", 3);\r\n\r\n        ubo.addUniform(\"cameraInfo\", 4);\r\n\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh data.\r\n     * @param world - The world matrix.\r\n     * @param mesh - The BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);\r\n\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", camera.minZ, camera.maxZ, 0, 0);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", 0, 0, 0, 0);\r\n        }\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\r\n\r\n        let reflectionTexture: Nullable<BaseTexture> = null;\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            reflectionTexture = this._getReflectionTexture();\r\n\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\r\n                        BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\r\n                    }\r\n\r\n                    if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                        ubo.updateFloat2(\"vBaseWeightInfos\", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);\r\n                        BindTextureMatrix(this._baseWeightTexture, ubo, \"baseWeight\");\r\n                    }\r\n\r\n                    if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                        ubo.updateFloat2(\"vBaseDiffuseRoughnessInfos\", this._baseDiffuseRoughnessTexture.coordinatesIndex, this._baseDiffuseRoughnessTexture.level);\r\n                        BindTextureMatrix(this._baseDiffuseRoughnessTexture, ubo, \"baseDiffuseRoughness\");\r\n                    }\r\n\r\n                    if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                        ubo.updateFloat4(\r\n                            \"vAmbientInfos\",\r\n                            this._ambientTexture.coordinatesIndex,\r\n                            this._ambientTexture.level,\r\n                            this._ambientTextureStrength,\r\n                            this._ambientTextureImpactOnAnalyticalLights\r\n                        );\r\n                        BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                        ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\r\n                        ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level * scene.iblIntensity, 0);\r\n\r\n                        if ((<any>reflectionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>reflectionTexture;\r\n\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n\r\n                        if (this.realTimeFiltering) {\r\n                            const width = reflectionTexture.getSize().width;\r\n                            ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Math.log2(width));\r\n                        }\r\n\r\n                        if (!defines.USEIRRADIANCEMAP) {\r\n                            const polynomials = reflectionTexture.sphericalPolynomial;\r\n                            if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n                                if (defines.SPHERICAL_HARMONICS) {\r\n                                    const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                                    ubo.updateVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                                    ubo.updateVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                                    ubo.updateVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                                    ubo.updateVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                                    ubo.updateVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                                    ubo.updateVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                                    ubo.updateVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                                    ubo.updateVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                                    ubo.updateVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n                                } else {\r\n                                    ubo.updateFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                                    ubo.updateFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                                    ubo.updateFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                                    ubo.updateFloat3(\r\n                                        \"vSphericalXX_ZZ\",\r\n                                        polynomials.xx.x - polynomials.zz.x,\r\n                                        polynomials.xx.y - polynomials.zz.y,\r\n                                        polynomials.xx.z - polynomials.zz.z\r\n                                    );\r\n                                    ubo.updateFloat3(\r\n                                        \"vSphericalYY_ZZ\",\r\n                                        polynomials.yy.x - polynomials.zz.x,\r\n                                        polynomials.yy.y - polynomials.zz.y,\r\n                                        polynomials.yy.z - polynomials.zz.z\r\n                                    );\r\n                                    ubo.updateFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                                    ubo.updateFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                                    ubo.updateFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                                    ubo.updateFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // If we're using an irradiance map with a dominant direction assigned, set it.\r\n                            if (defines.USEIRRADIANCEMAP && defines.USE_IRRADIANCE_DOMINANT_DIRECTION) {\r\n                                ubo.updateVector3(\"vReflectionDominantDirection\", reflectionTexture.irradianceTexture!._dominantDirection!);\r\n                            }\r\n                        }\r\n\r\n                        ubo.updateFloat3(\r\n                            \"vReflectionMicrosurfaceInfos\",\r\n                            reflectionTexture.getSize().width,\r\n                            reflectionTexture.lodGenerationScale,\r\n                            reflectionTexture.lodGenerationOffset\r\n                        );\r\n                    }\r\n\r\n                    if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (MaterialFlags.SpecularTextureEnabled) {\r\n                        if (this._metallicTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\r\n                            BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\r\n                        } else if (this._reflectivityTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\r\n                            BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\r\n                        }\r\n\r\n                        if (this._metallicReflectanceTexture) {\r\n                            ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\r\n                            BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\r\n                        }\r\n\r\n                        if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                            ubo.updateFloat2(\"vReflectanceInfos\", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);\r\n                            BindTextureMatrix(this._reflectanceTexture, ubo, \"reflectance\");\r\n                        }\r\n\r\n                        if (this._microSurfaceTexture) {\r\n                            ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\r\n                            BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\r\n                        }\r\n                    }\r\n\r\n                    if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\r\n                        BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                // Colors\r\n                if (defines.METALLICWORKFLOW) {\r\n                    TmpColors.Color4[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\r\n                    TmpColors.Color4[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\r\n                    const ior = this.subSurface?._indexOfRefraction ?? 1.5;\r\n                    const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\r\n                    TmpColors.Color4[0].b = ior;\r\n                    // We are here deriving our default reflectance from a common value for none metallic surface.\r\n                    // Based of the schlick fresnel approximation model\r\n                    // for dielectrics.\r\n                    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\r\n                    TmpColors.Color4[0].a = f0;\r\n                    ubo.updateDirectColor4(\"vReflectivityColor\", TmpColors.Color4[0]);\r\n                    ubo.updateColor4(\"vMetallicReflectanceFactors\", this._metallicReflectanceColor, this._metallicF0Factor);\r\n                } else {\r\n                    ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\r\n                }\r\n\r\n                ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\r\n                ubo.updateColor3(\"vReflectionColor\", this._reflectionColor);\r\n                if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\r\n                } else {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\r\n                }\r\n\r\n                ubo.updateFloat(\"baseWeight\", this._baseWeight);\r\n                ubo.updateFloat(\"baseDiffuseRoughness\", this._baseDiffuseRoughness || 0.0);\r\n\r\n                // Misc\r\n                this._lightingInfos.x = this._directIntensity;\r\n                this._lightingInfos.y = this._emissiveIntensity;\r\n                this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\r\n                this._lightingInfos.w = this._specularIntensity;\r\n\r\n                ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\r\n\r\n                // Colors\r\n                scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\r\n\r\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n\r\n                ubo.updateFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    ubo.setTexture(\"albedoSampler\", this._albedoTexture);\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    ubo.setTexture(\"baseWeightSampler\", this._baseWeightTexture);\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    ubo.setTexture(\"baseDiffuseRoughnessSampler\", this._baseDiffuseRoughnessTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    ubo.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    ubo.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (defines.LODBASEDMICROSFURACE) {\r\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else {\r\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\r\n                        ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\r\n                        ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\r\n                    }\r\n\r\n                    if (defines.USEIRRADIANCEMAP) {\r\n                        ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\r\n                    }\r\n\r\n                    //if realtime filtering and using CDF maps, set them.\r\n                    const cdfGenerator = this.getScene().iblCdfGenerator;\r\n                    if (this.realTimeFiltering && cdfGenerator) {\r\n                        ubo.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\r\n                    }\r\n                }\r\n\r\n                if (defines.ENVIRONMENTBRDF) {\r\n                    ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\r\n                    } else if (this._reflectivityTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\r\n                    }\r\n\r\n                    if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                        ubo.setTexture(\"reflectanceSampler\", this._reflectanceTexture);\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    ubo.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if (\r\n                (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\r\n                reflectionTexture ||\r\n                this.subSurface.refractionTexture ||\r\n                mesh.receiveShadows ||\r\n                defines.PREPASS\r\n            ) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                BindMorphTargetParameters(mesh, this._activeEffect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // image processing\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n\r\n            // Log. depth\r\n            BindLogDepth(defines, this._activeEffect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\r\n            results.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {\r\n            results.push(this._baseWeightTexture);\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture && this._baseDiffuseRoughnessTexture.animations && this._baseDiffuseRoughnessTexture.animations.length > 0) {\r\n            results.push(this._baseDiffuseRoughnessTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\r\n            results.push(this._metallicTexture);\r\n        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\r\n            results.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {\r\n            results.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {\r\n            results.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {\r\n            results.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for reflections.\r\n     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\r\n     */\r\n    private _getReflectionTexture(): Nullable<BaseTexture> {\r\n        if (this._reflectionTexture) {\r\n            return this._reflectionTexture;\r\n        }\r\n\r\n        return this.getScene().environmentTexture;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @returns - Array of BaseTextures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._albedoTexture) {\r\n            activeTextures.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._baseWeightTexture) {\r\n            activeTextures.push(this._baseWeightTexture);\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture) {\r\n            activeTextures.push(this._baseDiffuseRoughnessTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._reflectivityTexture) {\r\n            activeTextures.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._metallicTexture) {\r\n            activeTextures.push(this._metallicTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture) {\r\n            activeTextures.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture) {\r\n            activeTextures.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture) {\r\n            activeTextures.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._albedoTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._baseWeightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectivityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._microSurfaceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * It can't be sets when subsurface scattering of this material is disabled.\r\n     * When scene have ability to enable subsurface prepass effect, it will enable.\r\n     * @returns - If prepass is enabled or not.\r\n     */\r\n    public override setPrePassRenderer(): boolean {\r\n        if (!this.subSurface?.isScatteringEnabled) {\r\n            return false;\r\n        }\r\n\r\n        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\r\n        if (subSurfaceConfiguration) {\r\n            subSurfaceConfiguration.enabled = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeEffect - Forces the disposal of effects.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        this._breakShaderLoadedCheck = true;\r\n        if (forceDisposeTextures) {\r\n            if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\r\n                this._environmentBRDFTexture.dispose();\r\n            }\r\n\r\n            this._albedoTexture?.dispose();\r\n            this._baseWeightTexture?.dispose();\r\n            this._baseDiffuseRoughnessTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._metallicTexture?.dispose();\r\n            this._reflectivityTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._metallicReflectanceTexture?.dispose();\r\n            this._reflectanceTexture?.dispose();\r\n            this._microSurfaceTexture?.dispose();\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n}\r\n", "import { serialize, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { ColorCurves } from \"../../Materials/colorCurves\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Material } from \"../material\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * The Physically based material of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n */\r\nexport class PBRMaterial extends PBRBaseMaterial {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static override readonly PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static override readonly PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static override readonly PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static override readonly PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static override DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * OpenPBR Base Weight texture (multiplier to the diffuse and metal lobes).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public baseWeightTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * OpenPBR Base Diffuse Roughness texture (roughness of the diffuse lobe).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public baseDiffuseRoughnessTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureImpactOnAnalyticalLights: number = PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallic: Nullable<number>;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number>;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     */\r\n    @serializeAsColor3()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If useOnlyMetallicFromMetallicReflectanceTexture is true, don't use the RGB channels, only A\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both reflectanceTexture and metallicReflectanceTexture textures are provided and useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, metallicReflectanceTexture takes priority and reflectanceTexture is not used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurfaceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the refracted light information in a texture.\r\n     */\r\n    public get refractionTexture(): Nullable<BaseTexture> {\r\n        return this.subSurface.refractionTexture;\r\n    }\r\n    public set refractionTexture(value: Nullable<BaseTexture>) {\r\n        this.subSurface.refractionTexture = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        } else if (!this.subSurface.linkRefractionWithTransparency) {\r\n            this.subSurface.isRefractionEnabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"albedo\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * OpenPBR Base Weight (multiplier to the diffuse and metal lobes).\r\n     */\r\n    @serialize(\"baseWeight\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public baseWeight = 1;\r\n\r\n    /**\r\n     * OpenPBR Base Diffuse Roughness (roughness of the diffuse lobe).\r\n     */\r\n    @serialize(\"baseDiffuseRoughness\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public baseDiffuseRoughness: Nullable<number>;\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"reflectivity\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color reflected from the material.\r\n     */\r\n    @serializeAsColor3(\"reflection\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionColor = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The color emitted from the material.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurface = 1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    public get indexOfRefraction(): number {\r\n        return this.subSurface.indexOfRefraction;\r\n    }\r\n    public set indexOfRefraction(value: number) {\r\n        this.subSurface.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    public get invertRefractionY(): boolean {\r\n        return this.subSurface.invertRefractionY;\r\n    }\r\n    public set invertRefractionY(value: boolean) {\r\n        this.subSurface.invertRefractionY = value;\r\n    }\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    public get linkRefractionWithTransparency(): boolean {\r\n        return this.subSurface.linkRefractionWithTransparency;\r\n    }\r\n    public set linkRefractionWithTransparency(value: boolean) {\r\n        this.subSurface.linkRefractionWithTransparency = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public forceAlphaTest = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     * Needs useRoughnessFromMetallicTextureAlpha to be false.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    @serialize()\r\n    public get usePhysicalLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n    }\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    public set usePhysicalLightFalloff(value: boolean) {\r\n        if (value !== this.usePhysicalLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    @serialize()\r\n    public get useGLTFLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    public set useGLTFLightFalloff(value: boolean) {\r\n        if (value !== this.useGLTFLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceIrradianceInFragment = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Let user defines the brdf lookup texture used for IBL.\r\n     * A default 8bit version is embedded but you could point at :\r\n     * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png\r\n     * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png\r\n     * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap = false;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsImageProcessingDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Scene, forceGLSL = false) {\r\n        super(name, scene, forceGLSL);\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n    }\r\n\r\n    /**\r\n     * @returns the name of this material class.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PBRMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name - name to use for the new material.\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns cloned material instance\r\n     */\r\n    public override clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): PBRMaterial {\r\n        const clone = SerializationHelper.Clone(() => new PBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        this.stencil.copyTo(clone.stencil);\r\n\r\n        this._clonePlugins(clone, rootUrl);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this PBR Material.\r\n     * @returns - An object with the serialized material.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.PBRMaterial\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Parses a PBR Material from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene - BJS scene instance.\r\n     * @param rootUrl - url for the scene object\r\n     * @returns - PBRMaterial\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): PBRMaterial {\r\n        const material = SerializationHelper.Parse(() => new PBRMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._ParsePlugins(source, material, scene, rootUrl);\r\n\r\n        // The code block below ensures backward compatibility with serialized materials before plugins are automatically serialized.\r\n        if (source.clearCoat) {\r\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\r\n        }\r\n        if (source.anisotropy) {\r\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\r\n        }\r\n        if (source.brdf) {\r\n            material.brdf.parse(source.brdf, scene, rootUrl);\r\n        }\r\n        if (source.sheen) {\r\n            material.sheen.parse(source.sheen, scene, rootUrl);\r\n        }\r\n        if (source.subSurface) {\r\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\r\n        }\r\n        if (source.iridescence) {\r\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRMaterial\", PBRMaterial);\r\n", "import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _uv2s: Nullable<FloatArray> = null;\r\n    private _colors: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this.id = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates 2 data\r\n     */\r\n    public get hasUV2s(): boolean {\r\n        return !!this._uv2s;\r\n    }\r\n\r\n    public get hasColors(): boolean {\r\n        return !!this._colors;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices stored in this target\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._positions\r\n            ? this._positions.length / 3\r\n            : this._normals\r\n              ? this._normals.length / 3\r\n              : this._tangents\r\n                ? this._tangents.length / 3\r\n                : this._uvs\r\n                  ? this._uvs.length / 2\r\n                  : this._uv2s\r\n                    ? this._uv2s.length / 2\r\n                    : this._colors\r\n                      ? this._colors.length / 4\r\n                      : 0;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates 2 data to this target\r\n     * @param data defines the texture coordinates 2 data to use\r\n     */\r\n    public setUV2s(data: Nullable<FloatArray>) {\r\n        const hadUV2s = this.hasUV2s;\r\n\r\n        this._uv2s = data;\r\n\r\n        if (hadUV2s !== this.hasUV2s) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates 2 data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates 2 data (or null if not present)\r\n     */\r\n    public getUV2s(): Nullable<FloatArray> {\r\n        return this._uv2s;\r\n    }\r\n\r\n    /**\r\n     * Affects color data to this target\r\n     * @param data defines the color data to use\r\n     */\r\n    public setColors(data: Nullable<FloatArray>) {\r\n        const hadColors = this.hasColors;\r\n\r\n        this._colors = data;\r\n\r\n        if (hadColors !== this.hasColors) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color data stored in this target\r\n     * @returns a FloatArray containing the color data (or null if not present)\r\n     */\r\n    public getColors(): Nullable<FloatArray> {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n        newOne._uv2s = this._uv2s;\r\n        newOne._colors = this._colors;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n        if (this.hasUV2s) {\r\n            serializationObject.uv2s = Array.prototype.slice.call(this.getUV2s());\r\n        }\r\n        if (this.hasColors) {\r\n            serializationObject.colors = Array.prototype.slice.call(this.getColors());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n        if (serializationObject.uv2s) {\r\n            result.setUV2s(serializationObject.uv2s);\r\n        }\r\n        if (serializationObject.colors) {\r\n            result.setColors(serializationObject.colors);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.setUV2s(<FloatArray>mesh.getVerticesData(VertexBuffer.UV2Kind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.setColors(<FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTargetManager implements IDisposable {\r\n    /** Enable storing morph target data into textures when set to true (true by default) */\r\n    public static EnableTextureStorage = true;\r\n\r\n    /** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\r\n    public static MaxActiveMorphTargetsInVertexAttributeMode = 8;\r\n\r\n    /**\r\n     * When used in texture mode, if greather than 0, this will override the the morph manager numMaxInfluencers value.\r\n     */\r\n    public static ConstantTargetCountForTextureMode = 0;\r\n\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _supportsPositions = false;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _supportsUV2s = false;\r\n    private _supportsColors = false;\r\n    private _vertexCount = 0;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n    private _canUseTextureForTargets = false;\r\n    private _blockCounter = 0;\r\n    private _mustSynchronize = true;\r\n    private _forceUpdateWhenUnfrozen = false;\r\n\r\n    /** @internal */\r\n    public _textureVertexStride = 0;\r\n\r\n    /** @internal */\r\n    public _textureWidth = 0;\r\n\r\n    /** @internal */\r\n    public _textureHeight = 1;\r\n\r\n    /** @internal */\r\n    public _morphTargetTextureIndices: Float32Array;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _targetStoreTexture: Nullable<RawTexture2DArray>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\r\n     */\r\n    public optimizeInfluencers = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if positions must be morphed\r\n     */\r\n    public enablePositionMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV2 must be morphed\r\n     */\r\n    public enableUV2Morphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if colors must be morphed\r\n     */\r\n    public enableColorMorphing = true;\r\n\r\n    /**\r\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\r\n     */\r\n    public set areUpdatesFrozen(block: boolean) {\r\n        if (block) {\r\n            this._blockCounter++;\r\n        } else {\r\n            this._blockCounter--;\r\n            if (this._blockCounter <= 0) {\r\n                this._blockCounter = 0;\r\n\r\n                this._syncActiveTargets(this._forceUpdateWhenUnfrozen);\r\n                this._forceUpdateWhenUnfrozen = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public get areUpdatesFrozen() {\r\n        return this._blockCounter > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.addMorphTargetManager(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n\r\n            const engineCaps = this._scene.getEngine().getCaps();\r\n            this._canUseTextureForTargets =\r\n                engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\r\n        }\r\n    }\r\n\r\n    private _numMaxInfluencers = 0;\r\n\r\n    /**\r\n     * Gets or sets the maximum number of influencers (targets) (default value: 0).\r\n     * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.\r\n     * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.\r\n     * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.\r\n     * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.\r\n     * Note that this property has no effect if \"useTextureToStoreTargets\" is false.\r\n     * Note as well that if MorphTargetManager.ConstantTargetCountForTextureMode is greater than 0, this property will be ignored and the constant value will be used instead.\r\n     */\r\n    public get numMaxInfluencers(): number {\r\n        if (MorphTargetManager.ConstantTargetCountForTextureMode > 0 && this.isUsingTextureForTargets) {\r\n            return MorphTargetManager.ConstantTargetCountForTextureMode;\r\n        }\r\n        return this._numMaxInfluencers;\r\n    }\r\n\r\n    public set numMaxInfluencers(value: number) {\r\n        if (this._numMaxInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._numMaxInfluencers = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of positions\r\n     */\r\n    public get supportsPositions(): boolean {\r\n        return this._supportsPositions && this.enablePositionMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates 2\r\n     */\r\n    public get supportsUV2s(): boolean {\r\n        return this._supportsUV2s && this.enableUV2Morphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of colors\r\n     */\r\n    public get supportsColors(): boolean {\r\n        return this._supportsColors && this.enableColorMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing positions\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return this._supportsPositions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing normals\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return this._supportsNormals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing tangents\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return this._supportsTangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return this._supportsUVs;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates 2\r\n     */\r\n    public get hasUV2s(): boolean {\r\n        return this._supportsUV2s;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing colors\r\n     */\r\n    public get hasColors(): boolean {\r\n        return this._supportsColors;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        return this._influences;\r\n    }\r\n\r\n    private _useTextureToStoreTargets = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreTargets(): boolean {\r\n        return this._useTextureToStoreTargets;\r\n    }\r\n\r\n    public set useTextureToStoreTargets(value: boolean) {\r\n        if (this._useTextureToStoreTargets === value) {\r\n            return;\r\n        }\r\n        this._useTextureToStoreTargets = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\r\n     */\r\n    public get isUsingTextureForTargets() {\r\n        return (\r\n            MorphTargetManager.EnableTextureStorage &&\r\n            this.useTextureToStoreTargets &&\r\n            this._canUseTextureForTargets &&\r\n            !this._scene?.getEngine().getCaps().disableMorphTargetTexture\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the MorphTargetManager\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the first target with the specified name\r\n     * @param name defines the name to check\r\n     * @returns the requested target\r\n     */\r\n    public getTargetByName(name: string): Nullable<MorphTarget> {\r\n        for (const target of this._targets) {\r\n            if (target.name === name) {\r\n                return target;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(\r\n            target.onInfluenceChanged.add((needUpdate) => {\r\n                if (this.areUpdatesFrozen && needUpdate) {\r\n                    this._forceUpdateWhenUnfrozen = true;\r\n                }\r\n                this._syncActiveTargets(needUpdate);\r\n            })\r\n        );\r\n        this._targetDataLayoutChangedObservers.push(\r\n            target._onDataLayoutChanged.add(() => {\r\n                this._mustSynchronize = true;\r\n                this._syncActiveTargets();\r\n            })\r\n        );\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        const index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._mustSynchronize = true;\r\n            this._syncActiveTargets();\r\n        }\r\n\r\n        if (this._scene) {\r\n            this._scene.stopAnimation(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(effect: Effect) {\r\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\r\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\r\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\r\n        effect.setFloat(\"morphTargetCount\", this.numInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        const copy = new MorphTargetManager(this._scene);\r\n        copy.areUpdatesFrozen = true;\r\n\r\n        for (const target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n        copy.areUpdatesFrozen = false;\r\n\r\n        copy.enablePositionMorphing = this.enablePositionMorphing;\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n        copy.enableUV2Morphing = this.enableUV2Morphing;\r\n        copy.enableColorMorphing = this.enableColorMorphing;\r\n        copy.metadata = this.metadata;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (const target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate = false): void {\r\n        if (this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        const wasUsingTextureForTargets = !!this._targetStoreTexture;\r\n        const isUsingTextureForTargets = this.isUsingTextureForTargets;\r\n\r\n        if (this._mustSynchronize || wasUsingTextureForTargets !== isUsingTextureForTargets) {\r\n            this._mustSynchronize = false;\r\n            this.synchronize();\r\n        }\r\n\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n\r\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\r\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\r\n        }\r\n\r\n        let targetIndex = -1;\r\n        for (const target of this._targets) {\r\n            targetIndex++;\r\n            if (target.influence === 0 && this.optimizeInfluencers) {\r\n                continue;\r\n            }\r\n\r\n            if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\r\n                break;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n        }\r\n\r\n        if (this._morphTargetTextureIndices.length !== influenceCount) {\r\n            this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (let index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate && this._scene) {\r\n            for (const mesh of this._scene.meshes) {\r\n                if ((<any>mesh).morphTargetManager === this) {\r\n                    if (isUsingTextureForTargets) {\r\n                        mesh._markSubMeshesAsAttributesDirty();\r\n                    } else {\r\n                        (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene || this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._supportsPositions = true;\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._supportsUV2s = true;\r\n        this._supportsColors = true;\r\n        this._vertexCount = 0;\r\n\r\n        this._targetStoreTexture?.dispose();\r\n        this._targetStoreTexture = null;\r\n\r\n        if (this.isUsingTextureForTargets && this._targets.length > engine.getCaps().texture2DArrayMaxLayerCount) {\r\n            this.useTextureToStoreTargets = false;\r\n        }\r\n\r\n        for (const target of this._targets) {\r\n            this._supportsPositions = this._supportsPositions && target.hasPositions;\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n            this._supportsUV2s = this._supportsUV2s && target.hasUV2s;\r\n            this._supportsColors = this._supportsColors && target.hasColors;\r\n\r\n            const vertexCount = target.vertexCount;\r\n            if (this._vertexCount === 0) {\r\n                this._vertexCount = vertexCount;\r\n            } else if (this._vertexCount !== vertexCount) {\r\n                Logger.Error(\r\n                    `Incompatible target. Targets must all have the same vertices count. Current vertex count: ${this._vertexCount}, vertex count for target \"${target.name}\": ${vertexCount}`\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this.isUsingTextureForTargets) {\r\n            this._textureVertexStride = 0;\r\n\r\n            this._supportsPositions && this._textureVertexStride++;\r\n            this._supportsNormals && this._textureVertexStride++;\r\n            this._supportsTangents && this._textureVertexStride++;\r\n            this._supportsUVs && this._textureVertexStride++;\r\n            this._supportsUV2s && this._textureVertexStride++;\r\n            this._supportsColors && this._textureVertexStride++;\r\n\r\n            this._textureWidth = this._vertexCount * this._textureVertexStride || 1;\r\n            this._textureHeight = 1;\r\n\r\n            const maxTextureSize = engine.getCaps().maxTextureSize;\r\n            if (this._textureWidth > maxTextureSize) {\r\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\r\n                this._textureWidth = maxTextureSize;\r\n            }\r\n\r\n            const targetCount = this._targets.length;\r\n            const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\r\n\r\n            let offset = 0;\r\n            for (let index = 0; index < targetCount; index++) {\r\n                const target = this._targets[index];\r\n\r\n                const positions = target.getPositions();\r\n                const normals = target.getNormals();\r\n                const uvs = target.getUVs();\r\n                const tangents = target.getTangents();\r\n                const uv2s = target.getUV2s();\r\n                const colors = target.getColors();\r\n\r\n                offset = index * this._textureWidth * this._textureHeight * 4;\r\n                for (let vertex = 0; vertex < this._vertexCount; vertex++) {\r\n                    if (this._supportsPositions && positions) {\r\n                        data[offset] = positions[vertex * 3];\r\n                        data[offset + 1] = positions[vertex * 3 + 1];\r\n                        data[offset + 2] = positions[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsNormals && normals) {\r\n                        data[offset] = normals[vertex * 3];\r\n                        data[offset + 1] = normals[vertex * 3 + 1];\r\n                        data[offset + 2] = normals[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUVs && uvs) {\r\n                        data[offset] = uvs[vertex * 2];\r\n                        data[offset + 1] = uvs[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsTangents && tangents) {\r\n                        data[offset] = tangents[vertex * 3];\r\n                        data[offset + 1] = tangents[vertex * 3 + 1];\r\n                        data[offset + 2] = tangents[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUV2s && uv2s) {\r\n                        data[offset] = uv2s[vertex * 2];\r\n                        data[offset + 1] = uv2s[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsColors && colors) {\r\n                        data[offset] = colors[vertex * 4];\r\n                        data[offset + 1] = colors[vertex * 4 + 1];\r\n                        data[offset + 2] = colors[vertex * 4 + 2];\r\n                        data[offset + 3] = colors[vertex * 4 + 3];\r\n                        offset += 4;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(\r\n                data,\r\n                this._textureWidth,\r\n                this._textureHeight,\r\n                targetCount,\r\n                this._scene,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                Constants.TEXTURETYPE_FLOAT\r\n            );\r\n            this._targetStoreTexture.name = `Morph texture_${this.uniqueId}`;\r\n        }\r\n\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (const mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose() {\r\n        if (this._targetStoreTexture) {\r\n            this._targetStoreTexture.dispose();\r\n        }\r\n\r\n        this._targetStoreTexture = null;\r\n        this.metadata = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            this._scene.removeMorphTargetManager(this);\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n\r\n            for (const morph of this._targets) {\r\n                this._scene.stopAnimation(morph);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        const result = new MorphTargetManager(scene);\r\n\r\n        for (const targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData, scene));\r\n        }\r\n\r\n        if (serializationObject.metadata) {\r\n            result.metadata = serializationObject.metadata;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { GLTFLoader } from \"./glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\n\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ninterface IRegisteredGLTFExtension {\r\n    isGLTFExtension: boolean;\r\n    factory: GLTFExtensionFactory;\r\n}\r\n\r\nexport type GLTFExtensionFactory = (loader: GLTFLoader) => IGLTFLoaderExtension | Promise<IGLTFLoaderExtension>;\r\n\r\nconst RegisteredGLTFExtensions = new Map<string, IRegisteredGLTFExtension>();\r\n\r\n/**\r\n * All currently registered glTF 2.0 loader extensions.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const registeredGLTFExtensions: ReadonlyMap<string, Readonly<IRegisteredGLTFExtension>> = RegisteredGLTFExtensions;\r\n\r\n/**\r\n * Registers a loader extension.\r\n * @param name The name of the loader extension.\r\n * @param isGLTFExtension If the loader extension is a glTF extension, then it will only be used for glTF files that use the corresponding glTF extension. Otherwise, it will be used for all loaded glTF files.\r\n * @param factory The factory function that creates the loader extension.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function registerGLTFExtension(name: string, isGLTFExtension: boolean, factory: GLTFExtensionFactory): void {\r\n    if (unregisterGLTFExtension(name)) {\r\n        Logger.Warn(`Extension with the name '${name}' already exists`);\r\n    }\r\n\r\n    RegisteredGLTFExtensions.set(name, {\r\n        isGLTFExtension,\r\n        factory,\r\n    });\r\n}\r\n\r\n/**\r\n * Unregisters a loader extension.\r\n * @param name The name of the loader extension.\r\n * @returns A boolean indicating whether the extension has been unregistered\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function unregisterGLTFExtension(name: string): boolean {\r\n    return RegisteredGLTFExtensions.delete(name);\r\n}\r\n", "// https://stackoverflow.com/a/48218209\r\n/**\r\n * Merges a series of objects into a single object, deeply.\r\n * @param objects The objects to merge (objects later in the list take precedence).\r\n * @returns The merged object.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function deepMerge<T extends object>(...objects: T[]): T {\r\n    const isRecord = (obj: unknown): obj is Record<string, unknown> => !!obj && typeof obj === \"object\";\r\n\r\n    return objects.reduce<Record<string, unknown>>((prev, obj) => {\r\n        const keys = Object.keys(obj);\r\n        for (const key of keys) {\r\n            const pVal = prev[key];\r\n            const oVal = (obj as Record<string, unknown>)[key];\r\n\r\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\r\n                prev[key] = pVal.concat(...oVal);\r\n            } else if (isRecord(pVal) && isRecord(oVal)) {\r\n                prev[key] = deepMerge(pVal, oVal);\r\n            } else {\r\n                prev[key] = oVal;\r\n            }\r\n        }\r\n\r\n        return prev;\r\n    }, {}) as T;\r\n}\r\n", "/**\r\n * A class that lazily initializes a value given a factory function.\r\n */\r\nexport class Lazy<T> {\r\n    private _factory: (() => T) | undefined;\r\n    private _value: T | undefined;\r\n\r\n    /**\r\n     * Creates a new instance of the Lazy class.\r\n     * @param factory A function that creates the value.\r\n     */\r\n    constructor(factory: () => T) {\r\n        this._factory = factory;\r\n    }\r\n\r\n    /**\r\n     * Gets the lazily initialized value.\r\n     */\r\n    public get value(): T {\r\n        // If the factory function is still defined, it means we haven't called it yet.\r\n        if (this._factory) {\r\n            this._value = this._factory();\r\n            // Set the factory function to undefined to allow it to be garbage collected.\r\n            this._factory = undefined;\r\n        }\r\n        return this._value as T;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable github/no-then */\r\nimport type { IndicesArray, Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorType,\r\n    CameraType,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem,\r\n    _ISamplerData,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    _IAnimationSamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, GetMimeType, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { AnimationPropertyInfo } from \"./glTFLoaderAnimation\";\r\nimport type { IObjectInfo } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport { registeredGLTFExtensions, registerGLTFExtension, unregisterGLTFExtension } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { GLTFExtensionFactory } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { IInterpolationPropertyInfo } from \"core/FlowGraph/typeDefinitions\";\r\nimport { GetMappingForKey } from \"./Extensions/objectModelMapping\";\r\nimport { deepMerge } from \"core/Misc/deepMerger\";\r\nimport { GetTypedArrayConstructor } from \"core/Buffers/bufferUtils\";\r\nimport { Lazy } from \"core/Misc/lazy\";\r\n\r\n// Caching these dynamic imports gives a surprising perf boost (compared to importing them directly each time).\r\nconst LazyAnimationGroupModulePromise = new Lazy(() => import(\"core/Animations/animationGroup\"));\r\nconst LazyLoaderAnimationModulePromise = new Lazy(() => import(\"./glTFLoaderAnimation\"));\r\n\r\nexport { GLTFFileLoader };\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IWithMetadata {\r\n    metadata: any;\r\n    _internalMetadata: any;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Gets an item from the given array or returns null if not available.\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item or null\r\n     */\r\n    public static TryGet<T>(array: ArrayLike<T> | undefined, index: number | undefined): Nullable<T> {\r\n        if (!array || index == undefined || !array[index]) {\r\n            return null;\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport interface IAnimationTargetInfo {\r\n    /** @internal */\r\n    target: unknown;\r\n\r\n    /** @internal */\r\n    properties: Array<AnimationPropertyInfo>;\r\n}\r\n\r\n/** @internal */\r\nexport function LoadBoundingInfoFromPositionAccessor(accessor: IAccessor): Nullable<BoundingInfo> {\r\n    if (accessor.min && accessor.max) {\r\n        const minArray = accessor.min as [number, number, number];\r\n        const maxArray = accessor.max as [number, number, number];\r\n        const minVector = TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);\r\n        const maxVector = TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);\r\n        if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n            let divider = 1;\r\n            switch (accessor.componentType) {\r\n                case AccessorComponentType.BYTE:\r\n                    divider = 127.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_BYTE:\r\n                    divider = 255.0;\r\n                    break;\r\n                case AccessorComponentType.SHORT:\r\n                    divider = 32767.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_SHORT:\r\n                    divider = 65535.0;\r\n                    break;\r\n            }\r\n            const oneOverDivider = 1 / divider;\r\n            minVector.scaleInPlace(oneOverDivider);\r\n            maxVector.scaleInPlace(oneOverDivider);\r\n        }\r\n        return new BoundingInfo(minVector, maxVector);\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @internal */\r\n    public readonly _completePromises = new Array<Promise<unknown>>();\r\n\r\n    /** @internal */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @internal */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    /** @internal */\r\n    public _allMaterialsDirtyRequired = false;\r\n\r\n    /** @internal */\r\n    public _skipStartAnimationStep = false;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<TransformNode> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private readonly _postSceneLoadActions = new Array<() => void>();\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     * @deprecated Please use registerGLTFExtension instead.\r\n     */\r\n    public static RegisterExtension(name: string, factory: GLTFExtensionFactory): void {\r\n        registerGLTFExtension(name, false, factory);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     * @deprecated Please use unregisterGLTFExtension instead.\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        return unregisterGLTFExtension(name);\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon node when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<TransformNode> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * The root url when loading the asset.\r\n     */\r\n    public get rootUrl(): Nullable<string> {\r\n        return this._rootUrl;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await Promise.resolve().then(async () => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return await this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                    spriteManagers: [],\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        this._babylonScene = scene;\r\n        this._loadData(data);\r\n        return await this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n    }\r\n\r\n    private async _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return await Promise.resolve()\r\n            .then(async () => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n                this._allMaterialsDirtyRequired = false;\r\n\r\n                await this._loadExtensionsAsync();\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<unknown>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                if (this._allMaterialsDirtyRequired) {\r\n                    // This can happen if we add a light for instance as it will impact the whole scene.\r\n                    // This automatically resets everything if needed.\r\n                    this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n                } else {\r\n                    // By default a newly created material is dirty so there is no need to flag the full scene as dirty.\r\n                    // For perf reasons, we then bypass blockMaterialDirtyMechanism as this would \"dirty\" the entire scene.\r\n                    this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);\r\n                }\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh && this._rootBabylonMesh !== this._parent.customRootNode) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    // Making sure we enable enough lights to have all lights together\r\n                    for (const material of this._babylonScene.materials) {\r\n                        const mat = material as any;\r\n\r\n                        if (mat.maxSimultaneousLights !== undefined) {\r\n                            mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, this._babylonScene.lights.length);\r\n                        }\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n                    if (!this._skipStartAnimationStep) {\r\n                        this._startAnimations();\r\n                    }\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return await resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _loadExtensionsAsync() {\r\n        const extensionPromises: Promise<IGLTFLoaderExtension>[] = [];\r\n\r\n        registeredGLTFExtensions.forEach((registeredExtension, name) => {\r\n            // Don't load explicitly disabled extensions.\r\n            if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                // But warn if the disabled extension is used by the model.\r\n                if (registeredExtension.isGLTFExtension && this.isExtensionUsed(name)) {\r\n                    Logger.Warn(`Extension ${name} is used but has been explicitly disabled.`);\r\n                }\r\n            }\r\n            // Load loader extensions that are not a glTF extension, as well as extensions that are glTF extensions and are used by the model.\r\n            else if (!registeredExtension.isGLTFExtension || this.isExtensionUsed(name)) {\r\n                extensionPromises.push(\r\n                    (async () => {\r\n                        const extension = await registeredExtension.factory(this);\r\n                        if (extension.name !== name) {\r\n                            Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n                        }\r\n\r\n                        this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n                        return extension;\r\n                    })()\r\n                );\r\n            }\r\n        });\r\n\r\n        this._extensions.push(...(await Promise.all(extensionPromises)));\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                        throw new Error(`Required extension ${name} is disabled`);\r\n                    }\r\n                    throw new Error(`Required extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        if (this._parent.customRootNode !== undefined) {\r\n            this._rootBabylonMesh = this._parent.customRootNode;\r\n            return {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                _babylonTransformNode: this._rootBabylonMesh === null ? undefined : this._rootBabylonMesh,\r\n                index: -1,\r\n            };\r\n        }\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const rootMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh = rootMesh;\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries: Geometry[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes: AbstractMesh[] = [];\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh instanceof AbstractMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes: TransformNode[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons: Skeleton[] = [];\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups: AnimationGroup[] = [];\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                        if (!this._babylonScene.useRightHandedSystem) {\r\n                            babylonTransformNode.scaling.x = -1; // Cancelling root node scaling for handedness so the view matrix does not end up flipped.\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        const hasMesh = node.mesh != undefined;\r\n        const hasSkin = this._parent.loadSkins && node.skin != undefined;\r\n\r\n        if (!hasMesh || hasSkin) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (hasMesh) {\r\n            if (hasSkin) {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin!;\r\n\r\n                        // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\r\n                        babylonTransformNode.metadata = deepMerge(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until all the nodes are parented before parenting the skinned mesh.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        // Handle special case when the parent of the skeleton root is the skinned mesh.\r\n                                        const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent!;\r\n                                        if (node.index === parentNode.index) {\r\n                                            babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\r\n                                        } else {\r\n                                            babylonTransformNode.parent = parentNode._babylonTransformNode!;\r\n                                        }\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n\r\n                                    this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            } else {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                const asMesh = babylonMesh as Mesh;\r\n                if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true, true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<unknown>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then(async (babylonGeometry) => {\r\n                    return await this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        if (this._disposed) {\r\n                            return;\r\n                        }\r\n\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n            if (primitive.material == undefined) {\r\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                if (!babylonMaterial) {\r\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                }\r\n                babylonMesh.material = babylonMaterial;\r\n            } else if (!this.parent.skipMaterials) {\r\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                promises.push(\r\n                    this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        babylonMesh.material = babylonMaterial;\r\n                    })\r\n                );\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (name: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[name] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._gltf.accessors, attributes[name]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor);\r\n                        if (babylonBoundingInfo) {\r\n                            babylonGeometry._boundingInfo = babylonBoundingInfo;\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(this._babylonScene);\r\n        babylonMesh.morphTargetManager._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private async _loadMorphTargetVertexDataAsync(\r\n        context: string,\r\n        babylonGeometry: Geometry,\r\n        attributes: { [name: string]: number },\r\n        babylonMorphTarget: MorphTarget\r\n    ): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUVs(uvs);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUV2s(uvs);\r\n        });\r\n\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (babylonVertexBuffer, data) => {\r\n            let colors = null;\r\n            const componentSize = babylonVertexBuffer.getSize();\r\n            if (componentSize === 3) {\r\n                colors = new Float32Array((data.length / 3) * 4);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    const pixid = Math.floor(index / 3);\r\n                    const channel = index % 3;\r\n                    colors[4 * pixid + channel] = data[3 * pixid + channel] + value;\r\n                });\r\n                for (let i = 0; i < data.length / 3; ++i) {\r\n                    colors[4 * i + 3] = 1;\r\n                }\r\n            } else if (componentSize === 4) {\r\n                colors = new Float32Array(data.length);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    colors[index] = data[index] + value;\r\n                });\r\n            } else {\r\n                throw new Error(`${context}: Invalid number of components (${componentSize}) for COLOR_0 attribute`);\r\n            }\r\n            babylonMorphTarget.setColors(colors);\r\n        });\r\n\r\n        return await Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        if (!this._parent.loadSkins) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path: INode[] = [];\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        node._isJoint = true;\r\n\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateAbsoluteBindMatrices(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        camera._babylonCamera = babylonCamera;\r\n\r\n        // glTF cameras look towards the local -Z axis.\r\n        babylonCamera.setTarget(new Vector3(0, 0, -1));\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Load animations\");\r\n\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Load animations\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        this._parent._startPerformanceCounter(\"Load animation\");\r\n\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        return LazyAnimationGroupModulePromise.value.then(({ AnimationGroup }) => {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n            babylonAnimationGroup._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            ArrayItem.Assign(animation.channels);\r\n            ArrayItem.Assign(animation.samplers);\r\n\r\n            for (const channel of animation.channels) {\r\n                promises.push(\r\n                    this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\r\n                        babylonTarget.animations = babylonTarget.animations || [];\r\n                        babylonTarget.animations.push(babylonAnimation);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\r\n                    })\r\n                );\r\n            }\r\n\r\n            this._parent._endPerformanceCounter(\"Load animation\");\r\n\r\n            return Promise.all(promises).then(() => {\r\n                babylonAnimationGroup.normalize(0);\r\n                return babylonAnimationGroup;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n        const channelTargetPath = channel.target.path;\r\n        const pathIsWeights = channelTargetPath === AnimationChannelTargetPath.WEIGHTS;\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if ((pathIsWeights && !targetNode._numMorphTargets) || (!pathIsWeights && !targetNode._babylonTransformNode)) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Don't load node animations if disabled.\r\n        if (!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // async-load the animation sampler to provide the interpolation of the channelTargetPath\r\n        return LazyLoaderAnimationModulePromise.value.then(() => {\r\n            let properties: IInterpolationPropertyInfo[];\r\n            switch (channelTargetPath) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/translation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/rotation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/scale\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/weights\")?.interpolation!;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n            // stay safe\r\n            if (!properties) {\r\n                throw new Error(`${context}/target/path: Could not find interpolation properties for target path (${channel.target.path})`);\r\n            }\r\n\r\n            const targetInfo: IObjectInfo<IInterpolationPropertyInfo[]> = {\r\n                object: targetNode,\r\n                info: properties,\r\n            };\r\n\r\n            return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param targetInfo The glTF target and properties\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelFromTargetInfoAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        targetInfo: IObjectInfo<IInterpolationPropertyInfo[]>,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const fps = this.parent.targetFps;\r\n        const invfps = 1 / fps;\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let numAnimations = 0;\r\n\r\n            const target = targetInfo.object;\r\n            const propertyInfos = targetInfo.info;\r\n            // Extract the corresponding values from the read value.\r\n            // GLTF values may be dispatched to several Babylon properties.\r\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\r\n            // - albedoColor as Color3(`r`, `g`, `b`)\r\n            // - alpha as `a`\r\n            for (const propertyInfo of propertyInfos) {\r\n                const stride = propertyInfo.getStride(target);\r\n                const input = data.input;\r\n                const output = data.output;\r\n                const keys = new Array<IAnimationKey>(input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n                            const outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                inTangent: inTangent,\r\n                                value: value,\r\n                                outTangent: outTangent,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (outputOffset > 0) {\r\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\r\n                    const babylonAnimations = propertyInfo.buildAnimations(target, name, fps, keys);\r\n                    for (const babylonAnimation of babylonAnimations) {\r\n                        numAnimations++;\r\n                        onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArray;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArray;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(engine, data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n\r\n        if (accessor.sparse || accessor.bufferView == undefined) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    engine,\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    undefined,\r\n                    bufferView.byteStride,\r\n                    undefined,\r\n                    accessor.byteOffset,\r\n                    numComponents,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    undefined,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        babylonMaterial.metallicTexture = texture;\r\n                    })\r\n                );\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    babylonMaterial.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n\r\n            babylonMaterial.forceIrradianceInFragment = true;\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    babylonMaterial.ambientTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    babylonMaterial.emissiveTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                babylonMaterial.alpha = 1.0; // Force alpha to 1.0 for opaque mode.\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: unknown,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType ?? GetMimeType(image.uri ?? \"\"),\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n\r\n                // Set the internal texture label.\r\n                const internalTexture = babylonTexture.getInternalTexture();\r\n                if (internalTexture) {\r\n                    internalTexture.label = image.name;\r\n                }\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        if (this._parent.useGltfTextureNames) {\r\n            babylonTexture.name = image.name || image.uri || `image${image.index}`;\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substring(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with _internalMetadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void {\r\n        babylonObject.metadata = babylonObject.metadata || {};\r\n        const metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        try {\r\n            return GetTypedArrayConstructor(componentType);\r\n        } catch (e) {\r\n            throw new Error(`${context}: ${e.message}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): TypedArray {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            animation,\r\n            \"loadAnimationChannel\",\r\n            (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtensionAsync<TExtension = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtraAsync<TExtra = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n", "import { serialize, serializeAsMatrix, serializeAsVector3 } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\nimport \"../../Engines/AbstractEngine/abstractEngine.cubeTexture\";\r\n\r\n/**\r\n * Defines the available options when creating a cube texture\r\n */\r\nexport interface ICubeTextureCreationOptions {\r\n    /** Defines the suffixes add to the picture name in case six images are in use like _px.jpg */\r\n    extensions?: string[];\r\n\r\n    /** noMipmap defines if mipmaps should be created or not */\r\n    noMipmap?: boolean;\r\n\r\n    /** files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz */\r\n    files?: string[];\r\n\r\n    /** buffer to load instead of loading the data from the url */\r\n    buffer?: ArrayBufferView;\r\n\r\n    /** onLoad defines a callback triggered at the end of the file load if no errors occurred */\r\n    onLoad?: () => void;\r\n\r\n    /** onError defines a callback triggered in case of error during load */\r\n    onError?: (message?: string, exception?: any) => void;\r\n\r\n    /** format defines the internal format to use for the texture once loaded */\r\n    format?: number;\r\n\r\n    /** prefiltered defines whether or not the texture is created from prefiltered data */\r\n    prefiltered?: boolean;\r\n\r\n    /** forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name */\r\n    forcedExtension?: any;\r\n\r\n    /** createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary */\r\n    createPolynomials?: boolean;\r\n\r\n    /** lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness */\r\n    lodScale?: number;\r\n\r\n    /** lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness */\r\n    lodOffset?: number;\r\n\r\n    /** loaderOptions options to be passed to the loader */\r\n    loaderOptions?: any;\r\n\r\n    /** useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n}\r\n\r\n// The default scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\nconst DefaultLodScale = 0.8;\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number;\r\n    private _lodOffset: number;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    @serializeAsMatrix(\"textureMatrixRefraction\")\r\n    private _textureMatrixRefraction: Matrix = new Matrix();\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n    private _buffer: Nullable<ArrayBufferView> = null;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        for (const url of files) {\r\n            rootUrlKey += url;\r\n        }\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | AbstractEngine,\r\n        extensionsOrOptions: Nullable<string[] | ICubeTextureCreationOptions> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = DefaultLodScale,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n\r\n        let extensions: Nullable<string[]> = null;\r\n        let buffer: Nullable<ArrayBufferView> = null;\r\n\r\n        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {\r\n            extensions = extensionsOrOptions.extensions ?? null;\r\n            this._noMipmap = extensionsOrOptions.noMipmap ?? false;\r\n            files = extensionsOrOptions.files ?? null;\r\n            buffer = extensionsOrOptions.buffer ?? null;\r\n            this._format = extensionsOrOptions.format ?? Constants.TEXTUREFORMAT_RGBA;\r\n            prefiltered = extensionsOrOptions.prefiltered ?? false;\r\n            forcedExtension = extensionsOrOptions.forcedExtension ?? null;\r\n            this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;\r\n            this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;\r\n            this._lodOffset = extensionsOrOptions.lodOffset ?? 0;\r\n            this._loaderOptions = extensionsOrOptions.loaderOptions;\r\n            this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;\r\n            onLoad = extensionsOrOptions.onLoad ?? null;\r\n            onError = extensionsOrOptions.onError ?? null;\r\n        } else {\r\n            this._noMipmap = noMipmap;\r\n            this._format = format;\r\n            this._createPolynomials = createPolynomials;\r\n            extensions = extensionsOrOptions;\r\n            this._loaderOptions = loaderOptions;\r\n            this._useSRGBBuffer = useSRGBBuffer;\r\n            this._lodScale = lodScale;\r\n            this._lodOffset = lodOffset;\r\n        }\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param buffer the buffer to use instead of loading from the url\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension: Nullable<string> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null,\r\n        buffer: Nullable<ArrayBufferView> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        this._buffer = buffer;\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public override delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n\r\n        if (!this.getScene()?.useRightHandedSystem) {\r\n            return;\r\n        }\r\n\r\n        const scale = TmpVectors.Vector3[0];\r\n        const quat = TmpVectors.Quaternion[0];\r\n        const trans = TmpVectors.Vector3[1];\r\n\r\n        this._textureMatrix.decompose(scale, quat, trans);\r\n\r\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\r\n        quat.w *= -1;\r\n\r\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public override getRefractionTextureMatrix(): Matrix {\r\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer,\r\n                    this._buffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + (parsedTexture.url ?? parsedTexture.name),\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public override clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n", "import { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { InternalTextureSource } from \"./internalTexture\";\r\nimport { CubeTexture } from \"./cubeTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\r\nexport class RawCubeTexture extends CubeTexture {\r\n    /**\r\n     * Creates a cube texture where the raw buffers are passed in.\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        generateMipMaps: boolean = false,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        compression: Nullable<string> = null\r\n    ) {\r\n        super(\"\", scene);\r\n\r\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates the raw cube texture.\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    public update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null): void {\r\n        this._texture!.getEngine().updateRawCubeTexture(this._texture!, data, format, type, invertY, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates a raw cube texture with RGBD encoded data.\r\n     * @param data defines the array of data [mipmap][face] to use to create each face\r\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial> = null, lodScale: number = 0.8, lodOffset: number = 0): Promise<void> {\r\n        // eslint-disable-next-line github/no-then\r\n        return UpdateRGBDAsyncEnvTools(this._texture!, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Clones the raw cube texture.\r\n     * @returns a new cube texture\r\n     */\r\n    public override clone(): CubeTexture {\r\n        return SerializationHelper.Clone(() => {\r\n            const scene = this.getScene()!;\r\n            const internalTexture = this._texture!;\r\n\r\n            const texture = new RawCubeTexture(\r\n                scene,\r\n                internalTexture._bufferViewArray,\r\n                internalTexture.width,\r\n                internalTexture.format,\r\n                internalTexture.type,\r\n                internalTexture.generateMipMaps,\r\n                internalTexture.invertY,\r\n                internalTexture.samplingMode,\r\n                internalTexture._compression\r\n            );\r\n\r\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                texture.updateRGBDAsync(\r\n                    internalTexture._bufferViewArrayArray!,\r\n                    internalTexture._sphericalPolynomial,\r\n                    internalTexture._lodGenerationScale,\r\n                    internalTexture._lodGenerationOffset\r\n                );\r\n            }\r\n\r\n            return texture;\r\n        }, this);\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\r\nimport { Quaternion, Matrix } from \"core/Maths/math.vector\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RawCubeTexture } from \"core/Materials/Textures/rawCubeTexture\";\r\n\r\nimport type { IEXTLightsImageBased_LightReferenceImageBased, IEXTLightsImageBased_LightImageBased, IEXTLightsImageBased } from \"babylonjs-gltf2interface\";\r\nimport type { IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_lights_image_based extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_lights_image_based\"]: {};\r\n    }\r\n}\r\n\r\ndeclare module \"babylonjs-gltf2interface\" {\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    interface IEXTLightsImageBased_LightImageBased {\r\n        _babylonTexture?: BaseTexture;\r\n        _loaded?: Promise<void>;\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsImageBased_LightImageBased[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IEXTLightsImageBased;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsImageBased_LightReferenceImageBased>(context, scene, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(\r\n                // eslint-disable-next-line github/no-then\r\n                this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                    this._loader.babylonScene.environmentTexture = texture;\r\n                })\r\n            );\r\n\r\n            this._loader.logClose();\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadLightAsync(context: string, light: IEXTLightsImageBased_LightImageBased): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\r\n                            imageData[mipmap][face] = data;\r\n                        })\r\n                    );\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            light._loaded = Promise.all(promises).then(async () => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                babylonTexture.name = light.name || \"environment\";\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                if (!light.irradianceCoefficients) {\r\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scaleInPlace(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Math.log2(light.specularImageSize);\r\n                return await babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_image_based(loader));\r\n", "import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\n\r\ndeclare module \"./mesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n\r\n        /**\r\n         * Indicates that a buffer created as static should be recreated if the buffer is updated (by calling thinInstanceSetMatrixAt or thinInstanceSetAttributeAt, for eg.)\r\n         * If this flag is false (the default behavior), a buffer created as \"static\" won't show any update done to it, and will stay the same as it was created.\r\n         * Note however that recreating a buffer each time there's a change will have some performance cost, that's why it is set to false by default.\r\n         * You should set this flag to true only if your static buffers should change infrequently. If they change frequently, you should create your buffers as \"dynamic\" instead.\r\n         */\r\n        thinInstanceAllowAutomaticStaticBufferRecreation: boolean;\r\n\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - true by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _thinInstanceRecreateBuffer(kind: string, staticBuffer?: boolean): void;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = true): Buffer {\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = true): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (\r\n            this.thinInstanceAllowAutomaticStaticBufferRecreation &&\r\n            this._thinInstanceDataStorage.previousMatrixBuffer &&\r\n            !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()\r\n        ) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.isUpdatable()) {\r\n                this._thinInstanceRecreateBuffer(kind);\r\n            }\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = [] as Matrix[];\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n        const boundingInfo = this.getBoundingInfo();\r\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceRecreateBuffer = function (kind: string, staticBuffer: boolean = true) {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", this._thinInstanceDataStorage.matrixData, staticBuffer);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (this._scene.needsPreviousWorldMatrices) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\r\n                \"previousWorld\",\r\n                this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData,\r\n                staticBuffer\r\n            );\r\n        }\r\n    } else {\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n            this.getEngine(),\r\n            this._userThinInstanceBuffersStorage.data[kind],\r\n            kind,\r\n            !staticBuffer,\r\n            false,\r\n            this._userThinInstanceBuffersStorage.strides[kind],\r\n            true\r\n        );\r\n        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n    if (this._thinInstanceDataStorage?.previousMatrixBuffer) {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n    }\r\n};\r\n", "import { Vector3, Quaternion, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Meshes/thinInstanceMesh\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_mesh_gpu_instancing extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_mesh_gpu_instancing\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshGpuInstancing, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._disableInstancedMesh++;\r\n\r\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\r\n\r\n            this._loader._disableInstancedMesh--;\r\n\r\n            if (!node._primitiveBabylonMeshes) {\r\n                return await promise;\r\n            }\r\n\r\n            const promises = new Array<Promise<Nullable<Float32Array>>>();\r\n            let instanceCount = 0;\r\n\r\n            const loadAttribute = (attribute: string) => {\r\n                if (extension.attributes[attribute] == undefined) {\r\n                    promises.push(Promise.resolve(null));\r\n                    return;\r\n                }\r\n\r\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\r\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\r\n\r\n                if (instanceCount === 0) {\r\n                    instanceCount = accessor.count;\r\n                } else if (instanceCount !== accessor.count) {\r\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"TRANSLATION\");\r\n            loadAttribute(\"ROTATION\");\r\n            loadAttribute(\"SCALE\");\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            return await promise.then(async (babylonTransformNode) => {\r\n                const [translationBuffer, rotationBuffer, scaleBuffer] = await Promise.all(promises);\r\n                const matrices = new Float32Array(instanceCount * 16);\r\n                TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\r\n                TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\r\n                TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\r\n                for (let i = 0; i < instanceCount; ++i) {\r\n                    translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\r\n                    rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\r\n                    scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\r\n\r\n                    Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\r\n\r\n                    TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\r\n                }\r\n                for (const babylonMesh of node._primitiveBabylonMeshes!) {\r\n                    (babylonMesh as Mesh).thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\r\n                }\r\n                return babylonTransformNode;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_mesh_gpu_instancing(loader));\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let MeshoptDecoder: any;\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nlet NumberOfWorkers = 0;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nlet WorkerTimeout: Nullable<ReturnType<typeof setTimeout>> = null;\r\n\r\n/**\r\n * Configuration for meshoptimizer compression\r\n */\r\nexport interface IMeshoptCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the meshopt decoder library.\r\n         */\r\n        url: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Meshopt compression (https://github.com/zeux/meshoptimizer)\r\n *\r\n * This class wraps the meshopt library from https://github.com/zeux/meshoptimizer/tree/master/js.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the meshopt files on the Babylon.js preview CDN (e.g. https://preview.babylonjs.com/meshopt_decoder.js).\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     MeshoptCompression.Configuration = {\r\n *         decoder: {\r\n *             url: \"<url to the meshopt decoder library>\"\r\n *         }\r\n *     };\r\n * ```\r\n */\r\nexport class MeshoptCompression implements IDisposable {\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following:\r\n     * ```javascript\r\n     * decoder: {\r\n     *   url: \"https://cdn.babylonjs.com/meshopt_decoder.js\"\r\n     * }\r\n     * ```\r\n     */\r\n    public static Configuration: IMeshoptCompressionConfiguration = {\r\n        decoder: {\r\n            url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`,\r\n        },\r\n    };\r\n\r\n    private static _Default: Nullable<MeshoptCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the meshoptimizer object.\r\n     */\r\n    public static get Default(): MeshoptCompression {\r\n        if (!MeshoptCompression._Default) {\r\n            MeshoptCompression._Default = new MeshoptCompression();\r\n        }\r\n\r\n        return MeshoptCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() {\r\n        const decoder = MeshoptCompression.Configuration.decoder;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {\r\n            // Wait for WebAssembly compilation before resolving promise\r\n            return MeshoptDecoder.ready;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Decode meshopt data.\r\n     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder\r\n     * @param source The input data.\r\n     * @param count The number of elements.\r\n     * @param stride The stride in bytes.\r\n     * @param mode The compression mode.\r\n     * @param filter The compression filter.\r\n     * @returns a Promise<Uint8Array> that resolves to the decoded data\r\n     */\r\n    public async decodeGltfBufferAsync(source: Uint8Array, count: number, stride: number, mode: \"ATTRIBUTES\" | \"TRIANGLES\" | \"INDICES\", filter?: string): Promise<Uint8Array> {\r\n        await this._decoderModulePromise!;\r\n        if (NumberOfWorkers === 0) {\r\n            MeshoptDecoder.useWorkers(1);\r\n            NumberOfWorkers = 1;\r\n        }\r\n        const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);\r\n        // a simple debounce to avoid switching back and forth between workers and no workers while decoding\r\n        if (WorkerTimeout !== null) {\r\n            clearTimeout(WorkerTimeout);\r\n        }\r\n        WorkerTimeout = setTimeout(() => {\r\n            MeshoptDecoder.useWorkers(0);\r\n            NumberOfWorkers = 0;\r\n            WorkerTimeout = null;\r\n        }, 1000);\r\n        return result;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { ArrayItem, GLTFLoader } from \"../glTFLoader\";\r\nimport type { IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IEXTMeshoptCompression } from \"babylonjs-gltf2interface\";\r\nimport { MeshoptCompression } from \"core/Meshes/Compression/meshoptCompression\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_meshopt_compression\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_meshopt_compression extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_meshopt_compression\"]: {};\r\n    }\r\n}\r\n\r\ninterface IBufferViewMeshopt extends IBufferView {\r\n    _meshOptData?: Promise<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)\r\n *\r\n * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_meshopt_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshoptCompression, ArrayBufferView>(context, bufferView, this.name, async (extensionContext, extension) => {\r\n            const bufferViewMeshopt = bufferView as IBufferViewMeshopt;\r\n            if (bufferViewMeshopt._meshOptData) {\r\n                return await bufferViewMeshopt._meshOptData;\r\n            }\r\n\r\n            const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);\r\n            bufferViewMeshopt._meshOptData = this._loader\r\n                .loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength)\r\n                // eslint-disable-next-line github/no-then\r\n                .then(async (buffer) => {\r\n                    return await MeshoptCompression.Default.decodeGltfBufferAsync(buffer as Uint8Array, extension.count, extension.byteStride, extension.mode, extension.filter);\r\n                });\r\n\r\n            return await bufferViewMeshopt._meshOptData;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_meshopt_compression(loader));\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IEXTTextureWebP } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_texture_webp\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_texture_webp extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_texture_webp\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_texture_webp implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTTextureWebP, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_texture_webp(loader));\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IEXTTextureAVIF } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_texture_avif\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_texture_avif extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_texture_avif\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [glTF PR](https://github.com/KhronosGroup/glTF/pull/2235)\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_avif/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_texture_avif implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTTextureAVIF, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_texture_avif(loader));\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IEXTLightsIES_LightReference } from \"babylonjs-gltf2interface\";\r\nimport type { IEXTLightsIES_Light, INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nconst NAME = \"EXT_lights_ies\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_lights_ies extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_lights_ies\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_lights_ies)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_ies implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsIES_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsIES_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            let babylonSpotLight: SpotLight;\r\n            let light: IEXTLightsIES_Light;\r\n\r\n            const transformNode = await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                babylonSpotLight.angle = Math.PI / 2;\r\n                babylonSpotLight.innerAngle = 0;\r\n\r\n                babylonSpotLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonSpotLight;\r\n\r\n                babylonSpotLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonSpotLight.diffuse = extension.color ? Color3.FromArray(extension.color) : Color3.White();\r\n                babylonSpotLight.intensity = extension.multiplier || 1;\r\n                babylonSpotLight.range = Number.MAX_VALUE;\r\n                babylonSpotLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonSpotLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonSpotLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n\r\n            // Load the profile\r\n            let bufferData: ArrayBufferView;\r\n            if (light!.uri) {\r\n                bufferData = await this._loader.loadUriAsync(context, light!, light!.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, light!.bufferView);\r\n                bufferData = await this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n            babylonSpotLight!.iesProfileTexture = new Texture(\r\n                name + \"_iesProfile\",\r\n                this._loader.babylonScene,\r\n                true,\r\n                false,\r\n                undefined,\r\n                null,\r\n                null,\r\n                bufferData,\r\n                true,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                \".ies\"\r\n            );\r\n\r\n            return transformNode;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_ies(loader));\r\n", "import type { Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport type { EncoderMessage, IDracoAttributeData, IDracoEncodedMeshData, IDracoEncoderOptions } from \"./dracoEncoder.types\";\r\nimport type { DecoderMessage } from \"./dracoDecoder.types\";\r\nimport type { DecoderBuffer, Decoder, Mesh, PointCloud, Status, DecoderModule, EncoderModule, MeshBuilder, Encoder, DracoInt8Array } from \"draco3dgltf\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { VertexDataTypedArray } from \"core/Buffers/bufferUtils\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoEncoderModule: (props: { wasmBinary?: ArrayBuffer }) => Promise<EncoderModule>;\r\n\r\ninterface IInitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: IInitDoneMessage | DecoderMessage | EncoderMessage, transfer?: ArrayBufferLike[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function EncodeMesh(\r\n    module: unknown /** EncoderModule */,\r\n    attributes: Array<IDracoAttributeData>,\r\n    indices: Nullable<Uint16Array | Uint32Array>,\r\n    options: IDracoEncoderOptions\r\n): Nullable<IDracoEncodedMeshData> {\r\n    const encoderModule = module as EncoderModule;\r\n    let encoder: Nullable<Encoder> = null;\r\n    let meshBuilder: Nullable<MeshBuilder> = null;\r\n    let mesh: Nullable<Mesh> = null;\r\n    let encodedNativeBuffer: Nullable<DracoInt8Array> = null;\r\n    const attributeIDs: Record<string, number> = {}; // Babylon kind -> Draco unique id\r\n\r\n    // Double-check that at least a position attribute is provided\r\n    const positionAttribute = attributes.find((a) => a.dracoName === \"POSITION\");\r\n    if (!positionAttribute) {\r\n        throw new Error(\"Position attribute is required for Draco encoding\");\r\n    }\r\n\r\n    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.\r\n    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.\r\n    if (!indices) {\r\n        // Assume position attribute is the largest attribute.\r\n        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;\r\n        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);\r\n        for (let i = 0; i < positionVerticesCount; i++) {\r\n            indices[i] = i;\r\n        }\r\n    }\r\n\r\n    try {\r\n        encoder = new encoderModule.Encoder();\r\n        meshBuilder = new encoderModule.MeshBuilder();\r\n        mesh = new encoderModule.Mesh();\r\n\r\n        // Add the faces\r\n        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);\r\n\r\n        const addAttributeMap = new Map<\r\n            Function,\r\n            (builder: MeshBuilder, mesh: Mesh, attr: any, count: number, size: number, data: Exclude<VertexDataTypedArray, Uint8ClampedArray>) => number\r\n        >([\r\n            [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],\r\n            [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],\r\n            [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],\r\n            [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],\r\n            [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],\r\n            [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],\r\n            [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)],\r\n        ]);\r\n\r\n        // Add the attributes\r\n        for (const attribute of attributes) {\r\n            if (attribute.data instanceof Uint8ClampedArray) {\r\n                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray\r\n            }\r\n            const addAttribute = addAttributeMap.get(attribute.data.constructor)!;\r\n            const verticesCount = attribute.data.length / attribute.size;\r\n            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);\r\n            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {\r\n                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);\r\n            }\r\n        }\r\n\r\n        // Set the options\r\n        if (options.method) {\r\n            encoder.SetEncodingMethod(encoderModule[options.method]);\r\n        }\r\n        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {\r\n            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\r\n        }\r\n\r\n        // Encode to native buffer\r\n        encodedNativeBuffer = new encoderModule.DracoInt8Array();\r\n        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);\r\n        if (encodedLength <= 0) {\r\n            throw new Error(\"Draco encoding failed.\");\r\n        }\r\n\r\n        // Copy the native buffer data to worker heap\r\n        const encodedData = new Int8Array(encodedLength);\r\n        for (let i = 0; i < encodedLength; i++) {\r\n            encodedData[i] = encodedNativeBuffer.GetValue(i);\r\n        }\r\n\r\n        return { data: encodedData, attributeIds: attributeIDs };\r\n    } finally {\r\n        if (mesh) {\r\n            encoderModule.destroy(mesh);\r\n        }\r\n        if (meshBuilder) {\r\n            encoderModule.destroy(meshBuilder);\r\n        }\r\n        if (encoder) {\r\n            encoderModule.destroy(encoder);\r\n        }\r\n        if (encodedNativeBuffer) {\r\n            encoderModule.destroy(encodedNativeBuffer);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function EncoderWorkerFunction(): void {\r\n    let encoderPromise: PromiseLike<EncoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                encoderPromise = DracoEncoderModule(initEncoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"encodeMesh\": {\r\n                if (!encoderPromise) {\r\n                    throw new Error(\"Draco encoder module is not available\");\r\n                }\r\n                // eslint-disable-next-line github/no-then\r\n                encoderPromise.then((encoder) => {\r\n                    const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);\r\n                    postMessage({ id: \"encodeMeshDone\", encodedMeshData: result }, result ? [result.data.buffer] : undefined);\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function DecodeMesh(\r\n    module: unknown /** DecoderModule */,\r\n    data: Int8Array,\r\n    attributeIDs: Record<string, number> | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    const decoderModule = module as DecoderModule;\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any /** Attribute */) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo: Record<number, { typedArrayConstructor: TypedArrayConstructor; heap: TypedArray }> = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributeIDs) {\r\n            for (const kind in attributeIDs) {\r\n                const id = attributeIDs[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: Record<string, number> = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function DecoderWorkerFunction(): void {\r\n    let decoderPromise: PromiseLike<DecoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                decoderPromise = DracoDecoderModule(initDecoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                // eslint-disable-next-line github/no-then\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = DecodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// For backwards compatibility\r\nexport { DecoderWorkerFunction as workerFunction };\r\n\r\n/**\r\n * Initializes a worker that was created for the draco agent pool\r\n * @param worker  The worker to initialize\r\n * @param wasmBinary The wasm binary to load into the worker\r\n * @param moduleUrl The url to the draco decoder module (optional)\r\n * @returns A promise that resolves when the worker is initialized\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport async function initializeWebWorker(worker: Worker, wasmBinary?: ArrayBuffer, moduleUrl?: string): Promise<Worker> {\r\n    return await new Promise<Worker>((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (event: MessageEvent<IInitDoneMessage>) => {\r\n            if (event.data.id === \"initDone\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        // Load with either JS-only or WASM version\r\n        if (!wasmBinary) {\r\n            worker.postMessage({\r\n                id: \"init\",\r\n                url: moduleUrl,\r\n            });\r\n        } else {\r\n            // clone the array buffer to make it transferable\r\n            const clone = wasmBinary.slice(0);\r\n            worker.postMessage(\r\n                {\r\n                    id: \"init\",\r\n                    url: moduleUrl,\r\n                    wasmBinary: clone,\r\n                },\r\n                [clone]\r\n            );\r\n        }\r\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\r\n    });\r\n}\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { WorkerPool } from \"../../Misc/workerPool\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport { initializeWebWorker } from \"./dracoCompressionWorker\";\r\n\r\n/**\r\n * Configuration for using a Draco codec.\r\n */\r\nexport interface IDracoCodecConfiguration {\r\n    /**\r\n     * The url to the WebAssembly module.\r\n     */\r\n    wasmUrl?: string;\r\n\r\n    /**\r\n     * The url to the WebAssembly binary.\r\n     */\r\n    wasmBinaryUrl?: string;\r\n\r\n    /**\r\n     * The url to the fallback JavaScript module.\r\n     */\r\n    fallbackUrl?: string;\r\n\r\n    /**\r\n     * The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n\r\n    /**\r\n     * Optional worker pool to use for async encoding/decoding.\r\n     * If provided, the worker pool will be used as is: no Draco scripts will be loaded, and numWorkers will be ignored.\r\n     */\r\n    workerPool?: WorkerPool;\r\n\r\n    /**\r\n     * Optional ArrayBuffer of the WebAssembly binary.\r\n     * If provided it will be used instead of loading the binary from wasmBinaryUrl.\r\n     */\r\n    wasmBinary?: ArrayBuffer;\r\n\r\n    /**\r\n     * The codec module if already available.\r\n     */\r\n    jsModule?: unknown /* DracoDecoderModule | DracoEncoderModule */;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _GetDefaultNumWorkers(): number {\r\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n        return 1;\r\n    }\r\n\r\n    // Use 50% of the available logical processors but capped at 4.\r\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _IsConfigurationAvailable(config: IDracoCodecConfiguration): boolean {\r\n    return !!((config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === \"object\") || config.fallbackUrl);\r\n    // TODO: Account for jsModule\r\n}\r\n\r\n/**\r\n * Base class for a Draco codec.\r\n * @internal\r\n */\r\nexport abstract class DracoCodec implements IDisposable {\r\n    protected _workerPoolPromise?: Promise<WorkerPool>;\r\n    protected _modulePromise?: Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Checks if the default codec JS module is in scope.\r\n     */\r\n    protected abstract _isModuleAvailable(): boolean;\r\n\r\n    /**\r\n     * Creates the JS Module for the corresponding wasm.\r\n     */\r\n    protected abstract _createModuleAsync(\r\n        wasmBinary?: ArrayBuffer,\r\n        jsModule?: unknown /** DracoDecoderModule | DracoEncoderModule */\r\n    ): Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Returns the worker content.\r\n     */\r\n    protected abstract _getWorkerContent(): string;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param configuration The configuration for the DracoCodec instance.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration) {\r\n        // check if the codec binary and worker pool was injected\r\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\r\n        if (configuration.workerPool) {\r\n            // Set the promise accordingly\r\n            this._workerPoolPromise = Promise.resolve(configuration.workerPool);\r\n            return;\r\n        }\r\n\r\n        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise\r\n        const wasmBinaryProvided = configuration.wasmBinary;\r\n        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();\r\n        const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\r\n        const urlNeeded = useWorkers || !configuration.jsModule;\r\n        // code maintained here for back-compat with no changes\r\n\r\n        const codecInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | undefined> } =\r\n            configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : \"\",\r\n                      wasmBinaryPromise: wasmBinaryProvided\r\n                          ? Promise.resolve(wasmBinaryProvided)\r\n                          : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl!) : \"\",\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n        // If using workers, initialize a worker pool with either the wasm or url?\r\n        if (useWorkers) {\r\n            // eslint-disable-next-line github/no-then\r\n            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {\r\n                const workerContent = this._getWorkerContent();\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n                return new AutoReleaseWorkerPool(numberOfWorkers, () => {\r\n                    const worker = new Worker(workerBlobUrl);\r\n                    return initializeWebWorker(worker, wasmBinary, codecInfo.url);\r\n                });\r\n            });\r\n        } else {\r\n            // eslint-disable-next-line github/no-then\r\n            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {\r\n                if (!this._isModuleAvailable()) {\r\n                    if (!configuration.jsModule) {\r\n                        if (!codecInfo.url) {\r\n                            throw new Error(\"Draco codec module is not available\");\r\n                        }\r\n                        await Tools.LoadBabylonScriptAsync(codecInfo.url);\r\n                    }\r\n                }\r\n                return await this._createModuleAsync(wasmBinary as ArrayBuffer, configuration.jsModule);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public async whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            await this._workerPoolPromise;\r\n            return;\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            await this._modulePromise;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._modulePromise;\r\n    }\r\n}\r\n", "import { DracoDecoderModule } from \"draco3dgltf\";\r\nimport { _IsConfigurationAvailable, DracoCodec, type IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { DecodeMesh, DecoderWorkerFunction } from \"./dracoCompressionWorker\";\r\nimport type { IAttributeData, MeshData, DecoderMessage } from \"./dracoDecoder.types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\n/**\r\n * @experimental This class is an experimental version of `DracoCompression` and is subject to change.\r\n *\r\n * Draco Decoder (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco decoder module.\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the Babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoDecoder.DefaultConfiguration = {\r\n *          wasmUrl: \"<url to the WebAssembly library>\",\r\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoDecoder.DefaultAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoDecoder object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoDecoder.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n */\r\nexport class DracoDecoder extends DracoCodec {\r\n    /**\r\n     * Default configuration for the DracoDecoder. Defaults to the following:\r\n     * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\r\n     * - wasmUrl: `\"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"`\r\n     * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"`\r\n     * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.js\"`\r\n     */\r\n    public static DefaultConfiguration: IDracoCodecConfiguration = {\r\n        wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n        wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n        fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder's `DefaultConfiguration` is available.\r\n     */\r\n    public static get DefaultAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\r\n    }\r\n\r\n    protected static _Default: Nullable<DracoDecoder> = null;\r\n    /**\r\n     * Default instance for the DracoDecoder.\r\n     */\r\n    public static get Default(): DracoDecoder {\r\n        DracoDecoder._Default ??= new DracoDecoder();\r\n        return DracoDecoder._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default DracoDecoder object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoDecoder._Default) {\r\n            if (!skipDispose) {\r\n                DracoDecoder._Default.dispose();\r\n            }\r\n            DracoDecoder._Default = null;\r\n        }\r\n    }\r\n\r\n    protected override _isModuleAvailable(): boolean {\r\n        return typeof DracoDecoderModule !== \"undefined\";\r\n    }\r\n\r\n    protected override async _createModuleAsync(wasmBinary?: ArrayBuffer, jsModule?: unknown /** DracoDecoderModule */): Promise<{ module: unknown /** DecoderModule */ }> {\r\n        const module = await ((jsModule as DracoDecoderModule) || DracoDecoderModule)({ wasmBinary });\r\n        return { module };\r\n    }\r\n\r\n    protected override _getWorkerContent(): string {\r\n        return `${DecodeMesh}(${DecoderWorkerFunction})()`;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Draco decoder.\r\n     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration = DracoDecoder.DefaultConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to mesh data.\r\n     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\r\n     * @returns A promise that resolves with the decoded mesh data\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public decodeMeshToMeshDataAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            // eslint-disable-next-line github/no-then\r\n            return this._workerPoolPromise.then(async (workerPool) => {\r\n                return await new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<IAttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<DecoderMessage>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            // eslint-disable-next-line github/no-then\r\n            return this._modulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<IAttributeData> = [];\r\n\r\n                const numPoints = DecodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public async decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\r\n        const geometry = new Geometry(name, scene);\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n\r\n    /** @internal */\r\n    public async _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean },\r\n        boundingInfo: Nullable<BoundingInfo>\r\n    ): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\r\n        const geometry = new Geometry(name, scene);\r\n        if (boundingInfo) {\r\n            geometry._boundingInfo = boundingInfo;\r\n            geometry.useBoundingInfoFromGeometry = true;\r\n        }\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n}\r\n", "/* eslint-disable github/no-then */\r\nimport { DracoDecoder } from \"core/Meshes/Compression/dracoDecoder\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport type { IKHRDracoMeshCompression } from \"babylonjs-gltf2interface\";\r\nimport type { IMeshPrimitive, IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem, LoadBoundingInfoFromPositionAccessor } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_draco_mesh_compression extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_draco_mesh_compression\"]: {};\r\n    }\r\n}\r\n\r\ninterface IBufferViewDraco extends IBufferView {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * The draco decoder used to decode vertex data or DracoDecoder.Default if not defined\r\n     */\r\n    public dracoDecoder?: DracoDecoder;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether to use the normalized flag from the glTF accessor instead of the Draco data. Defaults to true.\r\n     */\r\n    public useNormalizedFlagFromAccessor = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        delete this.dracoDecoder;\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLES && primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n            }\r\n\r\n            const attributes: { [kind: string]: number } = {};\r\n            const normalized: { [kind: string]: boolean } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId == undefined) {\r\n                    return;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n\r\n                if (this.useNormalizedFlagFromAccessor) {\r\n                    const accessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[name]);\r\n                    if (accessor) {\r\n                        normalized[kind] = accessor.normalized || false;\r\n                    }\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(async (data) => {\r\n                    const dracoDecoder = this.dracoDecoder || DracoDecoder.Default;\r\n                    const positionAccessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[\"POSITION\"]);\r\n                    const babylonBoundingInfo =\r\n                        !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? LoadBoundingInfoFromPositionAccessor(positionAccessor) : null;\r\n                    return await dracoDecoder\r\n                        ._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo)\r\n                        .catch((error) => {\r\n                            throw new Error(`${context}: ${error.message}`);\r\n                        });\r\n                });\r\n            }\r\n\r\n            return await bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_draco_mesh_compression(loader));\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IKHRLightsPunctual_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_lights_punctual extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_lights_punctual\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case KHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        babylonDirectionalLight.position.setAll(0);\r\n                        babylonLight = babylonDirectionalLight;\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsPbrSpecularGlossiness } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_pbrSpecularGlossiness extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_pbrSpecularGlossiness\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 200;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsPbrSpecularGlossiness>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSpecularGlossinessPropertiesAsync(context: string, properties: IKHRMaterialsPbrSpecularGlossiness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.metallic = null;\r\n        babylonMaterial.roughness = null;\r\n\r\n        if (properties.diffuseFactor) {\r\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\r\n            babylonMaterial.alpha = properties.diffuseFactor[3];\r\n        } else {\r\n            babylonMaterial.albedoColor = Color3.White();\r\n        }\r\n\r\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\r\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\r\n\r\n        if (properties.diffuseTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse)`;\r\n                    babylonMaterial.albedoTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularGlossinessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular Glossiness)`;\r\n                    babylonMaterial.reflectivityTexture = texture;\r\n                    babylonMaterial.reflectivityTexture.hasAlpha = true;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_unlit extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_unlit\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 210;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, async () => {\r\n            return await this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n        babylonMaterial.unlit = true;\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_unlit(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_clearcoat extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_clearcoat\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsClearcoat>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClearCoatPropertiesAsync(context: string, properties: IKHRMaterialsClearcoat, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.clearCoat.isEnabled = true;\r\n        babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;\r\n        babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;\r\n\r\n        if (properties.clearcoatFactor != undefined) {\r\n            babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;\r\n        } else {\r\n            babylonMaterial.clearCoat.intensity = 0;\r\n        }\r\n\r\n        if (properties.clearcoatTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat)`;\r\n                    babylonMaterial.clearCoat.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatRoughnessFactor != undefined) {\r\n            babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;\r\n        } else {\r\n            babylonMaterial.clearCoat.roughness = 0;\r\n        }\r\n\r\n        if (properties.clearcoatRoughnessTexture) {\r\n            (properties.clearcoatRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;\r\n                    babylonMaterial.clearCoat.textureRoughness = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatNormalTexture) {\r\n            (properties.clearcoatNormalTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;\r\n                    babylonMaterial.clearCoat.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;\r\n            if (properties.clearcoatNormalTexture.scale != undefined) {\r\n                babylonMaterial.clearCoat.bumpTexture!.level = properties.clearcoatNormalTexture.scale;\r\n            }\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_clearcoat(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_iridescence extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_iridescence\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 195;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIridescence>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadIridescencePropertiesAsync(context: string, properties: IKHRMaterialsIridescence, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.iridescence.isEnabled = true;\r\n\r\n        babylonMaterial.iridescence.intensity = properties.iridescenceFactor ?? 0;\r\n        babylonMaterial.iridescence.indexOfRefraction = properties.iridescenceIor ?? (properties as any).iridescenceIOR ?? 1.3;\r\n        babylonMaterial.iridescence.minimumThickness = properties.iridescenceThicknessMinimum ?? 100;\r\n        babylonMaterial.iridescence.maximumThickness = properties.iridescenceThicknessMaximum ?? 400;\r\n\r\n        if (properties.iridescenceTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence)`;\r\n                    babylonMaterial.iridescence.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.iridescenceThicknessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;\r\n                    babylonMaterial.iridescence.thicknessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_iridescence(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_anisotropy extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_anisotropy\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 195;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsAnisotropy>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    private async _loadIridescencePropertiesAsync(context: string, properties: IKHRMaterialsAnisotropy, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.anisotropy.isEnabled = true;\r\n\r\n        babylonMaterial.anisotropy.intensity = properties.anisotropyStrength ?? 0;\r\n        babylonMaterial.anisotropy.angle = properties.anisotropyRotation ?? 0;\r\n\r\n        if (properties.anisotropyTexture) {\r\n            (properties.anisotropyTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/anisotropyTexture`, properties.anisotropyTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Anisotropy Intensity)`;\r\n                    babylonMaterial.anisotropy.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        await Promise.all(promises);\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_anisotropy(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_emissive_strength extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_emissive_strength\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 170;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsEmissiveStrength>(context, material, this.name, async (extensionContext, extension) => {\r\n            // eslint-disable-next-line github/no-then\r\n            return await this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(() => {\r\n                this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadEmissiveProperties(context: string, properties: IKHRMaterialsEmissiveStrength, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        if (properties.emissiveStrength !== undefined) {\r\n            babylonMaterial.emissiveIntensity = properties.emissiveStrength;\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_emissive_strength(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_sheen extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_sheen\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSheen>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSheenPropertiesAsync(context: string, properties: IKHRMaterialsSheen, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.sheen.isEnabled = true;\r\n        babylonMaterial.sheen.intensity = 1;\r\n\r\n        if (properties.sheenColorFactor != undefined) {\r\n            babylonMaterial.sheen.color = Color3.FromArray(properties.sheenColorFactor);\r\n        } else {\r\n            babylonMaterial.sheen.color = Color3.Black();\r\n        }\r\n\r\n        if (properties.sheenColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Color)`;\r\n                    babylonMaterial.sheen.texture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.sheenRoughnessFactor !== undefined) {\r\n            babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;\r\n        } else {\r\n            babylonMaterial.sheen.roughness = 0;\r\n        }\r\n\r\n        if (properties.sheenRoughnessTexture) {\r\n            (properties.sheenRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Roughness)`;\r\n                    babylonMaterial.sheen.textureRoughness = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        babylonMaterial.sheen.albedoScaling = true;\r\n        babylonMaterial.sheen.useRoughnessFromMainTexture = false;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_sheen(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { IEXTMaterialsSpecularEdgeColor, IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_specular extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_specular\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSpecular>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // Handle the EXT_materials_specular_edge_color sub-extension\r\n            // https://github.com/KhronosGroup/glTF/blob/2a1111b88f052cbd3e2d82abb9faee56e7494904/extensions/2.0/Vendor/EXT_materials_specular_edge_color/README.md\r\n            if (extension.extensions && extension.extensions.EXT_materials_specular_edge_color && babylonMaterial instanceof PBRMaterial) {\r\n                const specularEdgeColorExtension = extension.extensions.EXT_materials_specular_edge_color as IEXTMaterialsSpecularEdgeColor;\r\n                if (specularEdgeColorExtension.specularEdgeColorEnabled) {\r\n                    babylonMaterial.brdf.dielectricSpecularModel = Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR;\r\n                    babylonMaterial.brdf.conductorSpecularModel = Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR;\r\n                }\r\n            }\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSpecularPropertiesAsync(context: string, properties: IKHRMaterialsSpecular, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties.specularFactor !== undefined) {\r\n            babylonMaterial.metallicF0Factor = properties.specularFactor;\r\n        }\r\n\r\n        if (properties.specularColorFactor !== undefined) {\r\n            babylonMaterial.metallicReflectanceColor = Color3.FromArray(properties.specularColorFactor);\r\n        }\r\n\r\n        if (properties.specularTexture) {\r\n            (properties.specularTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular)`;\r\n                    babylonMaterial.metallicReflectanceTexture = texture;\r\n                    babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular Color)`;\r\n                    babylonMaterial.reflectanceTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_specular(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_ior extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_ior\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFLoaderExtension {\r\n    /**\r\n     * Default ior Value from the spec.\r\n     */\r\n    private static readonly _DEFAULT_IOR = 1.5;\r\n\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 180;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIor>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadIorPropertiesAsync(context: string, properties: IKHRMaterialsIor, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        if (properties.ior !== undefined) {\r\n            babylonMaterial.indexOfRefraction = properties.ior;\r\n        } else {\r\n            babylonMaterial.indexOfRefraction = KHR_materials_ior._DEFAULT_IOR;\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_ior(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { MaterialVariantsController } from \"../../glTFFileLoader\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\nexport { MaterialVariantsController };\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // Define options related types here so they can be referenced in the options,\r\n    // but export the types at the module level. This ensures the types are in the\r\n    // correct namespace for UMD.\r\n    type MaterialVariantsController = {\r\n        /**\r\n         * The list of available variant names for this asset.\r\n         */\r\n        readonly variants: readonly string[];\r\n\r\n        /**\r\n         * Gets or sets the selected variant.\r\n         */\r\n        selectedVariant: string;\r\n    };\r\n\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_variants extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_variants\"]: Partial<{\r\n            /**\r\n             * Specifies the name of the variant that should be selected by default.\r\n             */\r\n            defaultVariant: string;\r\n\r\n            /**\r\n             * Defines a callback that will be called if material variants are loaded.\r\n             * @experimental\r\n             */\r\n            onLoaded: (controller: MaterialVariantsController) => void;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootNode: TransformNode): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootNode: TransformNode): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public static Reset(rootNode: TransformNode): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public reset(rootNode: TransformNode): void {\r\n        KHR_materials_variants.Reset(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootNode: Nullable<TransformNode>): Nullable<IExtensionMetadata> {\r\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        const rootNode = this._loader.rootBabylonMesh;\r\n        if (rootNode) {\r\n            const options = this._loader.parent.extensionOptions[NAME];\r\n            if (options?.defaultVariant) {\r\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\r\n            }\r\n\r\n            options?.onLoaded?.({\r\n                get variants() {\r\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n                },\r\n                get selectedVariant(): string {\r\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n                    if (!lastSelectedVariant) {\r\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\r\n                    }\r\n                    if (Array.isArray(lastSelectedVariant)) {\r\n                        return lastSelectedVariant[0];\r\n                    }\r\n                    return lastSelectedVariant;\r\n                },\r\n                set selectedVariant(variantName) {\r\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot._internalMetadata = {};\r\n                                                for (const key in root._internalMetadata) {\r\n                                                    newRoot._internalMetadata[key] = root._internalMetadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot._internalMetadata.gltf = [];\r\n                                                for (const key in root._internalMetadata.gltf) {\r\n                                                    newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot._internalMetadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot._internalMetadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     * @returns the default options\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        if (!material) {\r\n            return false;\r\n        }\r\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                if (this._transparentMeshesCache.indexOf(mesh) === -1) {\r\n                    this._transparentMeshesCache.push(mesh);\r\n                }\r\n            } else {\r\n                if (this._opaqueMeshesCache.indexOf(mesh) === -1) {\r\n                    this._opaqueMeshesCache.push(mesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material instanceof PBRMaterial) {\r\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Check if the opaque render target has not been disposed and can still be used.\r\n     * @returns\r\n     */\r\n    public _isRenderTargetValid() {\r\n        return this._opaqueRenderTarget?.getInternalTexture() !== null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    public _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n        this._opaqueRenderTarget.renderSprites = true;\r\n        this._opaqueRenderTarget.renderParticles = true;\r\n        this._opaqueRenderTarget.disableImageProcessing = true;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n        });\r\n\r\n        for (const mesh of this._transparentMeshesCache) {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial;\r\n\r\n        // Enables \"refraction\" texture which represents transmitted light.\r\n        pbrMaterial.subSurface.isRefractionEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\r\n\r\n        if (extension.transmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\r\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\r\n                new TransmissionHelper({}, pbrMaterial.getScene());\r\n            } else if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper?._isRenderTargetValid()) {\r\n                // If the render target is not valid, recreate it.\r\n                scene._transmissionHelper?._setupRenderTargets();\r\n            }\r\n        } else {\r\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\r\n            pbrMaterial.subSurface.isRefractionEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            // eslint-disable-next-line github/no-then\r\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture: BaseTexture) => {\r\n                texture.name = `${babylonMaterial.name} (Transmission)`;\r\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\r\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_transmission(loader));\r\n", "/* eslint-disable github/no-then */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsDiffuseTransmission } from \"babylonjs-gltf2interface\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_diffuse_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_diffuse_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsDiffuseTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTranslucentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsDiffuseTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const pbrMaterial = babylonMaterial;\r\n\r\n        // Enables \"translucency\" texture which represents diffusely-transmitted light.\r\n        pbrMaterial.subSurface.isTranslucencyEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make the\r\n        // internal IOR == 1.0 and set the thickness to 0.\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n\r\n        // Tint color will be used for transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintTranslucency = false;\r\n\r\n        if (extension.diffuseTransmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.translucencyIntensity = extension.diffuseTransmissionFactor;\r\n        } else {\r\n            pbrMaterial.subSurface.translucencyIntensity = 0.0;\r\n            pbrMaterial.subSurface.isTranslucencyEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n\r\n        if (extension.diffuseTransmissionTexture) {\r\n            (extension.diffuseTransmissionTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionTexture`, extension.diffuseTransmissionTexture).then((texture: BaseTexture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Transmission)`;\r\n                    pbrMaterial.subSurface.translucencyIntensityTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (extension.diffuseTransmissionColorFactor !== undefined) {\r\n            pbrMaterial.subSurface.translucencyColor = Color3.FromArray(extension.diffuseTransmissionColorFactor);\r\n        } else {\r\n            pbrMaterial.subSurface.translucencyColor = Color3.White();\r\n        }\r\n\r\n        if (extension.diffuseTransmissionColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionColorTexture`, extension.diffuseTransmissionColorTexture).then((texture: BaseTexture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Transmission Color)`;\r\n                    pbrMaterial.subSurface.translucencyColorTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_diffuse_transmission(loader));\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_volume extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_volume\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 173;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\r\n            this._loader._disableInstancedMesh++;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        if (this.enabled) {\r\n            this._loader._disableInstancedMesh--;\r\n        }\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsVolume>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadVolumePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsVolume): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if ((!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled) || !extension.thicknessFactor) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // IOR in this extension only affects interior.\r\n        babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;\r\n        const attenuationDistance = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\r\n        babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;\r\n        if (extension.attenuationColor !== undefined && extension.attenuationColor.length == 3) {\r\n            babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);\r\n        }\r\n\r\n        babylonMaterial.subSurface.minimumThickness = 0.0;\r\n        babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;\r\n        babylonMaterial.subSurface.useThicknessAsDepth = true;\r\n        if (extension.thicknessTexture) {\r\n            (extension.thicknessTexture as ITextureInfo).nonColorData = true;\r\n            // eslint-disable-next-line github/no-then\r\n            return this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture).then((texture: BaseTexture) => {\r\n                texture.name = `${babylonMaterial.name} (Thickness)`;\r\n                babylonMaterial.subSurface.thicknessTexture = texture;\r\n                babylonMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_volume(loader));\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsDispersion } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_dispersion\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_dispersion extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_dispersion\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_dispersion implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsDispersion>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadDispersionPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadDispersionPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsDispersion): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if (!babylonMaterial.subSurface.isRefractionEnabled || !extension.dispersion) {\r\n            return Promise.resolve();\r\n        }\r\n        babylonMaterial.subSurface.isDispersionEnabled = true;\r\n        babylonMaterial.subSurface.dispersion = extension.dispersion;\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_dispersion(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IEXTMaterialsDiffuseRoughness } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\nconst NAME = \"EXT_materials_diffuse_roughness\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_materials_diffuse_roughness extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_materials_diffuse_roughness\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/fdee35425ae560ea378092e38977216d63a094ec/extensions/2.0/Khronos/EXT_materials_diffuse_roughness/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_materials_diffuse_roughness implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMaterialsDiffuseRoughness>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadDiffuseRoughnessPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadDiffuseRoughnessPropertiesAsync(context: string, properties: IEXTMaterialsDiffuseRoughness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.brdf.baseDiffuseModel = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n\r\n        if (properties.diffuseRoughnessFactor != undefined) {\r\n            babylonMaterial.baseDiffuseRoughness = properties.diffuseRoughnessFactor;\r\n        } else {\r\n            babylonMaterial.baseDiffuseRoughness = 0;\r\n        }\r\n\r\n        if (properties.diffuseRoughnessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseRoughnessTexture`, properties.diffuseRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Roughness)`;\r\n                    babylonMaterial.baseDiffuseRoughnessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_materials_diffuse_roughness(loader));\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_mesh_quantization\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_mesh_quantization extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_mesh_quantization\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_mesh_quantization implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {}\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_mesh_quantization(loader));\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IKHRTextureBasisU } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_texture_basisu\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_texture_basisu extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_texture_basisu\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_basisu implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureBasisU, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_texture_basisu(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nimport type { ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_texture_transform extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_texture_transform\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureTransform, BaseTexture>(context, textureInfo, this.name, async (extensionContext, extension) => {\r\n            return await this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\r\n                if (!(babylonTexture instanceof Texture)) {\r\n                    throw new Error(`${extensionContext}: Texture type not supported`);\r\n                }\r\n\r\n                if (extension.offset) {\r\n                    babylonTexture.uOffset = extension.offset[0];\r\n                    babylonTexture.vOffset = extension.offset[1];\r\n                }\r\n\r\n                // Always rotate around the origin.\r\n                babylonTexture.uRotationCenter = 0;\r\n                babylonTexture.vRotationCenter = 0;\r\n\r\n                if (extension.rotation) {\r\n                    babylonTexture.wAng = -extension.rotation;\r\n                }\r\n\r\n                if (extension.scale) {\r\n                    babylonTexture.uScale = extension.scale[0];\r\n                    babylonTexture.vScale = extension.scale[1];\r\n                }\r\n\r\n                if (extension.texCoord != undefined) {\r\n                    babylonTexture.coordinatesIndex = extension.texCoord;\r\n                }\r\n\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_texture_transform(loader));\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRXmpJsonLd_Gltf, IKHRXmpJsonLd_Node } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_xmp_json_ld\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_xmp_json_ld extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_xmp_json_ld\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_xmp_json_ld implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Called after the loader state changes to LOADING.\r\n     */\r\n    public onLoading(): void {\r\n        if (this._loader.rootBabylonMesh === null) {\r\n            return;\r\n        }\r\n\r\n        const xmpGltf = this._loader.gltf.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Gltf;\r\n        const xmpNode = this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Node;\r\n        if (xmpGltf && xmpNode) {\r\n            const packet = +xmpNode.packet;\r\n            if (xmpGltf.packets && packet < xmpGltf.packets.length) {\r\n                this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};\r\n                this._loader.rootBabylonMesh.metadata.xmp = xmpGltf.packets[packet];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_xmp_json_ld(loader));\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport type { ICamera, IKHRLightsPunctual_Light, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { AnimationPropertyInfo } from \"../glTFLoaderAnimation\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { SetInterpolationForKey } from \"./objectModelMapping\";\r\n\r\nfunction getColor3(_target: any, source: Float32Array, offset: number, scale: number): Color3 {\r\n    return Color3.FromArray(source, offset).scale(scale);\r\n}\r\n\r\nfunction getAlpha(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 3] * scale;\r\n}\r\n\r\nfunction getFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale;\r\n}\r\n\r\nfunction getMinusFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return -source[offset] * scale;\r\n}\r\n\r\nfunction getNextFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 1] * scale;\r\n}\r\n\r\nfunction getFloatBy2(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale * 2;\r\n}\r\n\r\nfunction getTextureTransformTree(textureName: string) {\r\n    return {\r\n        scale: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2),\r\n        ],\r\n        offset: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2),\r\n        ],\r\n        rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)],\r\n    };\r\n}\r\n\r\nclass CameraAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: ICamera, name: string, fps: number, keys: any[]) {\r\n        return [{ babylonAnimatable: target._babylonCamera!, babylonAnimation: this._buildAnimation(name, fps, keys) }];\r\n    }\r\n}\r\n\r\nclass MaterialAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: IMaterial, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        for (const fillMode in target._data!) {\r\n            babylonAnimations.push({\r\n                babylonAnimatable: target._data[fillMode].babylonMaterial,\r\n                babylonAnimation: this._buildAnimation(name, fps, keys),\r\n            });\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nclass LightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: IKHRLightsPunctual_Light, name: string, fps: number, keys: any[]) {\r\n        return [{ babylonAnimatable: target._babylonLight!, babylonAnimation: this._buildAnimation(name, fps, keys) }];\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/xmag\", [\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoLeft\", getMinusFloat, () => 1),\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoRight\", getNextFloat, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/ymag\", [\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoBottom\", getMinusFloat, () => 1),\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoTop\", getNextFloat, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/zfar\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/znear\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/perspective/yfov\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"fov\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/perspective/zfar\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/perspective/znear\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)]);\r\n\r\n// add interpolation to the materials mapping\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"albedoColor\", getColor3, () => 4),\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"alpha\", getAlpha, () => 4),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/metallicFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallic\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/metallicFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"roughness\", getFloat, () => 1)]);\r\nconst baseColorTextureInterpolation = getTextureTransformTree(\"albedoTexture\");\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale\", baseColorTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset\", baseColorTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/rotation\", baseColorTextureInterpolation.rotation);\r\n\r\nconst metallicRoughnessTextureInterpolation = getTextureTransformTree(\"metallicTexture\");\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/scale\", metallicRoughnessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/offset\", metallicRoughnessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/rotation\", metallicRoughnessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/emissiveFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"emissiveColor\", getColor3, () => 3)]);\r\nconst normalTextureInterpolation = getTextureTransformTree(\"bumpTexture\");\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/scale\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"bumpTexture.level\", getFloat, () => 1)]);\r\n\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/scale\", normalTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/offset\", normalTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/rotation\", normalTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/strength\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"ambientTextureStrength\", getFloat, () => 1)]);\r\n\r\nconst occlusionTextureInterpolation = getTextureTransformTree(\"ambientTexture\");\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/scale\", occlusionTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/offset\", occlusionTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/rotation\", occlusionTextureInterpolation.rotation);\r\nconst emissiveTextureInterpolation = getTextureTransformTree(\"emissiveTexture\");\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/scale\", emissiveTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/offset\", emissiveTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/rotation\", emissiveTextureInterpolation.rotation);\r\n\r\n// materials extensions\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyStrength\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"anisotropy.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyRotation\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"anisotropy.angle\", getFloat, () => 1),\r\n]);\r\nconst anisotropyTextureInterpolation = getTextureTransformTree(\"anisotropy.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/scale\", anisotropyTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/offset\", anisotropyTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/rotation\", anisotropyTextureInterpolation.rotation);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.roughness\", getFloat, () => 1),\r\n]);\r\nconst clearcoatTextureInterpolation = getTextureTransformTree(\"clearCoat.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/scale\", clearcoatTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/offset\", clearcoatTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/rotation\", clearcoatTextureInterpolation.rotation);\r\nconst clearcoatNormalTextureInterpolation = getTextureTransformTree(\"clearCoat.bumpTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/scale\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.bumpTexture.level\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/scale\", clearcoatNormalTextureInterpolation.scale);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/offset\",\r\n    clearcoatNormalTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/rotation\",\r\n    clearcoatNormalTextureInterpolation.rotation\r\n);\r\nconst clearcoatRoughnessTextureInterpolation = getTextureTransformTree(\"clearCoat.textureRoughness\");\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/scale\",\r\n    clearcoatRoughnessTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/offset\",\r\n    clearcoatRoughnessTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/rotation\",\r\n    clearcoatRoughnessTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_dispersion/dispersionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.dispersion\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_emissive_strength/emissiveStrength\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"emissiveIntensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_ior/ior\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"indexOfRefraction\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceIor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.indexOfRefraction\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMinimum\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.minimumThickness\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMaximum\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.maximumThickness\", getFloat, () => 1),\r\n]);\r\n\r\nconst iridescenceTextureInterpolation = getTextureTransformTree(\"iridescence.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/scale\", iridescenceTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/offset\", iridescenceTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/rotation\", iridescenceTextureInterpolation.rotation);\r\n\r\nconst iridescenceThicknessTextureInterpolation = getTextureTransformTree(\"iridescence.thicknessTexture\");\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/scale\",\r\n    iridescenceThicknessTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/offset\",\r\n    iridescenceThicknessTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/rotation\",\r\n    iridescenceThicknessTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"sheen.color\", getColor3, () => 3),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"sheen.roughness\", getFloat, () => 1),\r\n]);\r\n\r\nconst sheenTextureInterpolation = getTextureTransformTree(\"sheen.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/scale\", sheenTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/offset\", sheenTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/rotation\", sheenTextureInterpolation.rotation);\r\n\r\nconst sheenRoughnessTextureInterpolation = getTextureTransformTree(\"sheen.textureRoughness\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/scale\", sheenRoughnessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/offset\", sheenRoughnessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/rotation\", sheenRoughnessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallicF0Factor\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"metallicReflectanceColor\", getColor3, () => 3),\r\n]);\r\n\r\nconst specularTextureInterpolation = getTextureTransformTree(\"metallicReflectanceTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/scale\", specularTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/offset\", specularTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/rotation\", specularTextureInterpolation.rotation);\r\nconst specularColorTextureInterpolation = getTextureTransformTree(\"reflectanceTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/scale\", specularColorTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/offset\", specularColorTextureInterpolation.offset);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/rotation\",\r\n    specularColorTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.refractionIntensity\", getFloat, () => 1),\r\n]);\r\nconst transmissionTextureInterpolation = getTextureTransformTree(\"subSurface.refractionIntensityTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/scale\", transmissionTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/offset\", transmissionTextureInterpolation.offset);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/rotation\",\r\n    transmissionTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/attenuationColor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.tintColor\", getColor3, () => 3),\r\n]);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/attenuationDistance\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.tintColorAtDistance\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.maximumThickness\", getFloat, () => 1),\r\n]);\r\n\r\nconst thicknessTextureInterpolation = getTextureTransformTree(\"subSurface.thicknessTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/scale\", thicknessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/offset\", thicknessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/rotation\", thicknessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.translucencyIntensity\", getFloat, () => 1),\r\n]);\r\n\r\nconst diffuseTransmissionTextureInterpolation = getTextureTransformTree(\"subSurface.translucencyIntensityTexture\");\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/scale\",\r\n    diffuseTransmissionTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/offset\",\r\n    diffuseTransmissionTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/rotation\",\r\n    diffuseTransmissionTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.translucencyColor\", getColor3, () => 3),\r\n]);\r\n\r\nconst diffuseTransmissionColorTextureInterpolation = getTextureTransformTree(\"subSurface.translucencyColorTexture\");\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/scale\",\r\n    diffuseTransmissionColorTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/offset\",\r\n    diffuseTransmissionColorTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/rotation\",\r\n    diffuseTransmissionColorTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/color\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/intensity\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/range\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"range\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/spot/innerConeAngle\", [\r\n    new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"innerAngle\", getFloatBy2, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/spot/outerConeAngle\", [\r\n    new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"angle\", getFloatBy2, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/nodes/{}/extensions/EXT_lights_ies/color\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/extensions/EXT_lights_ies/multiplier\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)]);\r\n", "import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimation, IAnimationChannel } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRAnimationPointer } from \"babylonjs-gltf2interface\";\r\nimport { AnimationChannelTargetPath } from \"babylonjs-gltf2interface\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport \"./KHR_animation_pointer.data\";\r\n\r\nconst NAME = \"KHR_animation_pointer\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_animation_pointer extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_animation_pointer\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_animation_pointer implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _pathToObjectConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this._pathToObjectConverter = GetPathToObjectConverter(this._loader.gltf);\r\n    }\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public get enabled(): boolean {\r\n        return this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathToObjectConverter; // GC\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete or null if not handled\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        const extension = channel.target.extensions?.KHR_animation_pointer as IKHRAnimationPointer;\r\n        if (!extension || !this._pathToObjectConverter) {\r\n            return null;\r\n        }\r\n\r\n        if (channel.target.path !== AnimationChannelTargetPath.POINTER) {\r\n            Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${AnimationChannelTargetPath.POINTER}) when using the ${this.name} extension`);\r\n        }\r\n\r\n        if (channel.target.node != undefined) {\r\n            Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\r\n        }\r\n\r\n        const extensionContext = `${context}/extensions/${this.name}`;\r\n\r\n        const pointer = extension.pointer;\r\n        if (!pointer) {\r\n            throw new Error(`${extensionContext}: Pointer is missing`);\r\n        }\r\n\r\n        try {\r\n            const obj = this._pathToObjectConverter.convert(pointer);\r\n            if (!obj.info.interpolation) {\r\n                throw new Error(`${extensionContext}/pointer: Interpolation is missing`);\r\n            }\r\n            return this._loader._loadAnimationChannelFromTargetInfoAsync(\r\n                context,\r\n                animationContext,\r\n                animation,\r\n                channel,\r\n                {\r\n                    object: obj.object,\r\n                    info: obj.info.interpolation,\r\n                },\r\n                onLoad\r\n            );\r\n        } catch (e) {\r\n            Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_animation_pointer(loader));\r\n", "/**\r\n * Composed of a frame, and an action function\r\n */\r\nexport class AnimationEvent {\r\n    /**\r\n     * Specifies if the animation event is done\r\n     */\r\n    public isDone: boolean = false;\r\n\r\n    /**\r\n     * Initializes the animation event\r\n     * @param frame The frame for which the event is triggered\r\n     * @param action The event to perform when triggered\r\n     * @param onlyOnce Specifies if the event should be triggered only once\r\n     */\r\n    constructor(\r\n        /** The frame for which the event is triggered **/\r\n        public frame: number,\r\n        /** The event to perform when triggered **/\r\n        public action: (currentFrame: number) => void,\r\n        /** Specifies if the event should be triggered only once**/\r\n        public onlyOnce?: boolean\r\n    ) {}\r\n\r\n    /** @internal */\r\n    public _clone(): AnimationEvent {\r\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\r\n    }\r\n}\r\n", "import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { _RetryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n\r\n    private _loop = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (value === this._loop) {\r\n            return;\r\n        }\r\n\r\n        this._loop = value;\r\n        this.updateOptions({ loop: value });\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        if (AbstractEngine.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {\r\n            // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\r\n            // to get the actual current time.\r\n            const timeSinceLastStart = this.isPaused ? 0 : AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\r\n            return this._currentTime + timeSinceLastStart;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._spatialSound;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        if (newValue == this._spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const wasPlaying = this.isPlaying;\r\n        this.pause();\r\n\r\n        if (newValue) {\r\n            this._spatialSound = newValue;\r\n            this._updateSpatialParameters();\r\n        } else {\r\n            this._disableSpatialSound();\r\n        }\r\n\r\n        if (wasPlaying) {\r\n            this.play();\r\n        }\r\n    }\r\n\r\n    private _spatialSound: boolean = false;\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _currentTime: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: Nullable<AudioNode>;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: Nullable<HTMLAudioElement>;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" | \"AudioBuffer\" | \"MediaElement\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n    private _tryToPlayTimeout: Nullable<NodeJS.Timeout>;\r\n    private _audioUnlockedObserver?: Nullable<Observer<IAudioEngine>>;\r\n    private _url?: Nullable<string>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this._loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this._spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._soundGain = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._soundGain.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this._spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            let validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                        this._url = urlOrArrayBuffer;\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n                        this._urlType = \"MediaElement\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n                        this._urlType = \"AudioBuffer\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    let urls: string[] = [];\r\n                    let codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaElement\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"AudioBuffer\":\r\n                            this._audioBufferLoaded(urlOrArrayBuffer);\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        // eslint-disable-next-line no-fallthrough\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (let i = 0; i < urls.length; i++) {\r\n                                const url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".mp4\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\r\n                                            \"canplaythrough\",\r\n                                            () => {\r\n                                                this._isReadyToPlay = true;\r\n                                                if (this.autoplay) {\r\n                                                    this.play(0, this._offset, this._length);\r\n                                                }\r\n                                                if (this._readyToPlayCallback) {\r\n                                                    this._readyToPlayCallback();\r\n                                                }\r\n                                            },\r\n                                            { once: true }\r\n                                        );\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (AbstractEngine.audioEngine && !AbstractEngine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                AbstractEngine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n                this._htmlAudioElement = null;\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n                this._streamingSource = null;\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n\r\n            this._clearTimeoutsAndObservers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    private _audioBufferLoaded(buffer: AudioBuffer) {\r\n        if (!AbstractEngine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        this._audioBuffer = buffer;\r\n        this._isReadyToPlay = true;\r\n        if (this.autoplay) {\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n        if (this._readyToPlayCallback) {\r\n            this._readyToPlayCallback();\r\n        }\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!AbstractEngine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        AbstractEngine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBufferLoaded(buffer);\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this.spatialSound = options.spatialSound ?? this._spatialSound;\r\n            this._setOffset(options.offset ?? undefined);\r\n            this.setVolume(options.volume ?? this._volume);\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = this._soundPanner ?? AbstractEngine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disableSpatialSound() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        this._inputAudioNode = this._soundGain;\r\n        this._soundPanner?.disconnect();\r\n        this._soundPanner = null;\r\n        this._spatialSound = false;\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        if (this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        } else {\r\n            this._createSpatialParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (newPosition.equals(this._position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(newPosition);\r\n\r\n        if (\r\n            AbstractEngine.audioEngine?.canUseWebAudio &&\r\n            this._spatialSound &&\r\n            this._soundPanner &&\r\n            !isNaN(this._position.x) &&\r\n            !isNaN(this._position.y) &&\r\n            !isNaN(this._position.z)\r\n        ) {\r\n            this._soundPanner.positionX.value = this._position.x;\r\n            this._soundPanner.positionY.value = this._position.y;\r\n            this._soundPanner.positionZ.value = this._position.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.orientationX.value = direction.x;\r\n        this._soundPanner.orientationY.value = direction.y;\r\n        this._soundPanner.orientationZ.value = direction.z;\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            const distance = this._scene.audioListenerPositionProvider\r\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\r\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && AbstractEngine.audioEngine?.audioContext) {\r\n            try {\r\n                this._clearTimeoutsAndObservers();\r\n\r\n                let startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine?.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this._spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.positionX.value = this._position.x;\r\n                            this._soundPanner.positionY.value = this._position.y;\r\n                            this._soundPanner.positionZ.value = this._position.z;\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource && this._htmlAudioElement) {\r\n                        this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    if (this._streamingSource) {\r\n                        this._streamingSource.disconnect();\r\n                        if (this._inputAudioNode) {\r\n                            this._streamingSource.connect(this._inputAudioNode);\r\n                        }\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio element\r\n                        const tryToPlay = () => {\r\n                            if (AbstractEngine.audioEngine?.unlocked) {\r\n                                if (!this._htmlAudioElement) {\r\n                                    return;\r\n                                }\r\n\r\n                                this._htmlAudioElement.currentTime = offset ?? 0;\r\n                                const playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    // eslint-disable-next-line github/no-then\r\n                                    playPromise.catch(() => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        AbstractEngine.audioEngine?.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    const tryToPlay = () => {\r\n                        if (AbstractEngine.audioEngine?.audioContext) {\r\n                            length = length || this._length;\r\n\r\n                            if (offset !== undefined) {\r\n                                this._setOffset(offset);\r\n                            }\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = AbstractEngine.audioEngine?.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine.audioContext.currentTime;\r\n                                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer!.duration;\r\n                                this._soundSource.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (AbstractEngine.audioEngine?.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        this._tryToPlayTimeout = setTimeout(() => {\r\n                            if (AbstractEngine.audioEngine?.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                AbstractEngine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        this._startTime = 0;\r\n        this._currentTime = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource?.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\r\n                const stopTime = time ? AbstractEngine.audioEngine.audioContext.currentTime + time : undefined;\r\n                this._soundSource.onended = () => {\r\n                    this.isPlaying = false;\r\n                    this.isPaused = false;\r\n                    this._startTime = 0;\r\n                    this._currentTime = 0;\r\n                    if (this._soundSource) {\r\n                        this._soundSource.onended = () => void 0;\r\n                    }\r\n                    this._onended();\r\n                };\r\n                this._soundSource.stop(stopTime);\r\n            } else {\r\n                this.isPlaying = false;\r\n            }\r\n        } else if (this.isPaused) {\r\n            this.isPaused = false;\r\n            this._startTime = 0;\r\n            this._currentTime = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource?.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n            } else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\r\n                this._soundSource.onended = () => void 0;\r\n                this._soundSource.stop();\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n                this._currentTime += AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._soundGain) {\r\n            if (time && AbstractEngine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(AbstractEngine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, AbstractEngine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, AbstractEngine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        return this._playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this._spatialSound) {\r\n            this._spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => this._isReadyToPlay,\r\n                    () => {\r\n                        clonedSound._audioBuffer = this.getAudioBuffer();\r\n                        clonedSound._isReadyToPlay = true;\r\n                        if (clonedSound.autoplay) {\r\n                            clonedSound.play(0, this._offset, this._length);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n\r\n            const currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this._spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this._url,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this._spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this._spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        let newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => sourceSound._isReadyToPlay,\r\n                    () => {\r\n                        newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                        newSound._isReadyToPlay = true;\r\n                        if (newSound.autoplay) {\r\n                            newSound.play(0, newSound._offset, newSound._length);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n\r\n    private _setOffset(value?: number) {\r\n        if (this._offset === value) {\r\n            return;\r\n        }\r\n        if (this.isPaused) {\r\n            this.stop();\r\n            this.isPaused = false;\r\n        }\r\n        this._offset = value;\r\n    }\r\n\r\n    private _clearTimeoutsAndObservers() {\r\n        if (this._tryToPlayTimeout) {\r\n            clearTimeout(this._tryToPlayTimeout);\r\n            this._tryToPlayTimeout = null;\r\n        }\r\n        if (this._audioUnlockedObserver) {\r\n            AbstractEngine.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);\r\n            this._audioUnlockedObserver = null;\r\n        }\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.Sound\", Sound);\r\n", "import type { Sound } from \"../Audio/sound\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Wraps one or more Sound objects and selects one with random weight for playback.\r\n */\r\nexport class WeightedSound {\r\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\r\n    public loop: boolean = false;\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _volume: number = 1;\r\n    /** A Sound is currently playing. */\r\n    public isPlaying: boolean = false;\r\n    /** A Sound is currently paused. */\r\n    public isPaused: boolean = false;\r\n\r\n    private _sounds: Sound[] = [];\r\n    private _weights: number[] = [];\r\n    private _currentIndex?: number;\r\n\r\n    /**\r\n     * Creates a new WeightedSound from the list of sounds given.\r\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\r\n     * @param sounds Array of Sounds that will be selected from.\r\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\r\n     */\r\n    constructor(loop: boolean, sounds: Sound[], weights: number[]) {\r\n        if (sounds.length !== weights.length) {\r\n            throw new Error(\"Sounds length does not equal weights length\");\r\n        }\r\n\r\n        this.loop = loop;\r\n        this._weights = weights;\r\n        // Normalize the weights\r\n        let weightSum = 0;\r\n        for (const weight of weights) {\r\n            weightSum += weight;\r\n        }\r\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\r\n        for (let i = 0; i < this._weights.length; i++) {\r\n            this._weights[i] *= invWeightSum;\r\n        }\r\n        this._sounds = sounds;\r\n        for (const sound of this._sounds) {\r\n            sound.onEndedObservable.add(() => {\r\n                this._onended();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value !== this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value !== this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public get volume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public set volume(value: number) {\r\n        if (value !== this._volume) {\r\n            for (const sound of this._sounds) {\r\n                sound.setVolume(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].autoplay = false;\r\n        }\r\n        if (this.loop && this.isPlaying) {\r\n            this.play();\r\n        } else {\r\n            this.isPlaying = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Suspend playback\r\n     */\r\n    public pause() {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._currentIndex !== undefined) {\r\n                this._sounds[this._currentIndex].pause();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop playback\r\n     */\r\n    public stop() {\r\n        this.isPlaying = false;\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start playback.\r\n     * @param startOffset Position the clip head at a specific time in seconds.\r\n     */\r\n    public play(startOffset?: number) {\r\n        if (!this.isPaused) {\r\n            this.stop();\r\n            const randomValue = Math.random();\r\n            let total = 0;\r\n            for (let i = 0; i < this._weights.length; i++) {\r\n                total += this._weights[i];\r\n                if (randomValue <= total) {\r\n                    this._currentIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const sound = this._sounds[this._currentIndex ?? 0];\r\n        if (sound.isReady()) {\r\n            sound.play(0, this.isPaused ? undefined : startOffset);\r\n        } else {\r\n            sound.autoplay = true;\r\n        }\r\n        this.isPlaying = true;\r\n        this.isPaused = false;\r\n    }\r\n}\r\n", "import type { Sound } from \"./sound\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Options allowed during the creation of a sound track.\r\n */\r\nexport interface ISoundTrackOptions {\r\n    /**\r\n     * The volume the sound track should take during creation\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * Define if the sound track is the main sound track of the scene\r\n     */\r\n    mainTrack?: boolean;\r\n}\r\n\r\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n */\r\nexport class SoundTrack {\r\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\r\n    public id: number = -1;\r\n    /**\r\n     * The list of sounds included in the sound track.\r\n     */\r\n    public soundCollection: Array<Sound>;\r\n\r\n    private _outputAudioNode: Nullable<GainNode>;\r\n    private _scene: Scene;\r\n    private _connectedAnalyser: Analyser;\r\n    private _options: ISoundTrackOptions;\r\n    private _isInitialized = false;\r\n\r\n    /**\r\n     * Creates a new sound track.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n     * @param scene Define the scene the sound track belongs to\r\n     * @param options\r\n     */\r\n    constructor(scene?: Nullable<Scene>, options: ISoundTrackOptions = {}) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        this.soundCollection = [];\r\n        this._options = options;\r\n\r\n        if (!this._options.mainTrack && this._scene.soundTracks) {\r\n            this._scene.soundTracks.push(this);\r\n            this.id = this._scene.soundTracks.length - 1;\r\n        }\r\n    }\r\n\r\n    private _initializeSoundTrackAudioGraph() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\r\n\r\n            if (this._options) {\r\n                if (this._options.volume) {\r\n                    this._outputAudioNode.gain.value = this._options.volume;\r\n                }\r\n            }\r\n\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound track and its associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\r\n            if (this._connectedAnalyser) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n            }\r\n            while (this.soundCollection.length) {\r\n                this.soundCollection[0].dispose();\r\n            }\r\n            if (this._outputAudioNode) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a sound to this sound track\r\n     * @param sound define the sound to add\r\n     * @ignoreNaming\r\n     */\r\n    public addSound(sound: Sound): void {\r\n        if (!this._isInitialized) {\r\n            this._initializeSoundTrackAudioGraph();\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\r\n        }\r\n        if (sound.soundTrackId !== undefined) {\r\n            if (sound.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(sound);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\r\n            }\r\n        }\r\n\r\n        this.soundCollection.push(sound);\r\n        sound.soundTrackId = this.id;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound to this sound track\r\n     * @param sound define the sound to remove\r\n     * @ignoreNaming\r\n     */\r\n    public removeSound(sound: Sound): void {\r\n        const index = this.soundCollection.indexOf(sound);\r\n        if (index !== -1) {\r\n            this.soundCollection.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global volume for the full sound track.\r\n     * @param newVolume Define the new volume of the sound track\r\n     */\r\n    public setVolume(newVolume: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the sound track to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        this._connectedAnalyser = analyser;\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\r\n        }\r\n    }\r\n}\r\n", "import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (BabylonFileParsers[name]) {\r\n        return BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (IndividualBabylonFileParsers[name]) {\r\n        return IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(BabylonFileParsers, parserName)) {\r\n            BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "import { Sound } from \"./sound\";\r\nimport { SoundTrack } from \"./soundTrack\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"./audioEngine\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    // TODO: add sound\r\n    let loadedSounds: Sound[] = [];\r\n    let loadedSound: Sound;\r\n    container.sounds = container.sounds || [];\r\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\r\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\r\n            const parsedSound = parsedData.sounds[index];\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n                if (!parsedSound.url) {\r\n                    parsedSound.url = parsedSound.name;\r\n                }\r\n                if (!loadedSounds[parsedSound.url]) {\r\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\r\n                    loadedSounds[parsedSound.url] = loadedSound;\r\n                    container.sounds.push(loadedSound);\r\n                } else {\r\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\r\n                }\r\n            } else {\r\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\r\n            }\r\n        }\r\n    }\r\n\r\n    loadedSounds = [];\r\n});\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing field\r\n         */\r\n        _mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The main sound track played by the scene.\r\n         * It contains your primary collection of sounds.\r\n         */\r\n        mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The list of sound tracks added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        soundTracks: Nullable<Array<SoundTrack>>;\r\n\r\n        /**\r\n         * Gets a sound using a given name\r\n         * @param name defines the name to search for\r\n         * @returns the found sound or null if not found at all.\r\n         */\r\n        getSoundByName(name: string): Nullable<Sound>;\r\n\r\n        /**\r\n         * Gets or sets if audio support is enabled\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioEnabled: boolean;\r\n\r\n        /**\r\n         * Gets or sets if audio will be output to headphones\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        headphone: boolean;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener position provider\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioListenerPositionProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener rotation provider\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioListenerRotationProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets a refresh rate when using 3D audio positioning\r\n         */\r\n        audioPositioningRefreshRate: number;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (!this._mainSoundTrack) {\r\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\r\n        }\r\n\r\n        return this._mainSoundTrack;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getSoundByName = function (name: string): Nullable<Sound> {\r\n    let index: number;\r\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\r\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\r\n            return this.mainSoundTrack.soundCollection[index];\r\n        }\r\n    }\r\n\r\n    if (this.soundTracks) {\r\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\r\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\r\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\r\n                    return this.soundTracks[sdIndex].soundCollection[index];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioEnabled;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.enableAudio();\r\n        } else {\r\n            compo.disableAudio();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"headphone\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.headphone;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.switchAudioModeForHeadphones();\r\n        } else {\r\n            compo.switchAudioModeForNormalSpeakers();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerPositionProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerPositionProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerRotationProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerRotationProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioPositioningRefreshRate;\r\n    },\r\n    set: function (this: Scene, value: number) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        compo.audioPositioningRefreshRate = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Defines the sound scene component responsible to manage any sounds\r\n * in a given scene.\r\n */\r\nexport class AudioSceneComponent implements ISceneSerializableComponent {\r\n    private static _CameraDirection = new Vector3(0, 0, -1);\r\n\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_AUDIO;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _audioEnabled = true;\r\n    /**\r\n     * Gets whether audio is enabled or not.\r\n     * Please use related enable/disable method to switch state.\r\n     */\r\n    public get audioEnabled(): boolean {\r\n        return this._audioEnabled;\r\n    }\r\n\r\n    private _headphone = false;\r\n    /**\r\n     * Gets whether audio is outputting to headphone or not.\r\n     * Please use the according Switch methods to change output.\r\n     */\r\n    public get headphone(): boolean {\r\n        return this._headphone;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a refresh rate when using 3D audio positioning\r\n     */\r\n    public audioPositioningRefreshRate = 500;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener position for all sounds in the scene\r\n     * By default, this is the position of the first active camera\r\n     */\r\n    public audioListenerPositionProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener rotation for all sounds in the scene\r\n     * By default, this is the rotation of the first active camera\r\n     */\r\n    public audioListenerRotationProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        scene.soundTracks = [] as SoundTrack[];\r\n        scene.sounds = [] as Sound[];\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here. (Not rendering related)\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        serializationObject.sounds = [];\r\n\r\n        if (this.scene.soundTracks) {\r\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\r\n                const soundtrack = this.scene.soundTracks[index];\r\n\r\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\r\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.play();\r\n            sound.autoplay = true;\r\n            this.scene.mainSoundTrack.addSound(sound);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose = false): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.stop();\r\n            sound.autoplay = false;\r\n            this.scene.mainSoundTrack.removeSound(sound);\r\n            if (dispose) {\r\n                sound.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.scene;\r\n        if (scene._mainSoundTrack) {\r\n            scene.mainSoundTrack.dispose();\r\n        }\r\n\r\n        if (scene.soundTracks) {\r\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\r\n                scene.soundTracks[scIndex].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables audio in the associated scene.\r\n     */\r\n    public disableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = false;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.suspend();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            scene.mainSoundTrack.soundCollection[i].pause();\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    scene.soundTracks[i].soundCollection[j].pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables audio in the associated scene.\r\n     */\r\n    public enableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = true;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.resume();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\r\n                scene.mainSoundTrack.soundCollection[i].play();\r\n            }\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\r\n                        scene.soundTracks[i].soundCollection[j].play();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to headphone output.\r\n     */\r\n    public switchAudioModeForHeadphones() {\r\n        const scene = this.scene;\r\n        this._headphone = true;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToHRTF();\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to normal speakers.\r\n     */\r\n    public switchAudioModeForNormalSpeakers() {\r\n        const scene = this.scene;\r\n        this._headphone = false;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\r\n\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _cachedCameraDirection = new Vector3();\r\n    private _cachedCameraPosition = new Vector3();\r\n    private _lastCheck = 0;\r\n    private _invertMatrixTemp = new Matrix();\r\n    private _cameraDirectionTemp = new Vector3();\r\n\r\n    private _afterRender() {\r\n        const now = PrecisionDate.Now;\r\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck = now;\r\n\r\n        const scene = this.scene;\r\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\r\n            return;\r\n        }\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        if (audioEngine.audioContext) {\r\n            let listeningCamera = scene.activeCamera;\r\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\r\n                listeningCamera = scene.activeCameras[0];\r\n            }\r\n\r\n            // A custom listener position provider was set\r\n            // Use the users provided position instead of camera's\r\n            if (this.audioListenerPositionProvider) {\r\n                const position: Vector3 = this.audioListenerPositionProvider();\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // Set the listener position to the listening camera global position\r\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\r\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\r\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\r\n                }\r\n            }\r\n            // Otherwise set the listener position to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\r\n            }\r\n\r\n            // A custom listener rotation provider was set\r\n            // Use the users provided rotation instead of camera's\r\n            if (this.audioListenerRotationProvider) {\r\n                const rotation: Vector3 = this.audioListenerRotationProvider();\r\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // for VR cameras\r\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\r\n                    listeningCamera = listeningCamera.rigCameras[0];\r\n                }\r\n\r\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\r\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\r\n                this._cameraDirectionTemp.normalize();\r\n                // To avoid some errors on GearVR\r\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\r\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\r\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\r\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise set the listener rotation to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\r\n            }\r\n\r\n            let i: number;\r\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n                const sound = scene.mainSoundTrack.soundCollection[i];\r\n                if (sound.useCustomAttenuation) {\r\n                    sound.updateDistanceFromListener();\r\n                }\r\n            }\r\n            if (scene.soundTracks) {\r\n                for (i = 0; i < scene.soundTracks.length; i++) {\r\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                        const sound = scene.soundTracks[i].soundCollection[j];\r\n                        if (sound.useCustomAttenuation) {\r\n                            sound.updateDistanceFromListener();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nSound._SceneComponentInitialization = (scene: Scene) => {\r\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\r\n    if (!compo) {\r\n        compo = new AudioSceneComponent(scene);\r\n        scene._addComponent(compo);\r\n    }\r\n};\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Audio/audioSceneComponent\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_audio_emitter extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_audio_emitter\"]: {};\r\n    }\r\n}\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                for (const emitterIndex of extension.emitters) {\r\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                            for (const sound of emitter._babylonSounds) {\r\n                                sound.attachToMesh(babylonMesh);\r\n                                if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                    sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                    sound.setDirectionalCone(\r\n                                        2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                        2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                        0\r\n                                    );\r\n                                }\r\n                            }\r\n                        })\r\n                    );\r\n                }\r\n\r\n                assign(babylonMesh);\r\n            });\r\n            await Promise.all(promises);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, async (extensionContext, extension) => {\r\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\r\n            const promises = new Array<Promise<any>>();\r\n            ArrayItem.Assign(extension.events);\r\n            for (const event of extension.events) {\r\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n            }\r\n            await Promise.all(promises);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    // eslint-disable-next-line github/no-then\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        // eslint-disable-next-line github/no-then\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\r\n", "/* eslint-disable github/no-then */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_lod extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_lod\"]: Partial<{\r\n            /**\r\n             * Maximum number of LODs to load, starting from the lowest LOD.\r\n             */\r\n            maxLODsToLoad: number;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.\r\n        // For new extensions, they should only use options.\r\n        this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME]?.maxLODsToLoad ?? this.maxLODsToLoad;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = async (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return await bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties: T[] = [];\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials: Material[] = [];\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_lod(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_minecraftMesh\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_minecraftMesh extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_minecraftMesh\"]: {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_minecraftMesh implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, async (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (babylonMaterial.needAlphaBlending()) {\r\n                    babylonMaterial.forceDepthWrite = true;\r\n                    babylonMaterial.separateCullingPass = true;\r\n                }\r\n\r\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\r\n                babylonMaterial.twoSidedLighting = true;\r\n\r\n                return await promise;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_minecraftMesh(loader));\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_sRGBFactors\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_sRGBFactors extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_sRGBFactors\"]: {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_sRGBFactors implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal*/\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, async (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                const useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;\r\n                if (!babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor, useExactSrgbConversions);\r\n                }\r\n\r\n                if (!babylonMaterial.reflectivityTexture) {\r\n                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor, useExactSrgbConversions);\r\n                }\r\n\r\n                return await promise;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_sRGBFactors(loader));\r\n", "import type { FlowGraphBlock } from \"../flowGraphBlock\";\nimport { FlowGraphBlockNames } from \"./flowGraphBlockNames\";\n\n/**\n * Any external module that wishes to add a new block to the flow graph can add to this object using the helper function.\n */\nconst CustomBlocks: Record<string, () => Promise<typeof FlowGraphBlock>> = {};\n\n/**\n * If you want to add a new block to the block factory, you should use this function.\n * Please be sure to choose a unique name and define the responsible module.\n * @param module the name of the module that is responsible for the block\n * @param blockName the name of the block. This should be unique.\n * @param factory an async factory function to generate the block\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function addToBlockFactory(module: string, blockName: string, factory: () => Promise<typeof FlowGraphBlock>): void {\n    CustomBlocks[`${module}/${blockName}`] = factory;\n}\n\n/**\n * a function to get a factory function for a block.\n * @param blockName the block name to initialize. If the block comes from an external module, the name should be in the format \"module/blockName\"\n * @returns an async factory function that will return the block class when called.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function blockFactory(blockName: FlowGraphBlockNames | string): () => Promise<typeof FlowGraphBlock> {\n    switch (blockName) {\n        case FlowGraphBlockNames.PlayAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPlayAnimationBlock\")).FlowGraphPlayAnimationBlock;\n        case FlowGraphBlockNames.StopAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphStopAnimationBlock\")).FlowGraphStopAnimationBlock;\n        case FlowGraphBlockNames.PauseAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPauseAnimationBlock\")).FlowGraphPauseAnimationBlock;\n        case FlowGraphBlockNames.ValueInterpolation:\n            return async () => (await import(\"./Execution/Animation/flowGraphInterpolationBlock\")).FlowGraphInterpolationBlock;\n        case FlowGraphBlockNames.SceneReadyEvent:\n            return async () => (await import(\"./Event/flowGraphSceneReadyEventBlock\")).FlowGraphSceneReadyEventBlock;\n        case FlowGraphBlockNames.SceneTickEvent:\n            return async () => (await import(\"./Event/flowGraphSceneTickEventBlock\")).FlowGraphSceneTickEventBlock;\n        case FlowGraphBlockNames.SendCustomEvent:\n            return async () => (await import(\"./Event/flowGraphSendCustomEventBlock\")).FlowGraphSendCustomEventBlock;\n        case FlowGraphBlockNames.ReceiveCustomEvent:\n            return async () => (await import(\"./Event/flowGraphReceiveCustomEventBlock\")).FlowGraphReceiveCustomEventBlock;\n        case FlowGraphBlockNames.MeshPickEvent:\n            return async () => (await import(\"./Event/flowGraphMeshPickEventBlock\")).FlowGraphMeshPickEventBlock;\n        case FlowGraphBlockNames.E:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEBlock;\n        case FlowGraphBlockNames.PI:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPiBlock;\n        case FlowGraphBlockNames.Inf:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphInfBlock;\n        case FlowGraphBlockNames.NaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNaNBlock;\n        case FlowGraphBlockNames.Random:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRandomBlock;\n        case FlowGraphBlockNames.Add:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAddBlock;\n        case FlowGraphBlockNames.Subtract:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSubtractBlock;\n        case FlowGraphBlockNames.Multiply:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMultiplyBlock;\n        case FlowGraphBlockNames.Divide:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDivideBlock;\n        case FlowGraphBlockNames.Abs:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAbsBlock;\n        case FlowGraphBlockNames.Sign:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSignBlock;\n        case FlowGraphBlockNames.Trunc:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTruncBlock;\n        case FlowGraphBlockNames.Floor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFloorBlock;\n        case FlowGraphBlockNames.Ceil:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCeilBlock;\n        case FlowGraphBlockNames.Round:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRoundBlock;\n        case FlowGraphBlockNames.Fraction:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFractionBlock;\n        case FlowGraphBlockNames.Negation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNegationBlock;\n        case FlowGraphBlockNames.Modulo:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphModuloBlock;\n        case FlowGraphBlockNames.Min:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMinBlock;\n        case FlowGraphBlockNames.Max:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMaxBlock;\n        case FlowGraphBlockNames.Clamp:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphClampBlock;\n        case FlowGraphBlockNames.Saturate:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSaturateBlock;\n        case FlowGraphBlockNames.MathInterpolation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMathInterpolationBlock;\n        case FlowGraphBlockNames.Equality:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEqualityBlock;\n        case FlowGraphBlockNames.LessThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanBlock;\n        case FlowGraphBlockNames.LessThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanOrEqualBlock;\n        case FlowGraphBlockNames.GreaterThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanBlock;\n        case FlowGraphBlockNames.GreaterThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanOrEqualBlock;\n        case FlowGraphBlockNames.IsNaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsNanBlock;\n        case FlowGraphBlockNames.IsInfinity:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsInfinityBlock;\n        case FlowGraphBlockNames.DegToRad:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDegToRadBlock;\n        case FlowGraphBlockNames.RadToDeg:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRadToDegBlock;\n        case FlowGraphBlockNames.Sin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinBlock;\n        case FlowGraphBlockNames.Cos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCosBlock;\n        case FlowGraphBlockNames.Tan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanBlock;\n        case FlowGraphBlockNames.Asin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinBlock;\n        case FlowGraphBlockNames.Acos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcosBlock;\n        case FlowGraphBlockNames.Atan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanBlock;\n        case FlowGraphBlockNames.Atan2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtan2Block;\n        case FlowGraphBlockNames.Sinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinhBlock;\n        case FlowGraphBlockNames.Cosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCoshBlock;\n        case FlowGraphBlockNames.Tanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanhBlock;\n        case FlowGraphBlockNames.Asinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinhBlock;\n        case FlowGraphBlockNames.Acosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcoshBlock;\n        case FlowGraphBlockNames.Atanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanhBlock;\n        case FlowGraphBlockNames.Exponential:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphExpBlock;\n        case FlowGraphBlockNames.Log:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLogBlock;\n        case FlowGraphBlockNames.Log2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog2Block;\n        case FlowGraphBlockNames.Log10:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog10Block;\n        case FlowGraphBlockNames.SquareRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSquareRootBlock;\n        case FlowGraphBlockNames.Power:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPowerBlock;\n        case FlowGraphBlockNames.CubeRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCubeRootBlock;\n        case FlowGraphBlockNames.BitwiseAnd:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseAndBlock;\n        case FlowGraphBlockNames.BitwiseOr:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseOrBlock;\n        case FlowGraphBlockNames.BitwiseNot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseNotBlock;\n        case FlowGraphBlockNames.BitwiseXor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseXorBlock;\n        case FlowGraphBlockNames.BitwiseLeftShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseLeftShiftBlock;\n        case FlowGraphBlockNames.BitwiseRightShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseRightShiftBlock;\n        case FlowGraphBlockNames.Length:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphLengthBlock;\n        case FlowGraphBlockNames.Normalize:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphNormalizeBlock;\n        case FlowGraphBlockNames.Dot:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphDotBlock;\n        case FlowGraphBlockNames.Cross:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphCrossBlock;\n        case FlowGraphBlockNames.Rotate2D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate2DBlock;\n        case FlowGraphBlockNames.Rotate3D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate3DBlock;\n        case FlowGraphBlockNames.Transpose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphTransposeBlock;\n        case FlowGraphBlockNames.Determinant:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphDeterminantBlock;\n        case FlowGraphBlockNames.InvertMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphInvertMatrixBlock;\n        case FlowGraphBlockNames.MatrixMultiplication:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixMultiplicationBlock;\n        case FlowGraphBlockNames.Branch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphBranchBlock\")).FlowGraphBranchBlock;\n        case FlowGraphBlockNames.SetDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSetDelayBlock\")).FlowGraphSetDelayBlock;\n        case FlowGraphBlockNames.CancelDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCancelDelayBlock\")).FlowGraphCancelDelayBlock;\n        case FlowGraphBlockNames.CallCounter:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCounterBlock\")).FlowGraphCallCounterBlock;\n        case FlowGraphBlockNames.Debounce:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDebounceBlock\")).FlowGraphDebounceBlock;\n        case FlowGraphBlockNames.Throttle:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphThrottleBlock\")).FlowGraphThrottleBlock;\n        case FlowGraphBlockNames.DoN:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDoNBlock\")).FlowGraphDoNBlock;\n        case FlowGraphBlockNames.FlipFlop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphFlipFlopBlock\")).FlowGraphFlipFlopBlock;\n        case FlowGraphBlockNames.ForLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphForLoopBlock\")).FlowGraphForLoopBlock;\n        case FlowGraphBlockNames.MultiGate:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphMultiGateBlock\")).FlowGraphMultiGateBlock;\n        case FlowGraphBlockNames.Sequence:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSequenceBlock\")).FlowGraphSequenceBlock;\n        case FlowGraphBlockNames.Switch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSwitchBlock\")).FlowGraphSwitchBlock;\n        case FlowGraphBlockNames.WaitAll:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWaitAllBlock\")).FlowGraphWaitAllBlock;\n        case FlowGraphBlockNames.WhileLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWhileLoopBlock\")).FlowGraphWhileLoopBlock;\n        case FlowGraphBlockNames.ConsoleLog:\n            return async () => (await import(\"./Execution/flowGraphConsoleLogBlock\")).FlowGraphConsoleLogBlock;\n        case FlowGraphBlockNames.Conditional:\n            return async () => (await import(\"./Data/flowGraphConditionalDataBlock\")).FlowGraphConditionalDataBlock;\n        case FlowGraphBlockNames.Constant:\n            return async () => (await import(\"./Data/flowGraphConstantBlock\")).FlowGraphConstantBlock;\n        case FlowGraphBlockNames.TransformCoordinatesSystem:\n            return async () => (await import(\"./Data/flowGraphTransformCoordinatesSystemBlock\")).FlowGraphTransformCoordinatesSystemBlock;\n        case FlowGraphBlockNames.GetAsset:\n            return async () => (await import(\"./Data/flowGraphGetAssetBlock\")).FlowGraphGetAssetBlock;\n        case FlowGraphBlockNames.GetProperty:\n            return async () => (await import(\"./Data/flowGraphGetPropertyBlock\")).FlowGraphGetPropertyBlock;\n        case FlowGraphBlockNames.SetProperty:\n            return async () => (await import(\"./Execution/flowGraphSetPropertyBlock\")).FlowGraphSetPropertyBlock;\n        case FlowGraphBlockNames.GetVariable:\n            return async () => (await import(\"./Data/flowGraphGetVariableBlock\")).FlowGraphGetVariableBlock;\n        case FlowGraphBlockNames.SetVariable:\n            return async () => (await import(\"./Execution/flowGraphSetVariableBlock\")).FlowGraphSetVariableBlock;\n        case FlowGraphBlockNames.JsonPointerParser:\n            return async () => (await import(\"./Data/Transformers/flowGraphJsonPointerParserBlock\")).FlowGraphJsonPointerParserBlock;\n        case FlowGraphBlockNames.LeadingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLeadingZerosBlock;\n        case FlowGraphBlockNames.TrailingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTrailingZerosBlock;\n        case FlowGraphBlockNames.OneBitsCounter:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphOneBitsCounterBlock;\n        case FlowGraphBlockNames.CombineVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector2Block;\n        case FlowGraphBlockNames.CombineVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector3Block;\n        case FlowGraphBlockNames.CombineVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector4Block;\n        case FlowGraphBlockNames.CombineMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineMatrixBlock;\n        case FlowGraphBlockNames.ExtractVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector2Block;\n        case FlowGraphBlockNames.ExtractVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector3Block;\n        case FlowGraphBlockNames.ExtractVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector4Block;\n        case FlowGraphBlockNames.ExtractMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractMatrixBlock;\n        case FlowGraphBlockNames.TransformVector:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformBlock;\n        case FlowGraphBlockNames.TransformCoordinates:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformCoordinatesBlock;\n        case FlowGraphBlockNames.Conjugate:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphConjugateBlock;\n        case FlowGraphBlockNames.AngleBetween:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAngleBetweenBlock;\n        case FlowGraphBlockNames.QuaternionFromAxisAngle:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromAxisAngleBlock;\n        case FlowGraphBlockNames.AxisAngleFromQuaternion:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAxisAngleFromQuaternionBlock;\n        case FlowGraphBlockNames.QuaternionFromDirections:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromDirectionsBlock;\n        case FlowGraphBlockNames.MatrixDecompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixDecomposeBlock;\n        case FlowGraphBlockNames.MatrixCompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixComposeBlock;\n        case FlowGraphBlockNames.BooleanToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToFloat;\n        case FlowGraphBlockNames.BooleanToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToInt;\n        case FlowGraphBlockNames.FloatToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToBoolean;\n        case FlowGraphBlockNames.IntToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToBoolean;\n        case FlowGraphBlockNames.IntToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToFloat;\n        case FlowGraphBlockNames.FloatToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToInt;\n        case FlowGraphBlockNames.Easing:\n            return async () => (await import(\"./Execution/Animation/flowGraphEasingBlock\")).FlowGraphEasingBlock;\n        case FlowGraphBlockNames.BezierCurveEasing:\n            return async () => (await import(\"./Execution/Animation/flowGraphBezierCurveEasingBlock\")).FlowGraphBezierCurveEasingBlock;\n        case FlowGraphBlockNames.PointerOverEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOverEventBlock\")).FlowGraphPointerOverEventBlock;\n        case FlowGraphBlockNames.PointerOutEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOutEventBlock\")).FlowGraphPointerOutEventBlock;\n        case FlowGraphBlockNames.Context:\n            return async () => (await import(\"./Data/Utils/flowGraphContextBlock\")).FlowGraphContextBlock;\n        case FlowGraphBlockNames.ArrayIndex:\n            return async () => (await import(\"./Data/Utils/flowGraphArrayIndexBlock\")).FlowGraphArrayIndexBlock;\n        case FlowGraphBlockNames.CodeExecution:\n            return async () => (await import(\"./Data/Utils/flowGraphCodeExecutionBlock\")).FlowGraphCodeExecutionBlock;\n        case FlowGraphBlockNames.IndexOf:\n            return async () => (await import(\"./Data/Utils/flowGraphIndexOfBlock\")).FlowGraphIndexOfBlock;\n        case FlowGraphBlockNames.FunctionReference:\n            return async () => (await import(\"./Data/Utils/flowGraphFunctionReferenceBlock\")).FlowGraphFunctionReferenceBlock;\n        case FlowGraphBlockNames.DataSwitch:\n            return async () => (await import(\"./Data/flowGraphDataSwitchBlock\")).FlowGraphDataSwitchBlock;\n        default:\n            // check if the block is a custom block\n            if (CustomBlocks[blockName]) {\n                return CustomBlocks[blockName];\n            }\n            throw new Error(`Unknown block name ${blockName}`);\n    }\n}\n", "import type { IAssetContainer } from \"core/IAssetContainer\";\nimport { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport type { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\nimport type { FlowGraph, IFlowGraphParseOptions } from \"./flowGraph\";\nimport type { FlowGraphBlock, IFlowGraphBlockParseOptions } from \"./flowGraphBlock\";\nimport type { FlowGraphContext, IFlowGraphContextParseOptions } from \"./flowGraphContext\";\nimport type { IFlowGraphCoordinatorParseOptions } from \"./flowGraphCoordinator\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"./typeDefinitions\";\nimport type { Node } from \"core/node\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\nimport type { FlowGraphConnection } from \"./flowGraphConnection\";\n\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject: any, options: IFlowGraphCoordinatorParseOptions) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(\n        serializedObject._flowGraphs?.map(\n            async (serializedGraph: any) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })\n        )\n    );\n    return coordinator;\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions): Promise<FlowGraph> {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(\n        serializationObject.allBlocks.map(async (serializedBlock) => {\n            const classFactory = blockFactory(serializedBlock.className as FlowGraphBlockNames);\n            return await classFactory();\n        })\n    );\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions, resolvedClasses: (typeof FlowGraphBlock)[]) {\n    const graph = options.coordinator.createGraph();\n    const blocks: FlowGraphBlock[] = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(\n            serializedBlock,\n            { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction },\n            resolvedClasses[i]\n        );\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject: ISerializedFlowGraphContext, options: IFlowGraphContextParseOptions, rightHanded?: boolean): FlowGraphContext {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext: IAssetContainer = {\n            meshes: ac.meshes?.map((m: string) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l: string) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c: string) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m: string) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t: string) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a: string) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s: string) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps: string) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag: string) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn: string) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function (): Array<Node> {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n\n    return result;\n}\n\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject: ISerializedFlowGraphBlock, parseOptions: IFlowGraphBlockParseOptions): Promise<FlowGraphBlock> {\n    const classFactory = blockFactory(serializationObject.className as FlowGraphBlockNames);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(\n    serializationObject: ISerializedFlowGraphBlock,\n    parseOptions: IFlowGraphBlockParseOptions,\n    classType: typeof FlowGraphBlock\n): FlowGraphBlock {\n    const parsedConfig: any = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        } else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        } else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType<BlockT extends FlowGraphBlock>(serializationObject: any = {}, ownerBlock: BlockT, classType: typeof FlowGraphConnection) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject: any, ownerBlock: FlowGraphBlock, classType: typeof FlowGraphDataConnection): FlowGraphDataConnection<any> {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject: any): RichType<any> {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\nimport type { IKHRInteractivity_Declaration, IKHRInteractivity_Graph, IKHRInteractivity_Node } from \"babylonjs-gltf2interface\";\nimport { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport type { InteractivityEvent, InteractivityGraphToFlowGraphParser } from \"./interactivityGraphParser\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport { FlowGraphTypes, getAnimationTypeByFlowGraphType } from \"core/FlowGraph/flowGraphRichTypes\";\n\ninterface IGLTFToFlowGraphMappingObject<I = any, O = any> {\n    /**\n     * The name of the property in the FlowGraph block.\n     */\n    name: string;\n    /**\n     * The type of the property in the glTF specs.\n     * If not provided will be inferred.\n     */\n    gltfType?: string;\n    /**\n     * The type of the property in the FlowGraph block.\n     * If not defined it equals the glTF type.\n     */\n    flowGraphType?: string;\n    /**\n     * A function that transforms the data from the glTF to the FlowGraph block.\n     */\n    dataTransformer?: (data: I[], parser: InteractivityGraphToFlowGraphParser) => O[];\n    /**\n     * If the property is in the options passed to the constructor of the block.\n     */\n    inOptions?: boolean;\n\n    /**\n     * If the property is a pointer to a value.\n     * This will add an extra JsonPointerParser block to the graph.\n     */\n    isPointer?: boolean;\n\n    /**\n     * If the property is an index to a value.\n     * if defined this will be the name of the array to find the object in.\n     */\n    isVariable?: boolean;\n\n    /**\n     * the name of the class type this value will be mapped to.\n     * This is used if we generate more than one block for a single glTF node.\n     * Defaults to the first block in the mapping.\n     */\n    toBlock?: FlowGraphBlockNames;\n\n    /**\n     * Used in configuration values. If defined, this will be the default value, if no value is provided.\n     */\n    defaultValue?: O;\n}\n\nexport interface IGLTFToFlowGraphMapping {\n    /**\n     * The type of the FlowGraph block(s).\n     * Typically will be a single element in an array.\n     * When adding blocks defined in this module use the KHR_interactivity prefix.\n     */\n    blocks: (FlowGraphBlockNames | string)[];\n    /**\n     * The inputs of the glTF node mapped to the FlowGraph block.\n     */\n    inputs?: {\n        /**\n         * The value inputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow inputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The outputs of the glTF node mapped to the FlowGraph block.\n     */\n    outputs?: {\n        /**\n         * The value outputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow outputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The configuration of the glTF node mapped to the FlowGraph block.\n     * This information is usually passed to the constructor of the block.\n     */\n    configuration?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * If we generate more than one block for a single glTF node, this mapping will be used to map\n     * between the flowGraph classes.\n     */\n    typeToTypeMapping?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * The connections between two or more blocks.\n     * This is used to connect the blocks in the graph\n     */\n    interBlockConnectors?: {\n        /**\n         * The name of the input connection in the first block.\n         */\n        input: string;\n        /**\n         * The name of the output connection in the second block.\n         */\n        output: string;\n\n        /**\n         * The index of the block in the array of blocks that corresponds to the input.\n         */\n        inputBlockIndex: number;\n        /**\n         * The index of the block in the array of blocks that corresponds to the output.\n         */\n        outputBlockIndex: number;\n        /**\n         * If the connection is a variable connection or a flow connection.\n         */\n        isVariable?: boolean;\n    }[];\n\n    /**\n     * This optional function will allow to validate the node, according to the glTF specs.\n     * For example, if a node has a configuration object, it must be present and correct.\n     * This is a basic node-based validation.\n     * This function is expected to return false and log the error if the node is not valid.\n     * Note that this function can also modify the node, if needed.\n     *\n     * @param gltfBlock the glTF node to validate\n     * @param glTFObject the glTF object\n     * @returns true if validated, false if not.\n     */\n    validation?: (gltfBlock: IKHRInteractivity_Node, interactivityGraph: IKHRInteractivity_Graph, glTFObject?: IGLTF) => { valid: boolean; error?: string };\n\n    /**\n     * This is used if we need extra information for the constructor/options that is not provided directly by the glTF node.\n     * This function can return more than one node, if extra nodes are needed for this block to function correctly.\n     * Returning more than one block will usually happen when a json pointer was provided.\n     *\n     * @param gltfBlock the glTF node\n     * @param mapping the mapping object\n     * @param arrays the arrays of the interactivity object\n     * @param serializedObjects the serialized object\n     * @returns an array of serialized nodes that will be added to the graph.\n     */\n    extraProcessor?: (\n        gltfBlock: IKHRInteractivity_Node,\n        declaration: IKHRInteractivity_Declaration,\n        mapping: IGLTFToFlowGraphMapping,\n        parser: InteractivityGraphToFlowGraphParser,\n        serializedObjects: ISerializedFlowGraphBlock[],\n        context: ISerializedFlowGraphContext,\n        globalGLTF?: IGLTF\n    ) => ISerializedFlowGraphBlock[];\n}\n\nexport function getMappingForFullOperationName(fullOperationName: string) {\n    const [op, extension] = fullOperationName.split(\":\");\n    return getMappingForDeclaration({ op, extension });\n}\n\nexport function getMappingForDeclaration(declaration: IKHRInteractivity_Declaration, returnNoOpIfNotAvailable: boolean = true): IGLTFToFlowGraphMapping | undefined {\n    const mapping = declaration.extension ? gltfExtensionsToFlowGraphMapping[declaration.extension]?.[declaration.op] : gltfToFlowGraphMapping[declaration.op];\n    if (!mapping) {\n        Logger.Warn(`No mapping found for operation ${declaration.op} and extension ${declaration.extension || \"KHR_interactivity\"}`);\n        if (returnNoOpIfNotAvailable) {\n            const inputs: IGLTFToFlowGraphMapping[\"inputs\"] = {};\n            const outputs: IGLTFToFlowGraphMapping[\"outputs\"] = {\n                flows: {},\n            };\n            if (declaration.inputValueSockets) {\n                inputs.values = {};\n                for (const key in declaration.inputValueSockets) {\n                    inputs.values[key] = {\n                        name: key,\n                    };\n                }\n            }\n            if (declaration.outputValueSockets) {\n                outputs.values = {};\n                Object.keys(declaration.outputValueSockets).forEach((key) => {\n                    outputs.values![key] = {\n                        name: key,\n                    };\n                });\n            }\n            return {\n                blocks: [], // no blocks, just mapping\n                inputs,\n                outputs,\n            };\n        }\n    }\n    return mapping;\n}\n\n/**\n * This function will add new mapping to glTF interactivity.\n * Other extensions can define new types of blocks, this is the way to let interactivity know how to parse them.\n * @param key the type of node, i.e. \"variable/get\"\n * @param extension the extension of the interactivity operation, i.e. \"KHR_selectability\"\n * @param mapping The mapping object. See documentation or examples below.\n */\nexport function addNewInteractivityFlowGraphMapping(key: string, extension: string, mapping: IGLTFToFlowGraphMapping) {\n    gltfExtensionsToFlowGraphMapping[extension] ||= {};\n    gltfExtensionsToFlowGraphMapping[extension][key] = mapping;\n}\n\nconst gltfExtensionsToFlowGraphMapping: { [extension: string]: { [key: string]: IGLTFToFlowGraphMapping } } = {\n    /**\n     * This is the BABYLON extension for glTF interactivity.\n     * It defines babylon-specific blocks and operations.\n     */\n    BABYLON: {\n        /**\n         * flow/log is a flow node that logs input to the console.\n         * It has \"in\" and \"out\" flows, and takes a message as input.\n         * The message can be any type of value.\n         * The message is logged to the console when the \"in\" flow is triggered.\n         * The \"out\" flow is triggered when the message is logged.\n         */\n        \"flow/log\": {\n            blocks: [FlowGraphBlockNames.ConsoleLog],\n            inputs: {\n                values: {\n                    message: { name: \"message\" },\n                },\n            },\n        },\n    },\n};\n\n// this mapper is just a way to convert the glTF nodes to FlowGraph nodes in terms of input/output connection names and values.\nconst gltfToFlowGraphMapping: { [key: string]: IGLTFToFlowGraphMapping } = {\n    \"event/onStart\": {\n        blocks: [FlowGraphBlockNames.SceneReadyEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/onTick\": {\n        blocks: [FlowGraphBlockNames.SceneTickEvent],\n        inputs: {},\n        outputs: {\n            values: {\n                timeSinceLastTick: { name: \"deltaTime\", gltfType: \"number\" /*, dataTransformer: (time: number) => time / 1000*/ },\n            },\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/send\": {\n        blocks: [FlowGraphBlockNames.SendCustomEvent],\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/send\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"event/receive\": {\n        blocks: [FlowGraphBlockNames.ReceiveCustomEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n        validation(gltfBlock, interactivityGraph) {\n            if (!gltfBlock.configuration) {\n                Logger.Error(\"Receive event should have a configuration object\");\n                return { valid: false, error: \"Receive event should have a configuration object\" };\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            if (!eventConfiguration) {\n                Logger.Error(\"Receive event should have a single configuration object, the event itself\");\n                return { valid: false, error: \"Receive event should have a single configuration object, the event itself\" };\n            }\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                Logger.Error(\"Event id should be a number\");\n                return { valid: false, error: \"Event id should be a number\" };\n            }\n            const event = interactivityGraph.events?.[eventId];\n            if (!event) {\n                Logger.Error(`Event with id ${eventId} not found`);\n                return { valid: false, error: `Event with id ${eventId} not found` };\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/receive\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"math/E\": getSimpleInputMapping(FlowGraphBlockNames.E),\n    \"math/Pi\": getSimpleInputMapping(FlowGraphBlockNames.PI),\n    \"math/Inf\": getSimpleInputMapping(FlowGraphBlockNames.Inf),\n    \"math/NaN\": getSimpleInputMapping(FlowGraphBlockNames.NaN),\n    \"math/abs\": getSimpleInputMapping(FlowGraphBlockNames.Abs),\n    \"math/sign\": getSimpleInputMapping(FlowGraphBlockNames.Sign),\n    \"math/trunc\": getSimpleInputMapping(FlowGraphBlockNames.Trunc),\n    \"math/floor\": getSimpleInputMapping(FlowGraphBlockNames.Floor),\n    \"math/ceil\": getSimpleInputMapping(FlowGraphBlockNames.Ceil),\n    \"math/round\": {\n        blocks: [FlowGraphBlockNames.Round],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.roundHalfAwayFromZero = true;\n            return serializedObjects;\n        },\n    },\n    \"math/fract\": getSimpleInputMapping(FlowGraphBlockNames.Fraction),\n    \"math/neg\": getSimpleInputMapping(FlowGraphBlockNames.Negation),\n    \"math/add\": getSimpleInputMapping(FlowGraphBlockNames.Add, [\"a\", \"b\"], true),\n    \"math/sub\": getSimpleInputMapping(FlowGraphBlockNames.Subtract, [\"a\", \"b\"], true),\n    \"math/mul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.useMatrixPerComponent = true;\n            serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n            // try to infer the type or fallback to Integer\n            // check the gltf block for the inputs, see if they have a type\n            let type = -1;\n            Object.keys(_gltfBlock.values || {}).find((value) => {\n                if (_gltfBlock.values?.[value].type !== undefined) {\n                    type = _gltfBlock.values[value].type;\n                    return true;\n                }\n                return false;\n            });\n            if (type !== -1) {\n                serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.values) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    },\n    \"math/div\": getSimpleInputMapping(FlowGraphBlockNames.Divide, [\"a\", \"b\"], true),\n    \"math/rem\": getSimpleInputMapping(FlowGraphBlockNames.Modulo, [\"a\", \"b\"]),\n    \"math/min\": getSimpleInputMapping(FlowGraphBlockNames.Min, [\"a\", \"b\"]),\n    \"math/max\": getSimpleInputMapping(FlowGraphBlockNames.Max, [\"a\", \"b\"]),\n    \"math/clamp\": getSimpleInputMapping(FlowGraphBlockNames.Clamp, [\"a\", \"b\", \"c\"]),\n    \"math/saturate\": getSimpleInputMapping(FlowGraphBlockNames.Saturate),\n    \"math/mix\": getSimpleInputMapping(FlowGraphBlockNames.MathInterpolation, [\"a\", \"b\", \"c\"]),\n    \"math/eq\": getSimpleInputMapping(FlowGraphBlockNames.Equality, [\"a\", \"b\"]),\n    \"math/lt\": getSimpleInputMapping(FlowGraphBlockNames.LessThan, [\"a\", \"b\"]),\n    \"math/le\": getSimpleInputMapping(FlowGraphBlockNames.LessThanOrEqual, [\"a\", \"b\"]),\n    \"math/gt\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThan, [\"a\", \"b\"]),\n    \"math/ge\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThanOrEqual, [\"a\", \"b\"]),\n    \"math/isNaN\": getSimpleInputMapping(FlowGraphBlockNames.IsNaN),\n    \"math/isInf\": getSimpleInputMapping(FlowGraphBlockNames.IsInfinity),\n    \"math/select\": {\n        blocks: [FlowGraphBlockNames.Conditional],\n        inputs: {\n            values: {\n                condition: { name: \"condition\" },\n                // Should we validate those have the same type here, or assume it is already validated?\n                a: { name: \"onTrue\" },\n                b: { name: \"onFalse\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"output\" },\n            },\n        },\n    },\n    \"math/random\": {\n        blocks: [FlowGraphBlockNames.Random],\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/sin\": getSimpleInputMapping(FlowGraphBlockNames.Sin),\n    \"math/cos\": getSimpleInputMapping(FlowGraphBlockNames.Cos),\n    \"math/tan\": getSimpleInputMapping(FlowGraphBlockNames.Tan),\n    \"math/asin\": getSimpleInputMapping(FlowGraphBlockNames.Asin),\n    \"math/acos\": getSimpleInputMapping(FlowGraphBlockNames.Acos),\n    \"math/atan\": getSimpleInputMapping(FlowGraphBlockNames.Atan),\n    \"math/atan2\": getSimpleInputMapping(FlowGraphBlockNames.Atan2, [\"a\", \"b\"]),\n    \"math/sinh\": getSimpleInputMapping(FlowGraphBlockNames.Sinh),\n    \"math/cosh\": getSimpleInputMapping(FlowGraphBlockNames.Cosh),\n    \"math/tanh\": getSimpleInputMapping(FlowGraphBlockNames.Tanh),\n    \"math/asinh\": getSimpleInputMapping(FlowGraphBlockNames.Asinh),\n    \"math/acosh\": getSimpleInputMapping(FlowGraphBlockNames.Acosh),\n    \"math/atanh\": getSimpleInputMapping(FlowGraphBlockNames.Atanh),\n    \"math/exp\": getSimpleInputMapping(FlowGraphBlockNames.Exponential),\n    \"math/log\": getSimpleInputMapping(FlowGraphBlockNames.Log),\n    \"math/log2\": getSimpleInputMapping(FlowGraphBlockNames.Log2),\n    \"math/log10\": getSimpleInputMapping(FlowGraphBlockNames.Log10),\n    \"math/sqrt\": getSimpleInputMapping(FlowGraphBlockNames.SquareRoot),\n    \"math/cbrt\": getSimpleInputMapping(FlowGraphBlockNames.CubeRoot),\n    \"math/pow\": getSimpleInputMapping(FlowGraphBlockNames.Power, [\"a\", \"b\"]),\n    \"math/length\": getSimpleInputMapping(FlowGraphBlockNames.Length),\n    \"math/normalize\": getSimpleInputMapping(FlowGraphBlockNames.Normalize),\n    \"math/dot\": getSimpleInputMapping(FlowGraphBlockNames.Dot, [\"a\", \"b\"]),\n    \"math/cross\": getSimpleInputMapping(FlowGraphBlockNames.Cross, [\"a\", \"b\"]),\n    \"math/rotate2D\": {\n        blocks: [FlowGraphBlockNames.Rotate2D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                angle: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/rotate3D\": {\n        blocks: [FlowGraphBlockNames.Rotate3D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                rotation: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/transform\": {\n        // glTF transform is vectorN with matrixN\n        blocks: [FlowGraphBlockNames.TransformVector],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine2\": {\n        blocks: [FlowGraphBlockNames.CombineVector2],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine3\": {\n        blocks: [FlowGraphBlockNames.CombineVector3],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine4\": {\n        blocks: [FlowGraphBlockNames.CombineVector4],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    // one input, N outputs! outputs named using numbers.\n    \"math/extract2\": {\n        blocks: [FlowGraphBlockNames.ExtractVector2],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n            },\n        },\n    },\n    \"math/extract3\": {\n        blocks: [FlowGraphBlockNames.ExtractVector3],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n            },\n        },\n    },\n    \"math/extract4\": {\n        blocks: [FlowGraphBlockNames.ExtractVector4],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/transpose\": getSimpleInputMapping(FlowGraphBlockNames.Transpose),\n    \"math/determinant\": getSimpleInputMapping(FlowGraphBlockNames.Determinant),\n    \"math/inverse\": getSimpleInputMapping(FlowGraphBlockNames.InvertMatrix),\n    \"math/matMul\": getSimpleInputMapping(FlowGraphBlockNames.MatrixMultiplication, [\"a\", \"b\"]),\n    \"math/matCompose\": {\n        blocks: [FlowGraphBlockNames.MatrixCompose],\n        inputs: {\n            values: {\n                translation: { name: \"position\", gltfType: \"float3\" },\n                rotation: { name: \"rotationQuaternion\", gltfType: \"float4\" },\n                scale: { name: \"scaling\", gltfType: \"float3\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            const d = serializedObjects[0].dataInputs.find((input) => input.name === \"rotationQuaternion\");\n            if (!d) {\n                throw new Error(\"Rotation quaternion input not found\");\n            }\n            // if value is defined, set the type to quaternion\n            if (context._connectionValues[d.uniqueId]) {\n                context._connectionValues[d.uniqueId].type = FlowGraphTypes.Quaternion;\n            }\n            return serializedObjects;\n        },\n    },\n    \"math/matDecompose\": {\n        blocks: [FlowGraphBlockNames.MatrixDecompose],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                translation: { name: \"position\" },\n                rotation: { name: \"rotationQuaternion\" },\n                scale: { name: \"scaling\" },\n            },\n        },\n    },\n    \"math/quatConjugate\": getSimpleInputMapping(FlowGraphBlockNames.Conjugate, [\"a\"]),\n    \"math/quatMul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        inputs: {\n            values: {\n                a: { name: \"a\", gltfType: \"vector4\" },\n                b: { name: \"b\", gltfType: \"vector4\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.type = FlowGraphTypes.Quaternion;\n            return serializedObjects;\n        },\n    },\n    \"math/quatAngleBetween\": getSimpleInputMapping(FlowGraphBlockNames.AngleBetween, [\"a\", \"b\"]),\n    \"math/quatFromAxisAngle\": {\n        blocks: [FlowGraphBlockNames.QuaternionFromAxisAngle],\n        inputs: {\n            values: {\n                axis: { name: \"a\", gltfType: \"float3\" },\n                angle: { name: \"b\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/quatToAxisAngle\": getSimpleInputMapping(FlowGraphBlockNames.AxisAngleFromQuaternion, [\"a\"]),\n    \"math/quatFromDirections\": getSimpleInputMapping(FlowGraphBlockNames.QuaternionFromDirections, [\"a\", \"b\"]),\n    \"math/combine2x2\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract2x2\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float2x2\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/combine3x3\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract3x3\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float3x3\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n            },\n        },\n    },\n    \"math/combine4x4\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n                j: { name: \"input_9\", gltfType: \"number\" },\n                k: { name: \"input_10\", gltfType: \"number\" },\n                l: { name: \"input_11\", gltfType: \"number\" },\n                m: { name: \"input_12\", gltfType: \"number\" },\n                n: { name: \"input_13\", gltfType: \"number\" },\n                o: { name: \"input_14\", gltfType: \"number\" },\n                p: { name: \"input_15\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract4x4\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n                \"9\": { name: \"output_9\" },\n                \"10\": { name: \"output_10\" },\n                \"11\": { name: \"output_11\" },\n                \"12\": { name: \"output_12\" },\n                \"13\": { name: \"output_13\" },\n                \"14\": { name: \"output_14\" },\n                \"15\": { name: \"output_15\" },\n            },\n        },\n    },\n    \"math/not\": {\n        blocks: [FlowGraphBlockNames.BitwiseNot],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketIn = serializedObjects[0].dataInputs[0];\n            serializedObjects[0].config.valueType = context._connectionValues[socketIn.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/and\": {\n        blocks: [FlowGraphBlockNames.BitwiseAnd],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/or\": {\n        blocks: [FlowGraphBlockNames.BitwiseOr],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/xor\": {\n        blocks: [FlowGraphBlockNames.BitwiseXor],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/asr\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseRightShift, [\"a\", \"b\"]),\n    \"math/lsl\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseLeftShift, [\"a\", \"b\"]),\n    \"math/clz\": getSimpleInputMapping(FlowGraphBlockNames.LeadingZeros),\n    \"math/ctz\": getSimpleInputMapping(FlowGraphBlockNames.TrailingZeros),\n    \"math/popcnt\": getSimpleInputMapping(FlowGraphBlockNames.OneBitsCounter),\n    \"math/rad\": getSimpleInputMapping(FlowGraphBlockNames.DegToRad),\n    \"math/deg\": getSimpleInputMapping(FlowGraphBlockNames.RadToDeg),\n    \"type/boolToInt\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToInt),\n    \"type/boolToFloat\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToFloat),\n    \"type/intToBool\": getSimpleInputMapping(FlowGraphBlockNames.IntToBoolean),\n    \"type/intToFloat\": getSimpleInputMapping(FlowGraphBlockNames.IntToFloat),\n    \"type/floatToInt\": getSimpleInputMapping(FlowGraphBlockNames.FloatToInt),\n    \"type/floatToBool\": getSimpleInputMapping(FlowGraphBlockNames.FloatToBoolean),\n\n    // flows\n    \"flow/sequence\": {\n        blocks: [FlowGraphBlockNames.Sequence],\n        extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/branch\": {\n        blocks: [FlowGraphBlockNames.Branch],\n        outputs: {\n            flows: {\n                true: { name: \"onTrue\" },\n                false: { name: \"onFalse\" },\n            },\n        },\n    },\n    \"flow/switch\": {\n        blocks: [FlowGraphBlockNames.Switch],\n        configuration: {\n            cases: { name: \"cases\", inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n                default: { name: \"default\" },\n            },\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.configuration && gltfBlock.configuration.cases) {\n                const cases = gltfBlock.configuration.cases.value;\n                const onlyIntegers = cases.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    gltfBlock.configuration.cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases);\n                gltfBlock.configuration.cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            // convert all names of output flow to out_$1 apart from \"default\"\n            if (declaration.op !== \"flow/switch\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"Switch should have a single configuration object, the cases array\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.signalOutputs.forEach((output) => {\n                if (output.name !== \"default\") {\n                    output.name = \"out_\" + output.name;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/while\": {\n        blocks: [FlowGraphBlockNames.WhileLoop],\n        outputs: {\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n    },\n    \"flow/for\": {\n        blocks: [FlowGraphBlockNames.ForLoop],\n        configuration: {\n            initialIndex: { name: \"initialIndex\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            values: {\n                startIndex: { name: \"startIndex\", gltfType: \"number\" },\n                endIndex: { name: \"endIndex\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                index: { name: \"index\" },\n            },\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.incrementIndexWhenLoopDone = true;\n            return serializedObjects;\n        },\n    },\n    \"flow/doN\": {\n        blocks: [FlowGraphBlockNames.DoN],\n        configuration: {},\n        inputs: {\n            values: {\n                n: { name: \"maxExecutions\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                currentCount: { name: \"executionCount\" },\n            },\n        },\n    },\n    \"flow/multiGate\": {\n        blocks: [FlowGraphBlockNames.MultiGate],\n        configuration: {\n            isRandom: { name: \"isRandom\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n            isLoop: { name: \"isLoop\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            if (declaration.op !== \"flow/multiGate\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"MultiGate should have a single configuration object, the number of output flows\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/waitAll\": {\n        blocks: [FlowGraphBlockNames.WaitAll],\n        configuration: {\n            inputFlows: { name: \"inputSignalCount\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            flows: {\n                reset: { name: \"reset\" },\n                \"[segment]\": { name: \"in_$1\" },\n            },\n        },\n        validation(gltfBlock) {\n            // check that the configuration value is an integer\n            if (typeof gltfBlock.configuration?.inputFlows?.value[0] !== \"number\") {\n                gltfBlock.configuration = gltfBlock.configuration || {\n                    inputFlows: { value: [0] },\n                };\n                gltfBlock.configuration.inputFlows.value = [0];\n            }\n            return { valid: true };\n        },\n    },\n    \"flow/throttle\": {\n        blocks: [FlowGraphBlockNames.Throttle],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/setDelay\": {\n        blocks: [FlowGraphBlockNames.SetDelay],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/cancelDelay\": {\n        blocks: [FlowGraphBlockNames.CancelDelay],\n    },\n    \"variable/get\": {\n        blocks: [FlowGraphBlockNames.GetVariable],\n        validation(gltfBlock) {\n            if (!gltfBlock.configuration?.variable?.value) {\n                Logger.Error(\"Variable get block should have a variable configuration\");\n                return { valid: false, error: \"Variable get block should have a variable configuration\" };\n            }\n            return { valid: true };\n        },\n        configuration: {\n            variable: {\n                name: \"variable\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n        },\n    },\n    \"variable/set\": {\n        blocks: [FlowGraphBlockNames.SetVariable],\n        configuration: {\n            variable: {\n                name: \"variable\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index: number[], parser): string[] {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n        },\n    },\n    \"variable/setMultiple\": {\n        blocks: [FlowGraphBlockNames.SetVariable],\n        configuration: {\n            variables: {\n                name: \"variables\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                dataTransformer(index: number[][], parser): string[][] {\n                    return [index[0].map((i) => parser.getVariableName(i))];\n                },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[0];\n            serializedGetVariable.dataInputs.forEach((input) => {\n                input.name = parser.getVariableName(+input.name);\n            });\n\n            return serializedObjects;\n        },\n    },\n    \"variable/interpolate\": {\n        blocks: [\n            FlowGraphBlockNames.ValueInterpolation,\n            FlowGraphBlockNames.Context,\n            FlowGraphBlockNames.PlayAnimation,\n            FlowGraphBlockNames.BezierCurveEasing,\n            FlowGraphBlockNames.GetVariable,\n        ],\n        configuration: {\n            variable: {\n                name: \"propertyName\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n            useSlerp: {\n                name: \"animationType\",\n                inOptions: true,\n                defaultValue: false,\n                dataTransformer: (value) => {\n                    if (value[0] === true) {\n                        return [FlowGraphTypes.Quaternion];\n                    } else {\n                        return [undefined];\n                    }\n                },\n            },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                duration: { name: \"duration_1\", gltfType: \"number\" },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"userVariables\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 4,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // is useSlerp is used, animationType should be set to be quaternion!\n            const serializedValueInterpolation = serializedObjects[0];\n            const propertyIndex = gltfBlock.configuration?.variable.value[0];\n            if (typeof propertyIndex !== \"number\") {\n                Logger.Error(\"Variable index is not defined for variable interpolation block\");\n                throw new Error(\"Variable index is not defined for variable interpolation block\");\n            }\n            const variable = parser.arrays.staticVariables[propertyIndex];\n            // if not set by useSlerp\n            if (typeof serializedValueInterpolation.config.animationType.value === \"undefined\") {\n                // get the value type\n                parser.arrays.staticVariables;\n                serializedValueInterpolation.config.animationType.value = getAnimationTypeByFlowGraphType(variable.type);\n            }\n\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[4];\n            serializedGetVariable.config ||= {};\n            serializedGetVariable.config.variable ||= {};\n            serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);\n\n            // get the control points from the easing block\n            serializedObjects[3].config ||= {};\n\n            return serializedObjects;\n        },\n    },\n    \"pointer/get\": {\n        blocks: [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customGetFunction\",\n                output: \"getFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/set\": {\n        blocks: [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                // must be defined due to the array taking over\n                value: { name: \"value\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customSetFunction\",\n                output: \"setFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/interpolate\": {\n        // interpolate, parse the pointer and play the animation generated. 3 blocks!\n        blocks: [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.BezierCurveEasing],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n                duration: { name: \"duration_1\", gltfType: \"number\" /*, inOptions: true */ },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customBuildAnimation\",\n                output: \"generateAnimationsFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                } else if (serializedObject.className === FlowGraphBlockNames.ValueInterpolation) {\n                    serializedObject.config ||= {};\n                    Object.keys(gltfBlock.values || []).forEach((key) => {\n                        const value = gltfBlock.values?.[key];\n                        if (key === \"value\" && value) {\n                            // get the type of the value\n                            const type = value.type;\n                            if (type !== undefined) {\n                                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;\n                            }\n                        }\n                    });\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"animation/start\": {\n        blocks: [FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                speed: { name: \"speed\", gltfType: \"number\" },\n                startTime: { name: \"from\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n                endTime: { name: \"to\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stop\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stopAt\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        configuration: {},\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                stopTime: { name: \"stopAtFrame\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"math/switch\": {\n        blocks: [FlowGraphBlockNames.DataSwitch],\n        configuration: {\n            cases: { name: \"cases\", inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n            },\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.configuration && gltfBlock.configuration.cases) {\n                const cases = gltfBlock.configuration.cases.value;\n                const onlyIntegers = cases.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    gltfBlock.configuration.cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases);\n                gltfBlock.configuration.cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.dataInputs.forEach((input) => {\n                if (input.name !== \"default\" && input.name !== \"case\") {\n                    input.name = \"in_\" + input.name;\n                }\n            });\n            serializedObject.config ||= {};\n            serializedObject.config.treatCasesAsIntegers = true;\n            return serializedObjects;\n        },\n    },\n    \"debug/log\": {\n        blocks: [FlowGraphBlockNames.ConsoleLog],\n        configuration: {\n            message: { name: \"messageTemplate\", inOptions: true },\n        },\n    },\n};\n\nfunction getSimpleInputMapping(type: FlowGraphBlockNames, inputs: string[] = [\"a\"], inferType?: boolean): IGLTFToFlowGraphMapping {\n    return {\n        blocks: [type],\n        inputs: {\n            values: inputs.reduce(\n                (acc, input) => {\n                    acc[input] = { name: input };\n                    return acc;\n                },\n                {} as { [key: string]: { name: string } }\n            ),\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            if (inferType) {\n                // configure it to work the way glTF specifies\n                serializedObjects[0].config ||= {};\n                serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n                // try to infer the type or fallback to Integer\n                // check the gltf block for the inputs, see if they have a type\n                let type = -1;\n                Object.keys(gltfBlock.values || {}).find((value) => {\n                    if (gltfBlock.values?.[value].type !== undefined) {\n                        type = gltfBlock.values[value].type;\n                        return true;\n                    }\n                    return false;\n                });\n                if (type !== -1) {\n                    serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n                }\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (inferType) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    };\n}\n\nfunction ValidateTypes(gltfBlock: IKHRInteractivity_Node): { valid: boolean; error?: string } {\n    if (gltfBlock.values) {\n        const types = Object.keys(gltfBlock.values)\n            .map((key) => gltfBlock.values![key].type)\n            .filter((type) => type !== undefined);\n        const allSameType = types.every((type) => type === types[0]);\n        if (!allSameType) {\n            return { valid: false, error: \"All inputs must be of the same type\" };\n        }\n    }\n    return { valid: true };\n}\n\nexport function getAllSupportedNativeNodeTypes(): string[] {\n    return Object.keys(gltfToFlowGraphMapping);\n}\n\n/**\n * \n * These are the nodes from the specs:\n\n### Math Nodes\n1. **Constants**\n   - E (`math/E`) FlowGraphBlockNames.E\n   - Pi (`math/Pi`) FlowGraphBlockNames.PI\n   - Infinity (`math/Inf`) FlowGraphBlockNames.Inf\n   - Not a Number (`math/NaN`) FlowGraphBlockNames.NaN\n2. **Arithmetic Nodes**\n   - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n   - Sign (`math/sign`) FlowGraphBlockNames.Sign\n   - Truncate (`math/trunc`) FlowGraphBlockNames.Trunc\n   - Floor (`math/floor`) FlowGraphBlockNames.Floor\n   - Ceil (`math/ceil`) FlowGraphBlockNames.Ceil\n   - Round (`math/round`)  FlowGraphBlockNames.Round\n   - Fraction (`math/fract`) FlowGraphBlockNames.Fract\n   - Negation (`math/neg`) FlowGraphBlockNames.Negation\n   - Addition (`math/add`) FlowGraphBlockNames.Add\n   - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n   - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n   - Division (`math/div`) FlowGraphBlockNames.Divide\n   - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n   - Minimum (`math/min`) FlowGraphBlockNames.Min\n   - Maximum (`math/max`) FlowGraphBlockNames.Max\n   - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n   - Saturate (`math/saturate`) FlowGraphBlockNames.Saturate\n   - Interpolate (`math/mix`) FlowGraphBlockNames.MathInterpolation\n3. **Comparison Nodes**\n   - Equality (`math/eq`) FlowGraphBlockNames.Equality\n   - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n   - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n   - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n   - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n4. **Special Nodes**\n   - Is Not a Number (`math/isNaN`) FlowGraphBlockNames.IsNaN\n   - Is Infinity (`math/isInf`) FlowGraphBlockNames.IsInfinity\n   - Select (`math/select`) FlowGraphBlockNames.Conditional\n   - Switch (`math/switch`) FlowGraphBlockNames.DataSwitch\n   - Random (`math/random`) FlowGraphBlockNames.Random\n5. **Angle and Trigonometry Nodes**\n   - Degrees-To-Radians (`math/rad`) FlowGraphBlockNames.DegToRad\n   - Radians-To-Degrees (`math/deg`) FlowGraphBlockNames.RadToDeg\n   - Sine (`math/sin`)  FlowGraphBlockNames.Sin\n   - Cosine (`math/cos`) FlowGraphBlockNames.Cos\n   - Tangent (`math/tan`) FlowGraphBlockNames.Tan\n   - Arcsine (`math/asin`) FlowGraphBlockNames.Asin\n   - Arccosine (`math/acos`) FlowGraphBlockNames.Acos\n   - Arctangent (`math/atan`) FlowGraphBlockNames.Atan\n   - Arctangent 2 (`math/atan2`) FlowGraphBlockNames.Atan2\n6. **Hyperbolic Nodes**\n   - Hyperbolic Sine (`math/sinh`) FlowGraphBlockNames.Sinh\n   - Hyperbolic Cosine (`math/cosh`) FlowGraphBlockNames.Cosh\n   - Hyperbolic Tangent (`math/tanh`) FlowGraphBlockNames.Tanh\n   - Inverse Hyperbolic Sine (`math/asinh`) FlowGraphBlockNames.Asinh\n   - Inverse Hyperbolic Cosine (`math/acosh`) FlowGraphBlockNames.Acosh\n   - Inverse Hyperbolic Tangent (`math/atanh`) FlowGraphBlockNames.Atanh\n7. **Exponential Nodes**\n   - Exponent (`math/exp`) FlowGraphBlockNames.Exponential\n   - Natural Logarithm (`math/log`) FlowGraphBlockNames.Log\n   - Base-2 Logarithm (`math/log2`) FlowGraphBlockNames.Log2\n   - Base-10 Logarithm (`math/log10`) FlowGraphBlockNames.Log10\n   - Square Root (`math/sqrt`) FlowGraphBlockNames.SquareRoot\n   - Cube Root (`math/cbrt`) FlowGraphBlockNames.CubeRoot\n   - Power (`math/pow`) FlowGraphBlockNames.Power\n8. **Vector Nodes**\n   - Length (`math/length`) FlowGraphBlockNames.Length\n   - Normalize (`math/normalize`) FlowGraphBlockNames.Normalize\n   - Dot Product (`math/dot`) FlowGraphBlockNames.Dot\n   - Cross Product (`math/cross`) FlowGraphBlockNames.Cross\n   - Rotate 2D (`math/rotate2D`) FlowGraphBlockNames.Rotate2D\n   - Rotate 3D (`math/rotate3D`) FlowGraphBlockNames.Rotate3D\n   - Transform (`math/transform`) FlowGraphBlockNames.TransformVector\n9. **Matrix Nodes**\n   - Transpose (`math/transpose`) FlowGraphBlockNames.Transpose\n   - Determinant (`math/determinant`) FlowGraphBlockNames.Determinant\n   - Inverse (`math/inverse`) FlowGraphBlockNames.InvertMatrix\n   - Multiplication (`math/matMul`) FlowGraphBlockNames.MatrixMultiplication\n   - Compose (`math/matCompose`) FlowGraphBlockNames.MatrixCompose\n   - Decompose (`math/matDecompose`) FlowGraphBlockNames.MatrixDecompose\n10. **Quaternion Nodes**\n    - Conjugate (`math/quatConjugate`) FlowGraphBlockNames.Conjugate\n    - Multiplication (`math/quatMul`) FlowGraphBlockNames.Multiply\n    - Angle Between Quaternions (`math/quatAngleBetween`) FlowGraphBlockNames.AngleBetween\n    - Quaternion From Axis Angle (`math/quatFromAxisAngle`) FlowGraphBlockNames.QuaternionFromAxisAngle\n    - Quaternion To Axis Angle (`math/quatToAxisAngle`) FlowGraphBlockNames.QuaternionToAxisAngle\n    - Quaternion From Two Directional Vectors (`math/quatFromDirections`) FlowGraphBlockNames.QuaternionFromDirections\n11. **Swizzle Nodes**\n    - Combine (`math/combine2`, `math/combine3`, `math/combine4`, `math/combine2x2`, `math/combine3x3`, `math/combine4x4`)\n        FlowGraphBlockNames.CombineVector2, FlowGraphBlockNames.CombineVector3, FlowGraphBlockNames.CombineVector4\n        FlowGraphBlockNames.CombineMatrix2D, FlowGraphBlockNames.CombineMatrix3D, FlowGraphBlockNames.CombineMatrix\n    - Extract (`math/extract2`, `math/extract3`, `math/extract4`, `math/extract2x2`, `math/extract3x3`, `math/extract4x4`)\n        FlowGraphBlockNames.ExtractVector2, FlowGraphBlockNames.ExtractVector3, FlowGraphBlockNames.ExtractVector4\n        FlowGraphBlockNames.ExtractMatrix2D, FlowGraphBlockNames.ExtractMatrix3D, FlowGraphBlockNames.ExtractMatrix\n12. **Integer Arithmetic Nodes**\n    - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n    - Sign (`math/sign`) FlowGraphBlockNames.Sign\n    - Negation (`math/neg`) FlowGraphBlockNames.Negation\n    - Addition (`math/add`) FlowGraphBlockNames.Add\n    - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n    - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n    - Division (`math/div`) FlowGraphBlockNames.Divide\n    - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n    - Minimum (`math/min`) FlowGraphBlockNames.Min\n    - Maximum (`math/max`) FlowGraphBlockNames.Max\n    - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n13. **Integer Comparison Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n    - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n    - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n    - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n14. **Integer Bitwise Nodes**\n    - Bitwise NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Bitwise AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Bitwise OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Bitwise XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n    - Right Shift (`math/asr`) FlowGraphBlockNames.BitwiseRightShift\n    - Left Shift (`math/lsl`) FlowGraphBlockNames.BitwiseLeftShift\n    - Count Leading Zeros (`math/clz`) FlowGraphBlockNames.LeadingZeros\n    - Count Trailing Zeros (`math/ctz`) FlowGraphBlockNames.TrailingZeros\n    - Count One Bits (`math/popcnt`) FlowGraphBlockNames.OneBitsCounter\n15. **Boolean Arithmetic Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Boolean NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Boolean AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Boolean OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Boolean XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n\n### Type Conversion Nodes\n1. **Boolean Conversion Nodes**\n   - Boolean to Integer (`type/boolToInt`) FlowGraphBlockNames.BooleanToInt\n   - Boolean to Float (`type/boolToFloat`) FlowGraphBlockNames.BooleanToFloat\n2. **Integer Conversion Nodes**\n   - Integer to Boolean (`type/intToBool`) FlowGraphBlockNames.IntToBoolean\n   - Integer to Float (`type/intToFloat`) FlowGraphBlockNames.IntToFloat\n3. **Float Conversion Nodes**\n   - Float to Boolean (`type/floatToBool`) FlowGraphBlockNames.FloatToBoolean\n   - Float to Integer (`type/floatToInt`) FlowGraphBlockNames.FloatToInt\n\n### Control Flow Nodes\n1. **Sync Nodes**\n   - Sequence (`flow/sequence`) FlowGraphBlockNames.Sequence\n   - Branch (`flow/branch`) FlowGraphBlockNames.Branch\n   - Switch (`flow/switch`) FlowGraphBlockNames.Switch\n   - While Loop (`flow/while`) FlowGraphBlockNames.WhileLoop\n   - For Loop (`flow/for`) FlowGraphBlockNames.ForLoop\n   - Do N (`flow/doN`) FlowGraphBlockNames.DoN\n   - Multi Gate (`flow/multiGate`) FlowGraphBlockNames.MultiGate\n   - Wait All (`flow/waitAll`) FlowGraphBlockNames.WaitAll\n   - Throttle (`flow/throttle`) FlowGraphBlockNames.Throttle\n2. **Delay Nodes**\n   - Set Delay (`flow/setDelay`) FlowGraphBlockNames.SetDelay\n   - Cancel Delay (`flow/cancelDelay`) FlowGraphBlockNames.CancelDelay\n\n### State Manipulation Nodes\n1. **Custom Variable Access**\n   - Variable Get (`variable/get`) FlowGraphBlockNames.GetVariable\n   - Variable Set (`variable/set`) FlowGraphBlockNames.SetVariable\n   - Variable Interpolate (`variable/interpolate`)\n2. **Object Model Access** // TODO fully test this!!!\n   - JSON Pointer Template Parsing (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Effective JSON Pointer Generation (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Get (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Set (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Interpolate (`pointer/interpolate`) [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.Easing]\n\n### Animation Control Nodes\n1. **Animation Play** (`animation/start`) FlowGraphBlockNames.PlayAnimation\n2. **Animation Stop** (`animation/stop`) FlowGraphBlockNames.StopAnimation \n3. **Animation Stop At** (`animation/stopAt`) FlowGraphBlockNames.StopAnimation \n\n### Event Nodes\n1. **Lifecycle Event Nodes**\n   - On Start (`event/onStart`) FlowGraphBlockNames.SceneReadyEvent\n   - On Tick (`event/onTick`) FlowGraphBlockNames.SceneTickEvent\n2. **Custom Event Nodes**\n   - Receive (`event/receive`) FlowGraphBlockNames.ReceiveCustomEvent\n   - Send (`event/send`) FlowGraphBlockNames.SendCustomEvent\n\n */\n", "import type { IKHRInteractivity_Graph, IKHRInteractivity_Node, IKHRInteractivity_OutputSocketReference, IKHRInteractivity_Variable } from \"babylonjs-gltf2interface\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { IGLTFToFlowGraphMapping } from \"./declarationMapper\";\nimport { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphConnection, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport { RandomGUID } from \"core/Misc/guid\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { FlowGraphConnectionType } from \"core/FlowGraph/flowGraphConnection\";\nimport { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface InteractivityEvent {\n    eventId: string;\n    eventData?: {\n        eventData: boolean;\n        id: string;\n        type: string;\n        value?: any;\n    }[];\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const gltfTypeToBabylonType: {\n    [key: string]: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" };\n} = {\n    float: { length: 1, flowGraphType: FlowGraphTypes.Number, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: FlowGraphTypes.Boolean, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: FlowGraphTypes.Vector2, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: FlowGraphTypes.Vector3, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: FlowGraphTypes.Vector4, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: FlowGraphTypes.Matrix, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: FlowGraphTypes.Matrix2D, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: FlowGraphTypes.Matrix3D, elementType: \"number\" },\n    int: { length: 1, flowGraphType: FlowGraphTypes.Integer, elementType: \"number\" },\n};\n\nexport class InteractivityGraphToFlowGraphParser {\n    /**\n     * Note - the graph should be rejected if the same type is defined twice.\n     * We currently don't validate that.\n     */\n    private _types: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" }[] = [];\n    private _mappings: { flowGraphMapping: IGLTFToFlowGraphMapping; fullOperationName: string }[] = [];\n    private _staticVariables: { type: FlowGraphTypes; value: any[] }[] = [];\n    private _events: InteractivityEvent[] = [];\n    private _internalEventsCounter: number = 0;\n    private _nodes: { blocks: ISerializedFlowGraphBlock[]; fullOperationName: string }[] = [];\n\n    constructor(\n        private _interactivityGraph: IKHRInteractivity_Graph,\n        private _gltf: IGLTF,\n        public _animationTargetFps: number = 60\n    ) {\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n\n    public get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n\n    private _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n\n    private _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n\n    private _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n\n    private _parseVariable(variable: IKHRInteractivity_Variable, dataTransform?: (value: any, parser: InteractivityGraphToFlowGraphParser) => any) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case FlowGraphTypes.Boolean:\n                    value.push(false);\n                    break;\n                case FlowGraphTypes.Integer:\n                    value.push(0);\n                    break;\n                case FlowGraphTypes.Number:\n                    value.push(NaN);\n                    break;\n                case FlowGraphTypes.Vector2:\n                    value.push(NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector3:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector4:\n                case FlowGraphTypes.Matrix2D:\n                case FlowGraphTypes.Quaternion:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case FlowGraphTypes.Matrix:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case FlowGraphTypes.Matrix3D:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        // in case of NaN, Infinity, we need to parse the string to the object itself\n        if (type.elementType === \"number\" && typeof value[0] === \"string\") {\n            value[0] = parseFloat(value[0]);\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n\n    private _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted: InteractivityEvent = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n\n    private _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);\n                if (!validationResult.valid) {\n                    throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);\n                }\n            }\n            const blocks: ISerializedFlowGraphBlock[] = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n\n    private _getEmptyBlock(className: string, type: string): ISerializedFlowGraphBlock {\n        const uniqueId = RandomGUID();\n        const dataInputs: ISerializedFlowGraphConnection[] = [];\n        const dataOutputs: ISerializedFlowGraphConnection[] = [];\n        const signalInputs: ISerializedFlowGraphConnection[] = [];\n        const signalOutputs: ISerializedFlowGraphConnection[] = [];\n        const config: IFlowGraphBlockConfiguration = {};\n        const metadata = {};\n        return {\n            uniqueId,\n            className,\n            dataInputs,\n            dataOutputs,\n            signalInputs,\n            signalOutputs,\n            config,\n            type,\n            metadata,\n        };\n    }\n\n    private _parseNodeConfiguration(node: IKHRInteractivity_Node, block: ISerializedFlowGraphBlock, nodeMapping: IGLTFToFlowGraphMapping, blockType: FlowGraphBlockNames | string) {\n        const configuration = block.config;\n        if (node.configuration) {\n            const keys = Object.keys(node.configuration);\n            for (const key of keys) {\n                const value = node.configuration?.[key];\n                // value is always an array, never a number or string\n                if (!value) {\n                    Logger.Error([\"No value found for node configuration\", key]);\n                    throw new Error(\"Error parsing node configuration\");\n                }\n                const configMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    // get the right name for the configuration key\n                    const configKey = configMapping?.name || key;\n                    if ((!value || typeof value.value === \"undefined\") && typeof configMapping?.defaultValue !== \"undefined\") {\n                        configuration[configKey] = {\n                            value: configMapping.defaultValue,\n                        };\n                    } else if (value.value.length >= 0) {\n                        // supporting int[] and int/boolean/string\n                        configuration[configKey] = {\n                            value: value.value.length === 1 ? value.value[0] : value.value,\n                        };\n                    } else {\n                        Logger.Warn([\"Invalid value for node configuration\", value]);\n                    }\n                    // make sure we transform the data if needed\n                    if (configMapping && configMapping.dataTransformer) {\n                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];\n                    }\n                }\n            }\n        }\n    }\n\n    private _parseNodeConnections(context: ISerializedFlowGraphContext) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if ((value as IKHRInteractivity_Variable).value !== undefined) {\n                    const convertedValue = this._parseVariable(value as IKHRInteractivity_Variable, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                } else if (typeof (value as IKHRInteractivity_OutputSocketReference).node !== \"undefined\") {\n                    const nodeOutId = (value as IKHRInteractivity_OutputSocketReference).node;\n                    const nodeOutSocketName = (value as IKHRInteractivity_OutputSocketReference).socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                } else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(\n                    gltfNode,\n                    declaration,\n                    outputMapper.flowGraphMapping,\n                    this,\n                    flowGraphBlocks.blocks,\n                    context,\n                    this._gltf\n                );\n            }\n        }\n    }\n\n    private _createNewSocketConnection(name: string, isOutput?: boolean): ISerializedFlowGraphConnection {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? FlowGraphConnectionType.Output : FlowGraphConnectionType.Input,\n            connectedPointIds: [],\n        };\n    }\n\n    private _connectFlowGraphNodes(input: string, output: string, serializedInput: ISerializedFlowGraphBlock, serializedOutput: ISerializedFlowGraphBlock, isVariable?: boolean) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n\n    public getVariableName(index: number) {\n        return \"staticVariable_\" + index;\n    }\n\n    public serializeToFlowGraph(): ISerializedFlowGraph {\n        const context: ISerializedFlowGraphContext = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), [] as ISerializedFlowGraphBlock[]);\n\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IKHRInteractivity } from \"babylonjs-gltf2interface\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\nimport { ParseFlowGraphAsync } from \"core/FlowGraph/flowGraphParser\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { AddObjectAccessorToKey, GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport { InteractivityGraphToFlowGraphParser } from \"./KHR_interactivity/interactivityGraphParser\";\r\nimport { addToBlockFactory } from \"core/FlowGraph/Blocks/flowGraphBlockFactory\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IAnimation } from \"../glTFLoaderInterfaces\";\r\n\r\nconst NAME = \"KHR_interactivity\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_interactivity extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_interactivity\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * Loader extension for KHR_interactivity\r\n */\r\nexport class KHR_interactivity implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _pathConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     * @param _loader\r\n     */\r\n    constructor(private _loader: GLTFLoader) {\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        this._pathConverter = GetPathToObjectConverter(this._loader.gltf);\r\n        // avoid starting animations automatically.\r\n        _loader._skipStartAnimationStep = true;\r\n\r\n        // Update object model with new pointers\r\n\r\n        const scene = _loader.babylonScene;\r\n        if (scene) {\r\n            _AddInteractivityObjectModel(scene);\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathConverter;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises\r\n    public async onReady(): Promise<void> {\r\n        if (!this._loader.babylonScene || !this._pathConverter) {\r\n            return;\r\n        }\r\n        const scene = this._loader.babylonScene;\r\n        const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity as IKHRInteractivity;\r\n        if (!interactivityDefinition) {\r\n            // This can technically throw, but it's not a critical error\r\n            return;\r\n        }\r\n\r\n        const coordinator = new FlowGraphCoordinator({ scene });\r\n        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously\r\n        const graphs = interactivityDefinition.graphs.map((graph) => {\r\n            const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);\r\n            return parser.serializeToFlowGraph();\r\n        });\r\n        // parse each graph async\r\n        await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));\r\n\r\n        coordinator.start();\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * populates the object model with the interactivity extension\r\n */\r\nexport function _AddInteractivityObjectModel(scene: Scene) {\r\n    // Note - all of those are read-only, as per the specs!\r\n\r\n    // active camera rotation\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/rotation\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Quaternion(NaN, NaN, NaN, NaN);\r\n            }\r\n            const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();\r\n            if (!scene.useRightHandedSystem) {\r\n                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return quat;\r\n        },\r\n        type: \"Quaternion\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n    // activeCamera position\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/position\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Vector3(NaN, NaN, NaN);\r\n            }\r\n            const pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position\r\n            if (!scene.useRightHandedSystem) {\r\n                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return pos;\r\n        },\r\n        type: \"Vector3\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n\r\n    // /animations/{} pointers:\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/isPlaying\", {\r\n        get: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup?.isPlaying ?? false;\r\n        },\r\n        type: \"boolean\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/minTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.from ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/maxTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.to ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    // playhead\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/playhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/virtualPlayhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n}\r\n\r\n// Register flow graph blocks. Do it here so they are available when the extension is enabled.\r\naddToBlockFactory(NAME, \"FlowGraphGLTFDataProvider\", async () => {\r\n    return (await import(\"./KHR_interactivity/flowGraphGLTFDataProvider\")).FlowGraphGLTFDataProvider;\r\n});\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));\r\n", "import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_visibility\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_node_visibility extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_visibility\"]: {};\n    }\n}\n\n// object model extension for visibility\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_visibility/visible\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.isVisible !== undefined) {\n            return tn.isVisible;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.inheritVisibility = true;\n        });\n        if (node._babylonTransformNode) {\n            (node._babylonTransformNode as AbstractMesh).isVisible = value;\n        }\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"isVisible\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_node_visibility\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_visibility implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            node._primitiveBabylonMeshes?.forEach((mesh) => {\n                mesh.inheritVisibility = true;\n            });\n            // When the JSON Pointer is used we need to change both the transform node and the primitive meshes to the new value.\n            if (node.extensions?.KHR_node_visibility) {\n                if (node.extensions?.KHR_node_visibility.visible === false) {\n                    if (node._babylonTransformNode) {\n                        (node._babylonTransformNode as AbstractMesh).isVisible = false;\n                    }\n                    node._primitiveBabylonMeshes?.forEach((mesh) => {\n                        mesh.isVisible = false;\n                    });\n                }\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_visibility(loader));\n", "import { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { addNewInteractivityFlowGraphMapping } from \"./KHR_interactivity/declarationMapper\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_selectability\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_selectability extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_selectability\"]: {};\n    }\n}\n\n// add the interactivity mapping for the onSelect event\naddNewInteractivityFlowGraphMapping(\"event/onSelect\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.MeshPickEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [\"pickedMesh_\" + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            selectedNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n            selectionPoint: { name: \"pickedPoint\" },\n            selectionRayOrigin: { name: \"pickOrigin\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"asset\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"pickedMesh\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n        // find the listener nodeIndex value\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = \"pickedMesh_\" + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\n// object model extension for selectable\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_selectability/selectable\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.isPickable !== undefined) {\n            return tn.isPickable;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.isPickable = value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"isPickable\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_selectability\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_selectability implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            if (node.extensions?.KHR_node_selectability && node.extensions?.KHR_node_selectability.selectable === false) {\n                node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {\n                    mesh.isPickable = false;\n                });\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_selectability(loader));\n", "import { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { addNewInteractivityFlowGraphMapping } from \"./KHR_interactivity/declarationMapper\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_hoverability\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_node_hoverability extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_hoverability\"]: {};\n    }\n}\n\n// interactivity\nconst MeshPointerOverPrefix = \"targetMeshPointerOver_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverIn\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOverEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOverPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshUnderPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n        // find the listener nodeIndex value\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOverPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nconst MeshPointerOutPrefix = \"targetMeshPointerOut_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverOut\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOutEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOutPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshOutOfPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOutPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_hoverability/hoverable\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.pointerOverDisableMeshTesting !== undefined) {\n            return tn.pointerOverDisableMeshTesting;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.pointerOverDisableMeshTesting = !value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"pointerOverDisableMeshTesting\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_node_hoverability\n * @see https://github.com/KhronosGroup/glTF/pull/2426\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_hoverability implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            // default is true, so only apply if false\n            if (node.extensions?.KHR_node_hoverability && node.extensions?.KHR_node_hoverability.hoverable === false) {\n                node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {\n                    mesh.pointerOverDisableMeshTesting = true;\n                });\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_hoverability(loader));\n", "import type { Nullable } from \"core/types\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\n\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport type { INode, ICamera, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"ExtrasAsMetadata\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the ExtrasAsMetadata extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"ExtrasAsMetadata\"]: {};\r\n    }\r\n}\r\n\r\ninterface IObjectWithMetadata {\r\n    metadata: any;\r\n}\r\n\r\n/**\r\n * Store glTF extras (if present) in BJS objects' metadata\r\n */\r\nexport class ExtrasAsMetadata implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _assignExtras(babylonObject: IObjectWithMetadata, gltfProp: IProperty): void {\r\n        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {\r\n            const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n            const gltf = (metadata.gltf = metadata.gltf || {});\r\n            gltf.extras = gltfProp.extras;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._loader.loadNodeAsync(context, node, (babylonTransformNode): void => {\r\n            this._assignExtras(babylonTransformNode, node);\r\n            assign(babylonTransformNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._loader.loadCameraAsync(context, camera, (babylonCamera): void => {\r\n            this._assignExtras(babylonCamera, camera);\r\n            assign(babylonCamera);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);\r\n        this._assignExtras(babylonMaterial, material);\r\n        return babylonMaterial;\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, false, (loader) => new ExtrasAsMetadata(loader));\r\n"],
  "mappings": "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MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,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",
  "names": ["name", "data", "GLTFLoaderCoordinateSystemMode", "GLTFLoaderAnimationStartMode", "GLTFLoaderState", "name", "request", "data", "readAsync", "chunkLength", "chunkFormat", "EComponentType", "EShaderType", "EParameterType", "ETextureWrapMode", "ETextureFilterType", "ETextureFormat", "ECullingType", "EBlendingFunction", "name", "name", "ETokenType", "jointNode", "material", "name", "__exports", "GLTFLoader", "name", "name", "name", "name", "name", "GLTFLoader", "name", "GLTFLoader", "boundingInfo", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "buffer", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "name", "decoder", "geometry", "data", "data", "name", "NAME", "GLTFLoader", "name", "NAME", "GLTFLoader", "name", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "variantName", "name", "GLTFLoader", "metadata", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "NAME", "name", "NAME", "name", "transformNode", "name", "name", "NAME", "GLTFLoader", "babylonMesh", "name", "NAME", "GLTFLoader", "babylonMaterial", "NAME", "GLTFLoader", "NAME", "GLTFLoader", "type", "outputMapper", "valueMapping", "arrayMapping", "name", "NAME", "NAME", "NAME", "NAME", "NAME"]
}
