{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/WebGPU/webgpuTextureHelper.ts", "../../../dev/core/src/Engines/WebGPU/webgpuPerfCounter.ts", "../../../dev/core/src/Engines/thinWebGPUEngine.ts", "../../../dev/core/src/Engines/WebGPU/webgpuConstants.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessor.ts", "../../../dev/core/src/Engines/WebGPU/webgpuPipelineContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessingContext.ts", "../../../dev/core/src/Misc/codeStringParsingTools.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts", "../../../dev/core/src/Engines/WebGPU/webgpuShaderProcessorsWGSL.ts", "../../../dev/core/src/Engines/WebGPU/webgpuHardwareTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTextureManager.ts", "../../../dev/core/src/Meshes/WebGPU/webgpuDataBuffer.ts", "../../../dev/core/src/Engines/WebGPU/webgpuBufferManager.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheSampler.ts", "../../../dev/core/src/Buffers/buffer.nonFloatVertexBuffers.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheRenderPipeline.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheRenderPipelineTree.ts", "../../../dev/core/src/Engines/WebGPU/webgpuStencilStateComposer.ts", "../../../dev/core/src/Engines/WebGPU/webgpuDepthCullingState.ts", "../../../dev/core/src/Materials/Textures/externalTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuMaterialContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuDrawContext.ts", "../../../dev/core/src/Engines/WebGPU/webgpuCacheBindGroups.ts", "../../../dev/core/src/ShadersWGSL/clearQuad.vertex.ts", "../../../dev/core/src/ShadersWGSL/clearQuad.fragment.ts", "../../../dev/core/src/Engines/WebGPU/webgpuClearQuad.ts", "../../../dev/core/src/Engines/WebGPU/webgpuBundleList.ts", "../../../dev/core/src/Engines/WebGPU/webgpuQuerySet.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTimestampQuery.ts", "../../../dev/core/src/Engines/WebGPU/webgpuOcclusionQuery.ts", "../../../dev/core/src/Engines/Processors/shaderCodeInliner.ts", "../../../dev/core/src/Engines/WebGPU/webgpuTintWASM.ts", "../../../dev/core/src/Engines/WebGPU/webgpuSnapshotRendering.ts", "../../../dev/core/src/Buffers/buffer.align.ts", "../../../dev/core/src/Engines/WebGPU/webgpuExternalTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.alpha.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.rawTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.readTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.cubeTexture.ts", "../../../dev/core/src/Engines/WebGPU/webgpuRenderTargetWrapper.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTarget.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetTexture.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetCube.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.query.ts", "../../../dev/core/src/Engines/WebGPU/Extensions/engine.query.ts", "../../../dev/core/src/Engines/webgpuEngine.ts"],
  "sourcesContent": ["/* eslint-disable babylonjs/available */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { ILog2 } from \"../../Maths/math.scalar.functions\";\r\nimport { Constants } from \"../constants\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\n\r\n/** @internal */\r\nexport class WebGPUTextureHelper {\r\n    public static ComputeNumMipmapLevels(width: number, height: number) {\r\n        return ILog2(Math.max(width, height)) + 1;\r\n    }\r\n\r\n    public static GetTextureTypeFromFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            // One Component = 8 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n            // One Component = 8 bits signed\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return Constants.TEXTURETYPE_BYTE;\r\n\r\n            // One component = 16 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n            // One component = 16 bits signed\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n                return Constants.TEXTURETYPE_SHORT;\r\n\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            // One component = 32 bits unsigned\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            // One component = 32 bits signed\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    public static GetBlockInformationFromFormat(format: GPUTextureFormat): { width: number; height: number; length: number } {\r\n        switch (format) {\r\n            // 8 bits formats\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n                return { width: 1, height: 1, length: 1 };\r\n\r\n            // 16 bits formats\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n                return { width: 1, height: 1, length: 2 };\r\n\r\n            // 32 bits formats\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n                return { width: 1, height: 1, length: 4 };\r\n\r\n            // 64 bits formats\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n                return { width: 1, height: 1, length: 8 };\r\n\r\n            // 128 bits formats\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n                return { width: 1, height: 1, length: 16 };\r\n\r\n            // Depth and stencil formats\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Stencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return { width: 1, height: 1, length: 2 };\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24Plus format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"No fixed size for Depth24PlusStencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return { width: 1, height: 1, length: 4 };\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return { width: 1, height: 1, length: 5 };\r\n\r\n            // BC compressed formats usable if \"texture-compression-bc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n                return { width: 5, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n                return { width: 5, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n                return { width: 6, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n                return { width: 6, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n                return { width: 8, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n                return { width: 8, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n                return { width: 8, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n                return { width: 10, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n                return { width: 10, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n                return { width: 10, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n                return { width: 10, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n                return { width: 12, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return { width: 12, height: 12, length: 16 };\r\n        }\r\n\r\n        return { width: 1, height: 1, length: 4 };\r\n    }\r\n\r\n    public static IsHardwareTexture(texture: IHardwareTextureWrapper | GPUTexture): texture is IHardwareTextureWrapper {\r\n        return !!(texture as IHardwareTextureWrapper).release;\r\n    }\r\n\r\n    public static IsInternalTexture(texture: InternalTexture | GPUTexture): texture is InternalTexture {\r\n        return !!(texture as InternalTexture).dispose;\r\n    }\r\n\r\n    public static IsImageBitmap(imageBitmap: ImageBitmap | { width: number; height: number }): imageBitmap is ImageBitmap {\r\n        return (imageBitmap as ImageBitmap).close !== undefined;\r\n    }\r\n\r\n    public static IsImageBitmapArray(imageBitmap: ImageBitmap[] | { width: number; height: number }): imageBitmap is ImageBitmap[] {\r\n        return Array.isArray(imageBitmap as ImageBitmap[]) && (imageBitmap as ImageBitmap[])[0].close !== undefined;\r\n    }\r\n\r\n    public static IsCompressedFormat(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetWebGPUTextureFormat(type: number, format: number, useSRGBBuffer = false): GPUTextureFormat {\r\n        switch (format) {\r\n            case Constants.TEXTUREFORMAT_DEPTH16:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case Constants.TEXTUREFORMAT_DEPTH24:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case Constants.TEXTUREFORMAT_DEPTH24_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth24PlusStencil8;\r\n            case Constants.TEXTUREFORMAT_DEPTH32_FLOAT:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth32FloatStencil8;\r\n            case Constants.TEXTUREFORMAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Stencil8;\r\n\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC7RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBUFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC3RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC2RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC1RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB : WebGPUConstants.TextureFormat.ASTC4x4Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGB8Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGBA8Unorm;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Snorm;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_BGRA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BGRA8UnormSRGB : WebGPUConstants.TextureFormat.BGRA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Uint;\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_ALPHA format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                }\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_INT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R32Float; // By default. Other possibility is R16Float.\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG32Float; // By default. Other possibility is RG16Float.\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float; // By default. Other possibility is RGBA16Float.\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float;\r\n                }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R16Float;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG16Float;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RG11B10UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB9E5UFloat;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2UINT;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                }\r\n        }\r\n\r\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    }\r\n\r\n    public static GetNumChannelsFromWebGPUTextureFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.R16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Snorm:\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return 1;\r\n\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Unorm:\r\n            case WebGPUConstants.TextureFormat.RG16Snorm:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return 2;\r\n\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n                return 3;\r\n\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA16Snorm:\r\n            case WebGPUConstants.TextureFormat.RGB10A2UINT:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return 4;\r\n        }\r\n\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw `Unknown format ${format}!`;\r\n    }\r\n\r\n    public static HasStencilAspect(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static HasDepthAndStencilAspects(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetDepthFormatOnly(format: GPUTextureFormat): GPUTextureFormat {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n        }\r\n\r\n        return format;\r\n    }\r\n\r\n    public static GetSample(sampleCount: number) {\r\n        // WebGPU only supports 1 or 4\r\n        return sampleCount > 1 ? 4 : 1;\r\n    }\r\n}\r\n", "import { PerfCounter } from \"../../Misc/perfCounter\";\r\n\r\n/**\r\n * Class used to define a WebGPU performance counter\r\n */\r\nexport class WebGPUPerfCounter {\r\n    private _gpuTimeInFrameId = -1;\r\n\r\n    /**\r\n     * The GPU time in nanoseconds spent in the last frame\r\n     */\r\n    public counter = new PerfCounter();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addDuration(currentFrameId: number, duration: number) {\r\n        if (currentFrameId < this._gpuTimeInFrameId) {\r\n            return;\r\n        }\r\n        if (this._gpuTimeInFrameId !== currentFrameId) {\r\n            this.counter._fetchResult();\r\n            this.counter.fetchNewFrame();\r\n            this.counter.addCount(duration, false);\r\n            this._gpuTimeInFrameId = currentFrameId;\r\n        } else {\r\n            this.counter.addCount(duration, false);\r\n        }\r\n    }\r\n}\r\n", "import type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport type { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager\";\r\nimport type { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./WebGPU/webgpuPerfCounter\";\r\nimport type { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport { Constants } from \"./constants\";\r\nimport type { WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport type { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\n\r\n/**\r\n * The base engine class for WebGPU\r\n */\r\nexport abstract class ThinWebGPUEngine extends AbstractEngine {\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @internal */\r\n    public dbgShowShaderCode = false;\r\n    /** @internal */\r\n    public dbgSanityChecks = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @internal */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @internal */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n\r\n    /** @internal */\r\n    public _textureHelper: WebGPUTextureManager;\r\n    /** @internal */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    /** @internal */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @internal */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n\r\n    /** @internal */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n\r\n    protected _snapshotRendering: WebGPUSnapshotRendering;\r\n    protected _snapshotRenderingMode = Constants.SNAPSHOTRENDERING_STANDARD;\r\n\r\n    /** @internal */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @internal */\r\n    public _timestampIndex = 0;\r\n\r\n    /** @internal */\r\n    public _debugStackRenderPass: string[] = [];\r\n\r\n    /**\r\n     * Gets the GPU time spent in the main render pass for the last frame rendered (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     * It will only return time spent in the main pass, not additional render target / compute passes (if any)!\r\n     */\r\n    public readonly gpuTimeInFrameForMainPass?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Used for both the compatibilityMode=false and the snapshot rendering modes (as both can't be enabled at the same time)\r\n     * @internal\r\n     */\r\n    public _bundleList: WebGPUBundleList;\r\n\r\n    /**\r\n     * Enables or disables GPU timing measurements.\r\n     * Note that this is only supported if the \"timestamp-query\" extension is enabled in the options.\r\n     */\r\n    public get enableGPUTimingMeasurements(): boolean {\r\n        return this._timestampQuery.enable;\r\n    }\r\n\r\n    public set enableGPUTimingMeasurements(enable: boolean) {\r\n        if (this._timestampQuery.enable === enable) {\r\n            return;\r\n        }\r\n        (this.gpuTimeInFrameForMainPass as any) = enable ? new WebGPUPerfCounter() : undefined;\r\n        this._timestampQuery.enable = enable;\r\n    }\r\n\r\n    protected _currentPassIsMainPass() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _endCurrentRenderPass(): number {\r\n        if (!this._currentRenderPass) {\r\n            return 0;\r\n        }\r\n\r\n        if (this._debugStackRenderPass.length !== 0) {\r\n            for (let i = 0; i < this._debugStackRenderPass.length; ++i) {\r\n                this._currentRenderPass.popDebugGroup();\r\n            }\r\n        }\r\n\r\n        const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;\r\n\r\n        if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {\r\n            this._bundleList.run(this._currentRenderPass);\r\n            this._bundleList.reset();\r\n        }\r\n        this._currentRenderPass.end();\r\n\r\n        this._timestampQuery.endPass(\r\n            this._timestampIndex,\r\n            (this._currentRenderTarget && (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                ? (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                : this.gpuTimeInFrameForMainPass) as WebGPUPerfCounter\r\n        );\r\n        this._timestampIndex += 2;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - \" +\r\n                        (currentPassIndex === 2 ? \"main\" : \"render target\") +\r\n                        \" end pass\" +\r\n                        (currentPassIndex === 1 ? \" - internalTexture.uniqueId=\" + this._currentRenderTarget?.texture?.uniqueId : \"\")\r\n                );\r\n            }\r\n        }\r\n        this._debugPopGroup?.(0);\r\n        this._currentRenderPass = null;\r\n\r\n        return currentPassIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        commandEncoder = commandEncoder ?? this._renderEncoder;\r\n\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (commandEncoder === this._renderEncoder) {\r\n            // We must close the current pass (if any) because we are going to use the render encoder to generate the mipmaps (so, we are going to create a new render pass)\r\n            this._endCurrentRenderPass();\r\n        }\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - generate mipmaps - width=\" +\r\n                        texture.width +\r\n                        \", height=\" +\r\n                        texture.height +\r\n                        \", isCube=\" +\r\n                        texture.isCube +\r\n                        \", command encoder=\" +\r\n                        (commandEncoder === this._renderEncoder ? \"render\" : \"copy\")\r\n                );\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, texture.is3D, commandEncoder);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\n// eslint-disable-next-line import/export\r\nexport const enum PowerPreference {\r\n    LowPower = \"low-power\",\r\n    HighPerformance = \"high-performance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FeatureName {\r\n    CoreFeaturesAndLimits = \"core-features-and-limits\",\r\n    DepthClipControl = \"depth-clip-control\",\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n    TextureCompressionBC = \"texture-compression-bc\",\r\n    TextureCompressionBCSliced3D = \"texture-compression-bc-sliced-3d\",\r\n    TextureCompressionETC2 = \"texture-compression-etc2\",\r\n    TextureCompressionASTC = \"texture-compression-astc\",\r\n    TextureCompressionASTCSliced3D = \"texture-compression-astc-sliced-3d\",\r\n    TimestampQuery = \"timestamp-query\",\r\n    IndirectFirstInstance = \"indirect-first-instance\",\r\n    ShaderF16 = \"shader-f16\",\r\n    RG11B10UFloatRenderable = \"rg11b10ufloat-renderable\",\r\n    BGRA8UnormStorage = \"bgra8unorm-storage\",\r\n    Float32Filterable = \"float32-filterable\",\r\n    Float32Blendable = \"float32-blendable\",\r\n    ClipDistances = \"clip-distances\",\r\n    DualSourceBlending = \"dual-source-blending\",\r\n    Subgroups = \"subgroups\",\r\n    TextureFormatsTier1 = \"texture-formats-tier1\",\r\n    TextureFormatsTier2 = \"texture-formats-tier2\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferMapState {\r\n    Unmapped = \"unmapped\",\r\n    Pending = \"pending\",\r\n    Mapped = \"mapped\",\r\n}\r\n\r\n/** @internal */\r\nexport enum BufferUsage {\r\n    MapRead = 1,\r\n    MapWrite = 2,\r\n    CopySrc = 4,\r\n    CopyDst = 8,\r\n    Index = 16,\r\n    Vertex = 32,\r\n    Uniform = 64,\r\n    Storage = 128,\r\n    Indirect = 256,\r\n    QueryResolve = 512,\r\n}\r\n\r\n/** @internal */\r\nexport const enum MapMode {\r\n    Read = 1,\r\n    Write = 2,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureUsage {\r\n    CopySrc = 1,\r\n    CopyDst = 2,\r\n    TextureBinding = 4,\r\n    StorageBinding = 8,\r\n    RenderAttachment = 16,\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureViewDimension {\r\n    E1d = \"1d\",\r\n    E2d = \"2d\",\r\n    E2dArray = \"2d-array\",\r\n    Cube = \"cube\",\r\n    CubeArray = \"cube-array\",\r\n    E3d = \"3d\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureAspect {\r\n    All = \"all\",\r\n    StencilOnly = \"stencil-only\",\r\n    DepthOnly = \"depth-only\",\r\n}\r\n\r\n/**\r\n * Comments taken from https://github.com/gfx-rs/wgpu/blob/master/wgpu-types/src/lib.rs\r\n * @internal\r\n */\r\nexport const enum TextureFormat {\r\n    // 8-bit formats\r\n    R8Unorm = \"r8unorm\", // Red channel only. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    R8Snorm = \"r8snorm\", // Red channel only. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    R8Uint = \"r8uint\", // Red channel only. 8 bit integer per channel. Unsigned in shader.\r\n    R8Sint = \"r8sint\", // Red channel only. 8 bit integer per channel. Signed in shader.\r\n\r\n    // 16-bit formats\r\n    R16Uint = \"r16uint\", // Red channel only. 16 bit integer per channel. Unsigned in shader.\r\n    R16Sint = \"r16sint\", // Red channel only. 16 bit integer per channel. Signed in shader.\r\n    R16Float = \"r16float\", // Red channel only. 16 bit float per channel. Float in shader.\r\n    RG8Unorm = \"rg8unorm\", // Red and green channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RG8Snorm = \"rg8snorm\", // Red and green channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RG8Uint = \"rg8uint\", // Red and green channels. 8 bit integer per channel. Unsigned in shader.\r\n    RG8Sint = \"rg8sint\", // Red and green channels. 8 bit integer per channel. Signed in shader.\r\n    R16Unorm = \"r16unorm\", // Red channel only. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    R16Snorm = \"r16snorm\", // Red channel only. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n\r\n    // 32-bit formats\r\n    R32Uint = \"r32uint\", // Red channel only. 32 bit integer per channel. Unsigned in shader.\r\n    R32Sint = \"r32sint\", // Red channel only. 32 bit integer per channel. Signed in shader.\r\n    R32Float = \"r32float\", // Red channel only. 32 bit float per channel. Float in shader.\r\n    RG16Uint = \"rg16uint\", // Red and green channels. 16 bit integer per channel. Unsigned in shader.\r\n    RG16Sint = \"rg16sint\", // Red and green channels. 16 bit integer per channel. Signed in shader.\r\n    RG16Float = \"rg16float\", // Red and green channels. 16 bit float per channel. Float in shader.\r\n    RGBA8Unorm = \"rgba8unorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    RGBA8UnormSRGB = \"rgba8unorm-srgb\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    RGBA8Snorm = \"rgba8snorm\", // Red, green, blue, and alpha channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.\r\n    RGBA8Uint = \"rgba8uint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Unsigned in shader.\r\n    RGBA8Sint = \"rgba8sint\", // Red, green, blue, and alpha channels. 8 bit integer per channel. Signed in shader.\r\n    BGRA8Unorm = \"bgra8unorm\", // Blue, green, red, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.\r\n    BGRA8UnormSRGB = \"bgra8unorm-srgb\", // Blue, green, red, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.\r\n    RG16Unorm = \"rg16unorm\", // Red and green channels. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    RG16Snorm = \"rg16snorm\", // Red and green channels. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n    // Packed 32-bit formats\r\n    RGB9E5UFloat = \"rgb9e5ufloat\", // Packed unsigned float with 9 bits mantisa for each RGB component, then a common 5 bits exponent\r\n    RGB10A2UINT = \"rgb10a2uint\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha).\r\n    RGB10A2Unorm = \"rgb10a2unorm\", // Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha) converted to/from float [0, 1] in shader.\r\n    RG11B10UFloat = \"rg11b10ufloat\", // Red, green, and blue channels. 11 bit float with no sign bit for RG channels. 10 bit float with no sign bit for blue channel. Float in shader.\r\n\r\n    // 64-bit formats\r\n    RG32Uint = \"rg32uint\", // Red and green channels. 32 bit integer per channel. Unsigned in shader.\r\n    RG32Sint = \"rg32sint\", // Red and green channels. 32 bit integer per channel. Signed in shader.\r\n    RG32Float = \"rg32float\", // Red and green channels. 32 bit float per channel. Float in shader.\r\n    RGBA16Uint = \"rgba16uint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Unsigned in shader.\r\n    RGBA16Sint = \"rgba16sint\", // Red, green, blue, and alpha channels. 16 bit integer per channel. Signed in shader.\r\n    RGBA16Float = \"rgba16float\", // Red, green, blue, and alpha channels. 16 bit float per channel. Float in shader.\r\n    RGBA16Unorm = \"rgba16unorm\", // Red, green, blue, and alpha channels. 16 bit integer per channel. [0, 65535] converted to float [0, 1] in shader.\r\n    RGBA16Snorm = \"rgba16snorm\", // Red, green, blue, and alpha channels. 16 bit integer per channel. [-32768, 32767] converted to float [-1, 1] in shader.\r\n\r\n    // 128-bit formats\r\n    RGBA32Uint = \"rgba32uint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Unsigned in shader.\r\n    RGBA32Sint = \"rgba32sint\", // Red, green, blue, and alpha channels. 32 bit integer per channel. Signed in shader.\r\n    RGBA32Float = \"rgba32float\", // Red, green, blue, and alpha channels. 32 bit float per channel. Float in shader.\r\n\r\n    // Depth and stencil formats\r\n    Stencil8 = \"stencil8\",\r\n    Depth16Unorm = \"depth16unorm\",\r\n    Depth24Plus = \"depth24plus\", // Special depth format with at least 24 bit integer depth.\r\n    Depth24PlusStencil8 = \"depth24plus-stencil8\", // Special depth/stencil format with at least 24 bit integer depth and 8 bits integer stencil.\r\n    Depth32Float = \"depth32float\", // Special depth format with 32 bit floating point depth.\r\n\r\n    // BC compressed formats usable if \"texture-compression-bc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    BC1RGBAUnorm = \"bc1-rgba-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC1RGBAUnormSRGB = \"bc1-rgba-unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha. Also known as DXT1.\r\n    BC2RGBAUnorm = \"bc2-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC2RGBAUnormSRGB = \"bc2-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha. Also known as DXT3.\r\n    BC3RGBAUnorm = \"bc3-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC3RGBAUnormSRGB = \"bc3-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha. Also known as DXT5.\r\n    BC4RUnorm = \"bc4-r-unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC4RSnorm = \"bc4-r-snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R. Also known as RGTC1.\r\n    BC5RGUnorm = \"bc5-rg-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC5RGSnorm = \"bc5-rg-snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG. Also known as RGTC2.\r\n    BC6HRGBUFloat = \"bc6h-rgb-ufloat\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit unsigned float RGB. Float in shader. Also known as BPTC (float).\r\n    BC6HRGBFloat = \"bc6h-rgb-float\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit signed float RGB. Float in shader. Also known as BPTC (float).\r\n    BC7RGBAUnorm = \"bc7-rgba-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n    BC7RGBAUnormSRGB = \"bc7-rgba-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA. Also known as BPTC (unorm).\r\n\r\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ETC2RGB8Unorm = \"etc2-rgb8unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8UnormSRGB = \"etc2-rgb8unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.\r\n    ETC2RGB8A1Unorm = \"etc2-rgb8a1unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGB8A1UnormSRGB = \"etc2-rgb8a1unorm-srgb\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.\r\n    ETC2RGBA8Unorm = \"etc2-rgba8unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    ETC2RGBA8UnormSRGB = \"etc2-rgba8unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.\r\n    EACR11Unorm = \"eac-r11unorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACR11Snorm = \"eac-r11snorm\", // 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 11 bit integer R.\r\n    EACRG11Unorm = \"eac-rg11unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n    EACRG11Snorm = \"eac-rg11snorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 11 bit integer R + 11 bit integer G.\r\n\r\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n    // supported by the device/user agent and enabled in requestDevice.\r\n    ASTC4x4Unorm = \"astc-4x4-unorm\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC4x4UnormSRGB = \"astc-4x4-unorm-srgb\", // 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4Unorm = \"astc-5x4-unorm\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x4UnormSRGB = \"astc-5x4-unorm-srgb\", // 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5Unorm = \"astc-5x5-unorm\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC5x5UnormSRGB = \"astc-5x5-unorm-srgb\", // 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5Unorm = \"astc-6x5-unorm\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x5UnormSRGB = \"astc-6x5-unorm-srgb\", // 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6Unorm = \"astc-6x6-unorm\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC6x6UnormSRGB = \"astc-6x6-unorm-srgb\", // 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5Unorm = \"astc-8x5-unorm\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x5UnormSRGB = \"astc-8x5-unorm-srgb\", // 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6Unorm = \"astc-8x6-unorm\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x6UnormSRGB = \"astc-8x6-unorm-srgb\", // 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8Unorm = \"astc-8x8-unorm\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC8x8UnormSRGB = \"astc-8x8-unorm-srgb\", // 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5Unorm = \"astc-10x5-unorm\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x5UnormSRGB = \"astc-10x5-unorm-srgb\", // 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6Unorm = \"astc-10x6-unorm\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x6UnormSRGB = \"astc-10x6-unorm-srgb\", // 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8Unorm = \"astc-10x8-unorm\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x8UnormSRGB = \"astc-10x8-unorm-srgb\", // 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10Unorm = \"astc-10x10-unorm\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC10x10UnormSRGB = \"astc-10x10-unorm-srgb\", // 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10Unorm = \"astc-12x10-unorm\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x10UnormSRGB = \"astc-12x10-unorm-srgb\", // 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12Unorm = \"astc-12x12-unorm\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n    ASTC12x12UnormSRGB = \"astc-12x12-unorm-srgb\", // 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.\r\n\r\n    // \"depth32float-stencil8\" feature\r\n    Depth32FloatStencil8 = \"depth32float-stencil8\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AddressMode {\r\n    ClampToEdge = \"clamp-to-edge\",\r\n    Repeat = \"repeat\",\r\n    MirrorRepeat = \"mirror-repeat\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum MipmapFilterMode {\r\n    Nearest = \"nearest\",\r\n    Linear = \"linear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompareFunction {\r\n    Never = \"never\",\r\n    Less = \"less\",\r\n    Equal = \"equal\",\r\n    LessEqual = \"less-equal\",\r\n    Greater = \"greater\",\r\n    NotEqual = \"not-equal\",\r\n    GreaterEqual = \"greater-equal\",\r\n    Always = \"always\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ShaderStage {\r\n    Vertex = 1,\r\n    Fragment = 2,\r\n    Compute = 4,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BufferBindingType {\r\n    Uniform = \"uniform\",\r\n    Storage = \"storage\",\r\n    ReadOnlyStorage = \"read-only-storage\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum SamplerBindingType {\r\n    Filtering = \"filtering\",\r\n    NonFiltering = \"non-filtering\",\r\n    Comparison = \"comparison\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum TextureSampleType {\r\n    Float = \"float\",\r\n    UnfilterableFloat = \"unfilterable-float\",\r\n    Depth = \"depth\",\r\n    Sint = \"sint\",\r\n    Uint = \"uint\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StorageTextureAccess {\r\n    WriteOnly = \"write-only\",\r\n    ReadOnly = \"read-only\",\r\n    ReadWrite = \"read-write\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CompilationMessageType {\r\n    Error = \"error\",\r\n    Warning = \"warning\",\r\n    Info = \"info\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PipelineErrorReason {\r\n    Validation = \"validation\",\r\n    Internal = \"internal\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum AutoLayoutMode {\r\n    Auto = \"auto\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum PrimitiveTopology {\r\n    PointList = \"point-list\",\r\n    LineList = \"line-list\",\r\n    LineStrip = \"line-strip\",\r\n    TriangleList = \"triangle-list\",\r\n    TriangleStrip = \"triangle-strip\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum FrontFace {\r\n    CCW = \"ccw\",\r\n    CW = \"cw\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CullMode {\r\n    None = \"none\",\r\n    Front = \"front\",\r\n    Back = \"back\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ColorWrite {\r\n    Red = 1,\r\n    Green = 2,\r\n    Blue = 4,\r\n    Alpha = 8,\r\n    All = 15,\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendFactor {\r\n    Zero = \"zero\",\r\n    One = \"one\",\r\n    Src = \"src\",\r\n    OneMinusSrc = \"one-minus-src\",\r\n    SrcAlpha = \"src-alpha\",\r\n    OneMinusSrcAlpha = \"one-minus-src-alpha\",\r\n    Dst = \"dst\",\r\n    OneMinusDst = \"one-minus-dst\",\r\n    DstAlpha = \"dst-alpha\",\r\n    OneMinusDstAlpha = \"one-minus-dst-alpha\",\r\n    SrcAlphaSaturated = \"src-alpha-saturated\",\r\n    Constant = \"constant\",\r\n    OneMinusConstant = \"one-minus-constant\",\r\n    Src1 = \"src1\",\r\n    OneMinusSrc1 = \"one-minus-src1\",\r\n    Src1Alpha = \"src1-alpha\",\r\n    OneMinusSrc1Alpha = \"one-minus-src1-alpha\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum BlendOperation {\r\n    Add = \"add\",\r\n    Subtract = \"subtract\",\r\n    ReverseSubtract = \"reverse-subtract\",\r\n    Min = \"min\",\r\n    Max = \"max\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StencilOperation {\r\n    Keep = \"keep\",\r\n    Zero = \"zero\",\r\n    Replace = \"replace\",\r\n    Invert = \"invert\",\r\n    IncrementClamp = \"increment-clamp\",\r\n    DecrementClamp = \"decrement-clamp\",\r\n    IncrementWrap = \"increment-wrap\",\r\n    DecrementWrap = \"decrement-wrap\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum IndexFormat {\r\n    Uint16 = \"uint16\",\r\n    Uint32 = \"uint32\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexFormat {\r\n    Uint8 = \"uint8\",\r\n    Uint8x2 = \"uint8x2\",\r\n    Uint8x4 = \"uint8x4\",\r\n    Sint8 = \"sint8\",\r\n    Sint8x2 = \"sint8x2\",\r\n    Sint8x4 = \"sint8x4\",\r\n    Unorm8 = \"unorm8\",\r\n    Unorm8x2 = \"unorm8x2\",\r\n    Unorm8x4 = \"unorm8x4\",\r\n    Snorm8 = \"snorm8\",\r\n    Snorm8x2 = \"snorm8x2\",\r\n    Snorm8x4 = \"snorm8x4\",\r\n    Uint16 = \"uint16\",\r\n    Uint16x2 = \"uint16x2\",\r\n    Uint16x4 = \"uint16x4\",\r\n    Sint16 = \"sint16\",\r\n    Sint16x2 = \"sint16x2\",\r\n    Sint16x4 = \"sint16x4\",\r\n    Unorm16 = \"unorm16\",\r\n    Unorm16x2 = \"unorm16x2\",\r\n    Unorm16x4 = \"unorm16x4\",\r\n    Snorm16 = \"snorm16\",\r\n    Snorm16x2 = \"snorm16x2\",\r\n    Snorm16x4 = \"snorm16x4\",\r\n    Float16 = \"float16\",\r\n    Float16x2 = \"float16x2\",\r\n    Float16x4 = \"float16x4\",\r\n    Float32 = \"float32\",\r\n    Float32x2 = \"float32x2\",\r\n    Float32x3 = \"float32x3\",\r\n    Float32x4 = \"float32x4\",\r\n    Uint32 = \"uint32\",\r\n    Uint32x2 = \"uint32x2\",\r\n    Uint32x3 = \"uint32x3\",\r\n    Uint32x4 = \"uint32x4\",\r\n    Sint32 = \"sint32\",\r\n    Sint32x2 = \"sint32x2\",\r\n    Sint32x3 = \"sint32x3\",\r\n    Sint32x4 = \"sint32x4\",\r\n    UNORM10x10x10x2 = \"unorm10-10-10-2\",\r\n    UNORM8x4BGRA = \"unorm8x4-bgra\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexStepMode {\r\n    Vertex = \"vertex\",\r\n    Instance = \"instance\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ComputePassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum RenderPassTimestampLocation {\r\n    Beginning = \"beginning\",\r\n    End = \"end\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum LoadOp {\r\n    Load = \"load\",\r\n    Clear = \"clear\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum StoreOp {\r\n    Store = \"store\",\r\n    Discard = \"discard\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum QueryType {\r\n    Occlusion = \"occlusion\",\r\n    Timestamp = \"timestamp\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CanvasAlphaMode {\r\n    Opaque = \"opaque\",\r\n    Premultiplied = \"premultiplied\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum CanvasToneMappingMode {\r\n    Standard = \"standard\",\r\n    Extended = \"extended\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum DeviceLostReason {\r\n    Unknown = \"unknown\",\r\n    Destroyed = \"destroyed\",\r\n}\r\n\r\n/** @internal */\r\nexport const enum ErrorFilter {\r\n    Validation = \"validation\",\r\n    OutOfMemory = \"out-of-memory\",\r\n    Internal = \"internal\",\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IShaderProcessor } from \"../Processors/iShaderProcessor\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUSamplerDescription, WebGPUShaderProcessingContext, WebGPUTextureDescription, WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\n\r\n/** @internal */\r\nexport abstract class WebGPUShaderProcessor implements IShaderProcessor {\r\n    public static readonly LeftOvertUBOName = \"LeftOver\";\r\n    public static readonly InternalsUBOName = \"Internals\";\r\n\r\n    public static UniformSizes: { [type: string]: number } = {\r\n        // GLSL types\r\n        bool: 1,\r\n        int: 1,\r\n        float: 1,\r\n        vec2: 2,\r\n        ivec2: 2,\r\n        uvec2: 2,\r\n        vec3: 3,\r\n        ivec3: 3,\r\n        uvec3: 3,\r\n        vec4: 4,\r\n        ivec4: 4,\r\n        uvec4: 4,\r\n        mat2: 4,\r\n        mat3: 12,\r\n        mat4: 16,\r\n\r\n        // WGSL types\r\n        i32: 1,\r\n        u32: 1,\r\n        f32: 1,\r\n        mat2x2: 4,\r\n        mat3x3: 12,\r\n        mat4x4: 16,\r\n        mat2x2f: 4,\r\n        mat3x3f: 12,\r\n        mat4x4f: 16,\r\n        vec2i: 2,\r\n        vec3i: 3,\r\n        vec4i: 4,\r\n        vec2u: 2,\r\n        vec3u: 3,\r\n        vec4u: 4,\r\n        vec2f: 2,\r\n        vec3f: 3,\r\n        vec4f: 4,\r\n        vec2h: 1,\r\n        vec3h: 2,\r\n        vec4h: 2,\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerFunctionByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"sampler2D\",\r\n        sampler2DArray: \"sampler2DArray\",\r\n        sampler2DShadow: \"sampler2DShadow\",\r\n        sampler2DArrayShadow: \"sampler2DArrayShadow\",\r\n        samplerCube: \"samplerCube\",\r\n        sampler3D: \"sampler3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _TextureTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2D: \"texture2D\",\r\n        sampler2DArray: \"texture2DArray\",\r\n        sampler2DShadow: \"texture2D\",\r\n        sampler2DArrayShadow: \"texture2DArray\",\r\n        samplerCube: \"textureCube\",\r\n        samplerCubeArray: \"textureCubeArray\",\r\n        sampler3D: \"texture3D\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _GpuTextureViewDimensionByWebGPUTextureType: { [key: string]: GPUTextureViewDimension } = {\r\n        textureCube: WebGPUConstants.TextureViewDimension.Cube,\r\n        textureCubeArray: WebGPUConstants.TextureViewDimension.CubeArray,\r\n        texture2D: WebGPUConstants.TextureViewDimension.E2d,\r\n        texture2DArray: WebGPUConstants.TextureViewDimension.E2dArray,\r\n        texture3D: WebGPUConstants.TextureViewDimension.E3d,\r\n    };\r\n\r\n    // if the webgl sampler type is not listed in this array, \"sampler\" is taken by default\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _SamplerTypeByWebGLSamplerType: { [key: string]: string } = {\r\n        sampler2DShadow: \"samplerShadow\",\r\n        sampler2DArrayShadow: \"samplerShadow\",\r\n    };\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _IsComparisonSamplerByWebGPUSamplerType: { [key: string]: boolean } = {\r\n        samplerShadow: true,\r\n        samplerArrayShadow: true,\r\n        sampler: false,\r\n    };\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _webgpuProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected abstract _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number];\r\n    protected abstract _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string;\r\n\r\n    protected _addUniformToLeftOverUBO(name: string, uniformType: string, preProcessors: { [key: string]: string }): void {\r\n        let length = 0;\r\n\r\n        [name, uniformType, length] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {\r\n            if (this._webgpuProcessingContext.leftOverUniforms[i].name === name) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._webgpuProcessingContext.leftOverUniforms.push({\r\n            name,\r\n            type: uniformType,\r\n            length,\r\n        });\r\n    }\r\n\r\n    protected _buildLeftOverUBO(): string {\r\n        if (!this._webgpuProcessingContext.leftOverUniforms.length) {\r\n            return \"\";\r\n        }\r\n        const name = WebGPUShaderProcessor.LeftOvertUBOName;\r\n        let availableUBO = this._webgpuProcessingContext.availableBuffers[name];\r\n        if (!availableUBO) {\r\n            availableUBO = {\r\n                binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n            };\r\n            this._webgpuProcessingContext.availableBuffers[name] = availableUBO;\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, true);\r\n            this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, false);\r\n        }\r\n\r\n        return this._generateLeftOverUBOCode(name, availableUBO);\r\n    }\r\n\r\n    protected _collectBindingNames(): void {\r\n        // collect all the binding names for faster processing in WebGPUCacheBindGroup\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n            if (setDefinition === undefined) {\r\n                this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];\r\n                continue;\r\n            }\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const name = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;\r\n                if (entry) {\r\n                    if (entry.texture || entry.externalTexture || entry.storageTexture) {\r\n                        this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture!);\r\n                    } else if (entry.sampler) {\r\n                        this._webgpuProcessingContext.samplerNames.push(name);\r\n                    } else if (entry.buffer) {\r\n                        this._webgpuProcessingContext.bufferNames.push(name);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _preCreateBindGroupEntries(): void {\r\n        const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;\r\n\r\n        for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries: GPUBindGroupEntry[] = [];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: undefined as any,\r\n                    });\r\n                } else if (entry.buffer) {\r\n                    entries.push({\r\n                        binding: entry.binding,\r\n                        resource: {\r\n                            buffer: undefined as any,\r\n                            offset: 0,\r\n                            size: 0,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n\r\n            bindGroupEntries[i] = entries;\r\n        }\r\n    }\r\n\r\n    protected _addTextureBindingDescription(\r\n        name: string,\r\n        textureInfo: WebGPUTextureDescription,\r\n        textureIndex: number,\r\n        dimension: Nullable<GPUTextureViewDimension>,\r\n        format: Nullable<GPUTextureFormat>,\r\n        isVertex: boolean\r\n    ): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = textureInfo.textures[textureIndex];\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            let len;\r\n            if (dimension === null) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    externalTexture: {},\r\n                });\r\n            } else if (format) {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    storageTexture: {\r\n                        access: WebGPUConstants.StorageTextureAccess.WriteOnly,\r\n                        format,\r\n                        viewDimension: dimension,\r\n                    },\r\n                });\r\n            } else {\r\n                len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                    binding: bindingIndex,\r\n                    visibility: 0,\r\n                    texture: {\r\n                        sampleType: textureInfo.sampleType,\r\n                        viewDimension: dimension,\r\n                        multisampled: false,\r\n                    },\r\n                });\r\n            }\r\n            const textureName = textureInfo.isTextureArray ? name + textureIndex : name;\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1, nameInArrayOfTexture: textureName };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addSamplerBindingDescription(name: string, samplerInfo: WebGPUSamplerDescription, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = samplerInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                sampler: {\r\n                    type: samplerInfo.type,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n\r\n    protected _addBufferBindingDescription(name: string, uniformBufferInfo: WebGPUBufferDescription, bufferType: GPUBufferBindingType, isVertex: boolean): void {\r\n        // eslint-disable-next-line prefer-const\r\n        let { groupIndex, bindingIndex } = uniformBufferInfo.binding;\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\r\n        }\r\n        if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\r\n            const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\r\n                binding: bindingIndex,\r\n                visibility: 0,\r\n                buffer: {\r\n                    type: bufferType,\r\n                },\r\n            });\r\n            this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = { name, index: len - 1 };\r\n        }\r\n\r\n        bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\r\n        if (isVertex) {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\r\n        } else {\r\n            this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport interface IWebGPURenderPipelineStageDescriptor {\r\n    vertexStage: GPUProgrammableStage;\r\n    fragmentStage?: GPUProgrammableStage;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUPipelineContext implements IPipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public shaderProcessingContext: WebGPUShaderProcessingContext;\r\n\r\n    protected _leftOverUniformsByName: { [name: string]: string };\r\n\r\n    // Property used to handle vertex buffers with int values when the shader code expect float values.\r\n    public vertexBufferKindToType: { [kind: string]: number };\r\n\r\n    public sources: {\r\n        vertex: string;\r\n        fragment: string;\r\n        rawVertex: string;\r\n        rawFragment: string;\r\n    };\r\n\r\n    public stages: Nullable<IWebGPURenderPipelineStageDescriptor>;\r\n\r\n    // The field is indexed by textureState. See @WebGPUMaterialContext.textureState for more information.\r\n    public bindGroupLayouts: { [textureState: number]: GPUBindGroupLayout[] } = {};\r\n\r\n    /**\r\n     * Stores the left-over uniform buffer\r\n     */\r\n    public uniformBuffer: Nullable<UniformBuffer>;\r\n\r\n    // Default implementation.\r\n    public onCompiled?: () => void;\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.stages) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(shaderProcessingContext: WebGPUShaderProcessingContext, engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.shaderProcessingContext = shaderProcessingContext;\r\n        this._leftOverUniformsByName = {};\r\n        this.engine = engine;\r\n        this.vertexBufferKindToType = {};\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(): void {\r\n        // Nothing to do yet for spector.\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n\r\n        if (engine._doNotHandleContextLost) {\r\n            effect._fragmentSourceCode = \"\";\r\n            effect._vertexSourceCode = \"\";\r\n        }\r\n\r\n        const foundSamplers = this.shaderProcessingContext.availableTextures;\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const name = samplerList[index];\r\n            const sampler = foundSamplers[samplerList[index]];\r\n\r\n            if (sampler == null || sampler == undefined) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            } else {\r\n                samplers[name] = index;\r\n            }\r\n        }\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n\r\n        // Build the uniform layout for the left over uniforms.\r\n        this.buildUniformLayout();\r\n\r\n        const attributeNamesFromEffect: string[] = [];\r\n        const attributeLocationsFromEffect: number[] = [];\r\n        for (index = 0; index < attributesNames.length; index++) {\r\n            const location = attributes[index];\r\n            if (location >= 0) {\r\n                attributeNamesFromEffect.push(attributesNames[index]);\r\n                attributeLocationsFromEffect.push(location);\r\n            }\r\n        }\r\n        this.shaderProcessingContext.attributeNamesFromEffect = attributeNamesFromEffect;\r\n        this.shaderProcessingContext.attributeLocationsFromEffect = attributeLocationsFromEffect;\r\n    }\r\n\r\n    /** @internal */\r\n    /**\r\n     * Build the uniform buffer used in the material.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        if (!this.shaderProcessingContext.leftOverUniforms.length) {\r\n            return;\r\n        }\r\n\r\n        this.uniformBuffer?.dispose();\r\n        this.uniformBuffer = new UniformBuffer(this.engine, undefined, undefined, \"leftOver-\" + this._name);\r\n\r\n        for (const leftOverUniform of this.shaderProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n            this.uniformBuffer.addUniform(leftOverUniform.name, size, leftOverUniform.length);\r\n            this._leftOverUniformsByName[leftOverUniform.name] = leftOverUniform.type;\r\n        }\r\n\r\n        this.uniformBuffer.create();\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as WebGPUEngine;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this.uniformBuffer) {\r\n            this.uniformBuffer.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this.setIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUInt4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this.setUIntArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this.setArray(uniformName, array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrices(uniformName, matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix3x3(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateMatrix2x2(uniformName, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat(uniformName, value);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        this.setFloat2(uniformName, vector2.x, vector2.y);\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat2(uniformName, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        this.setFloat3(uniformName, vector3.x, vector3.y, vector3.z);\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat3(uniformName, x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        this.setFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        this.setFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (!this.uniformBuffer || !this._leftOverUniformsByName[uniformName]) {\r\n            return;\r\n        }\r\n        this.uniformBuffer.updateFloat4(uniformName, x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        this.setFloat3(uniformName, color3.r, color3.g, color3.b);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        this.setFloat4(uniformName, color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        this.setFloat4(uniformName, color4.r, color4.g, color4.b, color4.a);\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.sources?.vertex;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.sources?.fragment;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\n\r\nconst MaxGroups = 4;\r\nconst MaxBindingsPerGroup = 1 << 16;\r\n\r\n// all types not listed are assumed to consume 1 location\r\nconst TypeToLocationSize: { [key: string]: number } = {\r\n    // GLSL types\r\n    mat2: 2,\r\n    mat3: 3,\r\n    mat4: 4,\r\n\r\n    // WGSL types\r\n    mat2x2: 2,\r\n    mat3x3: 3,\r\n    mat4x4: 4,\r\n};\r\n\r\n/** @internal */\r\nexport interface WebGPUBindingInfo {\r\n    groupIndex: number;\r\n    bindingIndex: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUTextureDescription {\r\n    autoBindSampler?: boolean;\r\n    isTextureArray: boolean;\r\n    isStorageTexture: boolean;\r\n    textures: Array<WebGPUBindingInfo>;\r\n    sampleType?: GPUTextureSampleType; // not used if the texture is a storage texture\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUSamplerDescription {\r\n    binding: WebGPUBindingInfo;\r\n    type: GPUSamplerBindingType;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBufferDescription {\r\n    binding: WebGPUBindingInfo;\r\n}\r\n\r\n/** @internal */\r\nexport interface WebGPUBindGroupLayoutEntryInfo {\r\n    name: string;\r\n    index: number; // index of the entry (GPUBindGroupLayoutEntry) in the bindGroupLayoutEntries[group] array\r\n    nameInArrayOfTexture?: string; // something like texture0, texture1, ... if texture is an array, else same thing as \"name\"\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class WebGPUShaderProcessingContext implements _IShaderProcessingContext {\r\n    /** @internal */\r\n    public static _SimplifiedKnownBindings = true; // if true, use only group=0,binding=0 as a known group/binding for the Scene ubo and use group=1,binding=X for all other bindings\r\n    // if false, see _KnownUBOs for the known groups/bindings used\r\n\r\n    protected static _SimplifiedKnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n        Light0: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light1: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light2: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light3: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light4: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light5: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light6: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light7: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light8: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light9: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light10: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light11: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light12: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light13: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light14: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light15: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light16: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light17: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light18: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light19: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light20: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light21: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light22: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light23: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light24: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light25: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light26: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light27: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light28: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light29: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light30: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Light31: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Material: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Mesh: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n        Internals: { binding: { groupIndex: -1, bindingIndex: -1 } },\r\n    };\r\n\r\n    protected static _KnownUBOs: { [key: string]: WebGPUBufferDescription } = {\r\n        Scene: { binding: { groupIndex: 0, bindingIndex: 0 } },\r\n\r\n        Light0: { binding: { groupIndex: 1, bindingIndex: 0 } },\r\n        Light1: { binding: { groupIndex: 1, bindingIndex: 1 } },\r\n        Light2: { binding: { groupIndex: 1, bindingIndex: 2 } },\r\n        Light3: { binding: { groupIndex: 1, bindingIndex: 3 } },\r\n        Light4: { binding: { groupIndex: 1, bindingIndex: 4 } },\r\n        Light5: { binding: { groupIndex: 1, bindingIndex: 5 } },\r\n        Light6: { binding: { groupIndex: 1, bindingIndex: 6 } },\r\n        Light7: { binding: { groupIndex: 1, bindingIndex: 7 } },\r\n        Light8: { binding: { groupIndex: 1, bindingIndex: 8 } },\r\n        Light9: { binding: { groupIndex: 1, bindingIndex: 9 } },\r\n        Light10: { binding: { groupIndex: 1, bindingIndex: 10 } },\r\n        Light11: { binding: { groupIndex: 1, bindingIndex: 11 } },\r\n        Light12: { binding: { groupIndex: 1, bindingIndex: 12 } },\r\n        Light13: { binding: { groupIndex: 1, bindingIndex: 13 } },\r\n        Light14: { binding: { groupIndex: 1, bindingIndex: 14 } },\r\n        Light15: { binding: { groupIndex: 1, bindingIndex: 15 } },\r\n        Light16: { binding: { groupIndex: 1, bindingIndex: 16 } },\r\n        Light17: { binding: { groupIndex: 1, bindingIndex: 17 } },\r\n        Light18: { binding: { groupIndex: 1, bindingIndex: 18 } },\r\n        Light19: { binding: { groupIndex: 1, bindingIndex: 19 } },\r\n        Light20: { binding: { groupIndex: 1, bindingIndex: 20 } },\r\n        Light21: { binding: { groupIndex: 1, bindingIndex: 21 } },\r\n        Light22: { binding: { groupIndex: 1, bindingIndex: 22 } },\r\n        Light23: { binding: { groupIndex: 1, bindingIndex: 23 } },\r\n        Light24: { binding: { groupIndex: 1, bindingIndex: 24 } },\r\n        Light25: { binding: { groupIndex: 1, bindingIndex: 25 } },\r\n        Light26: { binding: { groupIndex: 1, bindingIndex: 26 } },\r\n        Light27: { binding: { groupIndex: 1, bindingIndex: 27 } },\r\n        Light28: { binding: { groupIndex: 1, bindingIndex: 28 } },\r\n        Light29: { binding: { groupIndex: 1, bindingIndex: 29 } },\r\n        Light30: { binding: { groupIndex: 1, bindingIndex: 30 } },\r\n        Light31: { binding: { groupIndex: 1, bindingIndex: 31 } },\r\n\r\n        Material: { binding: { groupIndex: 2, bindingIndex: 0 } },\r\n        Mesh: { binding: { groupIndex: 2, bindingIndex: 1 } },\r\n        Internals: { binding: { groupIndex: 2, bindingIndex: 2 } },\r\n    };\r\n\r\n    public static get KnownUBOs() {\r\n        return WebGPUShaderProcessingContext._SimplifiedKnownBindings ? WebGPUShaderProcessingContext._SimplifiedKnownUBOs : WebGPUShaderProcessingContext._KnownUBOs;\r\n    }\r\n\r\n    public shaderLanguage: ShaderLanguage;\r\n\r\n    public uboNextBindingIndex: number;\r\n    public freeGroupIndex: number;\r\n    public freeBindingIndex: number;\r\n\r\n    public availableVaryings: { [key: string]: number };\r\n    public availableAttributes: { [key: string]: number };\r\n    public availableBuffers: { [key: string]: WebGPUBufferDescription };\r\n    public availableTextures: { [key: string]: WebGPUTextureDescription };\r\n    public availableSamplers: { [key: string]: WebGPUSamplerDescription };\r\n\r\n    public leftOverUniforms: { name: string; type: string; length: number }[];\r\n\r\n    public orderedAttributes: string[];\r\n    public bindGroupLayoutEntries: GPUBindGroupLayoutEntry[][];\r\n    public bindGroupLayoutEntryInfo: WebGPUBindGroupLayoutEntryInfo[][];\r\n    public bindGroupEntries: GPUBindGroupEntry[][];\r\n    public bufferNames: string[]; // list of all uniform/storage buffer names used in the shader\r\n    public textureNames: string[]; // list of all texture names used in the shader\r\n    public samplerNames: string[]; // list of all sampler names used in the shader\r\n    public attributeNamesFromEffect: string[];\r\n    public attributeLocationsFromEffect: number[];\r\n\r\n    public vertexBufferKindToNumberOfComponents: { [kind: string]: number } = {};\r\n\r\n    private _attributeNextLocation: number;\r\n    private _varyingNextLocation: number;\r\n\r\n    constructor(shaderLanguage: ShaderLanguage, pureMode = false) {\r\n        this.shaderLanguage = shaderLanguage;\r\n\r\n        this._attributeNextLocation = 0;\r\n        this._varyingNextLocation = 0;\r\n        this.freeGroupIndex = 0;\r\n        this.freeBindingIndex = 0;\r\n\r\n        this.availableVaryings = {};\r\n        this.availableAttributes = {};\r\n        this.availableBuffers = {};\r\n        this.availableTextures = {};\r\n        this.availableSamplers = {};\r\n\r\n        this.orderedAttributes = [];\r\n        this.bindGroupLayoutEntries = [];\r\n        this.bindGroupLayoutEntryInfo = [];\r\n        this.bindGroupEntries = [];\r\n        this.bufferNames = [];\r\n        this.textureNames = [];\r\n        this.samplerNames = [];\r\n\r\n        this.leftOverUniforms = [];\r\n\r\n        if (!pureMode) {\r\n            this._findStartingGroupBinding();\r\n        }\r\n    }\r\n\r\n    private _findStartingGroupBinding(): void {\r\n        const knownUBOs = WebGPUShaderProcessingContext.KnownUBOs;\r\n\r\n        const groups: number[] = [];\r\n        for (const name in knownUBOs) {\r\n            const binding = knownUBOs[name].binding;\r\n            if (binding.groupIndex === -1) {\r\n                continue;\r\n            }\r\n            if (groups[binding.groupIndex] === undefined) {\r\n                groups[binding.groupIndex] = binding.bindingIndex;\r\n            } else {\r\n                groups[binding.groupIndex] = Math.max(groups[binding.groupIndex], binding.bindingIndex);\r\n            }\r\n        }\r\n\r\n        this.freeGroupIndex = groups.length - 1;\r\n        if (this.freeGroupIndex === 0) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        } else {\r\n            this.freeBindingIndex = groups[groups.length - 1] + 1;\r\n        }\r\n    }\r\n\r\n    public getAttributeNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._attributeNextLocation;\r\n\r\n        this._attributeNextLocation += (TypeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getVaryingNextLocation(dataType: string, arrayLength: number = 0): number {\r\n        const index = this._varyingNextLocation;\r\n\r\n        this._varyingNextLocation += (TypeToLocationSize[dataType] ?? 1) * (arrayLength || 1);\r\n\r\n        return index;\r\n    }\r\n\r\n    public getNextFreeUBOBinding() {\r\n        return this._getNextFreeBinding(1);\r\n    }\r\n\r\n    private _getNextFreeBinding(bindingCount: number) {\r\n        if (this.freeBindingIndex > MaxBindingsPerGroup - bindingCount) {\r\n            this.freeGroupIndex++;\r\n            this.freeBindingIndex = 0;\r\n        }\r\n\r\n        if (this.freeGroupIndex === MaxGroups) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Too many textures or UBOs have been declared and it is not supported in WebGPU.\";\r\n        }\r\n\r\n        const returnValue = {\r\n            groupIndex: this.freeGroupIndex,\r\n            bindingIndex: this.freeBindingIndex,\r\n        };\r\n\r\n        this.freeBindingIndex += bindingCount;\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Injects code at the beginning and/or end of a function.\r\n * The function is identified by \"mainFuncDecl\". The starting code is injected just after the first \"\\{\" found after the mainFuncDecl.\r\n * The ending code is injected just before the last \"\\}\" of the whole block of code (so, it is assumed that the function is the last of the block of code).\r\n * @param code code to inject into\r\n * @param mainFuncDecl Function declaration to find in the code (for eg: \"void main\")\r\n * @param startingCode The code to inject at the beginning of the function\r\n * @param endingCode The code to inject at the end of the function\r\n * @returns The code with the injected code\r\n */\r\nexport function InjectStartingAndEndingCode(code: string, mainFuncDecl: string, startingCode?: string, endingCode?: string): string {\r\n    let idx = code.indexOf(mainFuncDecl);\r\n    if (idx < 0) {\r\n        return code;\r\n    }\r\n    if (startingCode) {\r\n        // eslint-disable-next-line no-empty\r\n        while (idx++ < code.length && code.charAt(idx) != \"{\") {}\r\n        if (idx < code.length) {\r\n            const part1 = code.substring(0, idx + 1);\r\n            const part2 = code.substring(idx + 1);\r\n            code = part1 + startingCode + part2;\r\n        }\r\n    }\r\n\r\n    if (endingCode) {\r\n        const lastClosingCurly = code.lastIndexOf(\"}\");\r\n        code = code.substring(0, lastClosingCurly);\r\n        code += endingCode + \"\\n}\";\r\n    }\r\n\r\n    return code;\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport { InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { Constants } from \"../constants\";\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n    protected _vertexIsGLES3: boolean = false;\r\n    protected _fragmentIsGLES3: boolean = false;\r\n\r\n    public override shaderLanguage = ShaderLanguage.GLSL;\r\n    public parseGLES3 = true;\r\n    public attributeKeywordName: string | undefined;\r\n    public varyingVertexKeywordName: string | undefined;\r\n    public varyingFragmentKeywordName: string | undefined;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substring(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<_IShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n        this.attributeKeywordName = undefined;\r\n        this.varyingVertexKeywordName = undefined;\r\n        this.varyingFragmentKeywordName = undefined;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\r\n        const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\r\n\r\n        if (isFragment) {\r\n            this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n            if (this._fragmentIsGLES3) {\r\n                this.varyingFragmentKeywordName = \"in\";\r\n            }\r\n            return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n\r\n        this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n        if (this._vertexIsGLES3) {\r\n            this.attributeKeywordName = \"in\";\r\n            this.varyingVertexKeywordName = \"out\";\r\n        }\r\n        return alreadyInjected ? code : ubDeclaration + code;\r\n    }\r\n\r\n    public varyingCheck(varying: string, isFragment: boolean) {\r\n        const outRegex = /(flat\\s)?\\s*\\bout\\b/;\r\n        const inRegex = /(flat\\s)?\\s*\\bin\\b/;\r\n        const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n        const match = regex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationQualifier = match[1] ?? \"\";\r\n            const varyingType = match[2];\r\n            const name = match[3];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(\r\n                match[0],\r\n                location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`\r\n            );\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\r\n        const match = regex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType = numComponents < 0 ? (numComponents === -1 ? \"int\" : \"ivec\" + -numComponents) : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\r\n                const newName = `_int_${name}_`;\r\n\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\r\n            } else {\r\n                attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n            }\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match !== null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + Constants.AUTOSAMPLERSUFFIX;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substring(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                      ? WebGPUConstants.TextureSampleType.Uint\r\n                      : componentType === \"i\"\r\n                        ? WebGPUConstants.TextureSampleType.Sint\r\n                        : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match !== null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        defines: string[],\r\n        isFragment: boolean,\r\n        _processingContext: Nullable<_IShaderProcessingContext>,\r\n        _parameters?: { [key: string]: number | string | boolean | undefined }\r\n    ): string {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord_ = gl_FragCoord;\r\n                if (yFactor_ == 1.) {\r\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\r\n            const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\r\n            if (!this._fragmentIsGLES3) {\r\n                code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            } else {\r\n                const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\r\n                if (match !== null) {\r\n                    code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\r\n                }\r\n            }\r\n            code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = InjectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor_;\\n\";\r\n            // isNDCHalfZRange is always true in WebGPU\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match !== null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { _IShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { RemoveComments, InjectStartingAndEndingCode } from \"../../Misc/codeStringParsingTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport { Constants } from \"../constants\";\r\n\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex\";\r\nimport \"../../ShadersWGSL/ShadersInclude/helperFunctions\";\r\nimport \"../../ShadersWGSL/ShadersInclude/fresnelFunction\";\r\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration\";\r\nimport \"../../ShadersWGSL/ShadersInclude/decalFragment\";\r\n\r\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\r\n\r\nconst leftOverVarName = \"uniforms\";\r\nconst internalsVarName = \"internals\";\r\n\r\nconst gpuTextureViewDimensionByWebGPUTextureFunction: { [key: string]: Nullable<GPUTextureViewDimension> } = {\r\n    texture_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\r\n    texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\r\n    texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\r\n    texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\r\n    texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\r\n    texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\r\n    texture_external: null,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\r\n    protected _attributesInputWGSL: string[];\r\n    protected _attributesWGSL: string[];\r\n    protected _attributesConversionCodeWGSL: string[];\r\n    protected _hasNonFloatAttribute: boolean;\r\n    protected _varyingsWGSL: string[];\r\n    protected _varyingNamesWGSL: string[];\r\n    protected _stridedUniformArrays: string[];\r\n\r\n    public override shaderLanguage = ShaderLanguage.WGSL;\r\n    public uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\r\n    public textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\r\n    public noPrecision = true;\r\n    public pureMode = false;\r\n\r\n    protected _getArraySize(name: string, uniformType: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n\r\n        const endArray = uniformType.lastIndexOf(\">\");\r\n        if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\r\n            let startArray = endArray;\r\n            while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\r\n                startArray--;\r\n            }\r\n            const lengthInString = uniformType.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\r\n                startArray--;\r\n            }\r\n            uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\r\n        }\r\n\r\n        return [name, uniformType, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<_IShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._attributesInputWGSL = [];\r\n        this._attributesWGSL = [];\r\n        this._attributesConversionCodeWGSL = [];\r\n        this._hasNonFloatAttribute = false;\r\n        this._varyingsWGSL = [];\r\n        this._varyingNamesWGSL = [];\r\n        this._stridedUniformArrays = [];\r\n    }\r\n\r\n    public preProcessShaderCode(code: string): string {\r\n        // Same check as in webgpuShaderProcessorsGLSL to avoid same ubDelcaration to be injected twice.\r\n        const ubDeclaration = this.pureMode\r\n            ? \"\"\r\n            : `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n`;\r\n        const alreadyInjected = code.indexOf(ubDeclaration) !== -1;\r\n        return alreadyInjected ? code : ubDeclaration + RemoveComments(code);\r\n    }\r\n\r\n    public varyingCheck(varying: string): boolean {\r\n        const regex = /(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*\\bvarying\\b/;\r\n\r\n        return regex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        const varyingRegex = /\\s*(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = varyingRegex.exec(varying);\r\n        if (match !== null) {\r\n            const interpolationType = match[1] ?? \"perspective\";\r\n            const interpolationSampling = match[2] ?? \"center\";\r\n            const varyingType = match[4];\r\n            const name = match[3];\r\n            const interpolation = interpolationType === \"flat\" ? `@interpolate(${interpolationType})` : `@interpolate(${interpolationType}, ${interpolationSampling})`;\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._varyingsWGSL.push(`  @location(${location}) ${interpolation} ${name} : ${varyingType},`);\r\n                this._varyingNamesWGSL.push(name);\r\n            }\r\n\r\n            varying = \"\";\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\r\n        const match = attribRegex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[2];\r\n            const name = match[1];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            const numComponents = this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[name];\r\n            if (numComponents !== undefined) {\r\n                // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\r\n                const newType =\r\n                    numComponents < 0 ? (numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\") : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\r\n                const newName = `_int_${name}_`;\r\n\r\n                this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\r\n                this._hasNonFloatAttribute = true;\r\n            } else {\r\n                this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\r\n                this._attributesWGSL.push(`${name} : ${attributeType},`);\r\n                this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\r\n            }\r\n            attribute = \"\";\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.uniformRegexp.exec(uniform);\r\n        if (match !== null) {\r\n            const uniformType = match[2];\r\n            const name = match[1];\r\n\r\n            this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n\r\n            uniform = \"\";\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public textureProcessor(texture: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        const match = this.textureRegexp.exec(texture);\r\n        if (match !== null) {\r\n            const name = match[1]; // name of the variable\r\n            const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\r\n            const isArrayOfTexture = !!match[3];\r\n            const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\r\n            const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\r\n            const componentType = match[6]; // f32 or i32 or u32 or undefined\r\n            const storageTextureFormat = isStorageTexture ? (componentType.substring(0, componentType.indexOf(\",\")).trim() as GPUTextureFormat) : null;\r\n\r\n            let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\r\n            let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n            if (!textureInfo) {\r\n                textureInfo = {\r\n                    isTextureArray: arraySize > 0,\r\n                    isStorageTexture,\r\n                    textures: [],\r\n                    sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                };\r\n                arraySize = arraySize || 1;\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                }\r\n            } else {\r\n                arraySize = textureInfo.textures.length;\r\n            }\r\n\r\n            this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n\r\n            const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\r\n            const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\r\n            const sampleType = isDepthTexture\r\n                ? WebGPUConstants.TextureSampleType.Depth\r\n                : componentType === \"u32\"\r\n                  ? WebGPUConstants.TextureSampleType.Uint\r\n                  : componentType === \"i32\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n            textureInfo.sampleType = sampleType;\r\n\r\n            if (textureDimension === undefined) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\r\n            }\r\n\r\n            for (let i = 0; i < arraySize; ++i) {\r\n                const { groupIndex, bindingIndex } = textureInfo.textures[i];\r\n\r\n                if (i === 0) {\r\n                    texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\r\n                }\r\n\r\n                this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _convertDefinesToConst(preProcessors: { [key: string]: string }) {\r\n        let code = \"\";\r\n        for (const key in preProcessors) {\r\n            const value = preProcessors[key];\r\n            if (key.startsWith(\"__\")) {\r\n                continue;\r\n            }\r\n            if (!isNaN(parseInt(value)) || !isNaN(parseFloat(value))) {\r\n                code += `const ${key} = ${value};\\n`;\r\n            } else if (key && value === \"\") {\r\n                code += `const ${key} = true;\\n`;\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        _defines: string[],\r\n        _isFragment: boolean,\r\n        _processingContext: Nullable<_IShaderProcessingContext>,\r\n        _parameters: {\r\n            [key: string]: number | string | boolean | undefined;\r\n        },\r\n        preProcessors: { [key: string]: string },\r\n        preProcessorsFromCode: { [key: string]: string }\r\n    ) {\r\n        // Collect the preprocessor names (coming from a \"#define NAME VALUE\" declaration) directly defined in the shader code (preProcessorsFromCode) and not defined at the material level (preProcessors).\r\n        // This is because we will have to perform a replace on the code to replace the defines with their values.\r\n        //\r\n        // We don't have to do it for preprocessor names defined at the material level because replacing them by \"const NAME = VALUE;\" will take care of it (see _convertDefinesToConst()) and is faster than doing a search/replace for each of them.\r\n        //\r\n        // The reason why doing \"const NAME = VALUE;\" doesn't work for preprocessor names defined in the code is that VALUE can be any string and not only numbers or booleans.\r\n        // So, if we have this code:\r\n        //\r\n        //      #define vDiffuseUV vMainUV\r\n        //      textureSample(..., fragmentInputs.vDiffuseUV)\r\n        ///\r\n        // only a search/replace will work, 'const vDiffuseUV = \"vMainUV\";' will not work\r\n        //\r\n        // Note that the search/replace text processing will also apply to the \"#define NAME VALUE\" definition itself, so it will become \"#define VALUE VALUE\"\r\n        // It's not a problem, though, because all #define XXX will be commented out in the final code.\r\n        const defineList: string[] = [];\r\n\r\n        for (const key in preProcessorsFromCode) {\r\n            const value = preProcessorsFromCode[key];\r\n\r\n            // Excludes the defines that are booleans (note that there aren't \"false\" booleans: we simply don't add them in the preProcessorsFromCode object).\r\n            // That's because we need (at least some of) them to stay untouched, like #define DISABLE_UNIFORMTY_ANALYSIS or #define CUSTOM_VERTEX_BEGIN (else, they would be replaced with \"#define true\" after the search/replace processing)\r\n            if (value !== \"true\") {\r\n                defineList.push(key);\r\n            }\r\n        }\r\n\r\n        // We must sort the define names by length to avoid replacing a define with a longer name (ex: #define A 1 and #define AB 2, if we replace A with 1, we will have #define 1B 2)\r\n        // So, we start by longest names and we finish with the shortest ones.\r\n        defineList.sort((a, b) => (a.length - b.length > 0 ? -1 : a.length === b.length ? 0 : 1));\r\n\r\n        for (const name of defineList) {\r\n            // Let's retrieve the value of the define from the code\r\n            // Note that we can't use the value from preProcessorsFromCode[name] because this value could have been changed from a previous replace\r\n            // For example:\r\n            //      #define IOR 1.333\r\n            //      #define ETA 1.0/IOR\r\n            //\r\n            // After IOR replacement is performed, we will have:\r\n            //      #define 1.333 1.333\r\n            //      #define ETA 1.0/1.333\r\n            //\r\n            // but preProcessorsFromCode[\"ETA\"] is still \"1.0/IOR\" and not \"1.0/1.333\", so we must retrieve the value for ETA from the current code\r\n            const i0 = code.indexOf(\"#define \" + name);\r\n\r\n            let i1 = code.indexOf(\"\\n\", i0);\r\n            if (i1 === -1) {\r\n                i1 = code.length;\r\n            }\r\n\r\n            const value = code.substring(i0 + 8 + name.length + 1, i1);\r\n\r\n            code = code.replace(new RegExp(name, \"g\"), value);\r\n        }\r\n\r\n        code = this._convertDefinesToConst(preProcessors) + code;\r\n\r\n        return code;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        const enabledExtensions: string[] = [];\r\n\r\n        const fragCoordCode =\r\n            fragmentCode.indexOf(\"fragmentInputs.position\") >= 0 && !this.pureMode\r\n                ? `\r\n            if (internals.yFactor_ == 1.) {\r\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\r\n            }\r\n        `\r\n                : \"\";\r\n\r\n        // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\r\n        vertexCode = this._processSamplers(vertexCode, true);\r\n        fragmentCode = this._processSamplers(fragmentCode, false);\r\n\r\n        // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\r\n        vertexCode = this._processCustomBuffers(vertexCode, true);\r\n        fragmentCode = this._processCustomBuffers(fragmentCode, false);\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        // Vertex code\r\n        vertexCode = vertexCode.replace(/#define /g, \"//#define \");\r\n        vertexCode = this._processStridedUniformArrays(vertexCode);\r\n\r\n        let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\r\n        if (this._attributesInputWGSL.length > 0) {\r\n            vertexInputs += this._attributesInputWGSL.join(\"\\n\");\r\n        }\r\n        vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\r\n            vertexInputs += this._attributesWGSL.join(\"\\n\");\r\n            vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\r\n        }\r\n\r\n        let vertexOutputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            vertexOutputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\r\n\r\n        vertexCode = vertexInputs + vertexOutputs + vertexCode;\r\n\r\n        let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\r\n        if (this._hasNonFloatAttribute) {\r\n            vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\r\n            vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\r\n            vertexMainStartingCode += \"\\n\";\r\n        }\r\n        const vertexMainEndingCode = this.pureMode\r\n            ? `  return vertexOutputs;`\r\n            : `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\r\n        let needDiagnosticOff = vertexCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        vertexCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") +\r\n            \"diagnostic(off, chromium.unreachable_code);\\n\" +\r\n            InjectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\r\n\r\n        // fragment code\r\n        fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\r\n        fragmentCode = this._processStridedUniformArrays(fragmentCode);\r\n        if (!this.pureMode) {\r\n            fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\r\n        }\r\n\r\n        let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\r\n        if (this._varyingsWGSL.length > 0) {\r\n            fragmentInputs += this._varyingsWGSL.join(\"\\n\");\r\n        }\r\n        fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\r\n\r\n        let fragmentOutputs = \"struct FragmentOutputs {\\n\";\r\n\r\n        // Adding fragData output locations\r\n        const regexRoot = \"fragmentOutputs\\\\.fragData\";\r\n        let match = fragmentCode.match(new RegExp(regexRoot + \"0\", \"g\"));\r\n        let indexLocation = 0;\r\n\r\n        if (match) {\r\n            fragmentOutputs += ` @location(${indexLocation}) fragData0 : vec4<f32>,\\n`;\r\n            indexLocation++;\r\n            for (let index = 1; index < 8; index++) {\r\n                match = fragmentCode.match(new RegExp(regexRoot + index, \"g\"));\r\n                if (match) {\r\n                    fragmentOutputs += ` @location(${indexLocation}) fragData${indexLocation} : vec4<f32>,\\n`;\r\n                    indexLocation++;\r\n                }\r\n            }\r\n            if (fragmentCode.indexOf(\"MRT_AND_COLOR\") !== -1) {\r\n                fragmentOutputs += `  @location(${indexLocation}) color : vec4<f32>,\\n`;\r\n                indexLocation++;\r\n            }\r\n        }\r\n\r\n        // Adding fragData output locations\r\n        const regex = /oitDepthSampler/;\r\n        match = fragmentCode.match(regex);\r\n\r\n        if (match) {\r\n            fragmentOutputs += ` @location(${indexLocation++}) depth : vec2<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) frontColor : vec4<f32>,\\n`;\r\n            fragmentOutputs += ` @location(${indexLocation++}) backColor : vec4<f32>,\\n`;\r\n        }\r\n\r\n        if (indexLocation === 0) {\r\n            const useDualSourceBlending = fragmentCode.indexOf(\"DUAL_SOURCE_BLENDING\") !== -1;\r\n\r\n            if (useDualSourceBlending) {\r\n                enabledExtensions.push(\"dual_source_blending\");\r\n\r\n                fragmentOutputs += \"  @location(0) @blend_src(0) color : vec4<f32>,\\n\";\r\n                fragmentOutputs += \"  @location(0) @blend_src(1) color2 : vec4<f32>,\\n\";\r\n            } else {\r\n                fragmentOutputs += \"  @location(0) color : vec4<f32>,\\n\";\r\n            }\r\n            indexLocation++;\r\n        }\r\n\r\n        // FragDepth\r\n        let hasFragDepth = false;\r\n        let idx = 0;\r\n        while (!hasFragDepth) {\r\n            idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\r\n            if (idx < 0) {\r\n                break;\r\n            }\r\n            const saveIndex = idx;\r\n            hasFragDepth = true;\r\n            while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\r\n                if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\r\n                    hasFragDepth = false;\r\n                    break;\r\n                }\r\n                idx--;\r\n            }\r\n            idx = saveIndex + builtInName_frag_depth.length;\r\n        }\r\n\r\n        if (hasFragDepth) {\r\n            fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\r\n        }\r\n\r\n        fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\r\n\r\n        fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\r\n\r\n        const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\r\n        const fragmentEndingCode = \"  return fragmentOutputs;\";\r\n        needDiagnosticOff = fragmentCode.indexOf(Constants.DISABLEUA) !== -1;\r\n\r\n        if (enabledExtensions.length > 0) {\r\n            fragmentCode = \"enable \" + enabledExtensions.join(\";\\nenable \") + \";\\n\" + fragmentCode;\r\n        }\r\n\r\n        fragmentCode =\r\n            (needDiagnosticOff ? \"diagnostic(off, derivative_uniformity);\\n\" : \"\") +\r\n            \"diagnostic(off, chromium.unreachable_code);\\n\" +\r\n            InjectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents = {};\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let stridedArrays = \"\";\r\n        let ubo = `struct ${name} {\\n`;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\r\n            const size = WebGPUShaderProcessor.UniformSizes[type];\r\n\r\n            if (leftOverUniform.length > 0) {\r\n                if (size <= 2) {\r\n                    const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\r\n                    stridedArrays += `struct ${stridedArrayType} {\r\n                        @size(16)\r\n                        el: ${type},\r\n                    }`;\r\n                    this._stridedUniformArrays.push(leftOverUniform.name);\r\n\r\n                    ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\r\n                } else {\r\n                    ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\r\n                }\r\n            } else {\r\n                ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\";\r\n        ubo = `${stridedArrays}\\n${ubo}`;\r\n        ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\r\n\r\n        return ubo;\r\n    }\r\n\r\n    private _processSamplers(code: string, isVertex: boolean): string {\r\n        const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = samplerRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const name = match[1]; // name of the variable\r\n            const samplerType = match[2]; // sampler or sampler_comparison\r\n            const suffixLessLength = name.length - Constants.AUTOSAMPLERSUFFIX.length;\r\n            const textureName = name.lastIndexOf(Constants.AUTOSAMPLERSUFFIX) === suffixLessLength ? name.substring(0, suffixLessLength) : null;\r\n            const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n            if (textureName) {\r\n                const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\r\n                if (textureInfo) {\r\n                    textureInfo.autoBindSampler = true;\r\n                }\r\n            }\r\n\r\n            let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\r\n            if (!samplerInfo) {\r\n                samplerInfo = {\r\n                    binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                    type: samplerBindingType,\r\n                };\r\n                this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\r\n            }\r\n\r\n            this._addSamplerBindingDescription(name, samplerInfo, isVertex);\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            samplerRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processCustomBuffers(code: string, isVertex: boolean): string {\r\n        const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const match = instantiateBufferRegexp.exec(code);\r\n            if (match === null) {\r\n                break;\r\n            }\r\n\r\n            const type = match[1];\r\n            const decoration = match[3];\r\n            let name = match[4];\r\n            const structName = match[5];\r\n\r\n            let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!bufferInfo) {\r\n                const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\r\n\r\n                let binding;\r\n                if (knownUBO) {\r\n                    name = structName;\r\n                    binding = knownUBO.binding;\r\n                    if (binding.groupIndex === -1) {\r\n                        binding = this._webgpuProcessingContext.availableBuffers[name]?.binding;\r\n                        if (!binding) {\r\n                            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                        }\r\n                    }\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                bufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(\r\n                name,\r\n                this._webgpuProcessingContext.availableBuffers[name],\r\n                decoration === \"read_write\"\r\n                    ? WebGPUConstants.BufferBindingType.Storage\r\n                    : type === \"storage\"\r\n                      ? WebGPUConstants.BufferBindingType.ReadOnlyStorage\r\n                      : WebGPUConstants.BufferBindingType.Uniform,\r\n                isVertex\r\n            );\r\n\r\n            const groupIndex = bufferInfo.binding.groupIndex;\r\n            const bindingIndex = bufferInfo.binding.bindingIndex;\r\n\r\n            const part1 = code.substring(0, match.index);\r\n            const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\r\n            const part2 = code.substring(match.index);\r\n\r\n            code = part1 + insertPart + part2;\r\n\r\n            instantiateBufferRegexp.lastIndex += insertPart.length;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _processStridedUniformArrays(code: string): string {\r\n        for (const uniformArrayName of this._stridedUniformArrays) {\r\n            code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*?)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\r\n        }\r\n        return code;\r\n    }\r\n}\r\n", "/* eslint-disable jsdoc/require-jsdoc */\r\n/* eslint-disable babylonjs/available */\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport { ILog2 } from \"../../Maths/math.scalar.functions\";\r\nimport type { Nullable } from \"../../types\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n\r\n/** @internal */\r\nexport class WebGPUHardwareTexture implements IHardwareTextureWrapper {\r\n    /**\r\n     * Cache of RenderPassDescriptor and BindGroup used when generating mipmaps (see WebGPUTextureHelper.generateMipmaps)\r\n     * @internal\r\n     */\r\n    public _mipmapGenRenderPassDescr: GPURenderPassDescriptor[][];\r\n    /** @internal */\r\n    public _mipmapGenBindGroup: GPUBindGroup[][];\r\n\r\n    /**\r\n     * Cache for the invertYPreMultiplyAlpha function (see WebGPUTextureHelper)\r\n     * @internal\r\n     */\r\n    public _copyInvertYTempTexture?: GPUTexture;\r\n    /** @internal */\r\n    public _copyInvertYRenderPassDescr: GPURenderPassDescriptor;\r\n    /** @internal */\r\n    public _copyInvertYBindGroup: GPUBindGroup;\r\n    /** @internal */\r\n    public _copyInvertYBindGroupWithOfst: GPUBindGroup;\r\n\r\n    /** @internal */\r\n    public _originalFormatIsRGB = false;\r\n\r\n    private _webgpuTexture: Nullable<GPUTexture>;\r\n    // There can be multiple MSAA textures for a single WebGPU texture because different layers of a 2DArrayTexture / 3DTexture\r\n    // or different faces of a cube texture can be bound to different render targets at the same time (in a multi RenderTargetWrapper)\r\n    private _webgpuMSAATexture: Nullable<GPUTexture[]>;\r\n\r\n    public get underlyingResource(): Nullable<GPUTexture> {\r\n        return this._webgpuTexture;\r\n    }\r\n\r\n    public getMSAATexture(index: number): Nullable<GPUTexture> {\r\n        return this._webgpuMSAATexture?.[index] ?? null;\r\n    }\r\n\r\n    public setMSAATexture(texture: GPUTexture, index: number) {\r\n        if (!this._webgpuMSAATexture) {\r\n            this._webgpuMSAATexture = [];\r\n        }\r\n\r\n        this._webgpuMSAATexture[index] = texture;\r\n    }\r\n\r\n    public releaseMSAATexture(index?: number): void {\r\n        if (this._webgpuMSAATexture) {\r\n            if (index !== undefined) {\r\n                this._engine._textureHelper.releaseTexture(this._webgpuMSAATexture[index]);\r\n                delete this._webgpuMSAATexture[index];\r\n            } else {\r\n                for (const texture of this._webgpuMSAATexture) {\r\n                    this._engine._textureHelper.releaseTexture(texture);\r\n                }\r\n                this._webgpuMSAATexture = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public view: Nullable<GPUTextureView>;\r\n    public viewForWriting: Nullable<GPUTextureView>;\r\n    public format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    public textureUsages = 0;\r\n    public textureAdditionalUsages = 0;\r\n\r\n    constructor(\r\n        private _engine: WebGPUEngine,\r\n        existingTexture: Nullable<GPUTexture> = null\r\n    ) {\r\n        this._webgpuTexture = existingTexture;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public set(hardwareTexture: GPUTexture): void {\r\n        this._webgpuTexture = hardwareTexture;\r\n    }\r\n\r\n    public setUsage(_textureSource: number, generateMipMaps: boolean, is2DArray: boolean, isCube: boolean, is3D: boolean, width: number, height: number, depth: number): void {\r\n        let viewDimension: GPUTextureViewDimension = WebGPUConstants.TextureViewDimension.E2d;\r\n        let arrayLayerCount = 1;\r\n        if (isCube) {\r\n            viewDimension = is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n            arrayLayerCount = 6 * (depth || 1);\r\n        } else if (is3D) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E3d;\r\n            arrayLayerCount = 1;\r\n        } else if (is2DArray) {\r\n            viewDimension = WebGPUConstants.TextureViewDimension.E2dArray;\r\n            arrayLayerCount = depth;\r\n        }\r\n\r\n        const format = WebGPUTextureHelper.GetDepthFormatOnly(this.format);\r\n        const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(this.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n\r\n        this.createView({\r\n            label: `TextureView${is3D ? \"3D\" : isCube ? \"Cube\" : \"2D\"}${is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${generateMipMaps ? \"wmips\" : \"womips\"}_${\r\n                this.format\r\n            }_${viewDimension}`,\r\n            format,\r\n            dimension: viewDimension,\r\n            mipLevelCount: generateMipMaps ? ILog2(Math.max(width, height)) + 1 : 1,\r\n            baseArrayLayer: 0,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount,\r\n            aspect,\r\n        });\r\n    }\r\n\r\n    public createView(descriptor?: GPUTextureViewDescriptor, createViewForWriting = false): void {\r\n        this.view = this._webgpuTexture!.createView(descriptor);\r\n        if (createViewForWriting && descriptor) {\r\n            const saveNumMipMaps = descriptor.mipLevelCount;\r\n            descriptor.mipLevelCount = 1;\r\n            this.viewForWriting = this._webgpuTexture!.createView(descriptor);\r\n            descriptor.mipLevelCount = saveNumMipMaps;\r\n        }\r\n    }\r\n\r\n    public reset(): void {\r\n        this._webgpuTexture = null;\r\n        this._webgpuMSAATexture = null;\r\n        this.view = null;\r\n        this.viewForWriting = null;\r\n    }\r\n\r\n    public release(): void {\r\n        this._webgpuTexture?.destroy();\r\n        this.releaseMSAATexture();\r\n        this._copyInvertYTempTexture?.destroy();\r\n        this.reset();\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// License for the mipmap generation code:\r\n//\r\n// Copyright 2020 Brandon Jones\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IHardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport type { _IProcessingOptions } from \"../Processors/shaderProcessingOptions\";\r\nimport { ShaderLanguage } from \"core/Materials\";\r\nimport { Finalize, Initialize, Process } from \"../Processors/shaderProcessor\";\r\nimport type { WebGPUShaderProcessorWGSL } from \"./webgpuShaderProcessorsWGSL\";\r\n\r\n// TODO WEBGPU improve mipmap generation by using compute shaders\r\n\r\nconst mipmapVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.vTex = tex[input.vertexIndex];\r\n        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst mipmapFragmentSource = `\r\n    var imgSampler: sampler;\r\n    var img: texture_2d<f32>;\r\n\r\n    varying vTex: vec2f;\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = textureSample(img, imgSampler, input.vTex);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));\r\n\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        #ifdef INVERTY\r\n            vertexOutputs.vTextureSize = vec2f(textureDimensions(img, 0));\r\n        #endif\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(input.vTextureSize.y - input.position.y)), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\r\n    var img: texture_2d<f32>;\r\n    uniform ofstX: f32;\r\n    uniform ofstY: f32;\r\n    uniform width: f32;\r\n    uniform height: f32;\r\n\r\n    #ifdef INVERTY\r\n        varying vTextureSize: vec2f;\r\n    #endif\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        if (input.position.x < uniforms.ofstX || input.position.x >= uniforms.ofstX + uniforms.width) {\r\n            discard;\r\n        }\r\n        if (input.position.y < uniforms.ofstY || input.position.y >= uniforms.ofstY + uniforms.height) {\r\n            discard;\r\n        }\r\n    #ifdef INVERTY\r\n        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(uniforms.ofstY + uniforms.height - (input.position.y - uniforms.ofstY))), 0);\r\n    #else\r\n        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color = vec4f(color.rgb * color.a, color.a);\r\n    #endif\r\n        fragmentOutputs.color = color;\r\n    }\r\n    `;\r\n\r\nconst clearVertexSource = `\r\n    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));\r\n\r\n    @vertex\r\n    fn main(input : VertexInputs) -> FragmentInputs {\r\n        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst clearFragmentSource = `\r\n    uniform color: vec4f;\r\n\r\n\r\n    @fragment\r\n    fn main(input: FragmentInputs) -> FragmentOutputs {\r\n        fragmentOutputs.color = uniforms.color;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureVertexSource = `\r\n    struct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n        @location(0) fragUV : vec2<f32>\r\n    }\r\n\r\n    @vertex\r\n    fn main(\r\n        @builtin(vertex_index) VertexIndex : u32\r\n    ) -> VertexOutput {\r\n        var pos = array<vec2<f32>, 4>(\r\n            vec2(-1.0,  1.0),\r\n            vec2( 1.0,  1.0),\r\n            vec2(-1.0, -1.0),\r\n            vec2( 1.0, -1.0)\r\n        );\r\n        var tex = array<vec2<f32>, 4>(\r\n            vec2(0.0, 0.0),\r\n            vec2(1.0, 0.0),\r\n            vec2(0.0, 1.0),\r\n            vec2(1.0, 1.0)\r\n        );\r\n\r\n        var output: VertexOutput;\r\n\r\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        output.fragUV = tex[VertexIndex];\r\n\r\n        return output;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureInvertYFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\r\n    }\r\n    `;\r\n\r\nenum PipelineType {\r\n    MipMap = 0,\r\n    InvertYPremultiplyAlpha = 1,\r\n    Clear = 2,\r\n    InvertYPremultiplyAlphaWithOfst = 3,\r\n}\r\n\r\nenum VideoPipelineType {\r\n    DontInvertY = 0,\r\n    InvertY = 1,\r\n}\r\n\r\ninterface IPipelineParameters {\r\n    invertY?: boolean;\r\n    premultiplyAlpha?: boolean;\r\n}\r\n\r\nconst shadersForPipelineType = [\r\n    { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },\r\n    { vertex: clearVertexSource, fragment: clearFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource },\r\n];\r\n\r\n/**\r\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\r\n * The number of entries should not go over 64! Else, the code in WebGPUCacheRenderPipeline.setMRT should be updated\r\n */\r\nexport const renderableTextureFormatToIndex: { [name: string]: number } = {\r\n    \"\": 0,\r\n    r8unorm: 1,\r\n    r8uint: 2,\r\n    r8sint: 3,\r\n\r\n    r16uint: 4,\r\n    r16sint: 5,\r\n    r16float: 6,\r\n    rg8unorm: 7,\r\n    rg8uint: 8,\r\n    rg8sint: 9,\r\n\r\n    r32uint: 10,\r\n    r32sint: 11,\r\n    r32float: 12,\r\n    rg16uint: 13,\r\n    rg16sint: 14,\r\n    rg16float: 15,\r\n    rgba8unorm: 16,\r\n    \"rgba8unorm-srgb\": 17,\r\n    rgba8uint: 18,\r\n    rgba8sint: 19,\r\n    bgra8unorm: 20,\r\n    \"bgra8unorm-srgb\": 21,\r\n\r\n    rgb10a2uint: 22,\r\n    rgb10a2unorm: 23,\r\n    /* rg11b10ufloat: this entry is dynamically added if the \"RG11B10UFloatRenderable\" extension is supported */\r\n\r\n    rg32uint: 24,\r\n    rg32sint: 25,\r\n    rg32float: 26,\r\n    rgba16uint: 27,\r\n    rgba16sint: 28,\r\n    rgba16float: 29,\r\n\r\n    rgba32uint: 30,\r\n    rgba32sint: 31,\r\n    rgba32float: 32,\r\n\r\n    stencil8: 33,\r\n    depth16unorm: 34,\r\n    depth24plus: 35,\r\n    \"depth24plus-stencil8\": 36,\r\n    depth32float: 37,\r\n\r\n    \"depth32float-stencil8\": 38,\r\n\r\n    r16unorm: 39,\r\n    rg16unorm: 40,\r\n    rgba16unorm: 41,\r\n    r16snorm: 42,\r\n    rg16snorm: 43,\r\n    rgba16snorm: 44,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUTextureManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _mipmapSampler: GPUSampler;\r\n    private _videoSampler: GPUSampler;\r\n    private _ubCopyWithOfst: GPUBuffer;\r\n    private _pipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _compiledShaders: GPUShaderModule[][] = [];\r\n    private _videoPipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _videoCompiledShaders: GPUShaderModule[][] = [];\r\n    private _deferredReleaseTextures: Array<[Nullable<IHardwareTextureWrapper | GPUTexture>, Nullable<BaseTexture>]> = [];\r\n    private _commandEncoderForCreation: GPUCommandEncoder;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                         Initialization / Helpers\r\n    //------------------------------------------------------------------------------\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, enabledExtensions: GPUFeatureName[]) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        if (enabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) !== -1) {\r\n            const keys = Object.keys(renderableTextureFormatToIndex);\r\n            renderableTextureFormatToIndex[WebGPUConstants.TextureFormat.RG11B10UFloat] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;\r\n        }\r\n\r\n        this._mipmapSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._videoSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._ubCopyWithOfst = this._bufferManager.createBuffer(\r\n            4 * 4,\r\n            WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n            \"UBCopyWithOffset\"\r\n        ).underlyingResource;\r\n\r\n        this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n        this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n    }\r\n\r\n    private _getPipeline(format: GPUTextureFormat, type: PipelineType = PipelineType.MipMap, params?: IPipelineParameters): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index =\r\n            type === PipelineType.MipMap\r\n                ? 1 << 0\r\n                : type === PipelineType.InvertYPremultiplyAlpha\r\n                  ? ((params!.invertY ? 1 : 0) << 1) + ((params!.premultiplyAlpha ? 1 : 0) << 2)\r\n                  : type === PipelineType.Clear\r\n                    ? 1 << 3\r\n                    : type === PipelineType.InvertYPremultiplyAlphaWithOfst\r\n                      ? ((params!.invertY ? 1 : 0) << 4) + ((params!.premultiplyAlpha ? 1 : 0) << 5)\r\n                      : 0;\r\n\r\n        if (!this._pipelines[format]) {\r\n            this._pipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._pipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let defines = \"\";\r\n            if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\r\n                if (params!.invertY) {\r\n                    defines += \"#define INVERTY\\n\";\r\n                }\r\n                if (params!.premultiplyAlpha) {\r\n                    defines += \"#define PREMULTIPLYALPHA\\n\";\r\n                }\r\n            }\r\n\r\n            let modules = this._compiledShaders[index];\r\n            if (!modules) {\r\n                let vertexCode = shadersForPipelineType[type].vertex;\r\n                let fragmentCode = shadersForPipelineType[type].fragment;\r\n\r\n                const processorOptions: _IProcessingOptions = {\r\n                    defines: defines.split(\"\\n\"),\r\n                    indexParameters: null,\r\n                    isFragment: false,\r\n                    shouldUseHighPrecisionShader: true,\r\n                    processor: this._engine._getShaderProcessor(ShaderLanguage.WGSL),\r\n                    supportsUniformBuffers: true,\r\n                    shadersRepository: \"\",\r\n                    includesShadersStore: {},\r\n                    version: (this._engine.version * 100).toString(),\r\n                    platformName: this._engine.shaderPlatformName,\r\n                    processingContext: this._engine._getShaderProcessingContext(ShaderLanguage.WGSL, true),\r\n                    isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                };\r\n\r\n                Initialize(processorOptions);\r\n\r\n                // Disable special additions not needed here\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = true;\r\n\r\n                Process(\r\n                    vertexCode,\r\n                    processorOptions,\r\n                    (migratedVertexCode) => {\r\n                        vertexCode = migratedVertexCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                processorOptions.isFragment = true;\r\n\r\n                Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode) => {\r\n                        fragmentCode = migratedFragmentCode;\r\n                    },\r\n                    this._engine\r\n                );\r\n\r\n                const final = Finalize(vertexCode, fragmentCode, processorOptions);\r\n\r\n                // Restore\r\n                (processorOptions.processor as WebGPUShaderProcessorWGSL).pureMode = false;\r\n\r\n                const vertexModule = this._device.createShaderModule({\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVertexShader_${index}`,\r\n                    code: final.vertexCode,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalFragmentShader_${index}`,\r\n                    code: final.fragmentCode,\r\n                });\r\n                modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalPipeline_${format}_${index}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private _getVideoPipeline(format: GPUTextureFormat, type: VideoPipelineType = VideoPipelineType.DontInvertY): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\r\n\r\n        if (!this._videoPipelines[format]) {\r\n            this._videoPipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._videoPipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let modules = this._videoCompiledShaders[index];\r\n            if (!modules) {\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: copyVideoToTextureVertexSource,\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_VertexShader`,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_FragmentShader_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                });\r\n                modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_InternalVideoPipeline_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    public setCommandEncoder(encoder: GPUCommandEncoder): void {\r\n        this._commandEncoderForCreation = encoder;\r\n    }\r\n\r\n    public copyVideoToTexture(video: ExternalTexture, texture: InternalTexture, format: GPUTextureFormat, invertY = false, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\r\n\r\n        const webgpuHardwareTexture = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}${texture.label ? \"_\" + texture.label : \"\"}`,\r\n            colorAttachments: [\r\n                {\r\n                    view: webgpuHardwareTexture.underlyingResource!.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.All,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: this._videoSampler,\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: this._device.importExternalTexture({\r\n                        source: video.underlyingResource,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public invertYPreMultiplyAlpha(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        faceIndex = 0,\r\n        mipLevel = 0,\r\n        layers = 1,\r\n        ofstX = 0,\r\n        ofstY = 0,\r\n        rectWidth = 0,\r\n        rectHeight = 0,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const useRect = rectWidth !== 0;\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\r\n            invertY,\r\n            premultiplyAlpha,\r\n        });\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\r\n                // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\r\n                gpuOrHdwTexture = undefined as any;\r\n            }\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        if (useRect) {\r\n            this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        const outputTexture =\r\n            webgpuHardwareTexture?._copyInvertYTempTexture ??\r\n            this.createTexture(\r\n                { width, height, layers: 1 },\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                format,\r\n                1,\r\n                commandEncoder,\r\n                WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding,\r\n                undefined,\r\n                \"TempTextureForCopyWithInvertY\"\r\n            );\r\n\r\n        const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}_${\r\n                premultiplyAlpha ? \"PremultiplyAlpha\" : \"DontPremultiplyAlpha\"\r\n            }`,\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        baseMipLevel: 0,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                        baseArrayLayer: 0,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\r\n        if (!bindGroup) {\r\n            const descriptor: GPUBindGroupDescriptor = {\r\n                layout: bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: mipLevel,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: layers,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                    },\r\n                ],\r\n            };\r\n            if (useRect) {\r\n                descriptor.entries.push({\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this._ubCopyWithOfst,\r\n                    },\r\n                });\r\n            }\r\n            bindGroup = this._device.createBindGroup(descriptor);\r\n        }\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.copyTextureToTexture(\r\n            {\r\n                texture: outputTexture,\r\n            },\r\n            {\r\n                texture: gpuTexture,\r\n                mipLevel,\r\n                origin: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    z: faceIndex,\r\n                },\r\n            },\r\n            {\r\n                width: rectWidth || width,\r\n                height: rectHeight || height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        if (webgpuHardwareTexture) {\r\n            webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\r\n            webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\r\n            if (useRect) {\r\n                webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\r\n            } else {\r\n                webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\r\n            }\r\n        } else {\r\n            this._deferredReleaseTextures.push([outputTexture, null]);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                               Creation\r\n    //------------------------------------------------------------------------------\r\n\r\n    public createTexture(\r\n        imageBitmap: ImageBitmap | { width: number; height: number; layers: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        is3D = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const layerCount = (imageBitmap as any).layers || 1;\r\n        const textureSize = {\r\n            width: imageBitmap.width,\r\n            height: imageBitmap.height,\r\n            depthOrArrayLayers: layerCount,\r\n        };\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat && !is3D) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? \"3D\" : \"2D\"}_${label ? label + \"_\" : \"\"}${textureSize.width}x${textureSize.height}x${\r\n                textureSize.depthOrArrayLayers\r\n            }_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: textureSize,\r\n            dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n            this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, is3D, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public createCubeTexture(\r\n        imageBitmaps: ImageBitmap[] | { width: number; height: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\r\n        const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + \"_\" : \"\"}${width}x${height}x6_${\r\n                hasMipmaps ? \"wmips\" : \"womips\"\r\n            }_${format}_samples${sampleCount}`,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 6,\r\n            },\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\r\n            this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public generateCubeMipmaps(gpuTexture: GPUTexture | WebGPUHardwareTexture, format: GPUTextureFormat, mipLevelCount: number, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\r\n\r\n        for (let f = 0; f < 6; ++f) {\r\n            this.generateMipmaps(gpuTexture, format, mipLevelCount, f, false, commandEncoder);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public generateMipmaps(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        format: GPUTextureFormat,\r\n        mipLevelCount: number,\r\n        faceIndex = 0,\r\n        is3D = false,\r\n        commandEncoder?: GPUCommandEncoder\r\n    ): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format);\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\r\n            gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n        for (let i = 1; i < mipLevelCount; ++i) {\r\n            const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,\r\n                colorAttachments: [\r\n                    {\r\n                        view: gpuTexture.createView({\r\n                            format,\r\n                            dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: i,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: 1,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                        loadOp: WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    },\r\n                ],\r\n            };\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\r\n            }\r\n            const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n            const bindGroup =\r\n                webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ??\r\n                this._device.createBindGroup({\r\n                    layout: bindGroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: gpuTexture.createView({\r\n                                format,\r\n                                dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                                baseMipLevel: i - 1,\r\n                                mipLevelCount: 1,\r\n                                arrayLayerCount: 1,\r\n                                baseArrayLayer: faceIndex,\r\n                            }),\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: this._mipmapSampler,\r\n                        },\r\n                    ],\r\n                });\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\r\n            }\r\n\r\n            passEncoder.setPipeline(pipeline);\r\n            passEncoder.setBindGroup(0, bindGroup);\r\n            passEncoder.draw(4, 1, 0, 0);\r\n            passEncoder.end();\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public createGPUTextureForInternalTexture(\r\n        texture: InternalTexture,\r\n        width?: number,\r\n        height?: number,\r\n        depth?: number,\r\n        creationFlags?: number,\r\n        dontCreateMSAATexture?: boolean\r\n    ): WebGPUHardwareTexture {\r\n        if (!texture._hardwareTexture) {\r\n            texture._hardwareTexture = new WebGPUHardwareTexture(this._engine);\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = texture.width;\r\n        }\r\n        if (height === undefined) {\r\n            height = texture.height;\r\n        }\r\n        if (depth === undefined) {\r\n            depth = texture.depth;\r\n        }\r\n\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const isStorageTexture = ((creationFlags ?? 0) & Constants.TEXTURE_CREATIONFLAG_STORAGE) !== 0;\r\n\r\n        gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\r\n\r\n        gpuTextureWrapper.textureUsages =\r\n            texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : texture._source === InternalTextureSource.DepthStencil\r\n                  ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment\r\n                  : -1;\r\n\r\n        gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\r\n\r\n        const hasMipMaps = texture.generateMipMaps;\r\n        const layerCount = depth || 1;\r\n        let mipmapCount;\r\n        if (texture._maxLodLevel !== null) {\r\n            mipmapCount = texture._maxLodLevel;\r\n        } else {\r\n            mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            const gpuTexture = this.createCubeTexture(\r\n                { width, height },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${\r\n                        hasMipMaps ? \"wmips\" : \"womips\"\r\n                    }_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: 6,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        } else {\r\n            const gpuTexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray\r\n                ? WebGPUConstants.TextureViewDimension.E2dArray\r\n                : texture.is3D\r\n                  ? WebGPUConstants.TextureDimension.E3d\r\n                  : WebGPUConstants.TextureViewDimension.E2d;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? \"3D\" : \"2D\"}${\r\n                        texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"\r\n                    }_${width}x${height}${texture.is3D ? \"x\" + layerCount : \"\"}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        }\r\n\r\n        texture.width = texture.baseWidth = width;\r\n        texture.height = texture.baseHeight = height;\r\n        texture.depth = texture.baseDepth = depth;\r\n\r\n        if (!dontCreateMSAATexture) {\r\n            this.createMSAATexture(texture, texture.samples);\r\n        }\r\n\r\n        return gpuTextureWrapper;\r\n    }\r\n\r\n    public createMSAATexture(texture: InternalTexture, samples: number, releaseExisting = true, index = 0): void {\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (releaseExisting) {\r\n            gpuTextureWrapper?.releaseMSAATexture();\r\n        }\r\n\r\n        if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n\r\n        const gpuMSAATexture = this.createTexture(\r\n            { width, height, layers: 1 },\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            gpuTextureWrapper.format,\r\n            samples,\r\n            this._commandEncoderForCreation,\r\n            WebGPUConstants.TextureUsage.RenderAttachment,\r\n            0,\r\n            texture.label ? \"MSAA_\" + texture.label : \"MSAA\"\r\n        );\r\n        gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                                  Update\r\n    //------------------------------------------------------------------------------\r\n\r\n    public updateCubeTextures(\r\n        imageBitmaps: ImageBitmap[] | Uint8Array[],\r\n        gpuTexture: GPUTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0\r\n    ): void {\r\n        const faces = [0, 3, 1, 4, 2, 5];\r\n\r\n        for (let f = 0; f < faces.length; ++f) {\r\n            const imageBitmap = imageBitmaps[faces[f]];\r\n\r\n            this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\r\n        }\r\n    }\r\n\r\n    // TODO WEBGPU handle data source not being in the same format than the destination texture?\r\n    public updateTexture(\r\n        imageBitmap: ImageBitmap | Uint8Array | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas,\r\n        texture: GPUTexture | InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        layers: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture).underlyingResource! : texture;\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n        const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture) : texture;\r\n\r\n        const textureCopyView: GPUCopyExternalImageDestInfo = {\r\n            texture: gpuTexture,\r\n            origin: {\r\n                x: offsetX,\r\n                y: offsetY,\r\n                z: Math.max(faceIndex, 0),\r\n            },\r\n            mipLevel: mipLevel,\r\n            premultipliedAlpha: premultiplyAlpha,\r\n        };\r\n\r\n        const textureExtent = {\r\n            width: Math.ceil(width / blockInformation.width) * blockInformation.width,\r\n            height: Math.ceil(height / blockInformation.height) * blockInformation.height,\r\n            depthOrArrayLayers: layers || 1,\r\n        };\r\n\r\n        if ((imageBitmap as Uint8Array).byteLength !== undefined) {\r\n            imageBitmap = imageBitmap as Uint8Array;\r\n\r\n            const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n            const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\r\n\r\n            if (aligned) {\r\n                const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                const buffer = this._bufferManager.createRawBuffer(\r\n                    imageBitmap.byteLength,\r\n                    WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc,\r\n                    true,\r\n                    \"TempBufferForUpdateTexture\" + (gpuTexture ? \"_\" + gpuTexture.label : \"\")\r\n                );\r\n\r\n                const arrayBuffer = buffer.getMappedRange();\r\n\r\n                new Uint8Array(arrayBuffer).set(imageBitmap);\r\n\r\n                buffer.unmap();\r\n\r\n                commandEncoder.copyBufferToTexture(\r\n                    {\r\n                        buffer: buffer,\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureCopyView,\r\n                    textureExtent\r\n                );\r\n\r\n                this._device.queue.submit([commandEncoder.finish()]);\r\n\r\n                this._bufferManager.releaseBuffer(buffer);\r\n            } else {\r\n                this._device.queue.writeTexture(\r\n                    textureCopyView,\r\n                    imageBitmap,\r\n                    {\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureExtent\r\n                );\r\n            }\r\n\r\n            if (invertY || premultiplyAlpha) {\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n                    const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        texture.width,\r\n                        texture.height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        offsetX,\r\n                        offsetY,\r\n                        dontUseRect ? 0 : width,\r\n                        dontUseRect ? 0 : height,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we should never take this code path\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\r\n                }\r\n            }\r\n        } else {\r\n            imageBitmap = imageBitmap as ImageBitmap | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas;\r\n            this._device.queue.copyExternalImageToTexture({ source: imageBitmap, flipY: invertY }, textureCopyView, textureExtent);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n    public readPixels(\r\n        texture: GPUTexture,\r\n        x: number,\r\n        y: number,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n\r\n        const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n\r\n        const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\r\n\r\n        const size = bytesPerRowAligned * height;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempBufferForReadPixels\" + (texture.label ? \"_\" + texture.label : \"\")\r\n        );\r\n\r\n        const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n            {\r\n                texture,\r\n                mipLevel,\r\n                origin: {\r\n                    x,\r\n                    y,\r\n                    z: Math.max(faceIndex, 0),\r\n                },\r\n            },\r\n            {\r\n                buffer: gpuBuffer,\r\n                offset: 0,\r\n                bytesPerRow: bytesPerRowAligned,\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        this._device.queue.submit([commandEncoder.finish()]);\r\n\r\n        return this._bufferManager.readDataFromBuffer(\r\n            gpuBuffer,\r\n            size,\r\n            width,\r\n            height,\r\n            bytesPerRow,\r\n            bytesPerRowAligned,\r\n            WebGPUTextureHelper.GetTextureTypeFromFormat(format),\r\n            0,\r\n            buffer,\r\n            true,\r\n            noDataConversion\r\n        );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    public releaseTexture(texture: InternalTexture | GPUTexture): void {\r\n        if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n            const hardwareTexture = texture._hardwareTexture;\r\n            const irradianceTexture = texture._irradianceTexture;\r\n\r\n            // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\r\n            this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\r\n        } else {\r\n            this._deferredReleaseTextures.push([texture, null]);\r\n        }\r\n    }\r\n\r\n    public destroyDeferredTextures(): void {\r\n        for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\r\n            const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\r\n\r\n            if (hardwareTexture) {\r\n                if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {\r\n                    hardwareTexture.release();\r\n                } else {\r\n                    hardwareTexture.destroy();\r\n                }\r\n            }\r\n            irradianceTexture?.dispose();\r\n        }\r\n\r\n        this._deferredReleaseTextures.length = 0;\r\n    }\r\n}\r\n", "import { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGPUDataBuffer extends DataBuffer {\r\n    private _buffer: Nullable<GPUBuffer>;\r\n\r\n    // Used to make sure the buffer is not recreated twice after a context loss/restoration\r\n    public engineId = -1;\r\n\r\n    public set buffer(buffer: Nullable<GPUBuffer>) {\r\n        this._buffer = buffer;\r\n    }\r\n\r\n    public constructor(resource?: GPUBuffer, capacity = 0) {\r\n        super();\r\n        this.capacity = capacity;\r\n        if (resource) {\r\n            this._buffer = resource;\r\n        }\r\n    }\r\n\r\n    public override get underlyingResource(): any {\r\n        return this._buffer;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport { FromHalfFloat } from \"../../Misc/textureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { allocateAndCopyTypedBuffer } from \"../abstractEngine.functions\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUBufferManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _deferredReleaseBuffers: Array<GPUBuffer> = [];\r\n\r\n    private static _IsGPUBuffer(buffer: DataBuffer | GPUBuffer): buffer is GPUBuffer {\r\n        return (buffer as DataBuffer).underlyingResource === undefined;\r\n    }\r\n\r\n    private static _FlagsToString(flags: GPUBufferUsageFlags, suffix = \"\") {\r\n        let result = suffix;\r\n\r\n        for (let i = 0; i <= 9; ++i) {\r\n            if (flags & (1 << i)) {\r\n                if (result) {\r\n                    result += \"_\";\r\n                }\r\n                result += WebGPUConstants.BufferUsage[1 << i];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n    }\r\n\r\n    public createRawBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, mappedAtCreation = false, label?: string): GPUBuffer {\r\n        const alignedLength = (viewOrSize as ArrayBufferView).byteLength !== undefined ? ((viewOrSize as ArrayBufferView).byteLength + 3) & ~3 : ((viewOrSize as number) + 3) & ~3; // 4 bytes alignments (because of the upload which requires this)\r\n        const verticesBufferDescriptor = {\r\n            label: \"BabylonWebGPUDevice\" + this._engine.uniqueId + \"_\" + WebGPUBufferManager._FlagsToString(flags, label ?? \"Buffer\") + \"_size\" + alignedLength,\r\n            mappedAtCreation,\r\n            size: alignedLength,\r\n            usage: flags,\r\n        };\r\n\r\n        return this._device.createBuffer(verticesBufferDescriptor);\r\n    }\r\n\r\n    public createBuffer(viewOrSize: ArrayBufferView | number, flags: GPUBufferUsageFlags, label?: string): WebGPUDataBuffer {\r\n        const isView = (viewOrSize as ArrayBufferView).byteLength !== undefined;\r\n        const dataBuffer = new WebGPUDataBuffer();\r\n        const labelId = \"DataBufferUniqueId=\" + dataBuffer.uniqueId;\r\n        dataBuffer.buffer = this.createRawBuffer(viewOrSize, flags, undefined, label ? labelId + \"-\" + label : labelId);\r\n        dataBuffer.references = 1;\r\n        dataBuffer.capacity = isView ? (viewOrSize as ArrayBufferView).byteLength : (viewOrSize as number);\r\n        dataBuffer.engineId = this._engine.uniqueId;\r\n\r\n        if (isView) {\r\n            this.setSubData(dataBuffer, 0, viewOrSize as ArrayBufferView);\r\n        }\r\n\r\n        return dataBuffer;\r\n    }\r\n\r\n    // This calls GPUBuffer.writeBuffer() with no alignment corrections\r\n    // dstByteOffset and byteLength must both be aligned to 4 bytes and bytes moved must be within src and dst arrays\r\n    public setRawData(buffer: GPUBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset: number, byteLength: number): void {\r\n        srcByteOffset += src.byteOffset;\r\n\r\n        this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\r\n    }\r\n\r\n    // This calls GPUBuffer.writeBuffer() with alignment corrections (dstByteOffset and byteLength will be aligned to 4 byte boundaries)\r\n    // If alignment is needed, src must be a full copy of dataBuffer, or at least should be large enough to cope with the additional bytes copied because of alignment!\r\n    public setSubData(dataBuffer: WebGPUDataBuffer, dstByteOffset: number, src: ArrayBufferView, srcByteOffset = 0, byteLength = 0): void {\r\n        const buffer = dataBuffer.underlyingResource as GPUBuffer;\r\n\r\n        byteLength = byteLength || src.byteLength - srcByteOffset;\r\n\r\n        // Make sure the dst offset is aligned to 4 bytes\r\n        const startPre = dstByteOffset & 3;\r\n\r\n        srcByteOffset -= startPre;\r\n        dstByteOffset -= startPre;\r\n\r\n        // Make sure the byte length is aligned to 4 bytes\r\n        const originalByteLength = byteLength;\r\n\r\n        byteLength = (byteLength + startPre + 3) & ~3;\r\n\r\n        // Check if the backing buffer of src is large enough to cope with the additional bytes copied because of alignment\r\n        const backingBufferSize = src.buffer.byteLength - src.byteOffset;\r\n\r\n        if (backingBufferSize < byteLength) {\r\n            // Not enough place in the backing buffer for the aligned copy.\r\n            // Creates a new buffer and copy the source data to it.\r\n            // The buffer will have byteLength - originalByteLength zeros at the end.\r\n            const tmpBuffer = new Uint8Array(byteLength);\r\n            tmpBuffer.set(new Uint8Array(src.buffer, src.byteOffset + srcByteOffset, originalByteLength));\r\n            src = tmpBuffer;\r\n            srcByteOffset = 0;\r\n        }\r\n\r\n        this.setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength);\r\n    }\r\n\r\n    private _getHalfFloatAsFloatRGBAArrayBuffer(dataLength: number, arrayBuffer: ArrayBuffer, destArray?: Float32Array): Float32Array {\r\n        if (!destArray) {\r\n            destArray = new Float32Array(dataLength);\r\n        } else {\r\n            dataLength = Math.min(dataLength, destArray.length);\r\n        }\r\n        const srcData = new Uint16Array(arrayBuffer);\r\n        while (dataLength--) {\r\n            destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readDataFromBuffer(\r\n        gpuBuffer: GPUBuffer,\r\n        size: number,\r\n        width: number,\r\n        height: number,\r\n        bytesPerRow: number,\r\n        bytesPerRowAligned: number,\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        offset = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        destroyBuffer = true,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const floatFormat = type === Constants.TEXTURETYPE_FLOAT ? 2 : type === Constants.TEXTURETYPE_HALF_FLOAT ? 1 : 0;\r\n        const engineId = this._engine.uniqueId;\r\n        return new Promise((resolve, reject) => {\r\n            // eslint-disable-next-line github/no-then\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\r\n                    let data: Nullable<ArrayBufferView> | Uint8Array | Float32Array = buffer;\r\n                    if (noDataConversion) {\r\n                        if (data === null) {\r\n                            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\r\n                        } else {\r\n                            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\r\n                        }\r\n                    } else {\r\n                        if (data === null) {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(size);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(size / 4);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer));\r\n                                    break;\r\n                            }\r\n                        } else {\r\n                            switch (floatFormat) {\r\n                                case 0: // byte format\r\n                                    data = new Uint8Array(data.buffer);\r\n                                    (data as Uint8Array).set(new Uint8Array(copyArrayBuffer, 0, Math.min(data.byteLength, size)));\r\n                                    break;\r\n                                case 1: // half float\r\n                                    // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\r\n                                    data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer as Float32Array);\r\n                                    break;\r\n                                case 2: // float\r\n                                    data = new Float32Array(data.buffer);\r\n                                    (data as Float32Array).set(new Float32Array(copyArrayBuffer, 0, data.byteLength / 4));\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (bytesPerRow !== bytesPerRowAligned) {\r\n                        // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\r\n                        if (floatFormat === 1 && !noDataConversion) {\r\n                            // half float have been converted to float above\r\n                            bytesPerRow *= 2;\r\n                            bytesPerRowAligned *= 2;\r\n                        }\r\n                        const data2 = new Uint8Array(data.buffer);\r\n                        let offset = bytesPerRow,\r\n                            offset2 = 0;\r\n                        for (let y = 1; y < height; ++y) {\r\n                            offset2 = y * bytesPerRowAligned;\r\n                            for (let x = 0; x < bytesPerRow; ++x) {\r\n                                data2[offset++] = data2[offset2++];\r\n                            }\r\n                        }\r\n                        if (floatFormat !== 0 && !noDataConversion) {\r\n                            data = new Float32Array(data2.buffer, 0, offset / 4);\r\n                        } else {\r\n                            data = new Uint8Array(data2.buffer, 0, offset);\r\n                        }\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    if (destroyBuffer) {\r\n                        this.releaseBuffer(gpuBuffer);\r\n                    }\r\n                    resolve(data);\r\n                },\r\n                (reason) => {\r\n                    if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                        // The engine was disposed while waiting for the promise, or a context loss/restoration has occurred: don't reject\r\n                        resolve(new Uint8Array());\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(reason);\r\n                    }\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    public releaseBuffer(buffer: DataBuffer | GPUBuffer): boolean {\r\n        if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\r\n            this._deferredReleaseBuffers.push(buffer);\r\n            return true;\r\n        }\r\n\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deferredReleaseBuffers.push(buffer.underlyingResource as GPUBuffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public destroyDeferredBuffers(): void {\r\n        for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\r\n            this._deferredReleaseBuffers[i].destroy();\r\n        }\r\n\r\n        this._deferredReleaseBuffers.length = 0;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Constants } from \"../constants\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nconst FilterToBits = [\r\n    0 | (0 << 1) | (0 << 2), // not used\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    1 | (1 << 1) | (1 << 2), // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 | (0 << 1) | (0 << 2), // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 | (1 << 1) | (1 << 2), // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    0 | (1 << 1) | (0 << 2), // TEXTURE_NEAREST_LINEAR\r\n    0 | (0 << 1) | (1 << 2), // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    1 | (0 << 1) | (1 << 2), // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    1 | (1 << 1) | (0 << 2), // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 | (0 << 1) | (0 << 2), // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n// subtract 0x01FF from the comparison function value before indexing this array!\r\nconst ComparisonFunctionToBits = [\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // undefined\r\n    (0 << 3) | (0 << 4) | (0 << 5) | (1 << 6), // NEVER\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (0 << 6), // LESS\r\n    (0 << 3) | (0 << 4) | (1 << 5) | (1 << 6), // EQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (0 << 6), // LEQUAL\r\n    (0 << 3) | (1 << 4) | (0 << 5) | (1 << 6), // GREATER\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (0 << 6), // NOTEQUAL\r\n    (0 << 3) | (1 << 4) | (1 << 5) | (1 << 6), // GEQUAL\r\n    (1 << 3) | (0 << 4) | (0 << 5) | (0 << 6), // ALWAYS\r\n];\r\n\r\nconst FilterNoMipToBits = [\r\n    0 << 7, // not used\r\n    1 << 7, // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    1 << 7, // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    0 << 7, // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    0 << 7, // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    1 << 7, // TEXTURE_NEAREST_LINEAR\r\n    0 << 7, // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    0 << 7, // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    0 << 7, // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    1 << 7, // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n/** @internal */\r\nexport class WebGPUCacheSampler {\r\n    private _samplers: { [hash: number]: GPUSampler } = {};\r\n    private _device: GPUDevice;\r\n\r\n    public disabled: boolean;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this.disabled = false;\r\n    }\r\n\r\n    public static GetSamplerHashCode(sampler: TextureSampler): number {\r\n        // The WebGPU spec currently only allows values 1 and 4 for anisotropy\r\n        const anisotropy = sampler._cachedAnisotropicFilteringLevel ? sampler._cachedAnisotropicFilteringLevel : 1;\r\n        const code =\r\n            FilterToBits[sampler.samplingMode] +\r\n            ComparisonFunctionToBits[(sampler._comparisonFunction || 0x0202) - 0x0200 + 1] +\r\n            FilterNoMipToBits[sampler.samplingMode] + // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping\r\n            ((sampler._cachedWrapU ?? 1) << 8) +\r\n            ((sampler._cachedWrapV ?? 1) << 10) +\r\n            ((sampler._cachedWrapR ?? 1) << 12) +\r\n            ((sampler.useMipMaps ? 1 : 0) << 14) + // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND useMipMaps!\r\n            (anisotropy << 15);\r\n\r\n        return code;\r\n    }\r\n\r\n    private static _GetSamplerFilterDescriptor(\r\n        sampler: TextureSampler,\r\n        anisotropy: number\r\n    ): {\r\n        magFilter: GPUFilterMode;\r\n        minFilter: GPUFilterMode;\r\n        mipmapFilter: GPUFilterMode;\r\n        lodMinClamp?: number;\r\n        lodMaxClamp?: number;\r\n        anisotropyEnabled?: boolean;\r\n    } {\r\n        let magFilter: GPUFilterMode, minFilter: GPUFilterMode, mipmapFilter: GPUFilterMode, lodMinClamp: number | undefined, lodMaxClamp: number | undefined;\r\n        const useMipMaps = sampler.useMipMaps;\r\n        switch (sampler.samplingMode) {\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n            case Constants.TEXTURE_TRILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST:\r\n            case Constants.TEXTURE_NEAREST_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                if (!useMipMaps) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR:\r\n            case Constants.TEXTURE_BILINEAR_SAMPLINGMODE:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Linear;\r\n                // In WebGL, if sampling mode is TEXTURE_BILINEAR_SAMPLINGMODE and anisotropy is greater than 1, anisotropy is enabled for the sampler\r\n                if (anisotropy > 1) {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Linear;\r\n                } else {\r\n                    mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                    lodMinClamp = lodMaxClamp = 0;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST:\r\n                magFilter = WebGPUConstants.FilterMode.Linear;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n            default:\r\n                magFilter = WebGPUConstants.FilterMode.Nearest;\r\n                minFilter = WebGPUConstants.FilterMode.Nearest;\r\n                mipmapFilter = WebGPUConstants.FilterMode.Nearest;\r\n                lodMinClamp = lodMaxClamp = 0;\r\n                break;\r\n        }\r\n\r\n        if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0)) {\r\n            return {\r\n                magFilter: WebGPUConstants.FilterMode.Linear,\r\n                minFilter: WebGPUConstants.FilterMode.Linear,\r\n                mipmapFilter: WebGPUConstants.FilterMode.Linear,\r\n                anisotropyEnabled: true,\r\n            };\r\n        }\r\n\r\n        return {\r\n            magFilter,\r\n            minFilter,\r\n            mipmapFilter,\r\n            lodMinClamp,\r\n            lodMaxClamp,\r\n        };\r\n    }\r\n\r\n    private static _GetWrappingMode(mode: number): GPUAddressMode {\r\n        switch (mode) {\r\n            case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.Repeat;\r\n            case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.ClampToEdge;\r\n            case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n                return WebGPUConstants.AddressMode.MirrorRepeat;\r\n        }\r\n        return WebGPUConstants.AddressMode.Repeat;\r\n    }\r\n\r\n    private static _GetSamplerWrappingDescriptor(sampler: TextureSampler): {\r\n        addressModeU: GPUAddressMode;\r\n        addressModeV: GPUAddressMode;\r\n        addressModeW: GPUAddressMode;\r\n    } {\r\n        return {\r\n            addressModeU: this._GetWrappingMode(sampler._cachedWrapU!),\r\n            addressModeV: this._GetWrappingMode(sampler._cachedWrapV!),\r\n            addressModeW: this._GetWrappingMode(sampler._cachedWrapR!),\r\n        };\r\n    }\r\n\r\n    private static _GetSamplerDescriptor(sampler: TextureSampler, label?: string): GPUSamplerDescriptor {\r\n        // The check with Constants.TEXTURE_LINEAR_LINEAR is to be iso with the WebGL implementation\r\n        let anisotropy =\r\n            (sampler.useMipMaps || sampler.samplingMode === Constants.TEXTURE_LINEAR_LINEAR) && sampler._cachedAnisotropicFilteringLevel\r\n                ? sampler._cachedAnisotropicFilteringLevel\r\n                : 1;\r\n        // To be iso with the WebGL implementation\r\n        if (\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST &&\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR &&\r\n            sampler.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR\r\n        ) {\r\n            anisotropy = 1;\r\n        }\r\n        const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);\r\n        return {\r\n            label,\r\n            ...filterDescriptor,\r\n            ...this._GetSamplerWrappingDescriptor(sampler),\r\n            compare: sampler._comparisonFunction ? WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : undefined,\r\n            maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1,\r\n        };\r\n    }\r\n\r\n    public static GetCompareFunction(compareFunction: Nullable<number>): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case Constants.ALWAYS:\r\n                return WebGPUConstants.CompareFunction.Always;\r\n            case Constants.EQUAL:\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case Constants.GREATER:\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case Constants.GEQUAL:\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case Constants.LESS:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case Constants.LEQUAL:\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case Constants.NEVER:\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case Constants.NOTEQUAL:\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            default:\r\n                return WebGPUConstants.CompareFunction.Less;\r\n        }\r\n    }\r\n\r\n    public getSampler(sampler: TextureSampler, bypassCache = false, hash = 0, label?: string): GPUSampler {\r\n        if (this.disabled) {\r\n            return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n        }\r\n\r\n        if (bypassCache) {\r\n            hash = 0;\r\n        } else if (hash === 0) {\r\n            hash = WebGPUCacheSampler.GetSamplerHashCode(sampler);\r\n        }\r\n\r\n        let gpuSampler = bypassCache ? undefined : this._samplers[hash];\r\n        if (!gpuSampler) {\r\n            gpuSampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\r\n            if (!bypassCache) {\r\n                this._samplers[hash] = gpuSampler;\r\n            }\r\n        }\r\n\r\n        return gpuSampler;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { _IShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\n\r\nconst VertexBufferKindForNonFloatProcessing: { [kind: string]: boolean } = {\r\n    [VertexBuffer.PositionKind]: true,\r\n    [VertexBuffer.NormalKind]: true,\r\n    [VertexBuffer.TangentKind]: true,\r\n    [VertexBuffer.UVKind]: true,\r\n    [VertexBuffer.UV2Kind]: true,\r\n    [VertexBuffer.UV3Kind]: true,\r\n    [VertexBuffer.UV4Kind]: true,\r\n    [VertexBuffer.UV5Kind]: true,\r\n    [VertexBuffer.UV6Kind]: true,\r\n    [VertexBuffer.ColorKind]: true,\r\n    [VertexBuffer.ColorInstanceKind]: true,\r\n    [VertexBuffer.MatricesIndicesKind]: true,\r\n    [VertexBuffer.MatricesWeightsKind]: true,\r\n    [VertexBuffer.MatricesIndicesExtraKind]: true,\r\n    [VertexBuffer.MatricesWeightsExtraKind]: true,\r\n};\r\n\r\n/**\r\n * Indicates if the type is a signed or unsigned type\r\n * @param type Type to check\r\n * @returns True if it is a signed type\r\n */\r\nfunction IsSignedType(type: number): boolean {\r\n    switch (type) {\r\n        case VertexBuffer.BYTE:\r\n        case VertexBuffer.SHORT:\r\n        case VertexBuffer.INT:\r\n        case VertexBuffer.FLOAT:\r\n            return true;\r\n        case VertexBuffer.UNSIGNED_BYTE:\r\n        case VertexBuffer.UNSIGNED_SHORT:\r\n        case VertexBuffer.UNSIGNED_INT:\r\n            return false;\r\n        default:\r\n            throw new Error(`Invalid type '${type}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether some vertex buffers that should be of type float are of a different type (int, byte...).\r\n * If so, trigger a shader recompilation to give the shader processor the opportunity to update the code accordingly.\r\n * @param vertexBuffers List of vertex buffers to check\r\n * @param effect The effect (shaders) that should be recompiled if needed\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function checkNonFloatVertexBuffers(vertexBuffers: { [key: string]: Nullable<VertexBuffer> }, effect: Effect): void {\r\n    const engine = effect.getEngine();\r\n    const pipelineContext = effect._pipelineContext;\r\n\r\n    if (!pipelineContext?.vertexBufferKindToType) {\r\n        return;\r\n    }\r\n\r\n    let shaderProcessingContext: Nullable<_IShaderProcessingContext> = null;\r\n\r\n    for (const kind in vertexBuffers) {\r\n        const currentVertexBuffer = vertexBuffers[kind];\r\n\r\n        if (!currentVertexBuffer || !VertexBufferKindForNonFloatProcessing[kind]) {\r\n            continue;\r\n        }\r\n\r\n        const currentVertexBufferType = currentVertexBuffer.normalized ? VertexBuffer.FLOAT : currentVertexBuffer.type;\r\n        const vertexBufferType = pipelineContext.vertexBufferKindToType[kind];\r\n\r\n        if (\r\n            (currentVertexBufferType !== VertexBuffer.FLOAT && vertexBufferType === undefined) ||\r\n            (vertexBufferType !== undefined && vertexBufferType !== currentVertexBufferType)\r\n        ) {\r\n            if (!shaderProcessingContext) {\r\n                shaderProcessingContext = engine._getShaderProcessingContext(effect.shaderLanguage, false)!;\r\n            }\r\n            pipelineContext.vertexBufferKindToType[kind] = currentVertexBufferType;\r\n            if (currentVertexBufferType !== VertexBuffer.FLOAT) {\r\n                shaderProcessingContext.vertexBufferKindToNumberOfComponents![kind] = VertexBuffer.DeduceStride(kind);\r\n                if (IsSignedType(currentVertexBufferType)) {\r\n                    shaderProcessingContext.vertexBufferKindToNumberOfComponents![kind] *= -1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (shaderProcessingContext) {\r\n        // We temporarily disable parallel compilation of shaders because we want new shaders to be compiled after the _processShaderCode call, so that they are in effect for the rest of the frame.\r\n        // There is no additional call to async so the _processShaderCodeAsync will execute synchronously.\r\n        const parallelShaderCompile = engine._caps.parallelShaderCompile;\r\n        engine._caps.parallelShaderCompile = undefined;\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        effect._processShaderCodeAsync(null, engine._features._checkNonFloatVertexBuffersDontRecreatePipelineContext, shaderProcessingContext);\r\n\r\n        engine._caps.parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Constants } from \"../constants\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\nimport { checkNonFloatVertexBuffers } from \"core/Buffers/buffer.nonFloatVertexBuffers\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nenum StatePosition {\r\n    StencilReadMask = 0,\r\n    StencilWriteMask = 1,\r\n    //DepthBiasClamp = 1, // not used, so remove it to improve perf\r\n    DepthBias = 2,\r\n    DepthBiasSlopeScale = 3,\r\n    DepthStencilState = 4,\r\n    MRTAttachments = 5,\r\n    RasterizationState = 6,\r\n    ColorStates1 = 7,\r\n    ColorStates2 = 8,\r\n    ColorStates3 = 9,\r\n    ColorStates4 = 10,\r\n    ShaderStage = 11,\r\n    TextureStage = 12,\r\n    VertexState = 13, // vertex state will consume positions 13, 14, ... depending on the number of vertex inputs\r\n\r\n    NumStates = 14,\r\n}\r\n\r\nconst alphaBlendFactorToIndex: { [name: number]: number } = {\r\n    0: 1, // Zero\r\n    1: 2, // One\r\n    0x0300: 3, // SrcColor\r\n    0x0301: 4, // OneMinusSrcColor\r\n    0x0302: 5, // SrcAlpha\r\n    0x0303: 6, // OneMinusSrcAlpha\r\n    0x0304: 7, // DstAlpha\r\n    0x0305: 8, // OneMinusDstAlpha\r\n    0x0306: 9, // DstColor\r\n    0x0307: 10, // OneMinusDstColor\r\n    0x0308: 11, // SrcAlphaSaturated\r\n    0x8001: 12, // BlendColor\r\n    0x8002: 13, // OneMinusBlendColor\r\n    0x8003: 14, // BlendColor (alpha)\r\n    0x8004: 15, // OneMinusBlendColor (alpha)\r\n    0x88f9: 16, // Src1Color\r\n    0x88fa: 17, // OneMinusSrc1Color\r\n    0x8589: 18, // Src1Alpha\r\n    0x88fb: 19, // OneMinusSrc1Alpha\r\n};\r\n\r\nconst alphaBlendEquationToIndex: { [name: number]: number } = {\r\n    0x8006: 0, // Add\r\n    0x8007: 1, // Min\r\n    0x8008: 2, // Max\r\n    0x800a: 3, // Subtract\r\n    0x800b: 4, // ReverseSubtract\r\n};\r\n\r\nconst stencilOpToIndex: { [name: number]: number } = {\r\n    0x0000: 0, // ZERO\r\n    0x1e00: 1, // KEEP\r\n    0x1e01: 2, // REPLACE\r\n    0x1e02: 3, // INCR\r\n    0x1e03: 4, // DECR\r\n    0x150a: 5, // INVERT\r\n    0x8507: 6, // INCR_WRAP\r\n    0x8508: 7, // DECR_WRAP\r\n};\r\n\r\nconst colorStates = [0, 0, 0, 0];\r\n\r\n/** @internal */\r\nexport abstract class WebGPUCacheRenderPipeline {\r\n    public static LogErrorIfNoVertexBuffer = false;\r\n\r\n    public static NumCacheHitWithoutHash = 0;\r\n    public static NumCacheHitWithHash = 0;\r\n    public static NumCacheMiss = 0;\r\n    public static NumPipelineCreationLastFrame = 0;\r\n\r\n    public disabled: boolean;\r\n\r\n    private static _NumPipelineCreationCurrentFrame = 0;\r\n\r\n    protected _states: number[];\r\n    protected _statesLength: number;\r\n    protected _stateDirtyLowestIndex: number;\r\n    public lastStateDirtyLowestIndex: number; // for stats only\r\n\r\n    private _device: GPUDevice;\r\n    private _isDirty: boolean;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    private _parameter: { token: any; pipeline: Nullable<GPURenderPipeline> };\r\n    private _kMaxVertexBufferStride;\r\n\r\n    private _shaderId: number;\r\n    private _alphaToCoverageEnabled: boolean;\r\n    private _frontFace: number;\r\n    private _cullEnabled: boolean;\r\n    private _cullFace: number;\r\n    private _clampDepth: boolean;\r\n    private _rasterizationState: number;\r\n    private _depthBias: number;\r\n    private _depthBiasClamp: number;\r\n    private _depthBiasSlopeScale: number;\r\n    private _colorFormat: number;\r\n    private _webgpuColorFormat: (GPUTextureFormat | null)[];\r\n    private _mrtAttachments: number;\r\n    private _mrtFormats: (GPUTextureFormat | null)[];\r\n    private _mrtEnabledMask: number;\r\n    private _alphaBlendEnabled: boolean[];\r\n    private _numAlphaBlendTargetsEnabled: number;\r\n    private _alphaBlendFuncParams: Array<Nullable<number>>;\r\n    private _alphaBlendEqParams: Array<Nullable<number>>;\r\n    private _writeMask: number;\r\n    private _depthStencilFormat: number;\r\n    private _webgpuDepthStencilFormat: GPUTextureFormat | undefined;\r\n    private _depthTestEnabled: boolean;\r\n    private _depthWriteEnabled: boolean;\r\n    private _depthCompare: number;\r\n    private _stencilEnabled: boolean;\r\n    private _stencilFrontCompare: number;\r\n    private _stencilFrontDepthFailOp: number;\r\n    private _stencilFrontPassOp: number;\r\n    private _stencilFrontFailOp: number;\r\n    private _stencilBackCompare: number;\r\n    private _stencilBackDepthFailOp: number;\r\n    private _stencilBackPassOp: number;\r\n    private _stencilBackFailOp: number;\r\n    private _stencilReadMask: number;\r\n    private _stencilWriteMask: number;\r\n    private _depthStencilState: number;\r\n    private _vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _textureState: number;\r\n    private _useTextureStage: boolean;\r\n\r\n    constructor(device: GPUDevice, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._useTextureStage = true; // we force usage because we must handle depth textures with \"float\" filtering, which can't be fixed by a caps (like \"textureFloatLinearFiltering\" can for float textures)\r\n        this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\r\n        this._statesLength = 0;\r\n        this._stateDirtyLowestIndex = 0;\r\n        this._emptyVertexBuffer = emptyVertexBuffer;\r\n        this._mrtFormats = [];\r\n        this._parameter = { token: undefined, pipeline: null };\r\n        this.disabled = false;\r\n        this.vertexBuffers = [];\r\n        this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this._isDirty = true;\r\n        this.vertexBuffers.length = 0;\r\n        this.setAlphaToCoverage(false);\r\n        this.resetDepthCullingState();\r\n        this.setClampDepth(false);\r\n        this.setDepthBias(0);\r\n        //this.setDepthBiasClamp(0);\r\n        this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\r\n        this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\r\n        this.setMRT([]);\r\n        this.setAlphaBlendEnabled([false], 1);\r\n        this.setAlphaBlendFactors([null, null, null, null], [null, null]);\r\n        this.setWriteMask(0xf);\r\n        this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\r\n        this.setStencilEnabled(false);\r\n        this.resetStencilState();\r\n        this.setBuffers(null, null, null);\r\n        this._setTextureState(0);\r\n    }\r\n\r\n    protected abstract _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n    protected abstract _setRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n\r\n    public readonly vertexBuffers: VertexBuffer[];\r\n    public readonly indexBuffer: Nullable<DataBuffer>;\r\n\r\n    public get colorFormats(): (GPUTextureFormat | null)[] {\r\n        return this._mrtAttachments > 0 ? this._mrtFormats : this._webgpuColorFormat;\r\n    }\r\n\r\n    public readonly mrtAttachments: number[];\r\n    public readonly mrtTextureArray: InternalTexture[];\r\n    public readonly mrtTextureCount: number = 0;\r\n\r\n    public getRenderPipeline(fillMode: number, effect: Effect, sampleCount: number, textureState = 0): GPURenderPipeline {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        if (this.disabled) {\r\n            const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n            this._setVertexState(effect); // to fill this.vertexBuffers with correct data\r\n            this._setTextureState(textureState);\r\n\r\n            this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n\r\n            WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n            WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._setShaderStage(effect.uniqueId);\r\n        this._setRasterizationState(fillMode, sampleCount);\r\n        this._setColorStates();\r\n        this._setDepthStencilState();\r\n        this._setVertexState(effect);\r\n        this._setTextureState(textureState);\r\n\r\n        this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\r\n\r\n        if (!this._isDirty && this._parameter.pipeline) {\r\n            this._stateDirtyLowestIndex = this._statesLength;\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._getRenderPipeline(this._parameter);\r\n\r\n        this._isDirty = false;\r\n        this._stateDirtyLowestIndex = this._statesLength;\r\n\r\n        if (this._parameter.pipeline) {\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n        this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n        this._setRenderPipeline(this._parameter);\r\n\r\n        WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n        return this._parameter.pipeline;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\r\n    }\r\n\r\n    public setAlphaToCoverage(enabled: boolean): void {\r\n        this._alphaToCoverageEnabled = enabled;\r\n    }\r\n\r\n    public setFrontFace(frontFace: number): void {\r\n        this._frontFace = frontFace;\r\n    }\r\n\r\n    public setCullEnabled(enabled: boolean): void {\r\n        this._cullEnabled = enabled;\r\n    }\r\n\r\n    public setCullFace(cullFace: number): void {\r\n        this._cullFace = cullFace;\r\n    }\r\n\r\n    public setClampDepth(clampDepth: boolean): void {\r\n        this._clampDepth = clampDepth;\r\n    }\r\n\r\n    public resetDepthCullingState(): void {\r\n        this.setDepthCullingState(false, 2, 1, 0, 0, true, true, Constants.ALWAYS);\r\n    }\r\n\r\n    public setDepthCullingState(\r\n        cullEnabled: boolean,\r\n        frontFace: number,\r\n        cullFace: number,\r\n        zOffset: number,\r\n        zOffsetUnits: number,\r\n        depthTestEnabled: boolean,\r\n        depthWriteEnabled: boolean,\r\n        depthCompare: Nullable<number>\r\n    ): void {\r\n        this._depthWriteEnabled = depthWriteEnabled;\r\n        this._depthTestEnabled = depthTestEnabled;\r\n        this._depthCompare = (depthCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._cullFace = cullFace;\r\n        this._cullEnabled = cullEnabled;\r\n        this._frontFace = frontFace;\r\n        this.setDepthBiasSlopeScale(zOffset);\r\n        this.setDepthBias(zOffsetUnits);\r\n    }\r\n\r\n    public setDepthBias(depthBias: number): void {\r\n        if (this._depthBias !== depthBias) {\r\n            this._depthBias = depthBias;\r\n            this._states[StatePosition.DepthBias] = depthBias;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\r\n        }\r\n    }\r\n\r\n    /*public setDepthBiasClamp(depthBiasClamp: number): void {\r\n        if (this._depthBiasClamp !== depthBiasClamp) {\r\n            this._depthBiasClamp = depthBiasClamp;\r\n            this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\r\n            this._isDirty = true;\r\n        }\r\n    }*/\r\n\r\n    public setDepthBiasSlopeScale(depthBiasSlopeScale: number): void {\r\n        if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\r\n            this._depthBiasSlopeScale = depthBiasSlopeScale;\r\n            this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\r\n        }\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._webgpuColorFormat[0] = format;\r\n        this._colorFormat = renderableTextureFormatToIndex[format ?? \"\"];\r\n    }\r\n\r\n    // Must be called after setMRT!\r\n    public setMRTAttachments(attachments: number[]): void {\r\n        (this.mrtAttachments as any) = attachments;\r\n        let mask = 0;\r\n        for (let i = 0; i < attachments.length; ++i) {\r\n            if (attachments[i] !== 0) {\r\n                mask += 1 << i;\r\n            }\r\n        }\r\n        if (this._mrtEnabledMask !== mask) {\r\n            this._mrtEnabledMask = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments);\r\n        }\r\n    }\r\n\r\n    public setMRT(textureArray: InternalTexture[], textureCount?: number): void {\r\n        textureCount = textureCount ?? textureArray.length;\r\n        if (textureCount > 8) {\r\n            // We only support 8 MRTs in WebGPU, so we throw an error if we try to set more than that.\r\n            throw new Error(\"Can't handle more than 8 attachments for a MRT in cache render pipeline!\");\r\n        }\r\n        (this.mrtTextureArray as any) = textureArray;\r\n        (this.mrtTextureCount as any) = textureCount;\r\n\r\n        // Since we need approximately 45 different values per texture format (see WebGPUTextureManager.renderableTextureFormatToIndex), we use 6 bits to encode a texture format,\r\n        // which means we can encode 8 texture formats in 48 bits (a double can represent integers exactly up until 2^53, so 48 bits is ok).\r\n\r\n        this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\r\n\r\n        let mrtAttachments = 0;\r\n        let mask = 0;\r\n\r\n        for (let i = 0; i < textureCount; ++i) {\r\n            const texture = textureArray[i];\r\n            const gpuWrapper = texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n            this._mrtFormats[i] = gpuWrapper?.format ?? this._webgpuColorFormat[0];\r\n\r\n            mrtAttachments += renderableTextureFormatToIndex[this._mrtFormats[i] ?? \"\"] * 2 ** mask;\r\n            mask += 6;\r\n        }\r\n        this._mrtFormats.length = textureCount;\r\n        if (this._mrtAttachments !== mrtAttachments) {\r\n            this._mrtAttachments = mrtAttachments;\r\n            this._states[StatePosition.MRTAttachments] = mrtAttachments;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments);\r\n        }\r\n    }\r\n\r\n    public setAlphaBlendEnabled(enabled: boolean[], numAlphaBlendTargetsEnabled: number): void {\r\n        this._alphaBlendEnabled = enabled;\r\n        this._numAlphaBlendTargetsEnabled = numAlphaBlendTargetsEnabled;\r\n    }\r\n\r\n    public setAlphaBlendFactors(factors: Array<Nullable<number>>, operations: Array<Nullable<number>>): void {\r\n        this._alphaBlendFuncParams = factors;\r\n        this._alphaBlendEqParams = operations;\r\n    }\r\n\r\n    public setWriteMask(mask: number): void {\r\n        this._writeMask = mask;\r\n    }\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._webgpuDepthStencilFormat = format;\r\n        this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\r\n    }\r\n\r\n    public setDepthTestEnabled(enabled: boolean): void {\r\n        this._depthTestEnabled = enabled;\r\n    }\r\n\r\n    public setDepthWriteEnabled(enabled: boolean): void {\r\n        this._depthWriteEnabled = enabled;\r\n    }\r\n\r\n    public setDepthCompare(func: Nullable<number>): void {\r\n        this._depthCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilEnabled(enabled: boolean): void {\r\n        this._stencilEnabled = enabled;\r\n    }\r\n\r\n    public setStencilCompare(func: Nullable<number>): void {\r\n        this._stencilFrontCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilPassOp(op: Nullable<number>): void {\r\n        this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackCompare(func: Nullable<number>): void {\r\n        this._stencilBackCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilBackDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilBackDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackPassOp(op: Nullable<number>): void {\r\n        this._stencilBackPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilBackFailOp(op: Nullable<number>): void {\r\n        this._stencilBackFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilReadMask(mask: number): void {\r\n        if (this._stencilReadMask !== mask) {\r\n            this._stencilReadMask = mask;\r\n            this._states[StatePosition.StencilReadMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\r\n        }\r\n    }\r\n\r\n    public setStencilWriteMask(mask: number): void {\r\n        if (this._stencilWriteMask !== mask) {\r\n            this._stencilWriteMask = mask;\r\n            this._states[StatePosition.StencilWriteMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\r\n        }\r\n    }\r\n\r\n    public resetStencilState(): void {\r\n        this.setStencilState(false, Constants.ALWAYS, Constants.KEEP, Constants.REPLACE, Constants.KEEP, 0xff, 0xff);\r\n    }\r\n\r\n    public setStencilState(\r\n        stencilEnabled: boolean,\r\n        compare: Nullable<number>,\r\n        depthFailOp: Nullable<number>,\r\n        passOp: Nullable<number>,\r\n        failOp: Nullable<number>,\r\n        readMask: number,\r\n        writeMask: number,\r\n        backCompare: Nullable<number> = null,\r\n        backDepthFailOp: Nullable<number> = null,\r\n        backPassOp: Nullable<number> = null,\r\n        backFailOp: Nullable<number> = null\r\n    ): void {\r\n        this._stencilEnabled = stencilEnabled;\r\n        this._stencilFrontCompare = (compare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\r\n        this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\r\n        this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\r\n        this._stencilBackCompare = (backCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilBackDepthFailOp = backDepthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[backDepthFailOp];\r\n        this._stencilBackPassOp = backPassOp === null ? 2 /* REPLACE */ : stencilOpToIndex[backPassOp];\r\n        this._stencilBackFailOp = backFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[backFailOp];\r\n        this.setStencilReadMask(readMask);\r\n        this.setStencilWriteMask(writeMask);\r\n    }\r\n\r\n    public setBuffers(\r\n        vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>,\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        this._vertexBuffers = vertexBuffers;\r\n        this._overrideVertexBuffers = overrideVertexBuffers;\r\n        (this.indexBuffer as Nullable<DataBuffer>) = indexBuffer;\r\n    }\r\n\r\n    private static _GetTopology(fillMode: number): GPUPrimitiveTopology {\r\n        switch (fillMode) {\r\n            // Triangle views\r\n            case Constants.MATERIAL_TriangleFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n            case Constants.MATERIAL_PointFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_WireFrameFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            // Draw modes\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_LineListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n                // return this._gl.LINE_LOOP;\r\n                // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"LineLoop is an unsupported fillmode in WebGPU\";\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineStrip;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                // return this._gl.TRIANGLE_FAN;\r\n                // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"TriangleFan is an unsupported fillmode in WebGPU\";\r\n            default:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendOperation(operation: Nullable<number>): GPUBlendOperation {\r\n        switch (operation) {\r\n            case Constants.GL_ALPHA_EQUATION_ADD:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n            case Constants.GL_ALPHA_EQUATION_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.Subtract;\r\n            case Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.ReverseSubtract;\r\n            case Constants.GL_ALPHA_EQUATION_MIN:\r\n                return WebGPUConstants.BlendOperation.Min;\r\n            case Constants.GL_ALPHA_EQUATION_MAX:\r\n                return WebGPUConstants.BlendOperation.Max;\r\n            default:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendFactor(factor: Nullable<number>): GPUBlendFactor {\r\n        switch (factor) {\r\n            case 0:\r\n                return WebGPUConstants.BlendFactor.Zero;\r\n            case 1:\r\n                return WebGPUConstants.BlendFactor.One;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC:\r\n                return WebGPUConstants.BlendFactor.Src;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.SrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.DstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.Dst;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusDst;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED:\r\n                return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR:\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR:\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC1_COLOR:\r\n                return WebGPUConstants.BlendFactor.Src1;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc1;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC1_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Src1Alpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc1Alpha;\r\n            default:\r\n                return WebGPUConstants.BlendFactor.One;\r\n        }\r\n    }\r\n\r\n    private static _GetCompareFunction(compareFunction: number): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case 0: // NEVER\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case 1: // LESS\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case 2: // EQUAL\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case 3: // LEQUAL\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case 4: // GREATER\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case 5: // NOTEQUAL\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            case 6: // GEQUAL\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case 7: // ALWAYS\r\n                return WebGPUConstants.CompareFunction.Always;\r\n        }\r\n        return WebGPUConstants.CompareFunction.Never;\r\n    }\r\n\r\n    private static _GetStencilOpFunction(operation: number): GPUStencilOperation {\r\n        switch (operation) {\r\n            case 0:\r\n                return WebGPUConstants.StencilOperation.Zero;\r\n            case 1:\r\n                return WebGPUConstants.StencilOperation.Keep;\r\n            case 2:\r\n                return WebGPUConstants.StencilOperation.Replace;\r\n            case 3:\r\n                return WebGPUConstants.StencilOperation.IncrementClamp;\r\n            case 4:\r\n                return WebGPUConstants.StencilOperation.DecrementClamp;\r\n            case 5:\r\n                return WebGPUConstants.StencilOperation.Invert;\r\n            case 6:\r\n                return WebGPUConstants.StencilOperation.IncrementWrap;\r\n            case 7:\r\n                return WebGPUConstants.StencilOperation.DecrementWrap;\r\n        }\r\n        return WebGPUConstants.StencilOperation.Keep;\r\n    }\r\n\r\n    private static _GetVertexInputDescriptorFormat(vertexBuffer: VertexBuffer): GPUVertexFormat {\r\n        const type = vertexBuffer.type;\r\n        const normalized = vertexBuffer.normalized;\r\n        const size = vertexBuffer.getSize();\r\n\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Sint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Sint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Sint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Sint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Uint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Uint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Uint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Uint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.FLOAT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Float32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Float32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Float32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Float32x4;\r\n                }\r\n                break;\r\n        }\r\n\r\n        throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\r\n    }\r\n\r\n    private _getAphaBlendState(targetIndex: number): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled[targetIndex]) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 2]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 3]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[targetIndex * 2 + 1]),\r\n        };\r\n    }\r\n\r\n    private _getColorBlendState(targetIndex: number): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 0]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[targetIndex * 4 + 1]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[targetIndex * 2 + 0]),\r\n        };\r\n    }\r\n\r\n    private _setShaderStage(id: number): void {\r\n        if (this._shaderId !== id) {\r\n            this._shaderId = id;\r\n            this._states[StatePosition.ShaderStage] = id;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\r\n        }\r\n    }\r\n\r\n    private _setRasterizationState(topology: number, sampleCount: number): void {\r\n        const frontFace = this._frontFace;\r\n        const cullMode = this._cullEnabled ? this._cullFace : 0;\r\n        const clampDepth = this._clampDepth ? 1 : 0;\r\n        const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\r\n        const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\r\n\r\n        if (this._rasterizationState !== rasterizationState) {\r\n            this._rasterizationState = rasterizationState;\r\n            this._states[StatePosition.RasterizationState] = this._rasterizationState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\r\n        }\r\n    }\r\n\r\n    private _setColorStates(): void {\r\n        // Note that _depthWriteEnabled state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\r\n\r\n        // We need 4 color states because we will be grouping 2 blend targets in each state (and WebGPU supports up to 8 targets).\r\n        // Integers can only be represented exactly in 53 bits with a double, so we can only use 53 bits for each state.\r\n        // We use 25 bits for each blend target (5 bits for the 2 (color/alpha) equations and 4*5 bits for the 4 factors (src/dst color and src/dst alpha)).\r\n        // This means that we need 25*2=50 bits to pack 2 blend targets, and we can use the remaining 3 bits for other states (write mask, depth write, color format).\r\n        // The color format is encoded on 6 bits, so we dispatch it over 3 bits to the last two color states.\r\n\r\n        colorStates[0] = (this._writeMask ? 1 : 0) * 2 ** 53;\r\n        colorStates[1] = (this._depthWriteEnabled ? 1 : 0) * 2 ** 53;\r\n        colorStates[2] = (this._colorFormat & 0x07) * 2 ** 50;\r\n        colorStates[3] = (this._colorFormat & 0x38) * 2 ** 47;\r\n\r\n        let colorStateIndex = 0;\r\n        let isDirty = false;\r\n\r\n        for (let i = 0; i < 8; i++) {\r\n            if (this._alphaBlendEnabled[i]) {\r\n                const index0 = i * 4 + 0;\r\n                const index1 = i * 4 + 1;\r\n                const index2 = i * 4 + 2;\r\n                const index3 = i * 4 + 3;\r\n                const indexEq0 = i * 2 + 0;\r\n                const indexEq1 = i * 2 + 1;\r\n                const eq0 = this._alphaBlendEqParams[indexEq0] === null ? 0 : alphaBlendEquationToIndex[this._alphaBlendEqParams[indexEq0]];\r\n                const eq1 = this._alphaBlendEqParams[indexEq1] === null ? 0 : alphaBlendEquationToIndex[this._alphaBlendEqParams[indexEq1]];\r\n\r\n                colorStates[colorStateIndex] +=\r\n                    ((this._alphaBlendFuncParams[index0] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index0]]) << 0) +\r\n                    ((this._alphaBlendFuncParams[index1] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index1]]) << 5) +\r\n                    ((this._alphaBlendFuncParams[index2] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index2]]) << 10) +\r\n                    ((this._alphaBlendFuncParams[index3] === null ? 1 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[index3]]) << 15) +\r\n                    (eq0 + eq1 * 5) * (1 << 20);\r\n            }\r\n\r\n            if (i & 1) {\r\n                isDirty = isDirty || this._states[StatePosition.ColorStates1 + colorStateIndex] !== colorStates[colorStateIndex];\r\n                this._states[StatePosition.ColorStates1 + colorStateIndex] = colorStates[colorStateIndex];\r\n                colorStateIndex++;\r\n            }\r\n        }\r\n\r\n        if (isDirty) {\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates1);\r\n        }\r\n    }\r\n\r\n    private _setDepthStencilState(): void {\r\n        const stencilState = !this._stencilEnabled\r\n            ? 7 /* ALWAYS */ +\r\n              (1 /* KEEP */ << 3) +\r\n              (1 /* KEEP */ << 6) +\r\n              (1 /* KEEP */ << 9) + // front\r\n              (7 /* ALWAYS */ << 12) +\r\n              (1 /* KEEP */ << 15) +\r\n              (1 /* KEEP */ << 18) +\r\n              (1 /* KEEP */ << 21) // back\r\n            : this._stencilFrontCompare +\r\n              (this._stencilFrontDepthFailOp << 3) +\r\n              (this._stencilFrontPassOp << 6) +\r\n              (this._stencilFrontFailOp << 9) + // front\r\n              (this._stencilBackCompare << 12) +\r\n              (this._stencilBackDepthFailOp << 15) +\r\n              (this._stencilBackPassOp << 18) +\r\n              (this._stencilBackFailOp << 21); // back\r\n\r\n        const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) /* ALWAYS */ << 6) + stencilState * (1 << 10); // stencil front + back\r\n\r\n        if (this._depthStencilState !== depthStencilState) {\r\n            this._depthStencilState = depthStencilState;\r\n            this._states[StatePosition.DepthStencilState] = this._depthStencilState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\r\n        }\r\n    }\r\n\r\n    private _setVertexState(effect: Effect): void {\r\n        const currStateLen = this._statesLength;\r\n        let newNumStates = StatePosition.VertexState;\r\n\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let numVertexBuffers = 0;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n                if (WebGPUCacheRenderPipeline.LogErrorIfNoVertexBuffer) {\r\n                    Logger.Error(\r\n                        `No vertex buffer is provided for the \"${attributes[index]}\" attribute. A default empty vertex buffer will be used, but this may generate errors in some browsers.`\r\n                    );\r\n                }\r\n            }\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\r\n            // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\r\n            // See _getVertexInputDescriptor() below\r\n            if (vertexBuffer._validOffsetRange === undefined) {\r\n                const offset = vertexBuffer.effectiveByteOffset;\r\n                const formatSize = vertexBuffer.getSize(true);\r\n                const byteStride = vertexBuffer.effectiveByteStride;\r\n\r\n                vertexBuffer._validOffsetRange =\r\n                    (offset + formatSize <= this._kMaxVertexBufferStride && byteStride === 0) || (byteStride !== 0 && offset + formatSize <= byteStride);\r\n            }\r\n\r\n            if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\r\n                // we can't combine the previous vertexBuffer with the current one\r\n                this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\r\n                currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\r\n            }\r\n\r\n            const vid = vertexBuffer.hashCode + (location << 7);\r\n\r\n            this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\r\n            this._states[newNumStates++] = vid;\r\n        }\r\n\r\n        this.vertexBuffers.length = numVertexBuffers;\r\n\r\n        this._statesLength = newNumStates;\r\n        this._isDirty = this._isDirty || newNumStates !== currStateLen;\r\n        if (this._isDirty) {\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\r\n        }\r\n    }\r\n\r\n    private _setTextureState(textureState: number): void {\r\n        if (this._textureState !== textureState) {\r\n            this._textureState = textureState;\r\n            this._states[StatePosition.TextureStage] = this._textureState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\r\n        }\r\n    }\r\n\r\n    private _createPipelineLayout(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        if (this._useTextureStage) {\r\n            return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: setDefinition,\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[0] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _createPipelineLayoutWithTextureStage(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\r\n        const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        let bitVal = 1;\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.texture) {\r\n                    const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                    const textureInfo = shaderProcessingContext.availableTextures[name];\r\n                    const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + Constants.AUTOSAMPLERSUFFIX] : null;\r\n\r\n                    let sampleType = textureInfo.sampleType;\r\n                    let samplerType = samplerInfo?.type ?? WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n                    if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\r\n                        // The texture is a 32 bits float texture but the system does not support linear filtering for them OR the texture is a depth texture with \"float\" filtering:\r\n                        // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\r\n                        if (textureInfo.autoBindSampler) {\r\n                            samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\r\n                        }\r\n                        sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\r\n                    }\r\n\r\n                    entry.texture.sampleType = sampleType;\r\n\r\n                    if (samplerInfo) {\r\n                        const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\r\n                        bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler!.type = samplerType;\r\n                    }\r\n\r\n                    bitVal = bitVal << 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: bindGroupLayoutEntries[i],\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts[this._textureState] = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _getVertexInputDescriptor(effect: Effect): GPUVertexBufferLayout[] {\r\n        const descriptors: GPUVertexBufferLayout[] = [];\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let currentGPUAttributes: GPUVertexAttribute[] | undefined;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            let buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\r\n\r\n            // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\r\n            let offset = vertexBuffer.effectiveByteOffset;\r\n            const invalidOffsetRange = !vertexBuffer._validOffsetRange;\r\n            if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\r\n                const vertexBufferDescriptor: GPUVertexBufferLayout = {\r\n                    arrayStride: vertexBuffer.effectiveByteStride,\r\n                    stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.VertexStepMode.Instance : WebGPUConstants.VertexStepMode.Vertex,\r\n                    attributes: [],\r\n                };\r\n\r\n                descriptors.push(vertexBufferDescriptor);\r\n                currentGPUAttributes = vertexBufferDescriptor.attributes;\r\n                if (invalidOffsetRange) {\r\n                    offset = 0; // the offset will be set directly in the setVertexBuffer call\r\n                    buffer = null; // buffer can't be reused\r\n                }\r\n            }\r\n\r\n            currentGPUAttributes.push({\r\n                shaderLocation: location,\r\n                offset,\r\n                format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer),\r\n            });\r\n\r\n            currentGPUBuffer = buffer;\r\n        }\r\n\r\n        return descriptors;\r\n    }\r\n\r\n    private _createRenderPipeline(effect: Effect, topology: GPUPrimitiveTopology, sampleCount: number): GPURenderPipeline {\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const inputStateDescriptor = this._getVertexInputDescriptor(effect);\r\n        const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\r\n\r\n        const colorStates: Array<GPUColorTargetState | null> = [];\r\n\r\n        if (this._vertexBuffers) {\r\n            checkNonFloatVertexBuffers(this._vertexBuffers, effect);\r\n        }\r\n\r\n        if (this._mrtAttachments > 0) {\r\n            for (let i = 0; i < this._mrtFormats.length; ++i) {\r\n                const format = this._mrtFormats[i];\r\n                if (format) {\r\n                    const descr: GPUColorTargetState = {\r\n                        format,\r\n                        writeMask: (this._mrtEnabledMask & (1 << i)) !== 0 ? this._writeMask : 0,\r\n                    };\r\n                    const alphaBlend = this._getAphaBlendState(i < this._numAlphaBlendTargetsEnabled ? i : 0);\r\n                    const colorBlend = this._getColorBlendState(i < this._numAlphaBlendTargetsEnabled ? i : 0);\r\n\r\n                    if (alphaBlend && colorBlend) {\r\n                        descr.blend = {\r\n                            alpha: alphaBlend,\r\n                            color: colorBlend,\r\n                        };\r\n                    }\r\n                    colorStates.push(descr);\r\n                } else {\r\n                    colorStates.push(null);\r\n                }\r\n            }\r\n        } else {\r\n            if (this._webgpuColorFormat[0]) {\r\n                const descr: GPUColorTargetState = {\r\n                    format: this._webgpuColorFormat[0],\r\n                    writeMask: this._writeMask,\r\n                };\r\n                const alphaBlend = this._getAphaBlendState(0);\r\n                const colorBlend = this._getColorBlendState(0);\r\n\r\n                if (alphaBlend && colorBlend) {\r\n                    descr.blend = {\r\n                        alpha: alphaBlend,\r\n                        color: colorBlend,\r\n                    };\r\n                }\r\n                colorStates.push(descr);\r\n            } else {\r\n                colorStates.push(null);\r\n            }\r\n        }\r\n\r\n        const stencilFront: GPUStencilFaceState = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        const stencilBack: GPUStencilFaceState = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilBackCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilBackPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        const topologyIsTriangle = topology === WebGPUConstants.PrimitiveTopology.TriangleList || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n\r\n        let stripIndexFormat: GPUIndexFormat | undefined = undefined;\r\n        if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\r\n            stripIndexFormat = !this.indexBuffer || this.indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\r\n        }\r\n\r\n        const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\r\n\r\n        return this._device.createRenderPipeline({\r\n            label: `RenderPipeline_${colorStates[0]?.format ?? \"nooutput\"}_${this._webgpuDepthStencilFormat ?? \"nodepth\"}_samples${sampleCount}_textureState${this._textureState}`,\r\n            layout: pipelineLayout,\r\n            vertex: {\r\n                module: webgpuPipelineContext.stages!.vertexStage.module,\r\n                entryPoint: webgpuPipelineContext.stages!.vertexStage.entryPoint,\r\n                buffers: inputStateDescriptor,\r\n            },\r\n            primitive: {\r\n                topology,\r\n                stripIndexFormat,\r\n                frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\r\n                cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back,\r\n            },\r\n            fragment: !webgpuPipelineContext.stages!.fragmentStage\r\n                ? undefined\r\n                : {\r\n                      module: webgpuPipelineContext.stages!.fragmentStage.module,\r\n                      entryPoint: webgpuPipelineContext.stages!.fragmentStage.entryPoint,\r\n                      targets: colorStates,\r\n                  },\r\n\r\n            multisample: {\r\n                count: sampleCount,\r\n                /*mask,\r\n                alphaToCoverageEnabled,*/\r\n            },\r\n            depthStencil:\r\n                this._webgpuDepthStencilFormat === undefined\r\n                    ? undefined\r\n                    : {\r\n                          depthWriteEnabled: this._depthWriteEnabled,\r\n                          depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\r\n                          format: this._webgpuDepthStencilFormat,\r\n                          stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFront : undefined,\r\n                          stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilBack : undefined,\r\n                          stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\r\n                          stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\r\n                          depthBias: this._depthBias,\r\n                          depthBiasClamp: topologyIsTriangle ? this._depthBiasClamp : 0,\r\n                          depthBiasSlopeScale: topologyIsTriangle ? this._depthBiasSlopeScale : 0,\r\n                      },\r\n        });\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\n\r\n/** @internal */\r\nclass NodeState {\r\n    public values: { [id: number]: NodeState };\r\n    public pipeline: GPURenderPipeline;\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n\r\n    public count(): [number, number] {\r\n        let countNode = 0,\r\n            countPipeline = this.pipeline ? 1 : 0;\r\n        for (const value in this.values) {\r\n            const node = this.values[value];\r\n            const [childCountNodes, childCoundPipeline] = node.count();\r\n            countNode += childCountNodes;\r\n            countPipeline += childCoundPipeline;\r\n            countNode++;\r\n        }\r\n        return [countNode, countPipeline];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {\r\n    private static _Cache: NodeState = new NodeState();\r\n\r\n    private _nodeStack: NodeState[];\r\n\r\n    public static GetNodeCounts(): { nodeCount: number; pipelineCount: number } {\r\n        const counts = WebGPUCacheRenderPipelineTree._Cache.count();\r\n\r\n        return { nodeCount: counts[0], pipelineCount: counts[1] };\r\n    }\r\n\r\n    public static _GetPipelines(node: NodeState, pipelines: Array<Array<number>>, curPath: Array<number>, curPathLen: number): void {\r\n        if (node.pipeline) {\r\n            const path = curPath.slice();\r\n            path.length = curPathLen;\r\n            pipelines.push(path);\r\n        }\r\n        for (const value in node.values) {\r\n            const nnode = node.values[value];\r\n            curPath[curPathLen] = parseInt(value);\r\n            WebGPUCacheRenderPipelineTree._GetPipelines(nnode, pipelines, curPath, curPathLen + 1);\r\n        }\r\n    }\r\n\r\n    public static GetPipelines(): Array<Array<number>> {\r\n        const pipelines: Array<Array<number>> = [];\r\n        WebGPUCacheRenderPipelineTree._GetPipelines(WebGPUCacheRenderPipelineTree._Cache, pipelines, [], 0);\r\n        return pipelines;\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheRenderPipelineTree._Cache = new NodeState();\r\n    }\r\n\r\n    public override reset(): void {\r\n        this._nodeStack = [];\r\n        this._nodeStack[0] = WebGPUCacheRenderPipelineTree._Cache;\r\n        super.reset();\r\n    }\r\n\r\n    protected _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        let node = this._nodeStack[this._stateDirtyLowestIndex];\r\n        for (let i = this._stateDirtyLowestIndex; i < this._statesLength; ++i) {\r\n            let nn: NodeState | undefined = node.values[this._states[i]];\r\n            if (!nn) {\r\n                nn = new NodeState();\r\n                node.values[this._states[i]] = nn;\r\n            }\r\n            node = nn;\r\n            this._nodeStack[i + 1] = node;\r\n        }\r\n\r\n        param.token = node;\r\n        param.pipeline = node.pipeline;\r\n    }\r\n\r\n    protected _setRenderPipeline(param: { token: NodeState; pipeline: Nullable<GPURenderPipeline> }): void {\r\n        param.token.pipeline = param.pipeline!;\r\n    }\r\n}\r\n", "import type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { StencilStateComposer } from \"../../States/stencilStateComposer\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUStencilStateComposer extends StencilStateComposer {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public override set func(value: number) {\r\n        if (this._func === value) {\r\n            return;\r\n        }\r\n\r\n        this._func = value;\r\n        this._cache.setStencilCompare(value);\r\n    }\r\n\r\n    public override get backFunc(): number {\r\n        return this._backFunc;\r\n    }\r\n\r\n    public override set backFunc(value: number) {\r\n        if (this._backFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._backFunc = value;\r\n        this._cache.setStencilBackCompare(value);\r\n    }\r\n\r\n    public override get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public override set funcMask(value: number) {\r\n        if (this._funcMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcMask = value;\r\n        this._cache.setStencilReadMask(value);\r\n    }\r\n\r\n    public override get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public override set opStencilFail(value: number) {\r\n        if (this._opStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilFail = value;\r\n        this._cache.setStencilFailOp(value);\r\n    }\r\n\r\n    public override get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public override set opDepthFail(value: number) {\r\n        if (this._opDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opDepthFail = value;\r\n        this._cache.setStencilDepthFailOp(value);\r\n    }\r\n\r\n    public override get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public override set opStencilDepthPass(value: number) {\r\n        if (this._opStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilDepthPass = value;\r\n        this._cache.setStencilPassOp(value);\r\n    }\r\n\r\n    public override get backOpStencilFail(): number {\r\n        return this._backOpStencilFail;\r\n    }\r\n\r\n    public override set backOpStencilFail(value: number) {\r\n        if (this._backOpStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpStencilFail = value;\r\n        this._cache.setStencilBackFailOp(value);\r\n    }\r\n\r\n    public override get backOpDepthFail(): number {\r\n        return this._backOpDepthFail;\r\n    }\r\n\r\n    public override set backOpDepthFail(value: number) {\r\n        if (this._backOpDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpDepthFail = value;\r\n        this._cache.setStencilBackDepthFailOp(value);\r\n    }\r\n\r\n    public override get backOpStencilDepthPass(): number {\r\n        return this._backOpStencilDepthPass;\r\n    }\r\n\r\n    public override set backOpStencilDepthPass(value: number) {\r\n        if (this._backOpStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._backOpStencilDepthPass = value;\r\n        this._cache.setStencilBackPassOp(value);\r\n    }\r\n\r\n    public override get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public override set mask(value: number) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n        this._cache.setStencilWriteMask(value);\r\n    }\r\n\r\n    public override get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public override set enabled(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._cache.setStencilEnabled(value);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetStencilState();\r\n    }\r\n\r\n    public override apply() {\r\n        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;\r\n\r\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial!.enabled : this.stencilGlobal.enabled;\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial!.mask : this.stencilGlobal.mask;\r\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial!.funcRef : this.stencilGlobal.funcRef;\r\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial!.funcMask : this.stencilGlobal.funcMask;\r\n        this.func = stencilMaterialEnabled ? this.stencilMaterial!.func : this.stencilGlobal.func;\r\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.opStencilFail : this.stencilGlobal.opStencilFail;\r\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.opDepthFail : this.stencilGlobal.opDepthFail;\r\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\r\n        this.backFunc = stencilMaterialEnabled ? this.stencilMaterial!.backFunc : this.stencilGlobal.backFunc;\r\n        this.backOpStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.backOpStencilFail : this.stencilGlobal.backOpStencilFail;\r\n        this.backOpDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.backOpDepthFail : this.stencilGlobal.backOpDepthFail;\r\n        this.backOpStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.backOpStencilDepthPass : this.stencilGlobal.backOpStencilDepthPass;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { DepthCullingState } from \"../../States/depthCullingState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class WebGPUDepthCullingState extends DepthCullingState {\r\n    private _cache: WebGPUCacheRenderPipeline;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     * @param cache\r\n     */\r\n    public constructor(cache: WebGPUCacheRenderPipeline) {\r\n        super(false);\r\n        this._cache = cache;\r\n        this.reset();\r\n    }\r\n\r\n    public override get zOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    public override set zOffset(value: number) {\r\n        if (this._zOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffset = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBiasSlopeScale(value);\r\n    }\r\n\r\n    public override get zOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    public override set zOffsetUnits(value: number) {\r\n        if (this._zOffsetUnits === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffsetUnits = value;\r\n        this._isZOffsetDirty = true;\r\n        this._cache.setDepthBias(value);\r\n    }\r\n\r\n    public override get cullFace(): Nullable<number> {\r\n        return this._cullFace;\r\n    }\r\n\r\n    public override set cullFace(value: Nullable<number>) {\r\n        if (this._cullFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._cullFace = value;\r\n        this._isCullFaceDirty = true;\r\n        this._cache.setCullFace(value ?? 1);\r\n    }\r\n\r\n    public override get cull(): Nullable<boolean> {\r\n        return this._cull;\r\n    }\r\n\r\n    public override set cull(value: Nullable<boolean>) {\r\n        if (this._cull === value) {\r\n            return;\r\n        }\r\n\r\n        this._cull = value;\r\n        this._isCullDirty = true;\r\n        this._cache.setCullEnabled(!!value);\r\n    }\r\n\r\n    public override get depthFunc(): Nullable<number> {\r\n        return this._depthFunc;\r\n    }\r\n\r\n    public override set depthFunc(value: Nullable<number>) {\r\n        if (this._depthFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthFunc = value;\r\n        this._isDepthFuncDirty = true;\r\n        this._cache.setDepthCompare(value);\r\n    }\r\n\r\n    public override get depthMask(): boolean {\r\n        return this._depthMask;\r\n    }\r\n\r\n    public override set depthMask(value: boolean) {\r\n        if (this._depthMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthMask = value;\r\n        this._isDepthMaskDirty = true;\r\n        this._cache.setDepthWriteEnabled(value);\r\n    }\r\n\r\n    public override get depthTest(): boolean {\r\n        return this._depthTest;\r\n    }\r\n\r\n    public override set depthTest(value: boolean) {\r\n        if (this._depthTest === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthTest = value;\r\n        this._isDepthTestDirty = true;\r\n        this._cache.setDepthTestEnabled(value);\r\n    }\r\n\r\n    public override get frontFace(): Nullable<number> {\r\n        return this._frontFace;\r\n    }\r\n\r\n    public override set frontFace(value: Nullable<number>) {\r\n        if (this._frontFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._frontFace = value;\r\n        this._isFrontFaceDirty = true;\r\n        this._cache.setFrontFace(value ?? 2);\r\n    }\r\n\r\n    public override reset() {\r\n        super.reset();\r\n        this._cache.resetDepthCullingState();\r\n    }\r\n\r\n    public override apply() {\r\n        // nothing to do\r\n    }\r\n}\r\n", "import { Constants } from \"../../Engines/constants\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\r\n */\r\nexport class ExternalTexture {\r\n    /**\r\n     * Checks if a texture is an external or internal texture\r\n     * @param texture the external or internal texture\r\n     * @returns true if the texture is an external texture, else false\r\n     */\r\n    public static IsExternalTexture(texture: ExternalTexture | InternalTexture): texture is ExternalTexture {\r\n        return (texture as ExternalTexture).underlyingResource !== undefined;\r\n    }\r\n\r\n    private _video: HTMLVideoElement;\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ExternalTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExternalTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying texture object\r\n     */\r\n    public get underlyingResource(): any {\r\n        return this._video;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     */\r\n    public useMipMaps: boolean = false;\r\n\r\n    /**\r\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\r\n     */\r\n    public readonly type = Constants.TEXTURETYPE_UNDEFINED;\r\n\r\n    /**\r\n     * The format of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the format\r\n     */\r\n    public readonly format = Constants.TEXTUREFORMAT_UNDEFINED;\r\n\r\n    /**\r\n     * Gets the unique id of this texture\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Constructs the texture\r\n     * @param video The video the texture should be wrapped around\r\n     */\r\n    constructor(video: HTMLVideoElement) {\r\n        this._video = video;\r\n        this.uniqueId = InternalTexture._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {}\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatOrDepthTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    // The texture state is a bitfield where each bit is set if the texture is a float32 texture (calculated in @WebGPUEngine._draw).\r\n    // Float32 textures must be handled differently because float filtering may not be supported by the underlying browser implementation.\r\n    // In this case, we must configure the sampler as \"non filtering\", as well as set the texture sample type to \"unfilterable-float\" when creating the bind group layout.\r\n    // When that happens, we end up with different bind group layouts (depending on which type of textures have been set in the material), that we must all store\r\n    // in the WebGPUPipelineContext (see @WebGPUPipelineContext.bindGroupLayouts) for later retrieval in the bind group cache implementation (see @WebGPUCacheBindGroups.getBindGroups), thanks to this property.\r\n    // There's the same problem with depth textures, where \"float\" filtering is not supported either.\r\n    public textureState: number;\r\n\r\n    public useVertexPulling = false;\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatOrDepthTextures() {\r\n        return this._numFloatOrDepthTextures > 0;\r\n    }\r\n\r\n    protected _numFloatOrDepthTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.textureState = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatOrDepthTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatOrDepthTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatOrDepthTexture) {\r\n            this._numFloatOrDepthTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatOrDepthTexture =\r\n                texture.type === Constants.TEXTURETYPE_FLOAT ||\r\n                (texture.format >= Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 && texture.format <= Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatOrDepthTexture) {\r\n                this._numFloatOrDepthTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatOrDepthTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n", "import type { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDrawContext } from \"../IDrawContext\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/**\r\n * WebGPU implementation of the IDrawContext interface.\r\n * This class manages the draw context for WebGPU, including buffers and indirect draw data.\r\n */\r\nexport class WebGPUDrawContext implements IDrawContext {\r\n    private static _Counter = 0;\r\n\r\n    /**\r\n     * Bundle used in fast mode (when compatibilityMode==false)\r\n     */\r\n    public fastBundle?: GPURenderBundle;\r\n    /**\r\n     * Cache of the bind groups. Will be reused for the next draw if isDirty==false (and materialContext.isDirty==false)\r\n     */\r\n    public bindGroups?: GPUBindGroup[];\r\n\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     * By default, indirect draws are enabled in NON compatibility mode only\r\n     * To enable indirect draws in compatibility mode (done by the end user), enableIndirectDraw must be set to true\r\n     */\r\n    public _enableIndirectDrawInCompatMode = false;\r\n\r\n    /**\r\n     * Buffers (uniform / storage) used for the draw call\r\n     */\r\n    public buffers: { [name: string]: Nullable<WebGPUDataBuffer> };\r\n\r\n    public indirectDrawBuffer?: GPUBuffer;\r\n\r\n    private _materialContextUpdateId: number;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _useInstancing: boolean;\r\n    private _indirectDrawData?: Uint32Array;\r\n    private _currentInstanceCount: number;\r\n    private _isDirty: boolean;\r\n    private _enableIndirectDraw: boolean;\r\n    private _vertexPullingEnabled: boolean;\r\n\r\n    /**\r\n     * Checks if the draw context is dirty.\r\n     * @param materialContextUpdateId The update ID of the material context associated with the draw context.\r\n     * @returns True if the draw or material context is dirty, false otherwise.\r\n     */\r\n    public isDirty(materialContextUpdateId: number): boolean {\r\n        return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\r\n    }\r\n\r\n    /**\r\n     * Resets the dirty state of the draw context.\r\n     * @param materialContextUpdateId The update ID of the material context associated with the draw context.\r\n     */\r\n    public resetIsDirty(materialContextUpdateId: number): void {\r\n        this._isDirty = false;\r\n        this._materialContextUpdateId = materialContextUpdateId;\r\n    }\r\n\r\n    public get enableIndirectDraw() {\r\n        return this._enableIndirectDraw;\r\n    }\r\n\r\n    public set enableIndirectDraw(enable: boolean) {\r\n        this._enableIndirectDrawInCompatMode = true;\r\n\r\n        if (this._enableIndirectDraw === enable) {\r\n            return;\r\n        }\r\n\r\n        this._enableIndirectDraw = enable;\r\n\r\n        if (!enable && !this._useInstancing && this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        } else if (enable && !this.indirectDrawBuffer) {\r\n            this.indirectDrawBuffer = this._bufferManager.createRawBuffer(\r\n                20,\r\n                WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect | WebGPUConstants.BufferUsage.Storage,\r\n                undefined,\r\n                \"IndirectDrawBuffer\"\r\n            );\r\n            this._indirectDrawData = new Uint32Array(5);\r\n            this._indirectDrawData[3] = 0;\r\n            this._indirectDrawData[4] = 0;\r\n        }\r\n    }\r\n\r\n    public get useInstancing() {\r\n        return this._useInstancing;\r\n    }\r\n\r\n    public set useInstancing(use: boolean) {\r\n        if (this._useInstancing === use) {\r\n            return;\r\n        }\r\n\r\n        this._useInstancing = use;\r\n        this._currentInstanceCount = -1;\r\n\r\n        const enableIndirectDrawInCompatMode = this._enableIndirectDrawInCompatMode;\r\n\r\n        this.enableIndirectDraw = use;\r\n\r\n        this._enableIndirectDrawInCompatMode = enableIndirectDrawInCompatMode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new WebGPUDrawContext.\r\n     * @param bufferManager The buffer manager used to manage WebGPU buffers.\r\n     * @param _dummyIndexBuffer A dummy index buffer to be bound as the \"indices\"\r\n     * storage buffer when no index buffer is provided.\r\n     */\r\n    constructor(\r\n        bufferManager: WebGPUBufferManager,\r\n        private _dummyIndexBuffer: WebGPUDataBuffer\r\n    ) {\r\n        this._bufferManager = bufferManager;\r\n        this.uniqueId = WebGPUDrawContext._Counter++;\r\n        this._useInstancing = false;\r\n        this._currentInstanceCount = 0;\r\n        this._enableIndirectDraw = false;\r\n        this._vertexPullingEnabled = false;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.buffers = {};\r\n        this._isDirty = true;\r\n        this._materialContextUpdateId = 0;\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this._vertexPullingEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * Associates a buffer to the draw context.\r\n     * @param name The name of the buffer.\r\n     * @param buffer The buffer to set.\r\n     */\r\n    public setBuffer(name: string, buffer: Nullable<WebGPUDataBuffer>): void {\r\n        this._isDirty ||= buffer?.uniqueId !== this.buffers[name]?.uniqueId;\r\n\r\n        this.buffers[name] = buffer;\r\n    }\r\n\r\n    public setIndirectData(indexOrVertexCount: number, instanceCount: number, firstIndexOrVertex: number, forceUpdate = false): void {\r\n        if ((!forceUpdate && instanceCount === this._currentInstanceCount) || !this.indirectDrawBuffer || !this._indirectDrawData) {\r\n            // The current buffer is already up to date so do nothing\r\n            // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\r\n            // are supposed to not change during the lifetime of a draw context\r\n            return;\r\n        }\r\n        this._currentInstanceCount = instanceCount;\r\n\r\n        this._indirectDrawData[0] = indexOrVertexCount;\r\n        this._indirectDrawData[1] = instanceCount;\r\n        this._indirectDrawData[2] = firstIndexOrVertex;\r\n\r\n        this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\r\n    }\r\n\r\n    public setVertexPulling(\r\n        useVertexPulling: boolean,\r\n        webgpuPipelineContext: WebGPUPipelineContext,\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [kind: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        if (this._vertexPullingEnabled === useVertexPulling) {\r\n            return;\r\n        }\r\n\r\n        this._vertexPullingEnabled = useVertexPulling;\r\n        this._isDirty = true;\r\n\r\n        const bufferNames = webgpuPipelineContext.shaderProcessingContext.bufferNames;\r\n\r\n        if (overrideVertexBuffers) {\r\n            for (const attributeName in overrideVertexBuffers) {\r\n                const vertexBuffer = overrideVertexBuffers[attributeName];\r\n                if (!vertexBuffer || bufferNames.indexOf(attributeName) === -1) {\r\n                    continue;\r\n                }\r\n\r\n                const buffer = vertexBuffer.effectiveBuffer as Nullable<WebGPUDataBuffer>;\r\n\r\n                this.setBuffer(attributeName, useVertexPulling ? buffer : null);\r\n            }\r\n        }\r\n\r\n        for (const attributeName in vertexBuffers) {\r\n            if (overrideVertexBuffers && attributeName in overrideVertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const vertexBuffer = vertexBuffers[attributeName];\r\n            if (!vertexBuffer || bufferNames.indexOf(attributeName) === -1) {\r\n                continue;\r\n            }\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer as Nullable<WebGPUDataBuffer>;\r\n\r\n            this.setBuffer(attributeName, useVertexPulling ? buffer : null);\r\n        }\r\n\r\n        if (bufferNames.indexOf(\"indices\") !== -1) {\r\n            this.setBuffer(\"indices\", !useVertexPulling ? null : ((indexBuffer as WebGPUDataBuffer) ?? this._dummyIndexBuffer));\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        }\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this.buffers = undefined as any;\r\n        this._enableIndirectDraw = false;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\n/**\r\n * Sampler hash codes are 19 bits long, so using a start value of 2^20 for buffer ids will ensure we can't have any collision with the sampler hash codes\r\n */\r\nconst BufferIdStart = 1 << 20;\r\n\r\n/**\r\n * textureIdStart is added to texture ids to ensure we can't have any collision with the buffer ids / sampler hash codes.\r\n * 2^35 for textureIdStart means we can have:\r\n * - 2^(35-20) = 2^15 = 32768 possible buffer ids\r\n * - 2^(53-35) = 2^18 = 524288 possible texture ids\r\n */\r\nconst TextureIdStart = 2 ** 35;\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    public static ResetCache() {\r\n        WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     * @returns a bind group array\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = (drawContext.buffers[bufferName]?.uniqueId ?? 0) + BufferIdStart;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = (materialContext.textures[textureName]?.texture?.uniqueId ?? 0) + TextureIdStart;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode, sampler.label);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" not found in the material context. Make sure you bound it. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! name=\"${name}\", entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" not found in the material context. Make sure you bound it (something like effect.setTexture(\"${name}\", texture)). entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `External texture \"${name}\" not found in the material context. Make sure you bound it. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(\r\n                                materialContext,\r\n                                (key: string, value: any) => (key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\" in the draw context. Make sure you bound it. entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadVertexShader\";\nconst shader = `uniform depthValue: f32;const pos=array(\nvec2f(-1.0,1.0),\nvec2f(1.0,1.0),\nvec2f(-1.0,-1.0),\nvec2f(1.0,-1.0)\n);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.position=vec4f(pos[input.vertexIndex],uniforms.depthValue,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadVertexShaderWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadPixelShader\";\nconst shader = `uniform color: vec4f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=uniforms.color;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadPixelShaderWGSL = { name, shader };\n", "import type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IColor4Like } from \"../../Maths/math.like\";\r\nimport type { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./webgpuCacheRenderPipeline\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./webgpuCacheRenderPipelineTree\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager\";\r\n\r\nimport \"../../ShadersWGSL/clearQuad.vertex\";\r\nimport \"../../ShadersWGSL/clearQuad.fragment\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport class WebGPUClearQuad {\r\n    private _device: GPUDevice;\r\n    private _engine: WebGPUEngine;\r\n    private _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    private _effect: Effect;\r\n    private _bindGroups: { [id: string]: GPUBindGroup[] } = {};\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _bundleCache: { [key: string]: GPURenderBundle } = {};\r\n    private _keyTemp: number[] = [];\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._depthTextureFormat = format;\r\n        this._cacheRenderPipeline.setDepthStencilFormat(format);\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n    }\r\n\r\n    public setMRTAttachments(attachments: number[], textureArray: InternalTexture[], textureCount: number): void {\r\n        this._cacheRenderPipeline.setMRT(textureArray, textureCount);\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    }\r\n\r\n    constructor(device: GPUDevice, engine: WebGPUEngine, emptyVertexBuffer: VertexBuffer) {\r\n        this._device = device;\r\n        this._engine = engine;\r\n\r\n        this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer);\r\n        this._cacheRenderPipeline.setDepthTestEnabled(false);\r\n        this._cacheRenderPipeline.setStencilReadMask(0xff);\r\n\r\n        this._effect = engine.createEffect(\"clearQuad\", [], [\"color\", \"depthValue\"], undefined, undefined, undefined, undefined, undefined, undefined, ShaderLanguage.WGSL);\r\n    }\r\n\r\n    public clear(\r\n        renderPass: Nullable<GPURenderPassEncoder>,\r\n        clearColor?: Nullable<IColor4Like>,\r\n        clearDepth?: boolean,\r\n        clearStencil?: boolean,\r\n        sampleCount = 1\r\n    ): Nullable<GPURenderBundle> {\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder;\r\n        let bundle: Nullable<GPURenderBundle> = null;\r\n        let bundleKey: string;\r\n\r\n        const isRTTPass = !!this._engine._currentRenderTarget;\r\n\r\n        if (renderPass) {\r\n            renderPass2 = renderPass;\r\n        } else {\r\n            let idx = 0;\r\n            this._keyTemp.length = 0;\r\n            for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {\r\n                this._keyTemp[idx++] = renderableTextureFormatToIndex[this._cacheRenderPipeline.colorFormats[i] ?? \"\"];\r\n            }\r\n\r\n            const depthStencilFormatIndex = renderableTextureFormatToIndex[this._depthTextureFormat ?? 0];\r\n\r\n            this._keyTemp[idx] =\r\n                (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) +\r\n                (clearDepth ? 2 ** 32 : 0) +\r\n                (clearStencil ? 2 ** 33 : 0) +\r\n                (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) +\r\n                (isRTTPass ? 2 ** 35 : 0) +\r\n                (sampleCount > 1 ? 2 ** 36 : 0) +\r\n                depthStencilFormatIndex * 2 ** 37;\r\n\r\n            bundleKey = this._keyTemp.join(\"_\");\r\n            bundle = this._bundleCache[bundleKey];\r\n\r\n            if (bundle) {\r\n                return bundle;\r\n            }\r\n\r\n            renderPass2 = this._device.createRenderBundleEncoder({\r\n                label: \"clearQuadRenderBundle\",\r\n                colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                depthStencilFormat: this._depthTextureFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);\r\n        this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));\r\n        this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 0xff : 0);\r\n        this._cacheRenderPipeline.setStencilCompare(clearStencil ? Constants.ALWAYS : Constants.NEVER);\r\n        this._cacheRenderPipeline.setStencilPassOp(clearStencil ? Constants.REPLACE : Constants.KEEP);\r\n        this._cacheRenderPipeline.setWriteMask(clearColor ? 0xf : 0);\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(Constants.MATERIAL_TriangleStripDrawMode, this._effect, sampleCount);\r\n\r\n        const webgpuPipelineContext = this._effect._pipelineContext as WebGPUPipelineContext;\r\n\r\n        if (clearColor) {\r\n            this._effect.setDirectColor4(\"color\", clearColor);\r\n        }\r\n\r\n        this._effect.setFloat(\"depthValue\", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);\r\n\r\n        webgpuPipelineContext.uniformBuffer!.update();\r\n\r\n        const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;\r\n        const bufferLeftOver = webgpuPipelineContext.uniformBuffer!.getBuffer() as WebGPUDataBuffer;\r\n\r\n        const key = bufferLeftOver.uniqueId + \"-\" + bufferInternals.uniqueId;\r\n\r\n        let bindGroups = this._bindGroups[key];\r\n\r\n        if (!bindGroups) {\r\n            const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[0];\r\n            bindGroups = this._bindGroups[key] = [];\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup0-${key}`,\r\n                    layout: bindGroupLayouts[0],\r\n                    entries: [],\r\n                })\r\n            );\r\n            if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {\r\n                bindGroups.push(\r\n                    this._device.createBindGroup({\r\n                        label: `clearQuadBindGroup1-${key}`,\r\n                        layout: bindGroupLayouts[1],\r\n                        entries: [],\r\n                    })\r\n                );\r\n            }\r\n            bindGroups.push(\r\n                this._device.createBindGroup({\r\n                    label: `clearQuadBindGroup${WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2}-${key}`,\r\n                    layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: {\r\n                                buffer: bufferInternals.underlyingResource,\r\n                                size: bufferInternals.capacity,\r\n                            },\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: {\r\n                                buffer: bufferLeftOver.underlyingResource,\r\n                                size: bufferLeftOver.capacity,\r\n                            },\r\n                        },\r\n                    ],\r\n                })\r\n            );\r\n        }\r\n\r\n        renderPass2.setPipeline(pipeline);\r\n        for (let i = 0; i < bindGroups.length; ++i) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n        renderPass2.draw(4, 1, 0, 0);\r\n\r\n        if (!renderPass) {\r\n            bundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            this._bundleCache[bundleKey!] = bundle;\r\n        }\r\n\r\n        return bundle;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\n/** @internal */\r\ninterface IWebGPURenderItem {\r\n    run(renderPass: GPURenderPassEncoder): void;\r\n    clone(): IWebGPURenderItem;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemViewport implements IWebGPURenderItem {\r\n    public x: number;\r\n    public y: number;\r\n    public w: number;\r\n    public h: number;\r\n\r\n    public constructor(x: number, y: number, w: number, h: number) {\r\n        this.x = Math.floor(x);\r\n        this.y = Math.floor(y);\r\n        this.w = Math.floor(w);\r\n        this.h = Math.floor(h);\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemViewport {\r\n        return new WebGPURenderItemViewport(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemScissor implements IWebGPURenderItem {\r\n    public constructor(\r\n        public x: number,\r\n        public y: number,\r\n        public w: number,\r\n        public h: number\r\n    ) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setScissorRect(this.x, this.y, this.w, this.h);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemScissor {\r\n        return new WebGPURenderItemScissor(this.x, this.y, this.w, this.h);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemStencilRef implements IWebGPURenderItem {\r\n    public constructor(public ref: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setStencilReference(this.ref);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemStencilRef {\r\n        return new WebGPURenderItemStencilRef(this.ref);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBlendColor implements IWebGPURenderItem {\r\n    public constructor(public color: Nullable<number>[]) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.setBlendConstant(this.color as GPUColor);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBlendColor {\r\n        return new WebGPURenderItemBlendColor(this.color);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemBeginOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor(public query: number) {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.beginOcclusionQuery(this.query);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBeginOcclusionQuery {\r\n        return new WebGPURenderItemBeginOcclusionQuery(this.query);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPURenderItemEndOcclusionQuery implements IWebGPURenderItem {\r\n    public constructor() {}\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.endOcclusionQuery();\r\n    }\r\n\r\n    public clone(): WebGPURenderItemEndOcclusionQuery {\r\n        return new WebGPURenderItemEndOcclusionQuery();\r\n    }\r\n}\r\n\r\nclass WebGPURenderItemBundles implements IWebGPURenderItem {\r\n    public bundles: GPURenderBundle[];\r\n\r\n    public constructor() {\r\n        this.bundles = [];\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        renderPass.executeBundles(this.bundles);\r\n    }\r\n\r\n    public clone(): WebGPURenderItemBundles {\r\n        const cloned = new WebGPURenderItemBundles();\r\n        cloned.bundles = this.bundles;\r\n        return cloned;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUBundleList {\r\n    private _device: GPUDevice;\r\n    private _bundleEncoder: GPURenderBundleEncoder | undefined;\r\n\r\n    private _list: IWebGPURenderItem[];\r\n    private _listLength: number;\r\n\r\n    private _currentItemIsBundle: boolean;\r\n    private _currentBundleList: GPURenderBundle[];\r\n\r\n    public numDrawCalls = 0;\r\n\r\n    public constructor(device: GPUDevice) {\r\n        this._device = device;\r\n        this._list = new Array(10);\r\n        this._listLength = 0;\r\n    }\r\n\r\n    public addBundle(bundle?: GPURenderBundle): void {\r\n        if (!this._currentItemIsBundle) {\r\n            const item = new WebGPURenderItemBundles();\r\n\r\n            this._list[this._listLength++] = item;\r\n            this._currentBundleList = item.bundles;\r\n            this._currentItemIsBundle = true;\r\n        }\r\n        if (bundle) {\r\n            this._currentBundleList.push(bundle);\r\n        }\r\n    }\r\n\r\n    private _finishBundle(): void {\r\n        if (this._currentItemIsBundle && this._bundleEncoder) {\r\n            this._currentBundleList.push(this._bundleEncoder.finish());\r\n            this._bundleEncoder = undefined;\r\n            this._currentItemIsBundle = false;\r\n        }\r\n    }\r\n\r\n    public addItem(item: IWebGPURenderItem) {\r\n        this._finishBundle();\r\n        this._list[this._listLength++] = item;\r\n        this._currentItemIsBundle = false;\r\n    }\r\n\r\n    public getBundleEncoder(colorFormats: (GPUTextureFormat | null)[], depthStencilFormat: GPUTextureFormat | undefined, sampleCount: number): GPURenderBundleEncoder {\r\n        if (!this._currentItemIsBundle) {\r\n            this.addBundle();\r\n            this._bundleEncoder = this._device.createRenderBundleEncoder({\r\n                colorFormats,\r\n                depthStencilFormat,\r\n                sampleCount: WebGPUTextureHelper.GetSample(sampleCount),\r\n            });\r\n        }\r\n        return this._bundleEncoder!;\r\n    }\r\n\r\n    public close(): void {\r\n        this._finishBundle();\r\n    }\r\n\r\n    public run(renderPass: GPURenderPassEncoder) {\r\n        this.close();\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            this._list[i].run(renderPass);\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this._listLength = 0;\r\n        this._currentItemIsBundle = false;\r\n        this.numDrawCalls = 0;\r\n    }\r\n\r\n    public clone(): WebGPUBundleList {\r\n        this.close();\r\n\r\n        const cloned = new WebGPUBundleList(this._device);\r\n\r\n        cloned._list = new Array(this._listLength);\r\n        cloned._listLength = this._listLength;\r\n        cloned.numDrawCalls = this.numDrawCalls;\r\n\r\n        for (let i = 0; i < this._listLength; ++i) {\r\n            cloned._list[i] = this._list[i].clone();\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { QueryType } from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUQuerySet {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _count: number;\r\n    private _canUseMultipleBuffers: boolean;\r\n    private _querySet: GPUQuerySet;\r\n    private _queryBuffer: GPUBuffer;\r\n    private _dstBuffers: GPUBuffer[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, count: number, type: QueryType, device: GPUDevice, bufferManager: WebGPUBufferManager, canUseMultipleBuffers = true, label?: string) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n        this._count = count;\r\n        this._canUseMultipleBuffers = canUseMultipleBuffers;\r\n\r\n        this._querySet = device.createQuerySet({\r\n            label: label ?? \"QuerySet\",\r\n            type,\r\n            count,\r\n        });\r\n\r\n        this._queryBuffer = bufferManager.createRawBuffer(8 * count, WebGPUConstants.BufferUsage.QueryResolve | WebGPUConstants.BufferUsage.CopySrc, undefined, \"QueryBuffer\");\r\n\r\n        if (!canUseMultipleBuffers) {\r\n            this._dstBuffers.push(\r\n                this._bufferManager.createRawBuffer(\r\n                    8 * this._count,\r\n                    WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                    undefined,\r\n                    \"QueryBufferNoMultipleBuffers\"\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getBuffer(firstQuery: number, queryCount: number): GPUBuffer | null {\r\n        if (!this._canUseMultipleBuffers && this._dstBuffers.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const encoderResult = this._device.createCommandEncoder();\r\n\r\n        let buffer: GPUBuffer;\r\n        if (this._dstBuffers.length === 0) {\r\n            buffer = this._bufferManager.createRawBuffer(\r\n                8 * this._count,\r\n                WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n                undefined,\r\n                \"QueryBufferAdditionalBuffer\"\r\n            );\r\n        } else {\r\n            buffer = this._dstBuffers[this._dstBuffers.length - 1];\r\n            this._dstBuffers.length--;\r\n        }\r\n\r\n        encoderResult.resolveQuerySet(this._querySet, firstQuery, queryCount, this._queryBuffer, 0);\r\n        encoderResult.copyBufferToBuffer(this._queryBuffer, 0, buffer, 0, 8 * queryCount);\r\n\r\n        this._device.queue.submit([encoderResult.finish()]);\r\n\r\n        return buffer;\r\n    }\r\n\r\n    public async readValues(firstQuery = 0, queryCount = 1): Promise<BigUint64Array | null> {\r\n        const buffer = this._getBuffer(firstQuery, queryCount);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange()).slice();\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return arrayBuf;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return null;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public async readValue(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 1);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n            const value = Number(arrayBuf[0]);\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return value;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return 0;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public async readTwoValuesAndSubtract(firstQuery = 0): Promise<number | null> {\r\n        const buffer = this._getBuffer(firstQuery, 2);\r\n        if (buffer === null) {\r\n            return null;\r\n        }\r\n        const engineId = this._engine.uniqueId;\r\n\r\n        try {\r\n            await buffer.mapAsync(WebGPUConstants.MapMode.Read);\r\n            const arrayBuf = new BigUint64Array(buffer.getMappedRange());\r\n            const value = Number(arrayBuf[1] - arrayBuf[0]);\r\n\r\n            buffer.unmap();\r\n\r\n            this._dstBuffers[this._dstBuffers.length] = buffer;\r\n\r\n            return value;\r\n        } catch (err) {\r\n            if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\r\n                // Engine disposed or context loss/restoration\r\n                return 0;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.destroy();\r\n        this._bufferManager.releaseBuffer(this._queryBuffer);\r\n        for (let i = 0; i < this._dstBuffers.length; ++i) {\r\n            this._bufferManager.releaseBuffer(this._dstBuffers[i]);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable babylonjs/available */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { PerfCounter } from \"../../Misc/perfCounter\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/** @internal */\r\nexport class WebGPUTimestampQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _enabled = false;\r\n    private _gpuFrameTimeCounter: PerfCounter = new PerfCounter();\r\n    private _measureDuration: WebGPUDurationMeasure;\r\n    private _measureDurationState = 0;\r\n\r\n    public get gpuFrameTimeCounter() {\r\n        return this._gpuFrameTimeCounter;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n    }\r\n\r\n    public get enable(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enable(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._measureDurationState = 0;\r\n        if (value) {\r\n            try {\r\n                this._measureDuration = new WebGPUDurationMeasure(this._engine, this._device, this._bufferManager, 2000, \"QuerySet_TimestampQuery\");\r\n            } catch (e) {\r\n                this._enabled = false;\r\n                Logger.Error(\"Could not create a WebGPUDurationMeasure!\\nError: \" + e.message + \"\\nMake sure timestamp query is supported and enabled in your browser.\");\r\n                return;\r\n            }\r\n        } else {\r\n            this._measureDuration.dispose();\r\n        }\r\n    }\r\n\r\n    public startFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._enabled && this._measureDurationState === 0) {\r\n            this._measureDuration.start(commandEncoder);\r\n            this._measureDurationState = 1;\r\n        }\r\n    }\r\n\r\n    public endFrame(commandEncoder: GPUCommandEncoder): void {\r\n        if (this._measureDurationState === 1) {\r\n            this._measureDurationState = 2;\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._measureDuration.stop(commandEncoder).then((duration) => {\r\n                if (duration !== null && duration >= 0) {\r\n                    this._gpuFrameTimeCounter.fetchNewFrame();\r\n                    this._gpuFrameTimeCounter.addCount(duration, true);\r\n                }\r\n                this._measureDurationState = 0;\r\n            });\r\n        }\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (this._enabled) {\r\n            this._measureDuration.startPass(descriptor, index);\r\n        } else {\r\n            descriptor.timestampWrites = undefined;\r\n        }\r\n    }\r\n\r\n    public endPass(index: number, gpuPerfCounter?: WebGPUPerfCounter): void {\r\n        if (!this._enabled || !gpuPerfCounter) {\r\n            return;\r\n        }\r\n\r\n        const currentFrameId = this._engine.frameId;\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n        this._measureDuration.stopPass(index).then((duration_) => {\r\n            gpuPerfCounter._addDuration(currentFrameId, duration_ !== null && duration_ > 0 ? duration_ : 0);\r\n        });\r\n    }\r\n\r\n    public dispose() {\r\n        this._measureDuration?.dispose();\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUDurationMeasure {\r\n    private _querySet: WebGPUQuerySet;\r\n    private _count: number;\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, count = 2, querySetLabel?: string) {\r\n        this._count = count;\r\n        this._querySet = new WebGPUQuerySet(engine, count, WebGPUConstants.QueryType.Timestamp, device, bufferManager, true, querySetLabel);\r\n    }\r\n\r\n    public start(encoder: GPUCommandEncoder): void {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 0);\r\n    }\r\n\r\n    public async stop(encoder: GPUCommandEncoder): Promise<number | null> {\r\n        encoder.writeTimestamp?.(this._querySet.querySet, 1);\r\n\r\n        return encoder.writeTimestamp ? await this._querySet.readTwoValuesAndSubtract(0) : 0;\r\n    }\r\n\r\n    public startPass(descriptor: GPURenderPassDescriptor | GPUComputePassDescriptor, index: number): void {\r\n        if (index + 3 > this._count) {\r\n            throw new Error(\"WebGPUDurationMeasure: index out of range (\" + index + \")\");\r\n        }\r\n\r\n        descriptor.timestampWrites = {\r\n            querySet: this._querySet.querySet,\r\n            beginningOfPassWriteIndex: index + 2,\r\n            endOfPassWriteIndex: index + 3,\r\n        };\r\n    }\r\n\r\n    public async stopPass(index: number): Promise<number | null> {\r\n        return await this._querySet.readTwoValuesAndSubtract(index + 2);\r\n    }\r\n\r\n    public dispose() {\r\n        this._querySet.dispose();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\n\r\n/** @internal */\r\nexport class WebGPUOcclusionQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _currentTotalIndices: number;\r\n    private _countIncrement: number;\r\n    private _querySet: WebGPUQuerySet;\r\n    private _availableIndices: number[] = [];\r\n    private _lastBuffer: Nullable<BigUint64Array>;\r\n    private _frameLastBuffer: number;\r\n    private _frameQuerySetIsDirty = -1;\r\n    private _queryFrameId: number[] = [];\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet.querySet;\r\n    }\r\n\r\n    public get hasQueries(): boolean {\r\n        return this._currentTotalIndices !== this._availableIndices.length;\r\n    }\r\n\r\n    public canBeginQuery(index: number): boolean {\r\n        if (this._frameQuerySetIsDirty === this._engine.frameId || this._queryFrameId[index] === this._engine.frameId) {\r\n            return false;\r\n        }\r\n\r\n        const canBegin = this._engine._getCurrentRenderPassWrapper().renderPassDescriptor!.occlusionQuerySet !== undefined;\r\n\r\n        if (canBegin) {\r\n            this._queryFrameId[index] = this._engine.frameId;\r\n        }\r\n\r\n        return canBegin;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, startCount = 50, incrementCount = 100) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        this._frameLastBuffer = -1;\r\n        this._currentTotalIndices = 0;\r\n        this._countIncrement = incrementCount;\r\n\r\n        this._allocateNewIndices(startCount);\r\n    }\r\n\r\n    public createQuery(): number {\r\n        if (this._availableIndices.length === 0) {\r\n            this._allocateNewIndices();\r\n        }\r\n\r\n        const index = this._availableIndices[this._availableIndices.length - 1];\r\n        this._availableIndices.length--;\r\n\r\n        return index;\r\n    }\r\n\r\n    public deleteQuery(index: number): void {\r\n        this._availableIndices[this._availableIndices.length] = index;\r\n    }\r\n\r\n    public isQueryResultAvailable(index: number): boolean {\r\n        this._retrieveQueryBuffer();\r\n\r\n        return !!this._lastBuffer && index < this._lastBuffer.length;\r\n    }\r\n\r\n    public getQueryResult(index: number): number {\r\n        return Number(this._lastBuffer?.[index] ?? -1);\r\n    }\r\n\r\n    private _retrieveQueryBuffer(): void {\r\n        if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {\r\n            return;\r\n        }\r\n\r\n        if (this._frameLastBuffer !== this._engine.frameId) {\r\n            this._frameLastBuffer = this._engine.frameId;\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {\r\n                this._lastBuffer = arrayBuffer;\r\n            });\r\n        }\r\n    }\r\n\r\n    private _allocateNewIndices(numIndices?: number): void {\r\n        numIndices = numIndices ?? this._countIncrement;\r\n\r\n        this._delayQuerySetDispose();\r\n\r\n        for (let i = 0; i < numIndices; ++i) {\r\n            this._availableIndices.push(this._currentTotalIndices + i);\r\n        }\r\n\r\n        this._currentTotalIndices += numIndices;\r\n        this._querySet = new WebGPUQuerySet(\r\n            this._engine,\r\n            this._currentTotalIndices,\r\n            WebGPUConstants.QueryType.Occlusion,\r\n            this._device,\r\n            this._bufferManager,\r\n            false,\r\n            \"QuerySet_OcclusionQuery_count_\" + this._currentTotalIndices\r\n        );\r\n\r\n        this._frameQuerySetIsDirty = this._engine.frameId;\r\n    }\r\n\r\n    private _delayQuerySetDispose(): void {\r\n        const querySet = this._querySet;\r\n        if (querySet) {\r\n            // Wait a bit before disposing of the queryset, in case some queries are still running for it\r\n            setTimeout(() => querySet.dispose, 1000);\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._querySet?.dispose();\r\n        this._availableIndices.length = 0;\r\n    }\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            Logger.Log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    Logger.Warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options to load the associated Twgsl library\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface TwgslOptions {\r\n    /**\r\n     * Defines an existing instance of Twgsl (useful in modules who do not access the global instance).\r\n     */\r\n    twgsl?: any;\r\n    /**\r\n     * Defines the URL of the twgsl JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the twgsl WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUTintWASM {\r\n    // Default twgsl options.\r\n    private static readonly _TwgslDefaultOptions: TwgslOptions = {\r\n        jsPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.js`,\r\n        wasmPath: `${Tools._DefaultCdnUrl}/twgsl/twgsl.wasm`,\r\n    };\r\n\r\n    public static ShowWGSLShaderCode = false;\r\n\r\n    public static DisableUniformityAnalysis = false;\r\n\r\n    private static _Twgsl: any = null;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public async initTwgsl(twgslOptions?: TwgslOptions): Promise<void> {\r\n        if (WebGPUTintWASM._Twgsl) {\r\n            return;\r\n        }\r\n\r\n        twgslOptions = twgslOptions || {};\r\n        twgslOptions = {\r\n            ...WebGPUTintWASM._TwgslDefaultOptions,\r\n            ...twgslOptions,\r\n        };\r\n\r\n        if (twgslOptions.twgsl) {\r\n            WebGPUTintWASM._Twgsl = twgslOptions.twgsl;\r\n            return;\r\n        }\r\n\r\n        if (twgslOptions.jsPath && twgslOptions.wasmPath) {\r\n            await Tools.LoadBabylonScriptAsync(twgslOptions.jsPath);\r\n        }\r\n\r\n        if ((self as any).twgsl) {\r\n            // eslint-disable-next-line require-atomic-updates\r\n            WebGPUTintWASM._Twgsl = await (self as any).twgsl(Tools.GetBabylonScriptURL(twgslOptions.wasmPath!));\r\n            return;\r\n        }\r\n\r\n        throw new Error(\"twgsl is not available.\");\r\n    }\r\n\r\n    public convertSpirV2WGSL(code: Uint32Array, disableUniformityAnalysis = false): string {\r\n        const ccode = WebGPUTintWASM._Twgsl.convertSpirV2WGSL(code, WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis);\r\n        if (WebGPUTintWASM.ShowWGSLShaderCode) {\r\n            Logger.Log(ccode);\r\n            Logger.Log(\"***********************************************\");\r\n        }\r\n        return WebGPUTintWASM.DisableUniformityAnalysis || disableUniformityAnalysis ? \"diagnostic(off, derivative_uniformity);\\n\" + ccode : ccode;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBundleList } from \"./webgpuBundleList\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/** @internal */\r\nexport class WebGPUSnapshotRendering {\r\n    private _engine: WebGPUEngine;\r\n\r\n    private _record = false;\r\n    private _play = false;\r\n    private _playBundleListIndex = 0;\r\n    private _allBundleLists: WebGPUBundleList[] = [];\r\n    private _modeSaved: number;\r\n    private _bundleList: WebGPUBundleList;\r\n\r\n    private _enabled = false;\r\n    private _mode: number;\r\n\r\n    constructor(engine: WebGPUEngine, renderingMode: number, bundleList: WebGPUBundleList) {\r\n        this._engine = engine;\r\n        this._mode = renderingMode;\r\n        this._bundleList = bundleList;\r\n    }\r\n\r\n    public showDebugLogs = false;\r\n\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public get play() {\r\n        return this._play;\r\n    }\r\n\r\n    public get record() {\r\n        return this._record;\r\n    }\r\n\r\n    public set enabled(activate: boolean) {\r\n        this._log(\"enabled\", `activate=${activate}, mode=${this._mode}`);\r\n\r\n        this._allBundleLists.length = 0;\r\n        this._record = this._enabled = activate;\r\n        this._play = false;\r\n        if (activate) {\r\n            this._modeSaved = this._mode;\r\n            this._mode = Constants.SNAPSHOTRENDERING_STANDARD; // need to reset to standard for the recording pass to avoid some code being bypassed\r\n        }\r\n    }\r\n\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(mode: number) {\r\n        if (this._record) {\r\n            this._modeSaved = mode;\r\n        } else {\r\n            this._mode = mode;\r\n        }\r\n    }\r\n\r\n    public endRenderPass(currentRenderPass: GPURenderPassEncoder): boolean {\r\n        if (!this._record && !this._play) {\r\n            // Snapshot rendering mode is not enabled\r\n            return false;\r\n        }\r\n\r\n        let bundleList: Nullable<WebGPUBundleList> = null;\r\n\r\n        if (this._record) {\r\n            bundleList = this._bundleList.clone();\r\n            this._allBundleLists.push(bundleList);\r\n            this._bundleList.reset();\r\n            this._log(\"endRenderPass\", `bundleList recorded at position #${this._allBundleLists.length - 1}`);\r\n        } else {\r\n            // We are playing the snapshot\r\n            if (this._playBundleListIndex >= this._allBundleLists.length) {\r\n                this._log(\r\n                    \"endRenderPass\",\r\n                    `empty or out-of-sync bundleList (_allBundleLists.length=${this._allBundleLists.length}, playBundleListIndex=${this._playBundleListIndex})`\r\n                );\r\n            } else {\r\n                this._log(\"endRenderPass\", `run bundleList #${this._playBundleListIndex}`);\r\n                bundleList = this._allBundleLists[this._playBundleListIndex++];\r\n            }\r\n        }\r\n\r\n        if (bundleList) {\r\n            bundleList.run(currentRenderPass);\r\n\r\n            if (this._mode === Constants.SNAPSHOTRENDERING_FAST) {\r\n                this._engine._reportDrawCall(bundleList.numDrawCalls);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        if (this._record) {\r\n            // We stop recording and switch to replay mode for the next frames\r\n            this._record = false;\r\n            this._play = true;\r\n            this._mode = this._modeSaved;\r\n            this._log(\"endFrame\", \"bundles recorded, switching to play mode\");\r\n        }\r\n\r\n        this._playBundleListIndex = 0;\r\n    }\r\n\r\n    public reset(): void {\r\n        this._log(\"reset\", \"called\");\r\n        if (this._record) {\r\n            this._mode = this._modeSaved;\r\n        }\r\n        this.enabled = false;\r\n        this.enabled = true;\r\n    }\r\n\r\n    private _log(funcName: string, message: string) {\r\n        if (this.showDebugLogs) {\r\n            Logger.Log(`[Frame: ${this._engine.frameId}] WebGPUSnapshotRendering:${funcName} - ${message}`);\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { DataBuffer } from \"./dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"./buffer\";\r\nimport { GetTypeByteLength } from \"./bufferUtils\";\r\n\r\nconst IsLittleEndian = (() => {\r\n    const array = new Uint8Array(4);\r\n    const view = new Uint32Array(array.buffer);\r\n\r\n    return !!((view[0] = 1) & array[0]);\r\n})();\r\n\r\ndeclare module \"./buffer\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface VertexBuffer {\r\n        /**\r\n         * Gets the effective byte stride, that is the byte stride of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteStride if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteStride: number;\r\n\r\n        /**\r\n         * Gets the effective byte offset, that is the byte offset of the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.byteOffset if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveByteOffset: number;\r\n\r\n        /**\r\n         * Gets the effective buffer, that is the buffer that is actually sent to the GPU.\r\n         * It could be different from VertexBuffer.getBuffer() if a new buffer must be created under the hood because of the forceVertexBufferStrideAndOffsetMultiple4Bytes engine flag.\r\n         */\r\n        effectiveBuffer: Nullable<DataBuffer>;\r\n\r\n        /** @internal */\r\n        _alignBuffer(): void;\r\n\r\n        /** @internal */\r\n        _alignedBuffer?: Buffer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteStride\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.byteStride) || this.byteStride;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteOffset\", {\r\n    get: function (this: VertexBuffer) {\r\n        return this._alignedBuffer ? 0 : this.byteOffset;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(VertexBuffer.prototype, \"effectiveBuffer\", {\r\n    get: function (this: VertexBuffer) {\r\n        return (this._alignedBuffer && this._alignedBuffer.getBuffer()) || this._buffer.getBuffer();\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nVertexBuffer.prototype._rebuild = function (): void {\r\n    this._buffer?._rebuild();\r\n    this._alignedBuffer?._rebuild();\r\n};\r\n\r\nVertexBuffer.prototype.dispose = function (): void {\r\n    if (this._ownsBuffer) {\r\n        this._buffer.dispose();\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = undefined;\r\n\r\n    this._isDisposed = true;\r\n};\r\n\r\nVertexBuffer.prototype.getWrapperBuffer = function (): Buffer {\r\n    return this._alignedBuffer || this._buffer;\r\n};\r\n\r\nVertexBuffer.prototype._alignBuffer = function (): void {\r\n    const data = this._buffer.getData();\r\n\r\n    if (!this.engine._features.forceVertexBufferStrideAndOffsetMultiple4Bytes || (this.byteStride % 4 === 0 && this.byteOffset % 4 === 0) || !data) {\r\n        return;\r\n    }\r\n\r\n    const typeByteLength = GetTypeByteLength(this.type);\r\n    const alignedByteStride = (this.byteStride + 3) & ~3;\r\n    const alignedSize = alignedByteStride / typeByteLength;\r\n    const totalVertices = this._maxVerticesCount;\r\n    const totalByteLength = totalVertices * alignedByteStride;\r\n    const totalLength = totalByteLength / typeByteLength;\r\n\r\n    let sourceData: DataView;\r\n\r\n    if (Array.isArray(data)) {\r\n        const sourceDataAsFloat = new Float32Array(data);\r\n        sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);\r\n    } else if (data instanceof ArrayBuffer) {\r\n        sourceData = new DataView(data, 0, data.byteLength);\r\n    } else {\r\n        sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    }\r\n\r\n    let alignedData: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;\r\n\r\n    if (this.type === VertexBuffer.BYTE) {\r\n        alignedData = new Int8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {\r\n        alignedData = new Uint8Array(totalLength);\r\n    } else if (this.type === VertexBuffer.SHORT) {\r\n        alignedData = new Int16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {\r\n        alignedData = new Uint16Array(totalLength);\r\n    } else if (this.type === VertexBuffer.INT) {\r\n        alignedData = new Int32Array(totalLength);\r\n    } else if (this.type === VertexBuffer.UNSIGNED_INT) {\r\n        alignedData = new Uint32Array(totalLength);\r\n    } else {\r\n        alignedData = new Float32Array(totalLength);\r\n    }\r\n\r\n    const numComponents = this.getSize();\r\n\r\n    let sourceOffset = this.byteOffset;\r\n\r\n    for (let i = 0; i < totalVertices; ++i) {\r\n        for (let j = 0; j < numComponents; ++j) {\r\n            switch (this.type) {\r\n                case VertexBuffer.BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_BYTE:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);\r\n                    break;\r\n                case VertexBuffer.SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_SHORT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.UNSIGNED_INT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n                case VertexBuffer.FLOAT:\r\n                    alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, IsLittleEndian);\r\n                    break;\r\n            }\r\n        }\r\n        sourceOffset += this.byteStride;\r\n    }\r\n\r\n    this._alignedBuffer?.dispose();\r\n    this._alignedBuffer = new Buffer(\r\n        this.engine,\r\n        alignedData,\r\n        false,\r\n        alignedByteStride,\r\n        false,\r\n        this.getIsInstanced(),\r\n        true,\r\n        this.instanceDivisor,\r\n        (this._label ?? \"VertexBuffer\") + \"_aligned\"\r\n    );\r\n};\r\n", "import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\n/**\r\n * Nothing specific to WebGPU in this class, but the spec is not final yet so let's remove it later on\r\n * if it is not needed\r\n * @internal\r\n **/\r\nexport class WebGPUExternalTexture extends ExternalTexture {\r\n    public constructor(video: HTMLVideoElement) {\r\n        super(video);\r\n    }\r\n}\r\n", "import { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { Constants } from \"../../constants\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.alpha\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets the current alpha mode\r\n         * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n         * @param targetIndex defines the index of the target to set the alpha mode for (default is 0)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n         */\r\n        setAlphaMode(mode: number, noDepthWriteChange?: boolean, targetIndex?: number): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.setAlphaMode = function (mode: number, noDepthWriteChange: boolean = false, targetIndex: number = 0): void {\r\n    const alphaBlend = this._alphaState._alphaBlend[targetIndex];\r\n\r\n    if (this._alphaMode[targetIndex] === mode && ((mode === Constants.ALPHA_DISABLE && !alphaBlend) || (mode !== Constants.ALPHA_DISABLE && alphaBlend))) {\r\n        if (!noDepthWriteChange) {\r\n            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)\r\n            const depthMask = mode === Constants.ALPHA_DISABLE;\r\n            if (this.depthCullingState.depthMask !== depthMask) {\r\n                this.setDepthWrite(depthMask);\r\n                this._cacheRenderPipeline.setDepthWriteEnabled(depthMask);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    const alphaBlendDisabled = mode === Constants.ALPHA_DISABLE;\r\n\r\n    this._alphaState.setAlphaBlend(!alphaBlendDisabled, targetIndex);\r\n    this._alphaState.setAlphaMode(mode, targetIndex);\r\n\r\n    if (!noDepthWriteChange) {\r\n        this.setDepthWrite(alphaBlendDisabled);\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(alphaBlendDisabled);\r\n    }\r\n    this._alphaMode[targetIndex] = mode;\r\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n\r\nThinWebGPUEngine.prototype.setAlphaEquation = function (equation: number, targetIndex: number = 0): void {\r\n    AbstractEngine.prototype.setAlphaEquation.call(this, equation, targetIndex);\r\n\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0,\r\n    useSRGBBuffer: boolean = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._creationFlags = creationFlags;\r\n    texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture._originalFormat = format;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (format === Constants.TEXTUREFORMAT_RGB) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        gpuTextureWrapper._originalFormatIsRGB = true;\r\n    }\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    _format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = gpuTextureWrapper._originalFormatIsRGB;\r\n\r\n    const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[faces[i]];\r\n        if (needConversion) {\r\n            faceData = ConvertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = ConvertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?.removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n    texture._creationFlags = creationFlags;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = ConvertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction ConvertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/promise-function-async\r\nThinWebGPUEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource!, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);\r\n};\r\n\r\nThinWebGPUEngine.prototype._readTexturePixelsSync = function (): ArrayBufferView {\r\n    // eslint-disable-next-line no-throw-literal\r\n    throw \"_readTexturePixelsSync is unsupported in WebGPU!\";\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @param buffer defines the data buffer to load instead of loading the rootUrl\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * Force the mipmap generation for the given render target texture\r\n         * @param texture defines the render target texture to use\r\n         * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n         */\r\n        generateMipMapsForCubemap(texture: InternalTexture, unbind?: boolean): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.isCube = true;\r\n    internalTexture.label = options.label;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\r\n    const gpuTextureWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer,\r\n        buffer\r\n    );\r\n};\r\n\r\nThinWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n\r\nThinWebGPUEngine.prototype.generateMipMapsForCubemap = function (texture: InternalTexture) {\r\n    if (texture.generateMipMaps) {\r\n        const gpuTexture = texture._hardwareTexture?.underlyingResource;\r\n\r\n        if (!gpuTexture) {\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        this._generateMipmaps(texture);\r\n    }\r\n};\r\n", "import type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./webgpuPerfCounter\";\r\nimport type { ThinWebGPUEngine } from \"../thinWebGPUEngine\";\r\n\r\n/**\r\n * Specialized class used to store a render target of a WebGPU engine\r\n */\r\nexport class WebGPURenderTargetWrapper extends RenderTargetWrapper {\r\n    /** @internal */\r\n    public _defaultAttachments: number[];\r\n\r\n    /**\r\n     * Gets the GPU time spent rendering this render target in the last frame (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     */\r\n    public readonly gpuTimeInFrame?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     * @param label defines the label to use for the wrapper (for debugging purpose only)\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinWebGPUEngine, label?: string) {\r\n        super(isMulti, isCube, size, engine, label);\r\n\r\n        if (engine.enableGPUTimingMeasurements) {\r\n            this.gpuTimeInFrame = new WebGPUPerfCounter();\r\n        }\r\n    }\r\n}\r\n", "import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, DepthTextureCreationOptions, TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport { GetTypeForDepthTexture, HasStencilAspect } from \"core/Materials/Textures/textureHelper.functions\";\r\n\r\nimport \"../../AbstractEngine/abstractEngine.texture\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target wrapper ready to render texture\r\n         */\r\n        createRenderTargetTexture(size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Updates the sample count of a render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number;\r\n\r\n        /** @internal */\r\n        _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /** @internal */\r\n        _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper;\r\n\r\n        /** @internal */\r\n        _setupDepthStencilTexture(internalTexture: InternalTexture, size: TextureSize, bilinearFiltering: boolean, comparisonFunction: number, samples?: number): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti: boolean, isCube: boolean, size: TextureSize): WebGPURenderTargetWrapper {\r\n    const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);\r\n    this._renderTargetWrapperCache.push(rtWrapper);\r\n    return rtWrapper;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createRenderTargetTexture = function (size: TextureSize, options: boolean | RenderTargetCreationOptions): WebGPURenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        fullOptions.generateMipMaps = options.generateMipMaps;\r\n        fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n        fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        fullOptions.creationFlags = options.creationFlags ?? 0;\r\n        fullOptions.noColorAttachment = !!options.noColorAttachment;\r\n        fullOptions.colorAttachment = options.colorAttachment;\r\n        fullOptions.samples = options.samples;\r\n        fullOptions.label = options.label;\r\n        fullOptions.format = options.format;\r\n        fullOptions.type = options.type;\r\n    } else {\r\n        fullOptions.generateMipMaps = options;\r\n        fullOptions.generateDepthBuffer = true;\r\n        fullOptions.generateStencilBuffer = false;\r\n        fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        fullOptions.creationFlags = 0;\r\n        fullOptions.noColorAttachment = false;\r\n    }\r\n\r\n    const texture =\r\n        fullOptions.colorAttachment || (fullOptions.noColorAttachment ? null : this._createInternalTexture(size, fullOptions, true, InternalTextureSource.RenderTarget));\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._samples = fullOptions.colorAttachment?.samples ?? fullOptions.samples ?? 1;\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            false, // force false as filtering is not supported for depth textures\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples,\r\n            fullOptions.generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n            fullOptions.label ? fullOptions.label + \"-DepthStencil\" : undefined\r\n        );\r\n    }\r\n\r\n    if (texture && !fullOptions.colorAttachment) {\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);\r\n\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinWebGPUEngine.prototype._createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions, wrapper: WebGPURenderTargetWrapper): InternalTexture {\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    const hasStencil = HasStencilAspect(internalOptions.depthTextureFormat);\r\n\r\n    wrapper._depthStencilTextureWithStencil = hasStencil;\r\n\r\n    const internalTexture = new InternalTexture(this, hasStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\r\n\r\n    internalTexture.label = options.label;\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n    internalTexture.type = GetTypeForDepthTexture(internalTexture.format);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinWebGPUEngine.prototype._setupDepthStencilTexture = function (\r\n    internalTexture: InternalTexture,\r\n    size: TextureSize,\r\n    bilinearFiltering: boolean,\r\n    comparisonFunction: number,\r\n    samples = 1\r\n): void {\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n    const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n    const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n\r\n    internalTexture.baseWidth = width;\r\n    internalTexture.baseHeight = height;\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.is2DArray = layers > 0;\r\n    internalTexture.is3D = depth > 0;\r\n    internalTexture.depth = layers || depth;\r\n    internalTexture.isReady = true;\r\n    internalTexture.samples = samples;\r\n    internalTexture.generateMipMaps = false;\r\n    internalTexture.samplingMode = bilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    internalTexture.type = Constants.TEXTURETYPE_FLOAT; // the right type will be set later\r\n    internalTexture._comparisonFunction = comparisonFunction;\r\n    internalTexture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    internalTexture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n};\r\n\r\nThinWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    this._textureHelper.createMSAATexture(rtWrapper.texture, samples);\r\n\r\n    if (rtWrapper._depthStencilTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n    rtWrapper.texture.samples = samples;\r\n\r\n    return samples;\r\n};\r\n", "import type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a depth stencil texture from a render target to the according uniform.\r\n         * @param channel The texture channel\r\n         * @param uniform The uniform to set\r\n         * @param texture The render target texture containing the depth stencil texture to apply\r\n         * @param name The texture name\r\n         */\r\n        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.setDepthStencilTexture = function (\r\n    channel: number,\r\n    uniform: Nullable<WebGLUniformLocation>,\r\n    texture: Nullable<RenderTargetTexture>,\r\n    name?: string\r\n): void {\r\n    if (!texture || !texture.depthStencilTexture) {\r\n        this._setTexture(channel, null, undefined, undefined, name);\r\n    } else {\r\n        this._setTexture(channel, texture, false, true, name);\r\n    }\r\n};\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\n\r\ndeclare module \"../../abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target cube wrapper\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target cube wrapper\r\n         */\r\n        createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper;\r\n    }\r\n}\r\n\r\nThinWebGPUEngine.prototype.createRenderTargetCubeTexture = function (size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\r\n\r\n    const fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.depth = 0;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = fullOptions.samples;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            fullOptions.samplingMode === undefined ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST,\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples\r\n        );\r\n    }\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = true;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = false;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n", "import { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport type OcclusionQuery = WebGLQuery | number;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _OcclusionDataStorage {\r\n    /** @internal */\r\n    public occlusionInternalRetryCounter = 0;\r\n\r\n    /** @internal */\r\n    public isOcclusionQueryInProgress = false;\r\n\r\n    /** @internal */\r\n    public isOccluded = false;\r\n\r\n    /** @internal */\r\n    public occlusionRetryCount = -1;\r\n\r\n    /** @internal */\r\n    public occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;\r\n\r\n    /** @internal */\r\n    public occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;\r\n\r\n    /** @internal */\r\n    public forceRenderingWhenOccluded = false;\r\n}\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)\r\n         * @returns the new query\r\n         */\r\n        createQuery(): Nullable<OcclusionQuery>;\r\n        /**\r\n         * Delete and release a webGL query\r\n         * @param query defines the query to delete\r\n         * @returns the current engine\r\n         */\r\n        deleteQuery(query: OcclusionQuery): AbstractEngine /**\r\n         * Check if a given query has resolved and got its value\r\n         * @param query defines the query to check\r\n         * @returns true if the query got its value\r\n         */;\r\n        isQueryResultAvailable(query: OcclusionQuery): boolean;\r\n        /**\r\n         * Gets the value of a given query\r\n         * @param query defines the query to check\r\n         * @returns the value of the query\r\n         */\r\n        getQueryResult(query: OcclusionQuery): number;\r\n        /**\r\n         * Initiates an occlusion query\r\n         * @param algorithmType defines the algorithm to use\r\n         * @param query defines the query to use\r\n         * @returns the current engine\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        beginOcclusionQuery(algorithmType: number, query: OcclusionQuery): boolean;\r\n        /**\r\n         * Ends an occlusion query\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         * @param algorithmType defines the algorithm to use\r\n         * @returns the current engine\r\n         */\r\n        endOcclusionQuery(algorithmType: number): AbstractEngine;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.createQuery = function (): Nullable<OcclusionQuery> {\r\n    return null;\r\n};\r\n\r\nAbstractEngine.prototype.deleteQuery = function (query: OcclusionQuery): AbstractEngine {\r\n    // Do nothing. Must be implemented by child classes\r\n    return this;\r\n};\r\n\r\nAbstractEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    // Do nothing. Must be implemented by child classes\r\n    return false;\r\n};\r\n\r\nAbstractEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    // Do nothing. Must be implemented by child classes\r\n    return 0;\r\n};\r\n\r\nAbstractEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    // Do nothing. Must be implemented by child classes\r\n    return false;\r\n};\r\n\r\nAbstractEngine.prototype.endOcclusionQuery = function (algorithmType: number): AbstractEngine {\r\n    // Do nothing. Must be implemented by child classes\r\n    return this;\r\n};\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Backing filed\r\n         * @internal\r\n         */\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        __occlusionDataStorage: _OcclusionDataStorage;\r\n\r\n        /**\r\n         * Access property\r\n         * @internal\r\n         */\r\n        _occlusionDataStorage: _OcclusionDataStorage;\r\n\r\n        /**\r\n         * This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retrieved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decides to show or hide the object.\r\n         * The default value is -1 which means don't break the query and wait till the result\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionRetryCount: number;\r\n\r\n        /**\r\n         * This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:\r\n         * * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query within the Mesh.\r\n         * * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.\r\n         * * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionType: number;\r\n\r\n        /**\r\n         * This property determines the type of occlusion query algorithm to run in WebGl, you can use:\r\n         * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.\r\n         * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        occlusionQueryAlgorithmType: number;\r\n\r\n        /**\r\n         * Gets or sets whether the mesh is occluded or not, it is used also to set the initial state of the mesh to be occluded or not\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        isOccluded: boolean;\r\n\r\n        /**\r\n         * Flag to check the progress status of the query\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        isOcclusionQueryInProgress: boolean;\r\n\r\n        /**\r\n         * Flag to force rendering the mesh even if occluded\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/occlusionQueries\r\n         */\r\n        forceRenderingWhenOccluded: boolean;\r\n    }\r\n}\r\nObject.defineProperty(AbstractMesh.prototype, \"isOcclusionQueryInProgress\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.isOcclusionQueryInProgress;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.isOcclusionQueryInProgress = value;\r\n    },\r\n    enumerable: false,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"_occlusionDataStorage\", {\r\n    get: function (this: AbstractMesh) {\r\n        if (!this.__occlusionDataStorage) {\r\n            this.__occlusionDataStorage = new _OcclusionDataStorage();\r\n        }\r\n        return this.__occlusionDataStorage;\r\n    },\r\n    enumerable: false,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"isOccluded\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.isOccluded;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.isOccluded = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionQueryAlgorithmType\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionQueryAlgorithmType;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionQueryAlgorithmType = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionType\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionType;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionType = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"occlusionRetryCount\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.occlusionRetryCount;\r\n    },\r\n    set: function (this: AbstractMesh, value: number) {\r\n        this._occlusionDataStorage.occlusionRetryCount = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"forceRenderingWhenOccluded\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._occlusionDataStorage.forceRenderingWhenOccluded;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._occlusionDataStorage.forceRenderingWhenOccluded = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n// We also need to update AbstractMesh as there is a portion of the code there\r\nAbstractMesh.prototype._checkOcclusionQuery = function () {\r\n    const dataStorage = this._occlusionDataStorage;\r\n\r\n    if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!engine.getCaps().supportOcclusionQuery) {\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    if (!engine.isQueryResultAvailable) {\r\n        // Occlusion query where not referenced\r\n        dataStorage.isOccluded = false;\r\n        return false;\r\n    }\r\n\r\n    if (this.isOcclusionQueryInProgress && this._occlusionQuery !== null && this._occlusionQuery !== undefined) {\r\n        const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);\r\n        if (isOcclusionQueryAvailable) {\r\n            const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);\r\n\r\n            dataStorage.isOcclusionQueryInProgress = false;\r\n            dataStorage.occlusionInternalRetryCounter = 0;\r\n            dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;\r\n        } else {\r\n            dataStorage.occlusionInternalRetryCounter++;\r\n\r\n            if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {\r\n                dataStorage.isOcclusionQueryInProgress = false;\r\n                dataStorage.occlusionInternalRetryCounter = 0;\r\n\r\n                // if optimistic set isOccluded to false regardless of the status of isOccluded. (Render in the current render loop)\r\n                // if strict continue the last state of the object.\r\n                dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\r\n            } else {\r\n                return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\r\n            }\r\n        }\r\n    }\r\n\r\n    const scene = this.getScene();\r\n    if (scene.getBoundingBoxRenderer) {\r\n        const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();\r\n\r\n        if (this._occlusionQuery === null) {\r\n            this._occlusionQuery = engine.createQuery();\r\n        }\r\n\r\n        if (this._occlusionQuery && engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {\r\n            occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);\r\n            engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);\r\n            this._occlusionDataStorage.isOcclusionQueryInProgress = true;\r\n        }\r\n    }\r\n\r\n    return dataStorage.isOccluded;\r\n};\r\n", "import { ThinWebGPUEngine } from \"core/Engines/thinWebGPUEngine\";\r\nimport { WebGPURenderItemBeginOcclusionQuery, WebGPURenderItemEndOcclusionQuery } from \"../webgpuBundleList\";\r\n\r\nimport type { PerfCounter } from \"../../../Misc/perfCounter\";\r\nimport type { OcclusionQuery } from \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nimport \"../../../Engines/AbstractEngine/abstractEngine.query\";\r\n\r\nThinWebGPUEngine.prototype.getGPUFrameTimeCounter = function (): PerfCounter {\r\n    return this._timestampQuery.gpuFrameTimeCounter;\r\n};\r\n\r\nThinWebGPUEngine.prototype.captureGPUFrameTime = function (value: boolean) {\r\n    this._timestampQuery.enable = value && !!this._caps.timerQuery;\r\n};\r\n\r\nThinWebGPUEngine.prototype.createQuery = function (): OcclusionQuery {\r\n    return this._occlusionQuery.createQuery();\r\n};\r\n\r\nThinWebGPUEngine.prototype.deleteQuery = function (query: OcclusionQuery): ThinWebGPUEngine {\r\n    this._occlusionQuery.deleteQuery(query as number);\r\n\r\n    return this;\r\n};\r\n\r\nThinWebGPUEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    return this._occlusionQuery.isQueryResultAvailable(query as number);\r\n};\r\n\r\nThinWebGPUEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    return this._occlusionQuery.getQueryResult(query as number);\r\n};\r\n\r\nThinWebGPUEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    if (this.compatibilityMode) {\r\n        if (this._occlusionQuery.canBeginQuery(query as number)) {\r\n            this._currentRenderPass?.beginOcclusionQuery(query as number);\r\n            return true;\r\n        }\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query as number));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nThinWebGPUEngine.prototype.endOcclusionQuery = function (): ThinWebGPUEngine {\r\n    if (this.compatibilityMode) {\r\n        this._currentRenderPass?.endOcclusionQuery();\r\n    } else {\r\n        this._bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());\r\n    }\r\n    return this;\r\n};\r\n", "/* eslint-disable babylonjs/available */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { ThinWebGPUEngine } from \"./thinWebGPUEngine\";\r\nimport type { Nullable, DataArray, IndicesArray, Immutable, FloatArray } from \"../types\";\r\nimport { Color4 } from \"../Maths/math\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { Constants } from \"./constants\";\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IWebGPURenderPipelineStageDescriptor } from \"./WebGPU/webgpuPipelineContext\";\r\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL\";\r\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL\";\r\nimport type { _IShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { ISceneLike, AbstractEngineOptions } from \"./abstractEngine\";\r\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager\";\r\nimport type { IHardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler\";\r\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree\";\r\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer\";\r\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext\";\r\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext\";\r\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups\";\r\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { ComputeEffect } from \"../Compute/computeEffect\";\r\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport type { TwgslOptions } from \"./WebGPU/webgpuTintWASM\";\r\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport type { WebGPUDataBuffer } from \"../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\n\r\nimport \"../Buffers/buffer.align\";\r\n\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { PerformanceMonitor } from \"../Misc/performanceMonitor\";\r\nimport {\r\n    CreateImageBitmapFromSource,\r\n    ExitFullscreen,\r\n    ExitPointerlock,\r\n    GetFontOffset,\r\n    RequestFullscreen,\r\n    RequestPointerlock,\r\n    ResizeImageBitmap,\r\n    _CommonDispose,\r\n    _CommonInit,\r\n} from \"./engine.common\";\r\nimport { IsWrapper } from \"../Materials/drawWrapper.functions\";\r\nimport { PerfCounter } from \"../Misc/perfCounter\";\r\nimport \"./AbstractEngine/abstractEngine.loadingScreen\";\r\nimport \"./AbstractEngine/abstractEngine.dom\";\r\nimport \"./AbstractEngine/abstractEngine.states\";\r\nimport \"./AbstractEngine/abstractEngine.stencil\";\r\nimport \"./AbstractEngine/abstractEngine.renderPass\";\r\nimport \"../Audio/audioEngine\";\r\nimport { resetCachedPipeline } from \"../Materials/effect.functions\";\r\n\r\nimport { WebGPUExternalTexture } from \"./WebGPU/webgpuExternalTexture\";\r\nimport type { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport \"./WebGPU/Extensions/engine.alpha\";\r\nimport \"./WebGPU/Extensions/engine.rawTexture\";\r\nimport \"./WebGPU/Extensions/engine.readTexture\";\r\nimport \"./WebGPU/Extensions/engine.cubeTexture\";\r\nimport \"./WebGPU/Extensions/engine.renderTarget\";\r\nimport \"./WebGPU/Extensions/engine.renderTargetTexture\";\r\nimport \"./WebGPU/Extensions/engine.renderTargetCube\";\r\nimport \"./WebGPU/Extensions/engine.query\";\r\n\r\nconst ViewDescriptorSwapChainAntialiasing: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain_ResolveTarget`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\n\r\nconst ViewDescriptorSwapChain: GPUTextureViewDescriptor = {\r\n    label: `TextureView_SwapChain`,\r\n    dimension: WebGPUConstants.TextureDimension.E2d,\r\n    format: undefined as any, // will be updated with the right value\r\n    mipLevelCount: 1,\r\n    arrayLayerCount: 1,\r\n};\r\nconst TempColor4 = new Color4();\r\n\r\n/** @internal */\r\ninterface IWebGPURenderPassWrapper {\r\n    renderPassDescriptor: Nullable<GPURenderPassDescriptor>;\r\n\r\n    colorAttachmentViewDescriptor: Nullable<GPUTextureViewDescriptor>;\r\n    depthAttachmentViewDescriptor: Nullable<GPUTextureViewDescriptor>;\r\n    colorAttachmentGPUTextures: (WebGPUHardwareTexture | null)[];\r\n    depthTextureFormat: GPUTextureFormat | undefined;\r\n}\r\n\r\n/**\r\n * Options to load the associated Glslang library\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GlslangOptions {\r\n    /**\r\n     * Defines an existing instance of Glslang (useful in modules who do not access the global instance).\r\n     */\r\n    glslang?: any;\r\n    /**\r\n     * Defines the URL of the glslang JS File.\r\n     */\r\n    jsPath?: string;\r\n    /**\r\n     * Defines the URL of the glslang WASM File.\r\n     */\r\n    wasmPath?: string;\r\n}\r\n\r\n/**\r\n * Options to create the WebGPU engine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface WebGPUEngineOptions extends AbstractEngineOptions, GPURequestAdapterOptions {\r\n    /**\r\n     * The featureLevel property of the GPURequestAdapterOptions interface\r\n     */\r\n    featureLevel?: string;\r\n\r\n    /**\r\n     * Defines the category of adapter to use.\r\n     * Is it the discrete or integrated device.\r\n     */\r\n    powerPreference?: GPUPowerPreference;\r\n\r\n    /**\r\n     * When set to true, indicates that only a fallback adapter may be returned when requesting an adapter.\r\n     * If the user agent does not support a fallback adapter, will cause requestAdapter() to resolve to null.\r\n     * Default: false\r\n     */\r\n    forceFallbackAdapter?: boolean;\r\n\r\n    /**\r\n     * Defines the device descriptor used to create a device once we have retrieved an appropriate adapter\r\n     */\r\n    deviceDescriptor?: GPUDeviceDescriptor;\r\n\r\n    /**\r\n     * When requesting the device, enable all the features supported by the adapter. Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredFeatures\r\n     */\r\n    enableAllFeatures?: boolean;\r\n\r\n    /**\r\n     * When requesting the device, set the required limits to the maximum possible values (the ones from adapter.limits). Default: false\r\n     * Note that this setting is ignored if you explicitely set deviceDescriptor.requiredLimits\r\n     */\r\n    setMaximumLimits?: boolean;\r\n\r\n    /**\r\n     * Defines the requested Swap Chain Format.\r\n     */\r\n    swapChainFormat?: GPUTextureFormat;\r\n\r\n    /**\r\n     * Defines whether we should generate debug markers in the gpu command lists (can be seen with PIX for eg). Default: false\r\n     */\r\n    enableGPUDebugMarkers?: boolean;\r\n\r\n    /**\r\n     * Options to load the associated Glslang library\r\n     */\r\n    glslangOptions?: GlslangOptions;\r\n\r\n    /**\r\n     * Options to load the associated Twgsl library\r\n     */\r\n    twgslOptions?: TwgslOptions;\r\n}\r\n\r\n/**\r\n * The web GPU engine class provides support for WebGPU version of babylon.js.\r\n * @since 5.0.0\r\n */\r\nexport class WebGPUEngine extends ThinWebGPUEngine {\r\n    // Default glslang options.\r\n    private static readonly _GlslangDefaultOptions: GlslangOptions = {\r\n        jsPath: `${Tools._DefaultCdnUrl}/glslang/glslang.js`,\r\n        wasmPath: `${Tools._DefaultCdnUrl}/glslang/glslang.wasm`,\r\n    };\r\n\r\n    private static _InstanceId = 0;\r\n\r\n    /** A unique id to identify this instance */\r\n    public readonly uniqueId = -1;\r\n\r\n    // Page Life cycle and constants\r\n    private readonly _uploadEncoderDescriptor = { label: \"upload\" };\r\n    private readonly _renderEncoderDescriptor = { label: \"render\" };\r\n    /** @internal */\r\n    public readonly _clearDepthValue = 1;\r\n    /** @internal */\r\n    public readonly _clearReverseDepthValue = 0;\r\n    /** @internal */\r\n    public _clearStencilValue = 0;\r\n    private readonly _defaultSampleCount = 4; // Only supported value for now.\r\n\r\n    // Engine Life Cycle\r\n    /** @internal */\r\n    public _options: WebGPUEngineOptions;\r\n    private _glslang: any = null;\r\n    private _tintWASM: Nullable<WebGPUTintWASM> = null;\r\n    private _glslangAndTintAreFullyLoaded = false;\r\n    private _adapter: GPUAdapter;\r\n    private _adapterSupportedExtensions: GPUFeatureName[];\r\n    private _adapterInfo: GPUAdapterInfo = {\r\n        vendor: \"\",\r\n        architecture: \"\",\r\n        device: \"\",\r\n        description: \"\",\r\n        subgroupMinSize: 0,\r\n        subgroupMaxSize: 0,\r\n        isFallbackAdapter: false,\r\n    };\r\n    private _adapterSupportedLimits: GPUSupportedLimits;\r\n    /** @internal */\r\n    public _device: GPUDevice;\r\n    private _deviceEnabledExtensions: GPUFeatureName[];\r\n    private _deviceLimits: GPUSupportedLimits;\r\n    private _context: GPUCanvasContext;\r\n    private _mainPassSampleCount: number;\r\n    private _glslangOptions?: GlslangOptions;\r\n    private _twgslOptions?: TwgslOptions;\r\n    /** @internal */\r\n    public _bufferManager: WebGPUBufferManager;\r\n    private _clearQuad: WebGPUClearQuad;\r\n    /** @internal */\r\n    public _cacheSampler: WebGPUCacheSampler;\r\n    private _cacheBindGroups: WebGPUCacheBindGroups;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    /** @internal */\r\n    public _mrtAttachments: number[];\r\n    /** @internal */\r\n    public _compiledComputeEffects: { [key: string]: ComputeEffect } = {};\r\n    /** @internal */\r\n    public _counters: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Counters from last frame\r\n     */\r\n    public readonly countersLastFrame: {\r\n        numEnableEffects: number;\r\n        numEnableDrawWrapper: number;\r\n        numBundleCreationNonCompatMode: number;\r\n        numBundleReuseNonCompatMode: number;\r\n    } = {\r\n        numEnableEffects: 0,\r\n        numEnableDrawWrapper: 0,\r\n        numBundleCreationNonCompatMode: 0,\r\n        numBundleReuseNonCompatMode: 0,\r\n    };\r\n    /**\r\n     * Max number of uncaptured error messages to log\r\n     */\r\n    public numMaxUncapturedErrors = 20;\r\n\r\n    /**\r\n     * Gets the list of created scenes\r\n     */\r\n    public override scenes: Scene[] = [];\r\n\r\n    /** @internal */\r\n    public override _virtualScenes = new Array<Scene>();\r\n\r\n    // Some of the internal state might change during the render pass.\r\n    // This happens mainly during clear for the state\r\n    // And when the frame starts to swap the target texture from the swap chain\r\n    private _mainTexture: GPUTexture;\r\n    private _depthTexture: GPUTexture;\r\n    private _mainTextureExtends: GPUExtent3D;\r\n    private _depthTextureFormat: GPUTextureFormat | undefined;\r\n    private _colorFormat: GPUTextureFormat | null;\r\n    /** @internal */\r\n    public _ubInvertY: WebGPUDataBuffer;\r\n    /** @internal */\r\n    public _ubDontInvertY: WebGPUDataBuffer;\r\n\r\n    private _commandBuffers: GPUCommandBuffer[] = [null as any, null as any];\r\n\r\n    // Frame Buffer Life Cycle (recreated for each render target pass)\r\n\r\n    private _mainRenderPassWrapper: IWebGPURenderPassWrapper = {\r\n        renderPassDescriptor: null,\r\n        colorAttachmentViewDescriptor: null,\r\n        depthAttachmentViewDescriptor: null,\r\n        colorAttachmentGPUTextures: [],\r\n        depthTextureFormat: undefined,\r\n    };\r\n    private _rttRenderPassWrapper: IWebGPURenderPassWrapper = {\r\n        renderPassDescriptor: null,\r\n        colorAttachmentViewDescriptor: null,\r\n        depthAttachmentViewDescriptor: null,\r\n        colorAttachmentGPUTextures: [],\r\n        depthTextureFormat: undefined,\r\n    };\r\n    /** @internal */\r\n    public _pendingDebugCommands: Array<[string, Nullable<string>, number?]> = [];\r\n\r\n    // DrawCall Life Cycle\r\n    // Effect is on the parent class\r\n    // protected _currentEffect: Nullable<Effect> = null;\r\n    private _defaultDrawContext: WebGPUDrawContext;\r\n    private _defaultMaterialContext: WebGPUMaterialContext;\r\n    /** @internal */\r\n    public override _currentDrawContext: WebGPUDrawContext;\r\n    /** @internal */\r\n    public override _currentMaterialContext: WebGPUMaterialContext;\r\n    private _currentVertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _currentOverrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }> = null;\r\n    private _currentIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _dummyIndexBuffer: WebGPUDataBuffer;\r\n    private _colorWriteLocal = true;\r\n    private _forceEnableEffect = false;\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public override get snapshotRenderingMode(): number {\r\n        return this._snapshotRendering.mode;\r\n    }\r\n\r\n    public override set snapshotRenderingMode(mode: number) {\r\n        this._snapshotRendering.mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this._snapshotRendering.reset();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public override get snapshotRendering(): boolean {\r\n        return this._snapshotRendering.enabled;\r\n    }\r\n\r\n    public override set snapshotRendering(activate) {\r\n        this._snapshotRendering.enabled = activate;\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheSamplers(): boolean {\r\n        return this._cacheSampler ? this._cacheSampler.disabled : false;\r\n    }\r\n\r\n    public set disableCacheSamplers(disable: boolean) {\r\n        if (this._cacheSampler) {\r\n            this._cacheSampler.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheRenderPipelines(): boolean {\r\n        return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\r\n    }\r\n\r\n    public set disableCacheRenderPipelines(disable: boolean) {\r\n        if (this._cacheRenderPipeline) {\r\n            this._cacheRenderPipeline.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\r\n     */\r\n    public get disableCacheBindGroups(): boolean {\r\n        return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\r\n    }\r\n\r\n    public set disableCacheBindGroups(disable: boolean) {\r\n        if (this._cacheBindGroups) {\r\n            this._cacheBindGroups.disabled = disable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     * @returns an object containing ascent, height and descent\r\n     */\r\n    public override getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        return GetFontOffset(font);\r\n    }\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return !navigator.gpu\r\n            ? Promise.resolve(false)\r\n            : navigator.gpu\r\n                  .requestAdapter()\r\n                  // eslint-disable-next-line github/no-then\r\n                  .then(\r\n                      (adapter: GPUAdapter | undefined) => !!adapter,\r\n                      () => false\r\n                  )\r\n                  // eslint-disable-next-line github/no-then\r\n                  .catch(() => false);\r\n    }\r\n\r\n    /**\r\n     * Not supported by WebGPU, you should call IsSupportedAsync instead!\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** Gets the supported extensions by the WebGPU adapter */\r\n    public get supportedExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._adapterSupportedExtensions;\r\n    }\r\n\r\n    /** Gets the currently enabled extensions on the WebGPU device */\r\n    public get enabledExtensions(): Immutable<GPUFeatureName[]> {\r\n        return this._deviceEnabledExtensions;\r\n    }\r\n\r\n    /** Gets the supported limits by the WebGPU adapter */\r\n    public get supportedLimits(): GPUSupportedLimits {\r\n        return this._adapterSupportedLimits;\r\n    }\r\n\r\n    /** Gets the current limits of the WebGPU device */\r\n    public get currentLimits() {\r\n        return this._deviceLimits;\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public override get description(): string {\r\n        const description = this.name + this.version;\r\n\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return {\r\n            vendor: this._adapterInfo.vendor || \"unknown vendor\",\r\n            renderer: this._adapterInfo.architecture || \"unknown renderer\",\r\n            version: this._adapterInfo.description || \"unknown version\",\r\n        };\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public override get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public override set compatibilityMode(mode: boolean) {\r\n        this._compatibilityMode = mode;\r\n    }\r\n\r\n    /** @internal */\r\n    public get currentSampleCount(): number {\r\n        return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\r\n    }\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine asynchronously\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     * @returns a promise that resolves with the created engine\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public static CreateAsync(canvas: HTMLCanvasElement, options: WebGPUEngineOptions = {}): Promise<WebGPUEngine> {\r\n        const engine = new WebGPUEngine(canvas, options);\r\n\r\n        return new Promise((resolve) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public override readonly isNDCHalfZRange: boolean = true;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public override readonly hasOriginBottomLeft: boolean = false;\r\n\r\n    /**\r\n     * Create a new instance of the gpu engine.\r\n     * @param canvas Defines the canvas to use to display the result\r\n     * @param options Defines the options passed to the engine to create the GPU context dependencies\r\n     */\r\n    public constructor(canvas: HTMLCanvasElement | OffscreenCanvas, options: WebGPUEngineOptions = {}) {\r\n        super(options.antialias ?? true, options);\r\n        this._name = \"WebGPU\";\r\n\r\n        this._drawCalls = new PerfCounter();\r\n\r\n        options.deviceDescriptor = options.deviceDescriptor || {};\r\n        options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\r\n\r\n        Logger.Log(`Babylon.js v${AbstractEngine.Version} - ${this.description} engine`);\r\n        if (!navigator.gpu) {\r\n            Logger.Error(\"WebGPU is not supported by your browser.\");\r\n            return;\r\n        }\r\n\r\n        options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\r\n\r\n        this._isWebGPU = true;\r\n        this._shaderPlatformName = \"WEBGPU\";\r\n\r\n        this._renderingCanvas = canvas as HTMLCanvasElement;\r\n        this._options = options;\r\n\r\n        this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;\r\n\r\n        if (navigator && navigator.userAgent) {\r\n            this._setupMobileChecks();\r\n        }\r\n\r\n        this._sharedInit(this._renderingCanvas);\r\n\r\n        this._shaderProcessor = new WebGPUShaderProcessorGLSL();\r\n        this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Initialization\r\n    //------------------------------------------------------------------------------\r\n    private _workingGlslangAndTintPromise: Nullable<Promise<void>> = null;\r\n\r\n    /**\r\n     * Load the glslang and tintWASM libraries and prepare them for use.\r\n     * @returns a promise that resolves when the engine is ready to use the glslang and tintWASM\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public prepareGlslangAndTintAsync(): Promise<void> {\r\n        if (!this._workingGlslangAndTintPromise) {\r\n            this._workingGlslangAndTintPromise = new Promise<void>((resolve) => {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                this._initGlslangAsync(this._glslangOptions ?? this._options?.glslangOptions).then((glslang: any) => {\r\n                    this._glslang = glslang;\r\n                    this._tintWASM = new WebGPUTintWASM();\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    this._tintWASM.initTwgsl(this._twgslOptions ?? this._options?.twgslOptions).then(() => {\r\n                        this._glslangAndTintAreFullyLoaded = true;\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        return this._workingGlslangAndTintPromise;\r\n    }\r\n\r\n    /**\r\n     * Initializes the WebGPU context and dependencies.\r\n     * @param glslangOptions Defines the GLSLang compiler options if necessary\r\n     * @param twgslOptions Defines the Twgsl compiler options if necessary\r\n     * @returns a promise notifying the readiness of the engine.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public initAsync(glslangOptions?: GlslangOptions, twgslOptions?: TwgslOptions): Promise<void> {\r\n        (this.uniqueId as number) = WebGPUEngine._InstanceId++;\r\n        this._glslangOptions = glslangOptions;\r\n        this._twgslOptions = twgslOptions;\r\n        return (\r\n            navigator\r\n                .gpu!.requestAdapter(this._options)\r\n                // eslint-disable-next-line github/no-then\r\n                .then(async (adapter: GPUAdapter | undefined) => {\r\n                    if (!adapter) {\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\r\n                    } else {\r\n                        this._adapter = adapter!;\r\n                        this._adapterSupportedExtensions = [];\r\n                        this._adapter.features?.forEach((feature) => {\r\n                            this._adapterSupportedExtensions.push(feature as WebGPUConstants.FeatureName);\r\n                        });\r\n                        this._adapterSupportedLimits = this._adapter.limits;\r\n                        this._adapterInfo = this._adapter.info;\r\n\r\n                        const deviceDescriptor = this._options.deviceDescriptor ?? {};\r\n                        const requiredFeatures = deviceDescriptor?.requiredFeatures ?? (this._options.enableAllFeatures ? this._adapterSupportedExtensions : undefined);\r\n\r\n                        if (requiredFeatures) {\r\n                            const requestedExtensions = requiredFeatures;\r\n                            const validExtensions: GPUFeatureName[] = [];\r\n\r\n                            for (const extension of requestedExtensions) {\r\n                                if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\r\n                                    validExtensions.push(extension);\r\n                                }\r\n                            }\r\n\r\n                            deviceDescriptor.requiredFeatures = validExtensions;\r\n                        }\r\n\r\n                        if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {\r\n                            deviceDescriptor.requiredLimits = {};\r\n                            for (const name in this._adapterSupportedLimits) {\r\n                                if (name === \"minSubgroupSize\" || name === \"maxSubgroupSize\") {\r\n                                    // Chrome exposes these limits in \"webgpu developer\" mode, but these can't be set on the device.\r\n                                    continue;\r\n                                }\r\n                                deviceDescriptor.requiredLimits[name] = this._adapterSupportedLimits[name];\r\n                            }\r\n                        }\r\n\r\n                        deviceDescriptor.label = `BabylonWebGPUDevice${this.uniqueId}`;\r\n\r\n                        return await this._adapter.requestDevice(deviceDescriptor);\r\n                    }\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .then((device: GPUDevice) => {\r\n                    this._device = device;\r\n                    this._deviceEnabledExtensions = [];\r\n                    this._device.features?.forEach((feature) => {\r\n                        this._deviceEnabledExtensions.push(feature as WebGPUConstants.FeatureName);\r\n                    });\r\n                    this._deviceLimits = device.limits;\r\n\r\n                    let numUncapturedErrors = -1;\r\n                    this._device.addEventListener(\"uncapturederror\", (event) => {\r\n                        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${(<GPUUncapturedErrorEvent>event).error} - ${(<any>event).error.message}`);\r\n                        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\r\n                            Logger.Warn(\r\n                                `WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    if (!this._doNotHandleContextLost) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        this._device.lost?.then((info) => {\r\n                            if (this._isDisposed) {\r\n                                return;\r\n                            }\r\n                            this._contextWasLost = true;\r\n                            Logger.Warn(\"WebGPU context lost. \" + info);\r\n                            this.onContextLostObservable.notifyObservers(this);\r\n                            // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n                            this._restoreEngineAfterContextLost(async () => {\r\n                                const snapshotRenderingMode = this.snapshotRenderingMode;\r\n                                const snapshotRendering = this.snapshotRendering;\r\n                                const disableCacheSamplers = this.disableCacheSamplers;\r\n                                const disableCacheRenderPipelines = this.disableCacheRenderPipelines;\r\n                                const disableCacheBindGroups = this.disableCacheBindGroups;\r\n                                const enableGPUTimingMeasurements = this.enableGPUTimingMeasurements;\r\n\r\n                                await this.initAsync(this._glslangOptions ?? this._options?.glslangOptions, this._twgslOptions ?? this._options?.twgslOptions);\r\n\r\n                                this.snapshotRenderingMode = snapshotRenderingMode;\r\n                                this.snapshotRendering = snapshotRendering;\r\n                                this.disableCacheSamplers = disableCacheSamplers;\r\n                                this.disableCacheRenderPipelines = disableCacheRenderPipelines;\r\n                                this.disableCacheBindGroups = disableCacheBindGroups;\r\n                                this.enableGPUTimingMeasurements = enableGPUTimingMeasurements;\r\n                                this._currentRenderPass = null;\r\n                            });\r\n                        });\r\n                    }\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .then(() => {\r\n                    this._initializeLimits();\r\n\r\n                    this._bufferManager = new WebGPUBufferManager(this, this._device);\r\n                    this._textureHelper = new WebGPUTextureManager(this, this._device, this._bufferManager, this._deviceEnabledExtensions);\r\n                    this._cacheSampler = new WebGPUCacheSampler(this._device);\r\n                    this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\r\n                    this._timestampQuery = new WebGPUTimestampQuery(this, this._device, this._bufferManager);\r\n                    this._occlusionQuery = (this._device as any).createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : (undefined as any);\r\n                    this._bundleList = new WebGPUBundleList(this._device);\r\n                    this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList);\r\n\r\n                    this._ubInvertY = this._bufferManager.createBuffer(\r\n                        new Float32Array([-1, 0]),\r\n                        WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"UBInvertY\"\r\n                    );\r\n                    this._ubDontInvertY = this._bufferManager.createBuffer(\r\n                        new Float32Array([1, 0]),\r\n                        WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"UBDontInvertY\"\r\n                    );\r\n\r\n                    if (this.dbgVerboseLogsForFirstFrames) {\r\n                        if ((this as any)._count === undefined) {\r\n                            (this as any)._count = 0;\r\n                            Logger.Log([\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\"]);\r\n                        }\r\n                    }\r\n\r\n                    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n                    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n\r\n                    this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", {\r\n                        stride: 1,\r\n                        offset: 0,\r\n                        size: 1,\r\n                        label: \"EmptyVertexBuffer\",\r\n                    });\r\n\r\n                    this._dummyIndexBuffer = this._bufferManager.createBuffer(\r\n                        new Uint16Array([0, 0, 0, 0]),\r\n                        WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst,\r\n                        \"DummyIndices\"\r\n                    );\r\n\r\n                    this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer);\r\n\r\n                    this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\r\n                    this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\r\n                    this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n                    this._depthCullingState.depthTest = true;\r\n                    this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n                    this._depthCullingState.depthMask = true;\r\n\r\n                    this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n                    this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\r\n                    this._defaultDrawContext = this.createDrawContext()!;\r\n                    this._currentDrawContext = this._defaultDrawContext;\r\n                    this._defaultMaterialContext = this.createMaterialContext()!;\r\n                    this._currentMaterialContext = this._defaultMaterialContext;\r\n\r\n                    this._initializeContextAndSwapChain();\r\n                    this._initializeMainAttachments();\r\n                    this.resize();\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((e: any) => {\r\n                    Logger.Error(\"A fatal error occurred during WebGPU creation/initialization.\");\r\n                    throw e;\r\n                })\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _initGlslangAsync(glslangOptions?: GlslangOptions): Promise<any> {\r\n        glslangOptions = glslangOptions || {};\r\n        glslangOptions = {\r\n            ...WebGPUEngine._GlslangDefaultOptions,\r\n            ...glslangOptions,\r\n        };\r\n\r\n        if (glslangOptions.glslang) {\r\n            return glslangOptions.glslang;\r\n        }\r\n\r\n        if ((self as any).glslang) {\r\n            return (self as any).glslang(glslangOptions.wasmPath);\r\n        }\r\n\r\n        if (glslangOptions.jsPath && glslangOptions.wasmPath) {\r\n            // eslint-disable-next-line github/no-then\r\n            return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {\r\n                return (self as any).glslang(Tools.GetBabylonScriptURL(glslangOptions.wasmPath!));\r\n            });\r\n        }\r\n\r\n        throw new Error(\"glslang is not available\");\r\n    }\r\n\r\n    private _initializeLimits(): void {\r\n        // Init caps\r\n        const textureFormatsTier1 = this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureFormatsTier1) >= 0;\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\r\n            maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,\r\n            maxTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,\r\n            maxVertexAttribs: this._deviceLimits.maxVertexAttributes,\r\n            maxDrawBuffers: 8,\r\n            maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,\r\n            maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\r\n            shaderFloatPrecision: 23, // WGSL always uses IEEE-754 binary32 floats (which have 23 bits of significand)\r\n            standardDerivatives: true,\r\n            astc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined) as any,\r\n            s3tc: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined) as any,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: (this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined) as any,\r\n            bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\r\n            maxAnisotropy: 16, // Most implementations support maxAnisotropy values in range between 1 and 16, inclusive. The used value of maxAnisotropy will be clamped to the maximum value that the platform supports.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: true,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: true,\r\n            blendFloat: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Blendable) >= 0,\r\n            supportFloatTexturesResolve: false, // See https://github.com/gpuweb/gpuweb/issues/3844\r\n            rg11b10ufColorRenderable: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) >= 0,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Filterable) >= 0,\r\n            textureFloatRender: true,\r\n            textureHalfFloat: true,\r\n            textureHalfFloatLinearFiltering: true,\r\n            textureHalfFloatRender: true,\r\n            textureLOD: true,\r\n            texelFetch: true,\r\n            drawBuffersExtension: true,\r\n            depthTextureExtension: true,\r\n            vertexArrayObject: false,\r\n            instancedArrays: true,\r\n            timerQuery:\r\n                typeof BigUint64Array !== \"undefined\" && this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? (true as any) : undefined,\r\n            supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\r\n            canUseTimestampForTimerQuery: true,\r\n            multiview: false,\r\n            oculusMultiview: false,\r\n            parallelShaderCompile: undefined,\r\n            blendMinMax: true,\r\n            maxMSAASamples: 4, // the spec only supports values of 1 and 4\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: true,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: true,\r\n            texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,\r\n            disableMorphTargetTexture: false,\r\n            textureNorm16: textureFormatsTier1,\r\n            blendParametersPerTarget: true,\r\n            dualSourceBlending: true,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: true,\r\n            supportRenderAndCopyToLodForFloatTextures: true,\r\n            supportDepthStencilTexture: true,\r\n            supportShadowSamplers: true,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: true,\r\n            trackUbosInFrame: true,\r\n            checkUbosContentBeforeUpload: true,\r\n            supportCSM: true,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: true,\r\n            needTypeSuffixInShaderConstants: true,\r\n            supportMSAA: true,\r\n            supportSSAO2: true,\r\n            supportIBLShadows: true,\r\n            supportExtendedTextureFormats: true,\r\n            supportSwitchCaseInShader: true,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: false,\r\n            useUBOBindingCache: false,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: true,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: true,\r\n            forceVertexBufferStrideAndOffsetMultiple4Bytes: true,\r\n            _checkNonFloatVertexBuffersDontRecreatePipelineContext: true,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n    }\r\n\r\n    private _initializeContextAndSwapChain(): void {\r\n        if (!this._renderingCanvas) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"The rendering canvas has not been set!\";\r\n        }\r\n        this._context = this._renderingCanvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n        this._configureContext();\r\n        this._colorFormat = this._options.swapChainFormat!;\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture(this)];\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.format = this._colorFormat;\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n    }\r\n\r\n    // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\r\n    private _initializeMainAttachments(): void {\r\n        if (!this._bufferManager) {\r\n            return;\r\n        }\r\n\r\n        this.flushFramebuffer();\r\n\r\n        this._mainTextureExtends = {\r\n            width: this.getRenderWidth(true),\r\n            height: this.getRenderHeight(true),\r\n            depthOrArrayLayers: 1,\r\n        };\r\n\r\n        const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);\r\n\r\n        this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\r\n        this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\r\n\r\n        let mainColorAttachments: GPURenderPassColorAttachment[];\r\n\r\n        if (this._options.antialias) {\r\n            const mainTextureDescriptor: GPUTextureDescriptor = {\r\n                label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,\r\n                size: this._mainTextureExtends,\r\n                mipLevelCount: 1,\r\n                sampleCount: this._mainPassSampleCount,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._options.swapChainFormat!,\r\n                usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n            };\r\n\r\n            if (this._mainTexture) {\r\n                this._textureHelper.releaseTexture(this._mainTexture);\r\n            }\r\n            this._mainTexture = this._device.createTexture(mainTextureDescriptor);\r\n            mainColorAttachments = [\r\n                {\r\n                    view: this._mainTexture.createView({\r\n                        label: \"TextureView_MainColor_antialiasing\",\r\n                        dimension: WebGPUConstants.TextureDimension.E2d,\r\n                        format: this._options.swapChainFormat!,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                    }),\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store, // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\r\n                },\r\n            ];\r\n        } else {\r\n            mainColorAttachments = [\r\n                {\r\n                    view: undefined as any,\r\n                    clearValue: new Color4(0, 0, 0, 1),\r\n                    loadOp: WebGPUConstants.LoadOp.Clear,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ];\r\n        }\r\n\r\n        this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n\r\n        const depthTextureDescriptor: GPUTextureDescriptor = {\r\n            label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n            size: this._mainTextureExtends,\r\n            mipLevelCount: 1,\r\n            sampleCount: this._mainPassSampleCount,\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format: this._mainRenderPassWrapper.depthTextureFormat,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment,\r\n        };\r\n\r\n        if (this._depthTexture) {\r\n            this._textureHelper.releaseTexture(this._depthTexture);\r\n        }\r\n        this._depthTexture = this._device.createTexture(depthTextureDescriptor);\r\n        const mainDepthAttachment: GPURenderPassDepthStencilAttachment = {\r\n            view: this._depthTexture.createView({\r\n                label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\r\n                dimension: WebGPUConstants.TextureDimension.E2d,\r\n                format: this._depthTexture.format,\r\n                mipLevelCount: 1,\r\n                arrayLayerCount: 1,\r\n            }),\r\n\r\n            depthClearValue: this._clearDepthValue,\r\n            depthLoadOp: WebGPUConstants.LoadOp.Clear,\r\n            depthStoreOp: WebGPUConstants.StoreOp.Store,\r\n            stencilClearValue: this._clearStencilValue,\r\n            stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\r\n            stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store,\r\n        };\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor = {\r\n            label: \"MainRenderPass\",\r\n            colorAttachments: mainColorAttachments,\r\n            depthStencilAttachment: mainDepthAttachment,\r\n        };\r\n\r\n        this.beginFrame();\r\n        this._startMainRenderPass(true, null, true, false);\r\n        this._endCurrentRenderPass();\r\n        this.endFrame();\r\n        this._frameId--; // We don't want to count the frame as a real frame, because it was only used to initialize the depth texture\r\n    }\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected override _sharedInit(canvas: HTMLCanvasElement) {\r\n        super._sharedInit(canvas);\r\n\r\n        _CommonInit(this, canvas, this._creationOptions);\r\n    }\r\n\r\n    private _configureContext(): void {\r\n        this._context.configure({\r\n            device: this._device,\r\n            format: this._options.swapChainFormat!,\r\n            usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\r\n            alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public override resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return ResizeImageBitmap(this, image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override async _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return await CreateImageBitmapFromSource(this, imageSource, options);\r\n    }\r\n\r\n    /**\r\n     * Toggle full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override switchFullscreen(requestPointerLock: boolean): void {\r\n        if (this.isFullscreen) {\r\n            this.exitFullscreen();\r\n        } else {\r\n            this.enterFullscreen(requestPointerLock);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override enterFullscreen(requestPointerLock: boolean): void {\r\n        if (!this.isFullscreen) {\r\n            this._pointerLockRequested = requestPointerLock;\r\n            if (this._renderingCanvas) {\r\n                RequestFullscreen(this._renderingCanvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits full screen mode\r\n     */\r\n    public override exitFullscreen(): void {\r\n        if (this.isFullscreen) {\r\n            ExitFullscreen();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters Pointerlock mode\r\n     */\r\n    public enterPointerlock(): void {\r\n        if (this._renderingCanvas) {\r\n            RequestPointerlock(this._renderingCanvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits Pointerlock mode\r\n     */\r\n    public exitPointerlock(): void {\r\n        ExitPointerlock();\r\n    }\r\n\r\n    protected override _rebuildBuffers(): void {\r\n        super._rebuildBuffers();\r\n\r\n        for (const storageBuffer of this._storageBuffers) {\r\n            // The buffer can already be rebuilt by the call to _rebuildGeometries(), which recreates the storage buffers for the ComputeShaderParticleSystem\r\n            if ((storageBuffer.getBuffer() as WebGPUDataBuffer).engineId !== this.uniqueId) {\r\n                storageBuffer._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _restoreEngineAfterContextLost(initEngine: () => void) {\r\n        WebGPUCacheRenderPipelineTree.ResetCache();\r\n        WebGPUCacheBindGroups.ResetCache();\r\n\r\n        // Clear the draw wrappers and material contexts\r\n        const cleanScenes = (scenes: Scene[]) => {\r\n            for (const scene of scenes) {\r\n                for (const mesh of scene.meshes) {\r\n                    const subMeshes = mesh.subMeshes;\r\n                    if (!subMeshes) {\r\n                        continue;\r\n                    }\r\n                    for (const subMesh of subMeshes) {\r\n                        subMesh._drawWrappers = [];\r\n                    }\r\n                }\r\n\r\n                for (const material of scene.materials) {\r\n                    material._materialContext?.reset();\r\n                }\r\n            }\r\n        };\r\n\r\n        cleanScenes(this.scenes);\r\n        cleanScenes(this._virtualScenes);\r\n\r\n        // The leftOver uniform buffers are removed from the list because they will be recreated when we rebuild the effects\r\n        const uboList: UniformBuffer[] = [];\r\n        for (const uniformBuffer of this._uniformBuffers) {\r\n            if (uniformBuffer.name.indexOf(\"leftOver\") < 0) {\r\n                uboList.push(uniformBuffer);\r\n            }\r\n        }\r\n        this._uniformBuffers = uboList;\r\n\r\n        super._restoreEngineAfterContextLost(initEngine);\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public override setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!super.setSize(width, height, forceSetSize)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"frame #\" + (this as any)._count + \" - setSize -\", width, height]);\r\n            }\r\n        }\r\n\r\n        this._initializeMainAttachments();\r\n\r\n        if (this.snapshotRendering) {\r\n            // reset snapshot rendering so that the next frame will record a new list of bundles\r\n            this.snapshotRenderingReset();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _shaderProcessorWGSL: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._shaderProcessorWGSL;\r\n        }\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage, pureMode: boolean): Nullable<_IShaderProcessingContext> {\r\n        return new WebGPUShaderProcessingContext(shaderLanguage, pureMode);\r\n    }\r\n\r\n    private _getCurrentRenderPass(): GPURenderPassEncoder {\r\n        if (this._currentRenderTarget && !this._currentRenderPass) {\r\n            // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\r\n            this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        return this._currentRenderPass!;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getCurrentRenderPassWrapper() {\r\n        return this._currentRenderTarget ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                          Static Pipeline WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    /** @internal */\r\n    public applyStates() {\r\n        this._stencilStateComposer.apply();\r\n        this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n\r\n        //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\r\n        // _forceEnableEffect = true assumes the role of _currentEffect = null\r\n        this._forceEnableEffect = true;\r\n        this._currentIndexBuffer = null;\r\n        this._currentOverrideVertexBuffers = null;\r\n        this._cacheRenderPipeline.setBuffers(null, null, null);\r\n\r\n        if (bruteForce) {\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._resetAlphaMode();\r\n            this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n            this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState._alphaBlend, this._alphaState._numTargetEnabled);\r\n\r\n            this.setColorWrite(true);\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public override setColorWrite(enable: boolean): void {\r\n        this._colorWriteLocal = enable;\r\n        this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public override getColorWrite(): boolean {\r\n        return this._colorWriteLocal;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dynamic WebGPU States\r\n    //------------------------------------------------------------------------------\r\n\r\n    // index 0 is for main render pass, 1 for RTT render pass\r\n    private _viewportsCurrent: { x: number; y: number; w: number; h: number } = { x: 0, y: 0, w: 0, h: 0 };\r\n\r\n    private _mustUpdateViewport(): boolean {\r\n        const x = this._viewportCached.x,\r\n            y = this._viewportCached.y,\r\n            w = this._viewportCached.z,\r\n            h = this._viewportCached.w;\r\n\r\n        const update = this._viewportsCurrent.x !== x || this._viewportsCurrent.y !== y || this._viewportsCurrent.w !== w || this._viewportsCurrent.h !== h;\r\n\r\n        if (update) {\r\n            this._viewportsCurrent.x = this._viewportCached.x;\r\n            this._viewportsCurrent.y = this._viewportCached.y;\r\n            this._viewportsCurrent.w = this._viewportCached.z;\r\n            this._viewportsCurrent.h = this._viewportCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyViewport(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const x = Math.floor(this._viewportCached.x);\r\n        const w = Math.floor(this._viewportCached.z);\r\n        const h = Math.floor(this._viewportCached.w);\r\n\r\n        let y = Math.floor(this._viewportCached.y);\r\n\r\n        if (!this._currentRenderTarget) {\r\n            y = this.getRenderHeight(true) - y - h;\r\n        }\r\n\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemViewport(x, y, w, h));\r\n        } else {\r\n            this._getCurrentRenderPass().setViewport(x, y, w, h, 0, 1);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - viewport applied - (\",\r\n                    this._viewportCached.x,\r\n                    this._viewportCached.y,\r\n                    this._viewportCached.z,\r\n                    this._viewportCached.w,\r\n                    \") current pass is main pass=\" + this._currentPassIsMainPass(),\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        this._viewportCached.x = x;\r\n        this._viewportCached.y = y;\r\n        this._viewportCached.z = width;\r\n        this._viewportCached.w = height;\r\n    }\r\n\r\n    private _scissorsCurrent: { x: number; y: number; w: number; h: number } = { x: 0, y: 0, w: 0, h: 0 };\r\n    protected _scissorCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    private _mustUpdateScissor(): boolean {\r\n        const x = this._scissorCached.x,\r\n            y = this._scissorCached.y,\r\n            w = this._scissorCached.z,\r\n            h = this._scissorCached.w;\r\n\r\n        const update = this._scissorsCurrent.x !== x || this._scissorsCurrent.y !== y || this._scissorsCurrent.w !== w || this._scissorsCurrent.h !== h;\r\n\r\n        if (update) {\r\n            this._scissorsCurrent.x = this._scissorCached.x;\r\n            this._scissorsCurrent.y = this._scissorCached.y;\r\n            this._scissorsCurrent.w = this._scissorCached.z;\r\n            this._scissorsCurrent.h = this._scissorCached.w;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyScissor(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const y = this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y;\r\n\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w));\r\n        } else {\r\n            this._getCurrentRenderPass().setScissorRect(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - scissor applied - (\",\r\n                    this._scissorCached.x,\r\n                    this._scissorCached.y,\r\n                    this._scissorCached.z,\r\n                    this._scissorCached.w,\r\n                    \") current pass is main pass=\" + this._currentPassIsMainPass(),\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scissorIsActive() {\r\n        return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\r\n    }\r\n\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        this._scissorCached.x = x;\r\n        this._scissorCached.y = y;\r\n        this._scissorCached.z = width;\r\n        this._scissorCached.w = height;\r\n    }\r\n\r\n    public disableScissor() {\r\n        this._scissorCached.x = this._scissorCached.y = this._scissorCached.z = this._scissorCached.w = 0;\r\n        this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\r\n    }\r\n\r\n    private _stencilRefsCurrent = -1;\r\n\r\n    private _mustUpdateStencilRef(): boolean {\r\n        const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent;\r\n        if (update) {\r\n            this._stencilRefsCurrent = this._stencilStateComposer.funcRef;\r\n        }\r\n        return update;\r\n    }\r\n\r\n    private _applyStencilRef(bundleList: Nullable<WebGPUBundleList>): void {\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\r\n        } else {\r\n            this._getCurrentRenderPass().setStencilReference(this._stencilStateComposer.funcRef ?? 0);\r\n        }\r\n    }\r\n\r\n    private _blendColorsCurrent: Array<Nullable<number>> = [null, null, null, null];\r\n\r\n    private _mustUpdateBlendColor(): boolean {\r\n        const colorBlend = this._alphaState._blendConstants;\r\n\r\n        const update =\r\n            colorBlend[0] !== this._blendColorsCurrent[0] ||\r\n            colorBlend[1] !== this._blendColorsCurrent[1] ||\r\n            colorBlend[2] !== this._blendColorsCurrent[2] ||\r\n            colorBlend[3] !== this._blendColorsCurrent[3];\r\n\r\n        if (update) {\r\n            this._blendColorsCurrent[0] = colorBlend[0];\r\n            this._blendColorsCurrent[1] = colorBlend[1];\r\n            this._blendColorsCurrent[2] = colorBlend[2];\r\n            this._blendColorsCurrent[3] = colorBlend[3];\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    private _applyBlendColor(bundleList: Nullable<WebGPUBundleList>): void {\r\n        if (bundleList) {\r\n            bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\r\n        } else {\r\n            this._getCurrentRenderPass().setBlendConstant(this._alphaState._blendConstants as GPUColor);\r\n        }\r\n    }\r\n\r\n    private _resetRenderPassStates() {\r\n        this._viewportsCurrent.x = this._viewportsCurrent.y = this._viewportsCurrent.w = this._viewportsCurrent.h = 0;\r\n        this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\r\n        this._stencilRefsCurrent = -1;\r\n        this._blendColorsCurrent[0] = this._blendColorsCurrent[1] = this._blendColorsCurrent[2] = this._blendColorsCurrent[3] = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     * @param stencilClearValue defines the value to use to clear the stencil buffer (default is 0)\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false, stencilClearValue = 0): void {\r\n        // Some PGs are using color3...\r\n        if (color && color.a === undefined) {\r\n            color.a = 1;\r\n        }\r\n\r\n        if (stencil) {\r\n            this._clearStencilValue = stencilClearValue;\r\n        }\r\n\r\n        const hasScissor = this._scissorIsActive();\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"frame #\" + (this as any)._count + \" - clear - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor]);\r\n            }\r\n        }\r\n\r\n        // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\r\n        if (this._currentRenderTarget) {\r\n            if (hasScissor) {\r\n                if (!this._currentRenderPass) {\r\n                    this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\r\n                }\r\n                this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            } else {\r\n                if (this._currentRenderPass) {\r\n                    this._endCurrentRenderPass();\r\n                }\r\n                this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\r\n            }\r\n        } else {\r\n            if (!this._currentRenderPass || !hasScissor) {\r\n                this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\r\n            }\r\n            if (hasScissor) {\r\n                this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\r\n                this._clearFullQuad(backBuffer ? color : null, depth, stencil);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _clearFullQuad(clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\r\n\r\n        this._clearQuad.setColorFormat(this._colorFormat);\r\n        this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\r\n        this._clearQuad.setMRTAttachments(\r\n            this._cacheRenderPipeline.mrtAttachments ?? [],\r\n            this._cacheRenderPipeline.mrtTextureArray ?? [],\r\n            this._cacheRenderPipeline.mrtTextureCount\r\n        );\r\n\r\n        if (!this.compatibilityMode) {\r\n            this._bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\r\n        } else {\r\n            renderPass!.setStencilReference(this._clearStencilValue);\r\n        }\r\n\r\n        const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\r\n\r\n        if (!this.compatibilityMode) {\r\n            this._bundleList.addBundle(bundle!);\r\n            this._applyStencilRef(this._bundleList);\r\n            this._reportDrawCall();\r\n        } else {\r\n            this._applyStencilRef(null);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Vertex/Index/Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or the size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray | number, _updatable?: boolean, label?: string): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(\r\n            view,\r\n            WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Storage,\r\n            label\r\n        );\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray, label?: string): DataBuffer {\r\n        return this.createVertexBuffer(data, undefined, label);\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param _updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer {\r\n        let is32Bits = true;\r\n        let view: ArrayBufferView | undefined;\r\n\r\n        if (indices instanceof Uint32Array || indices instanceof Int32Array) {\r\n            view = indices;\r\n        } else if (indices instanceof Uint16Array) {\r\n            view = indices;\r\n            is32Bits = false;\r\n        } else {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                if (indices[index] > 65535) {\r\n                    view = new Uint32Array(indices);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!view) {\r\n                view = new Uint16Array(indices);\r\n                is32Bits = false;\r\n            }\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(\r\n            view,\r\n            WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Storage,\r\n            label\r\n        );\r\n        dataBuffer.is32Bits = is32Bits;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public override updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n        const gpuBuffer = indexBuffer as WebGPUDataBuffer;\r\n\r\n        let view: ArrayBufferView;\r\n        if (indexBuffer.is32Bits) {\r\n            view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);\r\n        } else {\r\n            view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);\r\n        }\r\n\r\n        this._bufferManager.setSubData(gpuBuffer, offset, view);\r\n    }\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param data the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public override updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const dataBuffer = vertexBuffer as WebGPUDataBuffer;\r\n        if (byteOffset === undefined) {\r\n            byteOffset = 0;\r\n        }\r\n\r\n        let view: ArrayBufferView;\r\n        if (byteLength === undefined) {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n            byteLength = view.byteLength;\r\n        } else {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n        let view: ArrayBufferView | number;\r\n\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n\r\n        let flags = 0;\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_READ) {\r\n            flags |= WebGPUConstants.BufferUsage.CopySrc;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_WRITE) {\r\n            flags |= WebGPUConstants.BufferUsage.CopyDst;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_UNIFORM) {\r\n            flags |= WebGPUConstants.BufferUsage.Uniform;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_VERTEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Vertex;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDEX) {\r\n            flags |= WebGPUConstants.BufferUsage.Index;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_STORAGE) {\r\n            flags |= WebGPUConstants.BufferUsage.Storage;\r\n        }\r\n        if (creationFlags & Constants.BUFFER_CREATIONFLAG_INDIRECT) {\r\n            flags |= WebGPUConstants.BufferUsage.Indirect;\r\n        }\r\n\r\n        return this._bufferManager.createBuffer(view, flags, label);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindBuffersDirectly(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public updateAndBindInstancesBuffer(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not implemented on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public unbindInstanceAttributes(): void {\r\n        // Does nothing\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers with the engine\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param _effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        _effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        this._currentVertexBuffers = vertexBuffers;\r\n        this._currentIndexBuffer = indexBuffer;\r\n        this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\r\n        this._cacheRenderPipeline.setBuffers(this._currentVertexBuffers, this._currentIndexBuffer, this._currentOverrideVertexBuffers);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        return this._bufferManager.releaseBuffer(buffer);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Uniform Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create an uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public createUniformBuffer(elements: FloatArray, label?: string): DataBuffer {\r\n        let view: Float32Array;\r\n        if (elements instanceof Array) {\r\n            view = new Float32Array(elements);\r\n        } else {\r\n            view = elements;\r\n        }\r\n\r\n        const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, label);\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Create a dynamic uniform buffer (no different from a non dynamic uniform buffer in WebGPU)\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer {\r\n        return this.createUniformBuffer(elements, label);\r\n    }\r\n\r\n    /**\r\n     * Update an existing uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param uniformBuffer defines the target uniform buffer\r\n     * @param elements defines the content to update\r\n     * @param offset defines the offset in the uniform buffer where update should start\r\n     * @param count defines the size of the data to update\r\n     */\r\n    public updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        const dataBuffer = uniformBuffer as WebGPUDataBuffer;\r\n        let view: Float32Array;\r\n        if (count === undefined) {\r\n            if (elements instanceof Float32Array) {\r\n                view = elements;\r\n            } else {\r\n                view = new Float32Array(elements);\r\n            }\r\n            count = view.byteLength;\r\n        } else {\r\n            if (elements instanceof Float32Array) {\r\n                view = elements;\r\n            } else {\r\n                view = new Float32Array(elements);\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, offset, view, 0, count);\r\n    }\r\n\r\n    /**\r\n     * Bind a buffer to the current draw context\r\n     * @param buffer defines the buffer to bind\r\n     * @param _location not used in WebGPU\r\n     * @param name Name of the uniform variable to bind\r\n     */\r\n    public bindUniformBufferBase(buffer: DataBuffer, _location: number, name: string): void {\r\n        this._currentDrawContext.setBuffer(name, buffer as WebGPUDataBuffer);\r\n    }\r\n\r\n    /**\r\n     * Unused in WebGPU\r\n     */\r\n    public bindUniformBlock(): void {}\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Effects\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @param extraInitializationsAsync additional async code to run before preparing the effect\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ): Effect {\r\n        const vertex = typeof baseName === \"string\" ? baseName : baseName.vertexToken || baseName.vertexSource || baseName.vertexElement || baseName.vertex;\r\n        const fragment = typeof baseName === \"string\" ? baseName : baseName.fragmentToken || baseName.fragmentSource || baseName.fragmentElement || baseName.fragment;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        const isOptions = (attributesNamesOrOptions as IEffectCreationOptions).attributes !== undefined;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += \"\\n\" + globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n            compiledEffect._refCount++;\r\n            return compiledEffect;\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            isOptions ? this : uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            (<IEffectCreationOptions>attributesNamesOrOptions).shaderLanguage ?? shaderLanguage,\r\n            (<IEffectCreationOptions>attributesNamesOrOptions).extraInitializationsAsync ?? extraInitializationsAsync\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _compileRawShaderToSpirV(source: string, type: string): Uint32Array {\r\n        return this._glslang.compileGLSL(source, type);\r\n    }\r\n\r\n    private _compileShaderToSpirV(source: string, type: string, defines: Nullable<string>, shaderVersion: string): Uint32Array {\r\n        return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\r\n    }\r\n\r\n    private _getWGSLShader(source: string, type: string, defines: Nullable<string>): string {\r\n        if (defines) {\r\n            defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n        } else {\r\n            defines = \"\";\r\n        }\r\n        return defines + source;\r\n    }\r\n\r\n    private _createPipelineStageDescriptor(\r\n        vertexShader: Uint32Array | string,\r\n        fragmentShader: Uint32Array | string,\r\n        shaderLanguage: ShaderLanguage,\r\n        disableUniformityAnalysisInVertex: boolean,\r\n        disableUniformityAnalysisInFragment: boolean\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\r\n            vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader as Uint32Array, disableUniformityAnalysisInVertex);\r\n            fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader as Uint32Array, disableUniformityAnalysisInFragment);\r\n        }\r\n\r\n        return {\r\n            vertexStage: {\r\n                module: this._device.createShaderModule({\r\n                    label: \"vertex\",\r\n                    code: vertexShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n            fragmentStage: {\r\n                module: this._device.createShaderModule({\r\n                    label: \"fragment\",\r\n                    code: fragmentShader,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        };\r\n    }\r\n\r\n    private _compileRawPipelineStageDescriptor(vertexCode: string, fragmentCode: string, shaderLanguage: ShaderLanguage): IWebGPURenderPipelineStageDescriptor {\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(Constants.DISABLEUA) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(Constants.DISABLEUA) >= 0;\r\n\r\n        const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\r\n        const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\r\n\r\n        return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n    }\r\n\r\n    private _compilePipelineStageDescriptor(\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        shaderLanguage: ShaderLanguage\r\n    ): IWebGPURenderPipelineStageDescriptor {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const disableUniformityAnalysisInVertex = vertexCode.indexOf(Constants.DISABLEUA) >= 0;\r\n        const disableUniformityAnalysisInFragment = fragmentCode.indexOf(Constants.DISABLEUA) >= 0;\r\n\r\n        const shaderVersion = \"#version 450\\n\";\r\n        const vertexShader =\r\n            shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\r\n        const fragmentShader =\r\n            shaderLanguage === ShaderLanguage.GLSL\r\n                ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion)\r\n                : this._getWGSLShader(fragmentCode, \"fragment\", defines);\r\n\r\n        const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\r\n\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createShaderProgram(): WebGLProgram {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Not available on WebGPU\";\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<_IShaderProcessingContext>): IPipelineContext {\r\n        return new WebGPUPipelineContext(shaderProcessingContext! as WebGPUShaderProcessingContext, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): WebGPUMaterialContext | undefined {\r\n        return new WebGPUMaterialContext();\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): WebGPUDrawContext | undefined {\r\n        return new WebGPUDrawContext(this._bufferManager, this._dummyIndexBuffer);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n    public async _preparePipelineContextAsync(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        _rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        _transformFeedbackVaryings: Nullable<string[]>,\r\n        _key: string,\r\n        onReady: () => void\r\n    ) {\r\n        const webGpuContext = pipelineContext as WebGPUPipelineContext;\r\n        const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\r\n\r\n        if (shaderLanguage === ShaderLanguage.GLSL && !this._glslangAndTintAreFullyLoaded) {\r\n            await this.prepareGlslangAndTintAsync();\r\n        }\r\n\r\n        if (this.dbgShowShaderCode) {\r\n            Logger.Log([\"defines\", defines]);\r\n            Logger.Log(vertexSourceCode);\r\n            Logger.Log(fragmentSourceCode);\r\n            Logger.Log(\"***********************************************\");\r\n        }\r\n\r\n        webGpuContext.sources = {\r\n            fragment: fragmentSourceCode,\r\n            vertex: vertexSourceCode,\r\n            rawVertex: rawVertexSourceCode,\r\n            rawFragment: rawFragmentSourceCode,\r\n        };\r\n\r\n        if (createAsRaw) {\r\n            webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\r\n        } else {\r\n            webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\r\n        }\r\n\r\n        onReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given WebGPU program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = new Array(attributesNames.length);\r\n        const gpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n\r\n        for (let i = 0; i < attributesNames.length; i++) {\r\n            const attributeName = attributesNames[i];\r\n            const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\r\n            if (attributeLocation === undefined) {\r\n                continue;\r\n            }\r\n\r\n            results[i] = attributeLocation;\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (!IsWrapper(effect)) {\r\n            this._currentEffect = effect;\r\n            this._currentMaterialContext = this._defaultMaterialContext;\r\n            this._currentDrawContext = this._defaultDrawContext;\r\n            this._counters.numEnableEffects++;\r\n            if (this.dbgLogIfNotDrawWrapper) {\r\n                Logger.Warn(\r\n                    `enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${typeof effect.name === \"string\" ? \"\" : effect.name.vertex}, effect.name.fragment=${typeof effect.name === \"string\" ? \"\" : effect.name.fragment}`,\r\n                    10\r\n                );\r\n            }\r\n        } else if (\r\n            !effect.effect ||\r\n            (effect.effect === this._currentEffect &&\r\n                effect.materialContext === this._currentMaterialContext &&\r\n                effect.drawContext === this._currentDrawContext &&\r\n                !this._forceEnableEffect)\r\n        ) {\r\n            if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\r\n                Logger.Log([\"drawWrapper=\", effect]);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Invalid call to enableEffect: the effect property is empty!\";\r\n            }\r\n            return;\r\n        } else {\r\n            this._currentEffect = effect.effect;\r\n            this._currentMaterialContext = effect.materialContext as WebGPUMaterialContext;\r\n            this._currentDrawContext = effect.drawContext as WebGPUDrawContext;\r\n            this._counters.numEnableDrawWrapper++;\r\n            if (!this._currentMaterialContext) {\r\n                Logger.Log([\"drawWrapper=\", effect]);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw `Invalid call to enableEffect: the materialContext property is empty!`;\r\n            }\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        this._forceEnableEffect = false;\r\n\r\n        if (this._currentEffect.onBind) {\r\n            this._currentEffect.onBind(this._currentEffect);\r\n        }\r\n        if (this._currentEffect._onBindObservable) {\r\n            this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n\r\n            this._deletePipelineContext(effect.getPipelineContext() as WebGPUPipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGPUPipelineContext;\r\n            this._deletePipelineContext(webGPUPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n\r\n        this.onReleaseEffectsObservable.notifyObservers(this);\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webgpuPipelineContext = pipelineContext as WebGPUPipelineContext;\r\n        if (webgpuPipelineContext) {\r\n            resetCachedPipeline(webgpuPipelineContext);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): IHardwareTextureWrapper {\r\n        return new WebGPUHardwareTexture(this);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        this._textureHelper.releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(): number {\r\n        return Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        const fullOptions: InternalTextureCreationOptions = {};\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.createMipMaps = options.createMipMaps;\r\n            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_BYTE : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            fullOptions.format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            fullOptions.samples = options.samples ?? 1;\r\n            fullOptions.creationFlags = options.creationFlags ?? 0;\r\n            fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;\r\n            fullOptions.label = options.label;\r\n        } else {\r\n            fullOptions.generateMipMaps = options;\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n            fullOptions.format = Constants.TEXTUREFORMAT_RGBA;\r\n            fullOptions.samples = 1;\r\n            fullOptions.creationFlags = 0;\r\n            fullOptions.useSRGBBuffer = false;\r\n        }\r\n\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n        const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth ?? 0;\r\n        const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers ?? 0;\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth || layers;\r\n        texture.isReady = true;\r\n        texture.samples = fullOptions.samples;\r\n        texture.generateMipMaps = !!fullOptions.generateMipMaps;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture.format = fullOptions.format;\r\n        texture.is2DArray = layers > 0;\r\n        texture.is3D = depth > 0;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\r\n        texture.label = fullOptions.label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        if (!delayGPUTextureCreation) {\r\n            const createMipMapsOnly = !fullOptions.generateMipMaps && fullOptions.createMipMaps;\r\n\r\n            if (createMipMapsOnly) {\r\n                // So that the call to createGPUTextureForInternalTexture creates the mipmaps\r\n                texture.generateMipMaps = true;\r\n            }\r\n\r\n            this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\r\n\r\n            if (createMipMapsOnly) {\r\n                // So that we don't automatically generate mipmaps when the render target is unbound\r\n                texture.generateMipMaps = false;\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a hardware texture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (\r\n                texture: InternalTexture,\r\n                extension: string,\r\n                scene: Nullable<ISceneLike>,\r\n                img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                invertY: boolean,\r\n                noMipmap: boolean,\r\n                isCompressed: boolean,\r\n                processFunction: (\r\n                    width: number,\r\n                    height: number,\r\n                    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n                    extension: string,\r\n                    texture: InternalTexture,\r\n                    continuationCallback: () => void\r\n                ) => boolean\r\n            ) => {\r\n                const imageBitmap = img as ImageBitmap | { width: number; height: number }; // we will never get an HTMLImageElement in WebGPU\r\n\r\n                texture.baseWidth = imageBitmap.width;\r\n                texture.baseHeight = imageBitmap.height;\r\n                texture.width = imageBitmap.width;\r\n                texture.height = imageBitmap.height;\r\n                texture.format = texture.format !== -1 ? texture.format : (format ?? Constants.TEXTUREFORMAT_RGBA);\r\n                texture.type = texture.type !== -1 ? texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                texture._creationFlags = creationFlags ?? 0;\r\n\r\n                processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\r\n\r\n                if (!texture._hardwareTexture?.underlyingResource) {\r\n                    // the texture could have been created before reaching this point so don't recreate it if already existing\r\n                    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\r\n\r\n                    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n                        this._textureHelper.updateTexture(\r\n                            imageBitmap,\r\n                            texture,\r\n                            imageBitmap.width,\r\n                            imageBitmap.height,\r\n                            texture.depth,\r\n                            gpuTextureWrapper.format,\r\n                            0,\r\n                            0,\r\n                            invertY,\r\n                            false,\r\n                            0,\r\n                            0\r\n                        );\r\n                        if (!noMipmap && !isCompressed) {\r\n                            this._generateMipmaps(texture, this._uploadEncoder);\r\n                        }\r\n                    }\r\n                } else if (!noMipmap && !isCompressed) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                if (scene) {\r\n                    scene.removePendingData(texture);\r\n                }\r\n\r\n                texture.isReady = true;\r\n\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n            },\r\n            () => false,\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gpu texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGPUTexture(texture: GPUTexture): InternalTexture {\r\n        const hardwareTexture = new WebGPUHardwareTexture(this, texture);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getUseSRGBBuffer(useSRGBBuffer: boolean, _noMipmap: boolean): boolean {\r\n        return useSRGBBuffer && this._caps.supportSRGBBuffers;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY(_value: boolean) {}\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._generateMipmaps(texture);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        if (wrapU !== null) {\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {\r\n        if (!texture._hardwareTexture) {\r\n            // the gpu texture is not created yet, so when it is it will be created with the right dimensions\r\n            return;\r\n        }\r\n\r\n        if (texture.width === width && texture.height === height && texture.depth === depth) {\r\n            return;\r\n        }\r\n\r\n        const additionalUsages = (texture._hardwareTexture as WebGPUHardwareTexture).textureAdditionalUsages;\r\n\r\n        texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setInternalTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>, baseName?: string): void {\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            const webgpuPipelineContext = this._currentEffect._pipelineContext as WebGPUPipelineContext;\r\n            const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\r\n\r\n            this._currentMaterialContext.setTexture(name, texture);\r\n\r\n            if (availableTexture && availableTexture.autoBindSampler) {\r\n                const samplerName = baseName + Constants.AUTOSAMPLERSUFFIX;\r\n                this._currentMaterialContext.setSampler(samplerName, texture as InternalTexture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n     * @param rootUrl defines the url where the file to load is located\r\n     * @param scene defines the current scene\r\n     * @param lodScale defines scale to apply to the mip map selection\r\n     * @param lodOffset defines offset to apply to the mip map selection\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public override createPrefilteredCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        lodScale: number,\r\n        lodOffset: number,\r\n        onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format?: number,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = true\r\n    ): InternalTexture {\r\n        const callback = (loadData: any) => {\r\n            if (!loadData) {\r\n                if (onLoad) {\r\n                    onLoad(null);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const texture = loadData.texture as InternalTexture;\r\n            if (!createPolynomials) {\r\n                texture._sphericalPolynomial = new SphericalPolynomial();\r\n            } else if (loadData.info.sphericalPolynomial) {\r\n                texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n            }\r\n            texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n        };\r\n\r\n        return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>, name: string): void {\r\n        this._setTexture(channel, texture, false, false, name, name);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the WebGPU context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param unused unused parameter\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, unused: Nullable<WebGLUniformLocation>, textures: BaseTexture[], name: string): void {\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _setTexture(\r\n        channel: number,\r\n        texture: Nullable<BaseTexture>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        isPartOfTextureArray = false,\r\n        depthStencilTexture = false,\r\n        name = \"\",\r\n        baseName?: string\r\n    ): boolean {\r\n        // name == baseName for a texture that is not part of a texture array\r\n        // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\r\n        // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\r\n        // name is used to look up the texture in the _currentMaterialContext.textures map\r\n        baseName = baseName ?? name;\r\n        if (this._currentEffect) {\r\n            if (!texture) {\r\n                this._currentMaterialContext.setTexture(name, null);\r\n                return false;\r\n            }\r\n\r\n            // Video\r\n            if ((<VideoTexture>texture).video) {\r\n                (<VideoTexture>texture).update();\r\n            } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                // Delay loading\r\n                texture.delayLoad();\r\n                return false;\r\n            }\r\n\r\n            let internalTexture: Nullable<InternalTexture> = null;\r\n            if (depthStencilTexture) {\r\n                internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n            } else if (texture.isReady()) {\r\n                internalTexture = <InternalTexture>texture.getInternalTexture();\r\n            } else if (texture.isCube) {\r\n                internalTexture = this.emptyCubeTexture;\r\n            } else if (texture.is3D) {\r\n                internalTexture = this.emptyTexture3D;\r\n            } else if (texture.is2DArray) {\r\n                internalTexture = this.emptyTexture2DArray;\r\n            } else {\r\n                internalTexture = this.emptyTexture;\r\n            }\r\n\r\n            if (internalTexture && !internalTexture.isMultiview) {\r\n                // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n                if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                    const textureWrapMode =\r\n                        texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                            ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                            : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    texture.wrapU = textureWrapMode;\r\n                    texture.wrapV = textureWrapMode;\r\n                }\r\n\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                if (internalTexture.is3D) {\r\n                    internalTexture._cachedWrapR = texture.wrapR;\r\n                }\r\n\r\n                this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\r\n            }\r\n\r\n            this._setInternalTexture(name, internalTexture, baseName);\r\n        } else {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    Logger.Log([\"frame #\" + (this as any)._count + \" - _setTexture called with a null _currentEffect! texture=\", texture]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        this._generateMipmaps(texture);\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\r\n\r\n        if (generateMipMaps) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            texture.format = internalFormat;\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n        }\r\n\r\n        const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        if (!texture._hardwareTexture?.underlyingResource) {\r\n            gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n        }\r\n\r\n        if (image instanceof HTMLImageElement) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\r\n        }\r\n\r\n        const bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\r\n\r\n        const width = Math.ceil(texture.width / (1 << lod));\r\n        const height = Math.ceil(texture.height / (1 << lod));\r\n\r\n        this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param _hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param data defines the data to fill with the read pixels (if not provided, a new one will be created)\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readPixels(x: number, y: number, width: number, height: number, _hasAlpha = true, flushRenderer = true, data: Nullable<Uint8Array> = null): Promise<ArrayBufferView> {\r\n        const renderPassWrapper = this._getCurrentRenderPassWrapper();\r\n        const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\r\n        if (!hardwareTexture) {\r\n            // we are calling readPixels for a render pass with no color texture bound\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        const gpuTexture = hardwareTexture.underlyingResource;\r\n        const gpuTextureFormat = hardwareTexture.format;\r\n        if (!gpuTexture) {\r\n            // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\r\n            return Promise.resolve(new Uint8Array(0));\r\n        }\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat, undefined, undefined, data);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Frame management\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _measureFps(): void {\r\n        this._performanceMonitor.sampleFrame();\r\n        this._fps = this._performanceMonitor.averageFPS;\r\n        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\r\n    }\r\n\r\n    private _performanceMonitor = new PerformanceMonitor();\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public get performanceMonitor(): PerformanceMonitor {\r\n        return this._performanceMonitor;\r\n    }\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public override beginFrame(): void {\r\n        this._measureFps();\r\n        super.beginFrame();\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public override endFrame() {\r\n        this._endCurrentRenderPass();\r\n\r\n        this._snapshotRendering.endFrame();\r\n\r\n        this._timestampQuery.endFrame(this._renderEncoder);\r\n        this._timestampIndex = 0;\r\n\r\n        this.flushFramebuffer();\r\n\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n\r\n        if (this._features._collectUbosUpdatedInFrame) {\r\n            if (this.dbgVerboseLogsForFirstFrames) {\r\n                if ((this as any)._count === undefined) {\r\n                    (this as any)._count = 0;\r\n                }\r\n                if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                    const list: Array<string> = [];\r\n                    for (const name in UniformBuffer._UpdatedUbosInFrame) {\r\n                        list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\r\n                    }\r\n                    Logger.Log([\"frame #\" + (this as any)._count + \" - updated ubos -\", list.join(\", \")]);\r\n                }\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame = {};\r\n        }\r\n\r\n        this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\r\n        this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\r\n        this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\r\n        this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\r\n        this._counters.numEnableEffects = 0;\r\n        this._counters.numEnableDrawWrapper = 0;\r\n        this._counters.numBundleCreationNonCompatMode = 0;\r\n        this._counters.numBundleReuseNonCompatMode = 0;\r\n\r\n        this._cacheRenderPipeline.endFrame();\r\n        this._cacheBindGroups.endFrame();\r\n\r\n        this._pendingDebugCommands.length = 0;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\"%c frame #\" + (this as any)._count + \" - end\", \"background: #ffff00\"]);\r\n            }\r\n            if ((this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                (this as any)._count++;\r\n                if ((this as any)._count !== this.dbgVerboseLogsNumFrames) {\r\n                    Logger.Log([\"%c frame #\" + (this as any)._count + \" - begin\", \"background: #ffff00\"]);\r\n                }\r\n            }\r\n        }\r\n\r\n        super.endFrame();\r\n    }\r\n\r\n    /**Gets driver info if available */\r\n    public extractDriverInfo() {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     */\r\n    public flushFramebuffer(): void {\r\n        // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\r\n        this._endCurrentRenderPass();\r\n\r\n        this._commandBuffers[0] = this._uploadEncoder.finish();\r\n        this._commandBuffers[1] = this._renderEncoder.finish();\r\n\r\n        this._device.queue.submit(this._commandBuffers);\r\n\r\n        this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\r\n        this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\r\n\r\n        this._timestampQuery.startFrame(this._uploadEncoder);\r\n\r\n        this._textureHelper.setCommandEncoder(this._uploadEncoder);\r\n\r\n        this._bundleList.reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentPassIsMainPass();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render Pass\r\n    //------------------------------------------------------------------------------\r\n\r\n    private _startRenderTargetRenderPass(\r\n        renderTargetWrapper: RenderTargetWrapper,\r\n        setClearStates: boolean,\r\n        clearColor: Nullable<IColor4Like>,\r\n        clearDepth: boolean,\r\n        clearStencil: boolean\r\n    ) {\r\n        this._endCurrentRenderPass();\r\n\r\n        const rtWrapper = renderTargetWrapper as WebGPURenderTargetWrapper;\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n        const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource as Nullable<GPUTexture>;\r\n        const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.getMSAATexture(0);\r\n\r\n        const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor!);\r\n        const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\r\n\r\n        const colorAttachments: (GPURenderPassColorAttachment | null)[] = [];\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const clearColorForIntegerRt = TempColor4;\r\n        if (clearColor) {\r\n            clearColorForIntegerRt.r = clearColor.r * 255;\r\n            clearColorForIntegerRt.g = clearColor.g * 255;\r\n            clearColorForIntegerRt.b = clearColor.b * 255;\r\n            clearColorForIntegerRt.a = clearColor.a * 255;\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        if (rtWrapper._attachments && rtWrapper.isMulti) {\r\n            // multi render targets\r\n            if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\r\n                this._mrtAttachments = rtWrapper._defaultAttachments;\r\n            }\r\n            for (let i = 0; i < this._mrtAttachments.length; ++i) {\r\n                const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\r\n                const mrtTexture = rtWrapper.textures![i];\r\n                const gpuMRTWrapper = mrtTexture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n                const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\r\n                if (gpuMRTWrapper && gpuMRTTexture) {\r\n                    const baseArrayLayer = rtWrapper.getBaseArrayLayer(i);\r\n                    const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(baseArrayLayer);\r\n\r\n                    const viewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        dimension: mrtTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer,\r\n                    };\r\n                    const msaaViewDescriptor = {\r\n                        ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor!,\r\n                        dimension: mrtTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                        format: gpuMRTWrapper.format,\r\n                        baseArrayLayer: 0,\r\n                    };\r\n                    const isRtInteger = mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || mrtTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                    const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\r\n                    const colorMSAATextureView = gpuMSAATexture?.createView(msaaViewDescriptor);\r\n\r\n                    colorAttachments.push({\r\n                        view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                        resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                        depthSlice: mrtTexture.is3D ? (rtWrapper.layerIndices?.[i] ?? 0) : undefined,\r\n                        clearValue: index !== 0 && mustClearColor ? (isRtInteger ? clearColorForIntegerRt : clearColor) : undefined,\r\n                        loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    });\r\n                }\r\n            }\r\n            this._cacheRenderPipeline.setMRT(rtWrapper.textures!, this._mrtAttachments.length);\r\n            this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n        } else {\r\n            // single render target\r\n            const internalTexture = rtWrapper.texture;\r\n            if (internalTexture) {\r\n                const gpuWrapper = internalTexture._hardwareTexture as WebGPUHardwareTexture;\r\n                const gpuTexture = gpuWrapper.underlyingResource!;\r\n\r\n                let depthSlice: number | undefined = undefined;\r\n\r\n                if (rtWrapper.is3D) {\r\n                    depthSlice = this._rttRenderPassWrapper.colorAttachmentViewDescriptor!.baseArrayLayer;\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor!.baseArrayLayer = 0;\r\n                }\r\n\r\n                const gpuMSAATexture = gpuWrapper.getMSAATexture(0);\r\n                const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor!);\r\n                const isRtInteger = internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_INTEGER || internalTexture.type === Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n                colorAttachments.push({\r\n                    view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\r\n                    resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\r\n                    depthSlice,\r\n                    clearValue: mustClearColor ? (isRtInteger ? clearColorForIntegerRt : clearColor) : undefined,\r\n                    loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                });\r\n            } else {\r\n                colorAttachments.push(null);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"render target pass\" + (renderTargetWrapper.label ? \" (\" + renderTargetWrapper.label + \")\" : \"\"), 0);\r\n\r\n        this._rttRenderPassWrapper.renderPassDescriptor = {\r\n            label: (renderTargetWrapper.label ?? \"RTT\") + \" - RenderPass\",\r\n            colorAttachments,\r\n            depthStencilAttachment:\r\n                depthStencilTexture && gpuDepthStencilTexture\r\n                    ? {\r\n                          view: depthMSAATextureView ? depthMSAATextureView : depthTextureView!,\r\n                          depthClearValue: mustClearDepth ? (this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue) : undefined,\r\n                          depthLoadOp: rtWrapper.depthReadOnly ? undefined : mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\r\n                          depthStoreOp: rtWrapper.depthReadOnly ? undefined : WebGPUConstants.StoreOp.Store,\r\n                          depthReadOnly: rtWrapper.depthReadOnly,\r\n                          stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\r\n                          stencilLoadOp: rtWrapper.stencilReadOnly\r\n                              ? undefined\r\n                              : !depthTextureHasStencil\r\n                                ? undefined\r\n                                : rtWrapper._depthStencilTextureWithStencil && mustClearStencil\r\n                                  ? WebGPUConstants.LoadOp.Clear\r\n                                  : WebGPUConstants.LoadOp.Load,\r\n                          stencilStoreOp: rtWrapper.stencilReadOnly ? undefined : !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store,\r\n                          stencilReadOnly: rtWrapper.stencilReadOnly,\r\n                      }\r\n                    : undefined,\r\n            occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined,\r\n        };\r\n        this._timestampQuery.startPass(this._rttRenderPassWrapper.renderPassDescriptor, this._timestampIndex);\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                const internalTexture = rtWrapper.texture!;\r\n                Logger.Log([\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - render target begin pass - rtt name=\" +\r\n                        renderTargetWrapper.label +\r\n                        \", internalTexture.uniqueId=\" +\r\n                        internalTexture.uniqueId +\r\n                        \", width=\" +\r\n                        internalTexture.width +\r\n                        \", height=\" +\r\n                        internalTexture.height +\r\n                        \", setClearStates=\" +\r\n                        setClearStates,\r\n                    \"renderPassDescriptor=\",\r\n                    this._rttRenderPassWrapper.renderPassDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetRenderPassStates();\r\n\r\n        if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    private _startMainRenderPass(setClearStates: boolean, clearColor?: Nullable<IColor4Like>, clearDepth?: boolean, clearStencil?: boolean): void {\r\n        this._endCurrentRenderPass();\r\n\r\n        if (this.useReverseDepthBuffer) {\r\n            this.setDepthFunctionToGreaterOrEqual();\r\n        }\r\n\r\n        const mustClearColor = setClearStates && clearColor;\r\n        const mustClearDepth = setClearStates && clearDepth;\r\n        const mustClearStencil = setClearStates && clearStencil;\r\n\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.clearValue = mustClearColor ? clearColor : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthClearValue = mustClearDepth\r\n            ? this.useReverseDepthBuffer\r\n                ? this._clearReverseDepthValue\r\n                : this._clearDepthValue\r\n            : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.depthStencilAttachment!.stencilLoadOp = !this.isStencilEnable\r\n            ? undefined\r\n            : mustClearStencil\r\n              ? WebGPUConstants.LoadOp.Clear\r\n              : WebGPUConstants.LoadOp.Load;\r\n        this._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\r\n\r\n        const swapChainTexture = this._context.getCurrentTexture();\r\n        this._mainRenderPassWrapper.colorAttachmentGPUTextures[0]!.set(swapChainTexture);\r\n\r\n        // Resolve in case of MSAA\r\n        if (this._options.antialias) {\r\n            ViewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.resolveTarget = swapChainTexture.createView(ViewDescriptorSwapChainAntialiasing);\r\n        } else {\r\n            ViewDescriptorSwapChain.format = swapChainTexture.format;\r\n            this._mainRenderPassWrapper.renderPassDescriptor!.colorAttachments[0]!.view = swapChainTexture.createView(ViewDescriptorSwapChain);\r\n        }\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" + (this as any)._count + \" - main begin pass - texture width=\" + (this._mainTextureExtends as any).width,\r\n                    \" height=\" + (this._mainTextureExtends as any).height + \", setClearStates=\" + setClearStates,\r\n                    \"renderPassDescriptor=\",\r\n                    this._mainRenderPassWrapper.renderPassDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        this._debugPushGroup?.(\"main pass\", 0);\r\n\r\n        this._timestampQuery.startPass(this._mainRenderPassWrapper.renderPassDescriptor!, this._timestampIndex);\r\n        this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor!);\r\n\r\n        this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n        this._setColorFormat(this._mainRenderPassWrapper);\r\n\r\n        this._debugFlushPendingCommands?.();\r\n\r\n        this._resetRenderPassStates();\r\n\r\n        if (!this._isStencilEnable) {\r\n            this._stencilStateComposer.enabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const hardwareTexture = texture.texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._endCurrentRenderPass();\r\n        }\r\n        this._currentRenderTarget = texture;\r\n\r\n        const depthStencilTexture = this._currentRenderTarget._depthStencilTexture;\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\r\n        this._rttRenderPassWrapper.depthTextureFormat = depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, depthStencilTexture.format) : undefined;\r\n\r\n        this._setDepthTextureFormat(this._rttRenderPassWrapper);\r\n        this._setColorFormat(this._rttRenderPassWrapper);\r\n\r\n        this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\r\n            format: this._colorFormat as GPUTextureFormat,\r\n            dimension: texture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\r\n            baseMipLevel: lodLevel,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\r\n            format: this._depthTextureFormat!,\r\n            dimension: depthStencilTexture && depthStencilTexture.is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n            mipLevelCount: 1,\r\n            baseArrayLayer: depthStencilTexture ? (depthStencilTexture.isCube ? layer * 6 + faceIndex : layer) : 0,\r\n            baseMipLevel: 0,\r\n            arrayLayerCount: 1,\r\n            aspect: WebGPUConstants.TextureAspect.All,\r\n        };\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log([\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - bindFramebuffer - rtt name=\" +\r\n                        texture.label +\r\n                        \", internalTexture.uniqueId=\" +\r\n                        texture.texture?.uniqueId +\r\n                        \", face=\" +\r\n                        faceIndex +\r\n                        \", lodLevel=\" +\r\n                        lodLevel +\r\n                        \", layer=\" +\r\n                        layer,\r\n                    \"colorAttachmentViewDescriptor=\",\r\n                    this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\r\n                    \"depthAttachmentViewDescriptor=\",\r\n                    this._rttRenderPassWrapper.depthAttachmentViewDescriptor,\r\n                ]);\r\n            }\r\n        }\r\n\r\n        // We don't create the render pass just now, we do a lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = texture.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = texture.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the WebGPU context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const saveCrt = this._currentRenderTarget;\r\n\r\n        this._currentRenderTarget = null; // to be iso with abstractEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._currentRenderTarget = saveCrt;\r\n\r\n        this._endCurrentRenderPass();\r\n\r\n        if (!disableGenerateMipMaps) {\r\n            if (texture.isMulti) {\r\n                this.generateMipMapsMultiFramebuffer(texture);\r\n            } else {\r\n                this.generateMipMapsFramebuffer(texture);\r\n            }\r\n        }\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\"frame #\" + (this as any)._count + \" - unBindFramebuffer - rtt name=\" + texture.label + \", internalTexture.uniqueId=\", texture.texture?.uniqueId);\r\n            }\r\n        }\r\n\r\n        this._mrtAttachments = [];\r\n        this._cacheRenderPipeline.setMRT([]);\r\n        this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    }\r\n\r\n    /**\r\n     * Generates mipmaps for the texture of the (single) render target\r\n     * @param texture The render target containing the texture to generate the mipmaps for\r\n     */\r\n    public generateMipMapsFramebuffer(texture: RenderTargetWrapper): void {\r\n        if (!texture.isMulti && texture.texture?.generateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture.texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves the MSAA texture of the (single) render target into its non-MSAA version.\r\n     * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n     * @param _texture The render target texture containing the MSAA texture to resolve\r\n     */\r\n    public resolveFramebuffer(_texture: RenderTargetWrapper): void {\r\n        throw new Error(\"resolveFramebuffer is not yet implemented in WebGPU!\");\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else if (!this._currentRenderPass) {\r\n            this._startMainRenderPass(false);\r\n        }\r\n\r\n        if (this._cachedViewport) {\r\n            this.setViewport(this._cachedViewport);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Render\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setColorFormat(wrapper: IWebGPURenderPassWrapper): void {\r\n        const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;\r\n        this._cacheRenderPipeline.setColorFormat(format);\r\n        if (this._colorFormat === format) {\r\n            return;\r\n        }\r\n        this._colorFormat = format;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDepthTextureFormat(wrapper: IWebGPURenderPassWrapper): void {\r\n        this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\r\n        if (this._depthTextureFormat === wrapper.depthTextureFormat) {\r\n            return;\r\n        }\r\n        this._depthTextureFormat = wrapper.depthTextureFormat;\r\n    }\r\n\r\n    public setDitheringState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    public setRasterizerState(): void {\r\n        // Does not exist in WebGPU\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // No parallel shader compilation.\r\n        // No Async, so direct launch\r\n        action();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public bindSamplers(): void {}\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public setStateCullFaceType(cullBackFaces?: boolean, force = false) {\r\n        const cullFace = (this.cullBackFaces ?? cullBackFaces ?? true) ? 1 : 2;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        this.setStateCullFaceType(cullBackFaces, force);\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? (this._currentRenderTarget ? 1 : 2) : this._currentRenderTarget ? 2 : 1;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    private _applyRenderPassChanges(bundleList: Nullable<WebGPUBundleList>): void {\r\n        const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef();\r\n        const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor();\r\n\r\n        if (this._mustUpdateViewport()) {\r\n            this._applyViewport(bundleList);\r\n        }\r\n        if (this._mustUpdateScissor()) {\r\n            this._applyScissor(bundleList);\r\n        }\r\n        if (mustUpdateStencilRef) {\r\n            this._applyStencilRef(bundleList);\r\n        }\r\n        if (mustUpdateBlendColor) {\r\n            this._applyBlendColor(bundleList);\r\n        }\r\n    }\r\n\r\n    private _draw(drawType: number, fillMode: number, start: number, count: number, instancesCount: number): void {\r\n        const renderPass = this._getCurrentRenderPass();\r\n        const bundleList = this._bundleList;\r\n\r\n        this.applyStates();\r\n\r\n        const webgpuPipelineContext = this._currentEffect!._pipelineContext as WebGPUPipelineContext;\r\n\r\n        this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\r\n\r\n        this._currentDrawContext.setVertexPulling(\r\n            this._currentMaterialContext.useVertexPulling,\r\n            webgpuPipelineContext,\r\n            this._currentVertexBuffers,\r\n            this._cacheRenderPipeline.indexBuffer, // don't use this._currentIndexBuffer, it will have been set to null by _drawArraysType!\r\n            this._currentOverrideVertexBuffers\r\n        );\r\n\r\n        if (webgpuPipelineContext.uniformBuffer) {\r\n            webgpuPipelineContext.uniformBuffer.update();\r\n            this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer()!, 0, WebGPUShaderProcessor.LeftOvertUBOName);\r\n        }\r\n\r\n        if (this._snapshotRendering.play) {\r\n            this._reportDrawCall();\r\n            return;\r\n        }\r\n\r\n        if (\r\n            !this.compatibilityMode &&\r\n            (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)\r\n        ) {\r\n            this._currentDrawContext.fastBundle = undefined;\r\n        }\r\n\r\n        const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\r\n        let renderPass2: GPURenderPassEncoder | GPURenderBundleEncoder = renderPass;\r\n\r\n        if (useFastPath || this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(bundleList);\r\n            if (!this._snapshotRendering.record) {\r\n                this._counters.numBundleReuseNonCompatMode++;\r\n                if (this._currentDrawContext.indirectDrawBuffer) {\r\n                    this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n                }\r\n                bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n                this._reportDrawCall();\r\n                return;\r\n            }\r\n\r\n            renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\r\n            bundleList.numDrawCalls++;\r\n        }\r\n\r\n        let textureState = 0;\r\n        if (this._currentMaterialContext.hasFloatOrDepthTextures) {\r\n            let bitVal = 1;\r\n            for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\r\n                const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\r\n                const texture = this._currentMaterialContext.textures[textureName]?.texture;\r\n                const textureIsDepth = texture && texture.format >= Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 && texture.format <= Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8;\r\n                if ((texture?.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) || textureIsDepth) {\r\n                    textureState |= bitVal;\r\n                }\r\n                bitVal = bitVal << 1;\r\n            }\r\n        }\r\n\r\n        this._currentMaterialContext.textureState = textureState;\r\n\r\n        const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect!, this.currentSampleCount, textureState);\r\n\r\n        const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\r\n\r\n        if (!this._snapshotRendering.record) {\r\n            this._applyRenderPassChanges(!this.compatibilityMode ? bundleList : null);\r\n            if (!this.compatibilityMode) {\r\n                this._counters.numBundleCreationNonCompatMode++;\r\n                renderPass2 = this._device.createRenderBundleEncoder({\r\n                    colorFormats: this._cacheRenderPipeline.colorFormats,\r\n                    depthStencilFormat: this._depthTextureFormat,\r\n                    sampleCount: WebGPUTextureHelper.GetSample(this.currentSampleCount),\r\n                });\r\n            }\r\n        }\r\n\r\n        // bind pipeline\r\n        renderPass2.setPipeline(pipeline);\r\n\r\n        // bind index/vertex buffers\r\n        if (this._currentIndexBuffer) {\r\n            renderPass2.setIndexBuffer(\r\n                this._currentIndexBuffer.underlyingResource,\r\n                this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16,\r\n                0\r\n            );\r\n        }\r\n\r\n        const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\r\n        for (let index = 0; index < vertexBuffers.length; index++) {\r\n            const vertexBuffer = vertexBuffers[index];\r\n\r\n            const buffer = vertexBuffer.effectiveBuffer;\r\n            if (buffer) {\r\n                renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\r\n            }\r\n        }\r\n\r\n        // bind bind groups\r\n        for (let i = 0; i < bindGroups.length; i++) {\r\n            renderPass2.setBindGroup(i, bindGroups[i]);\r\n        }\r\n\r\n        // draw\r\n        const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\r\n\r\n        if ((nonCompatMode || this._currentDrawContext._enableIndirectDrawInCompatMode) && this._currentDrawContext.indirectDrawBuffer) {\r\n            this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\r\n            if (drawType === 0) {\r\n                renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            } else {\r\n                renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\r\n            }\r\n        } else if (drawType === 0) {\r\n            renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\r\n        } else {\r\n            renderPass2.draw(count, instancesCount || 1, start, 0);\r\n        }\r\n\r\n        if (nonCompatMode) {\r\n            this._currentDrawContext.fastBundle = (renderPass2 as GPURenderBundleEncoder).finish();\r\n            bundleList.addBundle(this._currentDrawContext.fastBundle);\r\n        }\r\n\r\n        this._reportDrawCall();\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount: number = 1): void {\r\n        this._draw(0, fillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount: number = 1): void {\r\n        this._currentIndexBuffer = null;\r\n        this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public override dispose(): void {\r\n        this._isDisposed = true;\r\n        this.hideLoadingUI();\r\n        this._timestampQuery.dispose();\r\n        this._mainTexture?.destroy();\r\n        this._depthTexture?.destroy();\r\n        this._textureHelper.destroyDeferredTextures();\r\n        this._bufferManager.destroyDeferredBuffers();\r\n        this._device.destroy();\r\n\r\n        _CommonDispose(this, this._renderingCanvas);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Misc\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._renderingCanvas?.width ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._renderingCanvas?.height ?? 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Errors\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get the current error code of the WebGPU context\r\n     * @returns the error code\r\n     */\r\n    public getError(): number {\r\n        // TODO WEBGPU. from the webgpu errors.\r\n        return 0;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              External Textures\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates an external texture\r\n     * @param video video element\r\n     * @returns the external texture, or null if external textures are not supported by the engine\r\n     */\r\n    public createExternalTexture(video: HTMLVideoElement): Nullable<ExternalTexture> {\r\n        const texture = new WebGPUExternalTexture(video);\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Sets an internal texture to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param texture The texture to apply\r\n     */\r\n    public setExternalTexture(name: string, texture: Nullable<ExternalTexture>): void {\r\n        if (!texture) {\r\n            this._currentMaterialContext.setTexture(name, null);\r\n            return;\r\n        }\r\n        this._setInternalTexture(name, texture);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Samplers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Sets a texture sampler to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param sampler The sampler to apply\r\n     */\r\n    public setTextureSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        this._currentMaterialContext?.setSampler(name, sampler);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Storage Buffers\r\n    //------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a storage buffer\r\n     * @param data the data for the storage buffer or the size of the buffer\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public createStorageBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer {\r\n        return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE, label);\r\n    }\r\n\r\n    /**\r\n     * Clears a storage buffer to zeroes\r\n     * @param storageBuffer the storage buffer to clear\r\n     * @param byteOffset the byte offset to start clearing (optional)\r\n     * @param byteLength the byte length to clear (optional)\r\n     */\r\n    public clearStorageBuffer(storageBuffer: DataBuffer, byteOffset?: number, byteLength?: number): void {\r\n        this._renderEncoder.clearBuffer(storageBuffer.underlyingResource, byteOffset, byteLength);\r\n    }\r\n\r\n    /**\r\n     * Updates a storage buffer\r\n     * @param buffer the storage buffer to update\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public updateStorageBuffer(buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const dataBuffer = buffer as WebGPUDataBuffer;\r\n        if (byteOffset === undefined) {\r\n            byteOffset = 0;\r\n        }\r\n\r\n        let view: ArrayBufferView;\r\n        if (byteLength === undefined) {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n            byteLength = view.byteLength;\r\n        } else {\r\n            if (data instanceof Array) {\r\n                view = new Float32Array(data);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                view = new Uint8Array(data);\r\n            } else {\r\n                view = data;\r\n            }\r\n        }\r\n\r\n        this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n    }\r\n\r\n    private async _readFromGPUBuffer(gpuBuffer: GPUBuffer, size: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        return await new Promise((resolve, reject) => {\r\n            const readFromBuffer = () => {\r\n                // eslint-disable-next-line github/no-then\r\n                gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                    () => {\r\n                        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                        let data: ArrayBufferView | undefined = buffer;\r\n                        if (data === undefined) {\r\n                            data = new Uint8Array(size);\r\n                            (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                        } else {\r\n                            const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                            data = new ctor(data.buffer);\r\n                            (data as any).set(new ctor(copyArrayBuffer));\r\n                        }\r\n                        gpuBuffer.unmap();\r\n                        this._bufferManager.releaseBuffer(gpuBuffer);\r\n                        resolve(data!);\r\n                    },\r\n                    (reason) => {\r\n                        if (this.isDisposed) {\r\n                            resolve(new Uint8Array());\r\n                        } else {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(reason);\r\n                        }\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (noDelay) {\r\n                this.flushFramebuffer();\r\n                readFromBuffer();\r\n            } else {\r\n                // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n                // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n                this.onEndFrameObservable.addOnce(() => {\r\n                    readFromBuffer();\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Read data from a storage buffer\r\n     * @param storageBuffer The storage buffer to read from\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readFromStorageBuffer(storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        size = size || storageBuffer.capacity;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempReadFromStorageBuffer\"\r\n        );\r\n\r\n        this._renderEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n        return this._readFromGPUBuffer(gpuBuffer, size, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Read data from multiple storage buffers\r\n     * @param storageBuffers The list of storage buffers to read from\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0). This is the same offset for all storage buffers!\r\n     * @param size  The number of bytes to read from each storage buffer (default: capacity of the first buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffers to (optional). If provided, the buffer should be large enough to hold the data from all storage buffers!\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    public readFromMultipleStorageBuffers(storageBuffers: DataBuffer[], offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        size = size || storageBuffers[0].capacity;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size * storageBuffers.length,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempReadFromMultipleStorageBuffers\"\r\n        );\r\n\r\n        for (let i = 0; i < storageBuffers.length; i++) {\r\n            this._renderEncoder.copyBufferToBuffer(storageBuffers[i].underlyingResource, offset ?? 0, gpuBuffer, i * size, size);\r\n        }\r\n\r\n        return this._readFromGPUBuffer(gpuBuffer, size * storageBuffers.length, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Sets a storage buffer in the shader\r\n     * @param name Defines the name of the storage buffer as defined in the shader\r\n     * @param buffer Defines the value to give to the uniform\r\n     */\r\n    public setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void {\r\n        this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n    }\r\n}\r\n"],
  "mappings": "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D,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,QAAQ,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACvD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,IAAI,cAAc,GAAE,EAAE;EACxD,SAAS,EAAE,SAAS,EAAE,YAAY,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",
  "names": ["PowerPreference", "FeatureName", "BufferMapState", "BufferUsage", "MapMode", "TextureDimension", "TextureUsage", "TextureViewDimension", "TextureAspect", "TextureFormat", "AddressMode", "FilterMode", "MipmapFilterMode", "CompareFunction", "ShaderStage", "BufferBindingType", "SamplerBindingType", "TextureSampleType", "StorageTextureAccess", "CompilationMessageType", "PipelineErrorReason", "AutoLayoutMode", "PrimitiveTopology", "FrontFace", "CullMode", "ColorWrite", "BlendFactor", "BlendOperation", "StencilOperation", "IndexFormat", "VertexFormat", "VertexStepMode", "ComputePassTimestampLocation", "RenderPassTimestampLocation", "LoadOp", "StoreOp", "QueryType", "CanvasAlphaMode", "CanvasToneMappingMode", "DeviceLostReason", "ErrorFilter", "name", "name", "name", "name", "name", "PipelineType", "VideoPipelineType", "offset", "offset2", "StatePosition", "topology", "name", "colorStates", "name", "name", "name", "name", "shader", "name", "parameters", "name", "name", "scene", "invertY", "noMipmap"]
}
