import {
  create
} from "./chunk-IVAU7NLG.js";
import {
  forwardHtmlEvents
} from "./chunk-ZXV4YWI6.js";
import {
  require_client
} from "./chunk-IO64F4HD.js";
import "./chunk-D7552MD7.js";
import "./chunk-HTPD32MN.js";
import {
  require_jsx_runtime
} from "./chunk-OBYCLIUT.js";
import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from2 = Object(arguments[s2]);
        for (var key in from2) {
          if (hasOwnProperty.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y3) {
        if (x2 === y3) {
          return x2 !== 0 || 1 / x2 === 1 / y3;
        } else {
          return x2 !== x2 && y3 !== y3;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@iwer/devui/lib/index.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());

// node_modules/@iwer/devui/lib/components/controls.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);

// node_modules/@iwer/devui/lib/components/controller.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/@fortawesome/fontawesome-svg-core/index.mjs
var noop = () => {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e) {
}
var {
  userAgent = ""
} = _WINDOW.navigator || {};
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var a = "classic";
var t = "duotone";
var r = "sharp";
var o = "sharp-duotone";
var c = [a, t, r, o];
var et$1 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds"
  }
};
var bt = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
};
var Ct = ["kit"];
var Dt = /fa(s|r|l|t|d|b|k|kd|ss|sr|sl|st|sds)?[\-\ ]/;
var Kt = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var ao = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var eo = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds"
  }
};
var lo = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds"
  }
};
var y = {
  classic: ["fas", "far", "fal", "fat"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds"]
};
var no = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid"
  }
};
var fo = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds"
  }
};
var ho = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid"
  }
};
var x$1 = ["solid", "regular", "light", "thin", "duotone", "brands"];
var u$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var m$1 = u$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var t$1 = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var yo = [...Object.keys(y), ...x$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(u$1.map((o3) => "".concat(o3, "x"))).concat(m$1.map((o3) => "w-".concat(o3)));
var mo = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
};
var Io = {
  kit: {
    "fa-kit": "fak"
  },
  "kit-duotone": {
    "fa-kit-duotone": "fakd"
  }
};
var Fo = {
  kit: {
    fak: "fa-kit"
  },
  "kit-duotone": {
    fakd: "fa-kit-duotone"
  }
};
var So = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PRODUCTION = (() => {
  try {
    return false;
  } catch (e$$1) {
    return false;
  }
})();
var FAMILIES = [a, r, o];
function familyProxy(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[a];
    }
  });
}
var _PREFIX_TO_STYLE = {
  ...ho
};
_PREFIX_TO_STYLE[a] = {
  ...ho[a],
  ...bt["kit"],
  ...bt["kit-duotone"]
};
var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
var _STYLE_TO_PREFIX = {
  ...fo
};
_STYLE_TO_PREFIX[a] = {
  ..._STYLE_TO_PREFIX[a],
  ...So["kit"],
  ...So["kit-duotone"]
};
var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
var _PREFIX_TO_LONG_STYLE = {
  ...no
};
_PREFIX_TO_LONG_STYLE[a] = {
  ..._PREFIX_TO_LONG_STYLE[a],
  ...Fo["kit"]
};
var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
var _LONG_STYLE_TO_PREFIX = {
  ...lo
};
_LONG_STYLE_TO_PREFIX[a] = {
  ..._LONG_STYLE_TO_PREFIX[a],
  ...Io["kit"]
};
var LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
var ICON_SELECTION_SYNTAX_PATTERN = Dt;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = Kt;
var _FONT_WEIGHT_TO_PREFIX = {
  ...et$1
};
var FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = t$1;
var prefixes = /* @__PURE__ */ new Set();
Object.keys(STYLE_TO_PREFIX[a]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[r]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[o]).map(prefixes.add.bind(prefixes));
var RESERVED_CLASSES = [...Ct, ...yo];
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach((_ref) => {
    let [attr, key] = _ref;
    const val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
var _config = {
  ..._default,
  ...initial
};
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = {};
Object.keys(_default).forEach((key) => {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function(val) {
      _config[key] = val;
      _onChangeCb.forEach((cb) => cb(config));
    },
    get: function() {
      return _config[key];
    }
  });
});
Object.defineProperty(config, "familyPrefix", {
  enumerable: true,
  set: function(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach((cb) => cb(config));
  },
  get: function() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d$2 = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  const style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  const headChildren = DOCUMENT.head.childNodes;
  let beforeChild = null;
  for (let i2 = headChildren.length - 1; i2 > -1; i2--) {
    const child = headChildren[i2];
    const tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  let size = 12;
  let id = "";
  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray(obj) {
  const array = [];
  for (let i2 = (obj || []).length >>> 0; i2--; ) {
    array[i2] = obj[i2];
  }
  return array;
}
function classArray(node2) {
  if (node2.classList) {
    return toArray(node2.classList);
  } else {
    return (node2.getAttribute("class") || "").split(" ").filter((i2) => i2);
  }
}
function htmlEscape(str5) {
  return "".concat(str5).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  let {
    transform,
    containerWidth,
    iconWidth
  } = _ref;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref2) {
  let {
    transform,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref2;
  let val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
  }
  val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function css() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config.cssPrefix;
  const rc = config.replacementClass;
  let s2 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    const rPatt = new RegExp("\\.".concat(drc), "g");
    s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s2;
}
var _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout() {
    return {
      dom: {
        css,
        insertCss: ensureCss
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w$1 = WINDOW || {};
if (!w$1[NAMESPACE_IDENTIFIER]) w$1[NAMESPACE_IDENTIFIER] = {};
if (!w$1[NAMESPACE_IDENTIFIER].styles) w$1[NAMESPACE_IDENTIFIER].styles = {};
if (!w$1[NAMESPACE_IDENTIFIER].hooks) w$1[NAMESPACE_IDENTIFIER].hooks = {};
if (!w$1[NAMESPACE_IDENTIFIER].shims) w$1[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w$1[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener);
  loaded = 1;
  functions.map((fn) => fn());
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
function domready(fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}
function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children = []
  } = abstractNodes;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix2, iconName) {
  if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
    return {
      prefix: prefix2,
      iconName,
      icon: mapping[prefix2][iconName]
    };
  }
}
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a3, b, c3, d) {
    return func.call(thisContext, a3, b, c3, d);
  };
};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length5 = keys.length, iterator = thisContext !== void 0 ? bindInternal4(fn, thisContext) : fn, i2, key, result;
  if (initialValue === void 0) {
    i2 = 1;
    result = subject[keys[0]];
  } else {
    i2 = 0;
    result = initialValue;
  }
  for (; i2 < length5; i2++) {
    key = keys[i2];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string) {
  const output = [];
  let counter2 = 0;
  const length5 = string.length;
  while (counter2 < length5) {
    const value = string.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length5) {
      const extra = string.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index) {
  const size = string.length;
  let first = string.charCodeAt(index);
  let second;
  if (first >= 55296 && first <= 56319 && size > index + 1) {
    second = string.charCodeAt(index + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon2 = icons[iconName];
    const expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
}
function defineIcons(prefix2, icons) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix2, normalizeIcons(icons));
  } else {
    namespace.styles[prefix2] = {
      ...namespace.styles[prefix2] || {},
      ...normalized
    };
  }
  if (prefix2 === "fas") {
    defineIcons("fa", icons);
  }
}
var {
  styles,
  shims
} = namespace;
var LONG_STYLE = {
  [a]: Object.values(PREFIX_TO_LONG_STYLE[a]),
  [r]: Object.values(PREFIX_TO_LONG_STYLE[r]),
  [o]: Object.values(PREFIX_TO_LONG_STYLE[o])
};
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = {
  [a]: Object.keys(PREFIX_TO_STYLE[a]),
  [r]: Object.keys(PREFIX_TO_STYLE[r]),
  [o]: Object.keys(PREFIX_TO_STYLE[o])
};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts = cls.split("-");
  const prefix2 = parts[0];
  const iconName = parts.slice(1).join("-");
  if (prefix2 === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = () => {
  const lookup = (reducer) => {
    return reduce(styles, (o$$1, style, prefix2) => {
      o$$1[prefix2] = reduce(style, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup((acc, icon2, iconName) => {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "number";
      });
      aliases.forEach((alias) => {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup((acc, icon2, iconName) => {
    acc[iconName] = iconName;
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "string";
      });
      aliases.forEach((alias) => {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup((acc, icon2, iconName) => {
    const aliases = icon2[2];
    acc[iconName] = iconName;
    aliases.forEach((alias) => {
      acc[alias] = iconName;
    });
    return acc;
  });
  const hasRegular = "far" in styles || config.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix2 = shim[1];
    const iconName = shim[2];
    if (prefix2 === "far" && !hasRegular) {
      prefix2 = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix2,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix2,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange((c$$1) => {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix2, unicode) {
  return (_byUnicode[prefix2] || {})[unicode];
}
function byLigature(prefix2, ligature) {
  return (_byLigature[prefix2] || {})[ligature];
}
function byAlias(prefix2, alias) {
  return (_byAlias[prefix2] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family = a
  } = params;
  const style = PREFIX_TO_STYLE[family][styleOrPrefix];
  const prefix2 = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix2 || defined || null;
  return result;
}
var PREFIXES_FOR_FAMILY = {
  [a]: Object.keys(PREFIX_TO_LONG_STYLE[a]),
  [r]: Object.keys(PREFIX_TO_LONG_STYLE[r]),
  [o]: Object.keys(PREFIX_TO_LONG_STYLE[o])
};
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  const famProps = {
    [a]: "".concat(config.cssPrefix, "-").concat(a),
    [r]: "".concat(config.cssPrefix, "-").concat(r),
    [o]: "".concat(config.cssPrefix, "-").concat(o)
  };
  let givenPrefix = null;
  let family = a;
  const nonDuotoneFamilyIds = c.filter((familyId) => familyId !== t);
  nonDuotoneFamilyIds.forEach((familyId) => {
    if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  const canonical = values.reduce((acc, cls) => {
    const iconName = getIconName(config.cssPrefix, cls);
    if (styles[cls]) {
      cls = LONG_STYLE[family].includes(cls) ? LONG_STYLE_TO_PREFIX[family][cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES[family].indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls, {
        family
      });
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass && !nonDuotoneFamilyIds.some((familyName) => cls === famProps[familyName])) {
      acc.rest.push(cls);
    }
    if (!skipLookups && acc.prefix && acc.iconName) {
      const shim = givenPrefix === "fa" ? byOldName(acc.iconName) : {};
      const aliasIconName = byAlias(acc.prefix, acc.iconName);
      if (shim.prefix) {
        givenPrefix = null;
      }
      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;
      if (acc.prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
        acc.prefix = "fas";
      }
    }
    return acc;
  }, emptyCanonicalIcon());
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (values.includes("fa-duotone") || values.includes("fad")) {
    canonical.prefix = "fad";
  }
  if (!canonical.prefix && family === r && (styles["fass"] || config.autoFetchSvg)) {
    canonical.prefix = "fass";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (!canonical.prefix && family === o && (styles["fasds"] || config.autoFetchSvg)) {
    canonical.prefix = "fasds";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach((key) => {
      this.definitions[key] = {
        ...this.definitions[key] || {},
        ...additions[key]
      };
      defineIcons(key, additions[key]);
      const longPrefix = PREFIX_TO_LONG_STYLE[a][key];
      if (longPrefix) defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map((key) => {
      const {
        prefix: prefix2,
        iconName,
        icon: icon2
      } = normalized[key];
      const aliases = icon2[2];
      if (!additions[prefix2]) additions[prefix2] = {};
      if (aliases.length > 0) {
        aliases.forEach((alias) => {
          if (typeof alias === "string") {
            additions[prefix2][alias] = icon2;
          }
        });
      }
      additions[prefix2][iconName] = icon2;
    });
    return additions;
  }
};
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  let {
    mixoutsTo: obj
  } = _ref;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach((k2) => {
    if (defaultProviderKeys.indexOf(k2) === -1) {
      delete providers[k2];
    }
  });
  _plugins.forEach((plugin) => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach((tk) => {
      if (typeof mixout[tk] === "function") {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === "object") {
        Object.keys(mixout[tk]).forEach((sk) => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks = plugin.hooks();
      Object.keys(hooks).forEach((hook) => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    accumulator = hookFn.apply(null, [accumulator, ...args]);
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  let {
    iconName
  } = iconLookup;
  const prefix2 = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix2, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
}
var library = new Library();
var noAuto = () => {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
var dom = {
  i2svg: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject(new Error("Operation requires a DOM of some kind."));
    }
  },
  watch: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot
    } = params;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(() => {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
var parse = {
  icon: (icon2) => {
    if (icon2 === null) {
      return null;
    }
    if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
      return {
        prefix: icon2.prefix,
        iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
      };
    }
    if (Array.isArray(icon2) && icon2.length === 2) {
      const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
      const prefix2 = getCanonicalPrefix(icon2[0]);
      return {
        prefix: prefix2,
        iconName: byAlias(prefix2, iconName) || iconName
      };
    }
    if (typeof icon2 === "string" && (icon2.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof icon2 === "string") {
      const prefix2 = getDefaultUsablePrefix();
      return {
        prefix: prefix2,
        iconName: byAlias(prefix2, icon2) || icon2
      };
    }
  }
};
var api = {
  noAuto,
  config,
  dom,
  parse,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function() {
  let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function() {
      return val.abstract.map((a3) => toHtml(a3));
    }
  });
  Object.defineProperty(val, "node", {
    get: function() {
      if (!IS_DOM) return;
      const container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref) {
  let {
    children,
    main,
    mask,
    attributes,
    styles: styles2,
    transform
  } = _ref;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles({
      ...styles2,
      "transform-origin": "".concat(offset.x + transform.x / 16, "em ").concat(offset.y + transform.y / 16, "em")
    });
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref) {
  let {
    prefix: prefix2,
    iconName,
    children,
    attributes,
    symbol: symbol2
  } = _ref;
  const id = symbol2 === true ? "".concat(prefix2, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol2;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: {
        ...attributes,
        id
      },
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix: prefix2,
    iconName,
    transform,
    symbol: symbol2,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = prefix2 === "fak";
  const attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter((c3) => extra.classes.indexOf(c3) === -1).filter((c3) => c3 !== "" || !!c3).concat(extra.classes).join(" ");
  let content = {
    children: [],
    attributes: {
      ...extra.attributes,
      "data-prefix": prefix2,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    }
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = {
    ...content,
    prefix: prefix2,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol: symbol2,
    styles: {
      ...uploadedIconWidthStyle,
      ...extra.styles
    }
  };
  const {
    children,
    attributes
  } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  };
  args.children = children;
  args.attributes = attributes;
  if (symbol2) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  const styles2 = {
    ...extra.styles
  };
  if (transformIsMeaningful(transform)) {
    styles2["transform"] = transformForCss({
      transform,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  const styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var {
  styles: styles$1
} = namespace;
function asFoundIcon(icon2) {
  const width = icon2[0];
  const height = icon2[1];
  const [vectorData] = icon2.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix2) {
  if (!PRODUCTION && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix2, '" is missing.'));
  }
}
function findIcon(iconName, prefix2) {
  let givenPrefix = prefix2;
  if (prefix2 === "fa" && config.styleDefault !== null) {
    prefix2 = getDefaultUsablePrefix();
  }
  return new Promise((resolve, reject) => {
    if (givenPrefix === "fa") {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix2 = shim.prefix || prefix2;
    }
    if (iconName && prefix2 && styles$1[prefix2] && styles$1[prefix2][iconName]) {
      const icon2 = styles$1[prefix2][iconName];
      return resolve(asFoundIcon(icon2));
    }
    maybeNotifyMissing(iconName, prefix2);
    resolve({
      ...missingIconResolutionMixin,
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    });
  });
}
var noop$1 = () => {
};
var p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = 'FA "6.6.0"';
var begin = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
};
var end = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = () => {
};
function isWatched(node2) {
  const i2svg = node2.getAttribute ? node2.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === "string";
}
function hasPrefixAndIcon(node2) {
  const prefix2 = node2.getAttribute ? node2.getAttribute(DATA_PREFIX) : null;
  const icon2 = node2.getAttribute ? node2.getAttribute(DATA_ICON) : null;
  return prefix2 && icon2;
}
function hasBeenReplaced(node2) {
  return node2 && node2.classList && node2.classList.contains && node2.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === "svg" ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node2) {
  let comment2 = " ".concat(node2.outerHTML, " ");
  comment2 = "".concat(comment2, "Font Awesome fontawesome.com ");
  return comment2;
}
var mutators = {
  replace: function(mutation) {
    const node2 = mutation[0];
    if (node2.parentNode) {
      mutation[1].forEach((abstract) => {
        node2.parentNode.insertBefore(convertSVG(abstract), node2);
      });
      if (node2.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        let comment2 = DOCUMENT.createComment(nodeAsComment(node2));
        node2.parentNode.replaceChild(comment2, node2);
      } else {
        node2.remove();
      }
    }
  },
  nest: function(mutation) {
    const node2 = mutation[0];
    const abstract = mutation[1];
    if (~classArray(node2).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls) => {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node2.removeAttribute("class");
      } else {
        node2.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    const newInnerHTML = abstract.map((a3) => toHtml(a3)).join("\n");
    node2.setAttribute(DATA_FA_I2SVG, "");
    node2.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(() => {
      const mutator = getMutator();
      const mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo$1 = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT
  } = options;
  mo$1 = new MUTATION_OBSERVER((objects) => {
    if (disabled) return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach((mutationRecord) => {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix: prefix2,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix2 || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo$1.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo$1) return;
  mo$1.disconnect();
}
function styleParser(node2) {
  const style = node2.getAttribute("style");
  let val = [];
  if (style) {
    val = style.split(";").reduce((acc, style2) => {
      const styles2 = style2.split(":");
      const prop = styles2[0];
      const value = styles2.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node2) {
  const existingPrefix = node2.getAttribute("data-prefix");
  const existingIconName = node2.getAttribute("data-icon");
  const innerText = node2.innerText !== void 0 ? node2.innerText.trim() : "";
  let val = getCanonicalIcon(classArray(node2));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node2.innerText) || byUnicode(val.prefix, toHex(node2.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node2.firstChild && node2.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node2.firstChild.data;
  }
  return val;
}
function attributesParser(node2) {
  const extraAttributes = toArray(node2.attributes).reduce((acc, attr) => {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node2.getAttribute("title");
  const titleId = node2.getAttribute("data-fa-title-id");
  if (config.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node2) {
  let parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix: prefix2,
    rest: extraClasses
  } = classParser(node2);
  const extraAttributes = attributesParser(node2);
  const pluginMeta = chainHooks("parseNodeAttributes", {}, node2);
  let extraStyles = parser.styleParser ? styleParser(node2) : [];
  return {
    iconName,
    title: node2.getAttribute("title"),
    titleId: node2.getAttribute("data-fa-title-id"),
    prefix: prefix2,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    },
    ...pluginMeta
  };
}
var {
  styles: styles$2
} = namespace;
function generateMutation(node2) {
  const nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node2, {
    styleParser: false
  }) : parseMeta(node2);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node2, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node2, nodeMeta);
  }
}
var knownPrefixes = /* @__PURE__ */ new Set();
FAMILIES.map((family) => {
  knownPrefixes.add("fa-".concat(family));
});
Object.keys(PREFIX_TO_STYLE[a]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[r]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[o]).map(knownPrefixes.add.bind(knownPrefixes));
knownPrefixes = [...knownPrefixes];
function onTree(root) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  const htmlClassList = DOCUMENT.documentElement.classList;
  const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes2 = config.autoFetchSvg ? knownPrefixes : FAMILIES.map((f$$1) => "fa-".concat(f$$1)).concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray(root.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin("onTree");
  const mutations = candidates.reduce((acc, node2) => {
    try {
      const mutation = generateMutation(node2);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve, reject) => {
    Promise.all(mutations).then((resolvedMutations) => {
      perform(resolvedMutations, () => {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function") callback();
        mark();
        resolve();
      });
    }).catch((e$$1) => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node2) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node2).then((mutation) => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next2) {
  return function(maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next2(iconDefinition, {
      ...params,
      mask
    });
  };
}
var render = function(iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform = meaninglessTransform,
    symbol: symbol2 = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles: styles2 = {}
  } = params;
  if (!iconDefinition) return;
  const {
    prefix: prefix2,
    iconName,
    icon: icon2
  } = iconDefinition;
  return domVariants({
    type: "icon",
    ...iconDefinition
  }, () => {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix2,
      iconName,
      transform: {
        ...meaninglessTransform,
        ...transform
      },
      symbol: symbol2,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      const {
        node: node2 = DOCUMENT,
        callback = () => {
        }
      } = params;
      return onTree(node2, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node2, nodeMeta) {
      const {
        iconName,
        title,
        titleId,
        prefix: prefix2,
        transform,
        symbol: symbol2,
        mask,
        maskId,
        extra
      } = nodeMeta;
      return new Promise((resolve, reject) => {
        Promise.all([findIcon(iconName, prefix2), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then((_ref) => {
          let [main, mask2] = _ref;
          resolve([node2, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix: prefix2,
            iconName,
            transform,
            symbol: symbol2,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref2) {
      let {
        children,
        attributes,
        main,
        transform,
        styles: styles2
      } = _ref2;
      const styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      let nextChild;
      if (transformIsMeaningful(transform)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children.push(nextChild || main.icon);
      return {
        children,
        attributes
      };
    };
  }
};
var Layers = {
  mixout() {
    return {
      layer(assembler) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes = []
        } = params;
        return domVariants({
          type: "layer"
        }, () => {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          let children = [];
          assembler((args) => {
            Array.isArray(args) ? args.map((a3) => {
              children = children.concat(a3.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers"), ...classes].join(" ")
            },
            children
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout() {
    return {
      counter(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "counter",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-counter"), ...classes]
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout() {
    return {
      text(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform = meaninglessTransform,
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "text",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: {
              ...meaninglessTransform,
              ...transform
            },
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-text"), ...classes]
            }
          });
        });
      }
    };
  },
  provides(providers$$1) {
    providers$$1.generateLayersText = function(node2, nodeMeta) {
      const {
        title,
        transform,
        extra
      } = nodeMeta;
      let width = null;
      let height = null;
      if (IS_IE) {
        const computedFontSize = parseInt(getComputedStyle(node2).fontSize, 10);
        const boundingClientRect = node2.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node2, makeLayersTextAbstract({
        content: node2.innerHTML,
        width,
        height,
        transform,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
var _FONT_FAMILY_WEIGHT_TO_PREFIX = {
  ...{
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  },
  ...eo,
  ...ao,
  ...mo
};
var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
  const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node2, position2) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position2.replace(":", "-"));
  return new Promise((resolve, reject) => {
    if (node2.getAttribute(pendingAttribute) !== null) {
      return resolve();
    }
    const children = toArray(node2.children);
    const alreadyProcessedPseudoElement = children.filter((c3) => c3.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position2)[0];
    const styles2 = WINDOW.getComputedStyle(node2, position2);
    const fontFamily = styles2.getPropertyValue("font-family");
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles2.getPropertyValue("font-weight");
    const content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node2.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      const content2 = styles2.getPropertyValue("content");
      let prefix2 = getPrefix(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content2);
      const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      let iconName = byUnicode(prefix2, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix2 = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix2 || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node2.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node2.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position2;
        findIcon(iconName, prefix2).then((main) => {
          const abstract = makeInlineSvgAbstract({
            ...meta,
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix2,
            iconName: iconIdentifier,
            extra,
            watchable: true
          });
          const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position2 === "::before") {
            node2.insertBefore(element, node2.firstChild);
          } else {
            node2.appendChild(element);
          }
          element.outerHTML = abstract.map((a3) => toHtml(a3)).join("\n");
          node2.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace(node2) {
  return Promise.all([replaceForPosition(node2, "::before"), replaceForPosition(node2, "::after")]);
}
function processable(node2) {
  return node2.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node2.tagName.toUpperCase()) && !node2.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node2.parentNode || node2.parentNode.tagName !== "svg");
}
function searchPseudoElements(root) {
  if (!IS_DOM) return;
  return new Promise((resolve, reject) => {
    const operations = toArray(root.querySelectorAll("*")).filter(processable).map(replace);
    const end2 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(() => {
      end2();
      enableObservation();
      resolve();
    }).catch(() => {
      end2();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.pseudoElements2svg = function(params) {
      const {
        node: node2 = DOCUMENT
      } = params;
      if (config.searchPseudoElements) {
        searchPseudoElements(node2);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout() {
    return {
      dom: {
        unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto() {
        disconnect();
      },
      watch(params) {
        const {
          observeMutationsRoot
        } = params;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = (transformString) => {
  let transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce((acc, n) => {
    const parts = n.toLowerCase().split("-");
    const first = parts[0];
    let rest = parts.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout() {
    return {
      parse: {
        transform: (transformString) => {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const transformString = node2.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref) {
      let {
        main,
        transform,
        containerWidth,
        iconWidth
      } = _ref;
      const outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      const inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      const path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      const operations = {
        outer,
        inner,
        path
      };
      return {
        tag: "g",
        attributes: {
          ...operations.outer
        },
        children: [{
          tag: "g",
          attributes: {
            ...operations.inner
          },
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: {
              ...main.icon.attributes,
              ...operations.path
            }
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const maskData = node2.getAttribute("data-fa-mask");
        const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i2) => i2.trim()));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node2.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractMask = function(_ref) {
      let {
        children,
        attributes,
        main,
        mask,
        maskId: explicitMaskId,
        transform
      } = _ref;
      const {
        width: mainWidth,
        icon: mainPath
      } = main;
      const {
        width: maskWidth,
        icon: maskPath
      } = mask;
      const trans = transformForSvg({
        transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      const maskRect = {
        tag: "rect",
        attributes: {
          ...ALL_SPACE,
          fill: "white"
        }
      };
      const maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      const maskInnerGroup = {
        tag: "g",
        attributes: {
          ...trans.inner
        },
        children: [fillBlack({
          tag: mainPath.tag,
          attributes: {
            ...mainPath.attributes,
            ...trans.path
          },
          ...maskInnerGroupChildrenMixin
        })]
      };
      const maskOuterGroup = {
        tag: "g",
        attributes: {
          ...trans.outer
        },
        children: [maskInnerGroup]
      };
      const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      const maskTag = {
        tag: "mask",
        attributes: {
          ...ALL_SPACE,
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        },
        children: [maskRect, maskOuterGroup]
      };
      const defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: "rect",
        attributes: {
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")"),
          ...ALL_SPACE
        }
      });
      return {
        children,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides(providers2) {
    let reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      const gChildren = [];
      const FILL = {
        fill: "currentColor"
      };
      const ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        }
      });
      const OPACITY_ANIMATE = {
        ...ANIMATION_BASE,
        attributeName: "opacity"
      };
      const dot4 = {
        tag: "circle",
        attributes: {
          ...FILL,
          cx: "256",
          cy: "364",
          r: "28"
        },
        children: []
      };
      if (!reduceMotion) {
        dot4.children.push({
          tag: "animate",
          attributes: {
            ...ANIMATION_BASE,
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          }
        }, {
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;1;1;0;1;"
          }
        });
      }
      gChildren.push(dot4);
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        },
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;0;0;0;1;"
          }
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: {
            ...FILL,
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          },
          children: [{
            tag: "animate",
            attributes: {
              ...OPACITY_ANIMATE,
              values: "0;0;1;1;0;0;"
            }
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node2) {
        const symbolData = node2.getAttribute("data-fa-symbol");
        const symbol2 = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol2;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
var noAuto$1 = api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
var dom$1 = api.dom;
var parse$1 = api.parse;
var findIconDefinition$1 = api.findIconDefinition;
var toHtml$1 = api.toHtml;
var icon = api.icon;
var layer = api.layer;
var text = api.text;
var counter = api.counter;

// node_modules/@fortawesome/react-fontawesome/index.es.js
var import_prop_types = __toESM(require_prop_types());
var import_react = __toESM(require_react());
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray(o3, minLen);
  var n = Object.prototype.toString.call(o3).slice(8, -1);
  if (n === "Object" && o3.constructor) n = o3.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o3);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len4) {
  if (len4 == null || len4 > arr.length) len4 = arr.length;
  for (var i2 = 0, arr2 = new Array(len4); i2 < len4; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function classList(props) {
  var _classes;
  var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse3 = props.inverse, border = props.border, listItem = props.listItem, flip = props.flip, size = props.size, rotation = props.rotation, pull = props.pull;
  var classes = (_classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse3,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip === true,
    "fa-flip-horizontal": flip === "horizontal" || flip === "both",
    "fa-flip-vertical": flip === "vertical" || flip === "both"
  }, _defineProperty(_classes, "fa-".concat(size), typeof size !== "undefined" && size !== null), _defineProperty(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  }
  string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string.substr(0, 1).toLowerCase() + string.substr(1);
}
var _excluded = ["style"];
function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}
function styleToObject(style) {
  return style.split(";").map(function(s2) {
    return s2.trim();
  }).filter(function(s2) {
    return s2;
  }).reduce(function(acc, pair) {
    var i2 = pair.indexOf(":");
    var prop = camelize(pair.slice(0, i2));
    var value = pair.slice(i2 + 1).trim();
    prop.startsWith("webkit") ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}
function convert(createElement2, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof element === "string") {
    return element;
  }
  var children = (element.children || []).map(function(child) {
    return convert(createElement2, child);
  });
  var mixins = Object.keys(element.attributes || {}).reduce(function(acc, key) {
    var val = element.attributes[key];
    switch (key) {
      case "class":
        acc.attrs["className"] = val;
        delete element.attributes["class"];
        break;
      case "style":
        acc.attrs["style"] = styleToObject(val);
        break;
      default:
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
    }
    return acc;
  }, {
    attrs: {}
  });
  var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties(extraProps, _excluded);
  mixins.attrs["style"] = _objectSpread2(_objectSpread2({}, mixins.attrs["style"]), existingStyle);
  return createElement2.apply(void 0, [element.tag, _objectSpread2(_objectSpread2({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
}
var PRODUCTION2 = false;
try {
  PRODUCTION2 = false;
} catch (e) {
}
function log() {
  if (!PRODUCTION2 && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty({}, key, value) : {};
}
var defaultProps = {
  border: false,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: false
};
var FontAwesomeIcon = import_react.default.forwardRef(function(props, ref) {
  var allProps = _objectSpread2(_objectSpread2({}, defaultProps), props);
  var iconArgs = allProps.icon, maskArgs = allProps.mask, symbol2 = allProps.symbol, className = allProps.className, title = allProps.title, titleId = allProps.titleId, maskId = allProps.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey("classes", [].concat(_toConsumableArray(classList(allProps)), _toConsumableArray((className || "").split(" "))));
  var transform = objectWithKey("transform", typeof allProps.transform === "string" ? parse$1.transform(allProps.transform) : allProps.transform);
  var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
  var renderedIcon = icon(iconLookup, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes), transform), mask), {}, {
    symbol: symbol2,
    title,
    titleId,
    maskId
  }));
  if (!renderedIcon) {
    log("Could not find icon", iconLookup);
    return null;
  }
  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref
  };
  Object.keys(allProps).forEach(function(key) {
    if (!defaultProps.hasOwnProperty(key)) {
      extraProps[key] = allProps[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = "FontAwesomeIcon";
FontAwesomeIcon.propTypes = {
  beat: import_prop_types.default.bool,
  border: import_prop_types.default.bool,
  beatFade: import_prop_types.default.bool,
  bounce: import_prop_types.default.bool,
  className: import_prop_types.default.string,
  fade: import_prop_types.default.bool,
  flash: import_prop_types.default.bool,
  mask: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.array, import_prop_types.default.string]),
  maskId: import_prop_types.default.string,
  fixedWidth: import_prop_types.default.bool,
  inverse: import_prop_types.default.bool,
  flip: import_prop_types.default.oneOf([true, false, "horizontal", "vertical", "both"]),
  icon: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.array, import_prop_types.default.string]),
  listItem: import_prop_types.default.bool,
  pull: import_prop_types.default.oneOf(["right", "left"]),
  pulse: import_prop_types.default.bool,
  rotation: import_prop_types.default.oneOf([0, 90, 180, 270]),
  shake: import_prop_types.default.bool,
  size: import_prop_types.default.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: import_prop_types.default.bool,
  spinPulse: import_prop_types.default.bool,
  spinReverse: import_prop_types.default.bool,
  symbol: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string]),
  title: import_prop_types.default.string,
  titleId: import_prop_types.default.string,
  transform: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.object]),
  swapOpacity: import_prop_types.default.bool
};
var convertCurry = convert.bind(null, import_react.default.createElement);

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_react2 = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length5) {
  return charat(value, 0) ^ 45 ? (((length5 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace2(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin2, end2) {
  return value.slice(begin2, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length5, siblings) {
  return { value, root, parent, type, props, children, line, column, length: length5, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin2, end2) {
  return substr(characters, begin2, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length5 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length5 - 1) == 58) {
          if (indexof(characters2 += replace2(delimit(character2), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace2(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length5)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length5 - 1, declarations) : declaration(replace2(characters2, " ", "") + ";", rule, parent, length5 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length5, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse2(characters2, root, reference, reference, props, rulesets, length5, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length5, children), children), rules, children, length5, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length5 = pseudo;
        break;
      case 58:
        length5 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length5 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length5, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y3 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y3 : replace2(y3, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length5, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length5, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length5), substr(value, length5 + 1, -1), length5, siblings);
}

// node_modules/stylis/src/Prefixer.js
function prefix(value, length5, children) {
  switch (hash(value, length5)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length5 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace2(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace2(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace2(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace2(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace2(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace2(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace2(value, "-grow", "") + WEBKIT + value + MS + replace2(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace2(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace2(replace2(replace2(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace2(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace2(replace2(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length5) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace2(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length5 = index, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length5].value), "span", 0) ? value : MS + replace2(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace2(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace2(replace2(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace2(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length5 > 6)
        switch (charat(value, length5 + 1)) {
          case 109:
            if (charat(value, length5 + 4) !== 45)
              break;
          case 102:
            return replace2(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length5 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace2(value, "stretch", "fill-available"), length5, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace2(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a3, b, c3, d, e, f2) {
        return MS + a3 + ":" + b + f2 + (c3 ? MS + a3 + "-span:" + (d ? e : +e - +b) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length5 + 6) === 121)
        return replace2(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace2(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace2(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace2(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length5 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length5; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace2(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace2(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace2(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace2(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace2(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/styled-components/dist/styled-components.browser.esm.js
var f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var m = "active";
var y2 = "data-styled-version";
var v = "6.1.19";
var g = "/*!sc*/\n";
var S = "undefined" != typeof window && "undefined" != typeof document;
var w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
var E = /invalid hook call/i;
var N = /* @__PURE__ */ new Set();
var P = function(t2, n) {
  if (true) {
    var o3 = n ? ' with the id of "'.concat(n, '"') : "", s2 = "The component ".concat(t2).concat(o3, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.\nSee https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.\n", i2 = console.error;
    try {
      var a3 = true;
      console.error = function(t3) {
        for (var n2 = [], o4 = 1; o4 < arguments.length; o4++) n2[o4 - 1] = arguments[o4];
        E.test(t3) ? (a3 = false, N.delete(s2)) : i2.apply(void 0, __spreadArray([t3], n2, false));
      }, (0, import_react2.useRef)(), a3 && !N.has(s2) && (console.warn(s2), N.add(s2));
    } catch (e) {
      E.test(e.message) && N.delete(s2);
    } finally {
      console.error = i2;
    }
  }
};
var _ = Object.freeze([]);
var C = Object.freeze({});
function I(e, t2, n) {
  return void 0 === n && (n = C), e.theme !== n.theme && e.theme || t2 || n.theme;
}
var A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
var O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var D = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi;
var k = 52;
var j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x(e) {
  var t2, n = "";
  for (t2 = Math.abs(e); t2 > k; t2 = t2 / k | 0) n = j(t2 % k) + n;
  return (j(t2 % k) + n).replace(T, "$1-$2");
}
var V;
var F = 5381;
var M = function(e, t2) {
  for (var n = t2.length; n; ) e = 33 * e ^ t2.charCodeAt(--n);
  return e;
};
var z = function(e) {
  return M(F, e);
};
function $(e) {
  return x(z(e) >>> 0);
}
function B(e) {
  return "string" == typeof e && e || e.displayName || e.name || "Component";
}
function L(e) {
  return "string" == typeof e && e.charAt(0) === e.charAt(0).toLowerCase();
}
var G = "function" == typeof Symbol && Symbol.for;
var Y = G ? Symbol.for("react.memo") : 60115;
var W = G ? Symbol.for("react.forward_ref") : 60112;
var q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e) {
  return ("type" in (t2 = e) && t2.type.$$typeof) === Y ? U : "$$typeof" in e ? J[e.$$typeof] : q;
  var t2;
}
var Z = Object.defineProperty;
var K = Object.getOwnPropertyNames;
var Q = Object.getOwnPropertySymbols;
var ee = Object.getOwnPropertyDescriptor;
var te = Object.getPrototypeOf;
var ne = Object.prototype;
function oe(e, t2, n) {
  if ("string" != typeof t2) {
    if (ne) {
      var o3 = te(t2);
      o3 && o3 !== ne && oe(e, o3, n);
    }
    var r3 = K(t2);
    Q && (r3 = r3.concat(Q(t2)));
    for (var s2 = X(e), i2 = X(t2), a3 = 0; a3 < r3.length; ++a3) {
      var c3 = r3[a3];
      if (!(c3 in H || n && n[c3] || i2 && c3 in i2 || s2 && c3 in s2)) {
        var l2 = ee(t2, c3);
        try {
          Z(e, c3, l2);
        } catch (e2) {
        }
      }
    }
  }
  return e;
}
function re(e) {
  return "function" == typeof e;
}
function se(e) {
  return "object" == typeof e && "styledComponentId" in e;
}
function ie(e, t2) {
  return e && t2 ? "".concat(e, " ").concat(t2) : e || t2 || "";
}
function ae(e, t2) {
  if (0 === e.length) return "";
  for (var n = e[0], o3 = 1; o3 < e.length; o3++) n += t2 ? t2 + e[o3] : e[o3];
  return n;
}
function ce(e) {
  return null !== e && "object" == typeof e && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function le(e, t2, n) {
  if (void 0 === n && (n = false), !n && !ce(e) && !Array.isArray(e)) return t2;
  if (Array.isArray(t2)) for (var o3 = 0; o3 < t2.length; o3++) e[o3] = le(e[o3], t2[o3]);
  else if (ce(t2)) for (var o3 in t2) e[o3] = le(e[o3], t2[o3]);
  return e;
}
function ue(e, t2) {
  Object.defineProperty(e, "toString", { value: t2 });
}
var pe = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function de() {
  for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
  for (var n = e[0], o3 = [], r3 = 1, s2 = e.length; r3 < s2; r3 += 1) o3.push(e[r3]);
  return o3.forEach(function(e2) {
    n = n.replace(/%[a-z]/, e2);
  }), n;
}
function he(t2) {
  for (var n = [], o3 = 1; o3 < arguments.length; o3++) n[o3 - 1] = arguments[o3];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de.apply(void 0, __spreadArray([pe[t2]], n, false)).trim());
}
var fe = function() {
  function e(e2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e2;
  }
  return e.prototype.indexOfGroup = function(e2) {
    for (var t2 = 0, n = 0; n < e2; n++) t2 += this.groupSizes[n];
    return t2;
  }, e.prototype.insertRules = function(e2, t2) {
    if (e2 >= this.groupSizes.length) {
      for (var n = this.groupSizes, o3 = n.length, r3 = o3; e2 >= r3; ) if ((r3 <<= 1) < 0) throw he(16, "".concat(e2));
      this.groupSizes = new Uint32Array(r3), this.groupSizes.set(n), this.length = r3;
      for (var s2 = o3; s2 < r3; s2++) this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e2 + 1), a3 = (s2 = 0, t2.length); s2 < a3; s2++) this.tag.insertRule(i2, t2[s2]) && (this.groupSizes[e2]++, i2++);
  }, e.prototype.clearGroup = function(e2) {
    if (e2 < this.length) {
      var t2 = this.groupSizes[e2], n = this.indexOfGroup(e2), o3 = n + t2;
      this.groupSizes[e2] = 0;
      for (var r3 = n; r3 < o3; r3++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e2) {
    var t2 = "";
    if (e2 >= this.length || 0 === this.groupSizes[e2]) return t2;
    for (var n = this.groupSizes[e2], o3 = this.indexOfGroup(e2), r3 = o3 + n, s2 = o3; s2 < r3; s2++) t2 += "".concat(this.tag.getRule(s2)).concat(g);
    return t2;
  }, e;
}();
var me = 1 << 30;
var ye = /* @__PURE__ */ new Map();
var ve = /* @__PURE__ */ new Map();
var ge = 1;
var Se = function(e) {
  if (ye.has(e)) return ye.get(e);
  for (; ve.has(ge); ) ge++;
  var t2 = ge++;
  if ((0 | t2) < 0 || t2 > me) throw he(16, "".concat(t2));
  return ye.set(e, t2), ve.set(t2, e), t2;
};
var we = function(e, t2) {
  ge = t2 + 1, ye.set(e, t2), ve.set(t2, e);
};
var be = "style[".concat(f, "][").concat(y2, '="').concat(v, '"]');
var Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var Ne = function(e, t2, n) {
  for (var o3, r3 = n.split(","), s2 = 0, i2 = r3.length; s2 < i2; s2++) (o3 = r3[s2]) && e.registerName(t2, o3);
};
var Pe = function(e, t2) {
  for (var n, o3 = (null !== (n = t2.textContent) && void 0 !== n ? n : "").split(g), r3 = [], s2 = 0, i2 = o3.length; s2 < i2; s2++) {
    var a3 = o3[s2].trim();
    if (a3) {
      var c3 = a3.match(Ee);
      if (c3) {
        var l2 = 0 | parseInt(c3[1], 10), u2 = c3[2];
        0 !== l2 && (we(u2, l2), Ne(e, u2, c3[3]), e.getTag().insertRules(l2, r3)), r3.length = 0;
      } else r3.push(a3);
    }
  }
};
var _e = function(e) {
  for (var t2 = document.querySelectorAll(be), n = 0, o3 = t2.length; n < o3; n++) {
    var r3 = t2[n];
    r3 && r3.getAttribute(f) !== m && (Pe(e, r3), r3.parentNode && r3.parentNode.removeChild(r3));
  }
};
function Ce() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t2 = document.head, n = e || t2, o3 = document.createElement("style"), r3 = function(e2) {
    var t3 = Array.from(e2.querySelectorAll("style[".concat(f, "]")));
    return t3[t3.length - 1];
  }(n), s2 = void 0 !== r3 ? r3.nextSibling : null;
  o3.setAttribute(f, m), o3.setAttribute(y2, v);
  var i2 = Ce();
  return i2 && o3.setAttribute("nonce", i2), n.insertBefore(o3, s2), o3;
};
var Ae = function() {
  function e(e2) {
    this.element = Ie(e2), this.element.appendChild(document.createTextNode("")), this.sheet = function(e3) {
      if (e3.sheet) return e3.sheet;
      for (var t2 = document.styleSheets, n = 0, o3 = t2.length; n < o3; n++) {
        var r3 = t2[n];
        if (r3.ownerNode === e3) return r3;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t2) {
    try {
      return this.sheet.insertRule(t2, e2), this.length++, true;
    } catch (e3) {
      return false;
    }
  }, e.prototype.deleteRule = function(e2) {
    this.sheet.deleteRule(e2), this.length--;
  }, e.prototype.getRule = function(e2) {
    var t2 = this.sheet.cssRules[e2];
    return t2 && t2.cssText ? t2.cssText : "";
  }, e;
}();
var Oe = function() {
  function e(e2) {
    this.element = Ie(e2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t2) {
    if (e2 <= this.length && e2 >= 0) {
      var n = document.createTextNode(t2);
      return this.element.insertBefore(n, this.nodes[e2] || null), this.length++, true;
    }
    return false;
  }, e.prototype.deleteRule = function(e2) {
    this.element.removeChild(this.nodes[e2]), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.nodes[e2].textContent : "";
  }, e;
}();
var De = function() {
  function e(e2) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t2) {
    return e2 <= this.length && (this.rules.splice(e2, 0, t2), this.length++, true);
  }, e.prototype.deleteRule = function(e2) {
    this.rules.splice(e2, 1), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.rules[e2] : "";
  }, e;
}();
var Re = S;
var Te = { isServer: !S, useCSSOMInjection: !w };
var ke = function() {
  function e(e2, n, o3) {
    void 0 === e2 && (e2 = C), void 0 === n && (n = {});
    var r3 = this;
    this.options = __assign(__assign({}, Te), e2), this.gs = n, this.names = new Map(o3), this.server = !!e2.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
      return function(e3) {
        for (var t2 = e3.getTag(), n2 = t2.length, o4 = "", r4 = function(n3) {
          var r5 = function(e4) {
            return ve.get(e4);
          }(n3);
          if (void 0 === r5) return "continue";
          var s3 = e3.names.get(r5), i2 = t2.getGroup(n3);
          if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
          var a3 = "".concat(f, ".g").concat(n3, '[id="').concat(r5, '"]'), c3 = "";
          void 0 !== s3 && s3.forEach(function(e4) {
            e4.length > 0 && (c3 += "".concat(e4, ","));
          }), o4 += "".concat(i2).concat(a3, '{content:"').concat(c3, '"}').concat(g);
        }, s2 = 0; s2 < n2; s2++) r4(s2);
        return o4;
      }(r3);
    });
  }
  return e.registerId = function(e2) {
    return Se(e2);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, o3) {
    return void 0 === o3 && (o3 = true), new e(__assign(__assign({}, this.options), n), this.gs, o3 && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(e2) {
    return this.gs[e2] = (this.gs[e2] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e2 = function(e3) {
      var t2 = e3.useCSSOMInjection, n = e3.target;
      return e3.isServer ? new De(n) : t2 ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e2)));
    var e2;
  }, e.prototype.hasNameForId = function(e2, t2) {
    return this.names.has(e2) && this.names.get(e2).has(t2);
  }, e.prototype.registerName = function(e2, t2) {
    if (Se(e2), this.names.has(e2)) this.names.get(e2).add(t2);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(t2), this.names.set(e2, n);
    }
  }, e.prototype.insertRules = function(e2, t2, n) {
    this.registerName(e2, t2), this.getTag().insertRules(Se(e2), n);
  }, e.prototype.clearNames = function(e2) {
    this.names.has(e2) && this.names.get(e2).clear();
  }, e.prototype.clearRules = function(e2) {
    this.getTag().clearGroup(Se(e2)), this.clearNames(e2);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}();
var je = /&/g;
var xe = /^\s*\/\/.*$/gm;
function Ve(e, t2) {
  return e.map(function(e2) {
    return "rule" === e2.type && (e2.value = "".concat(t2, " ").concat(e2.value), e2.value = e2.value.replaceAll(",", ",".concat(t2, " ")), e2.props = e2.props.map(function(e3) {
      return "".concat(t2, " ").concat(e3);
    })), Array.isArray(e2.children) && "@keyframes" !== e2.type && (e2.children = Ve(e2.children, t2)), e2;
  });
}
function Fe(e) {
  var t2, n, o3, r3 = void 0 === e ? C : e, s2 = r3.options, i2 = void 0 === s2 ? C : s2, a3 = r3.plugins, c3 = void 0 === a3 ? _ : a3, l2 = function(e2, o4, r4) {
    return r4.startsWith(n) && r4.endsWith(n) && r4.replaceAll(n, "").length > 0 ? ".".concat(t2) : e2;
  }, u2 = c3.slice();
  u2.push(function(e2) {
    e2.type === RULESET && e2.value.includes("&") && (e2.props[0] = e2.props[0].replace(je, n).replace(o3, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e2, r4, s3, a4) {
    void 0 === r4 && (r4 = ""), void 0 === s3 && (s3 = ""), void 0 === a4 && (a4 = "&"), t2 = a4, n = r4, o3 = new RegExp("\\".concat(n, "\\b"), "g");
    var c4 = e2.replace(xe, ""), l3 = compile(s3 || r4 ? "".concat(s3, " ").concat(r4, " { ").concat(c4, " }") : c4);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e3) {
      return p3.push(e3);
    })))), p3;
  };
  return p2.hash = c3.length ? c3.reduce(function(e2, t3) {
    return t3.name || he(15), M(e2, t3.name);
  }, F).toString() : "", p2;
}
var Me = new ke();
var ze = Fe();
var $e = import_react2.default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
var Be = $e.Consumer;
var Le = import_react2.default.createContext(void 0);
function Ge() {
  return (0, import_react2.useContext)($e);
}
function Ye(e) {
  var t2 = (0, import_react2.useState)(e.stylisPlugins), n = t2[0], r3 = t2[1], c3 = Ge().styleSheet, l2 = (0, import_react2.useMemo)(function() {
    var t3 = c3;
    return e.sheet ? t3 = e.sheet : e.target && (t3 = t3.reconstructWithOptions({ target: e.target }, false)), e.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
  }, [e.disableCSSOMInjection, e.sheet, e.target, c3]), u2 = (0, import_react2.useMemo)(function() {
    return Fe({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  (0, import_react2.useEffect)(function() {
    (0, import_shallowequal.default)(n, e.stylisPlugins) || r3(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var d = (0, import_react2.useMemo)(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e.shouldForwardProp, l2, u2]);
  return import_react2.default.createElement($e.Provider, { value: d }, import_react2.default.createElement(Le.Provider, { value: u2 }, e.children));
}
var We = function() {
  function e(e2, t2) {
    var n = this;
    this.inject = function(e3, t3) {
      void 0 === t3 && (t3 = ze);
      var o3 = n.name + t3.hash;
      e3.hasNameForId(n.id, o3) || e3.insertRules(n.id, o3, t3(n.rules, o3, "@keyframes"));
    }, this.name = e2, this.id = "sc-keyframes-".concat(e2), this.rules = t2, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e2) {
    return void 0 === e2 && (e2 = ze), this.name + e2.hash;
  }, e;
}();
var qe = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t2 = "", n = 0; n < e.length; n++) {
    var o3 = e[n];
    if (1 === n && "-" === o3 && "-" === e[0]) return e;
    qe(o3) ? t2 += "-" + o3.toLowerCase() : t2 += o3;
  }
  return t2.startsWith("ms-") ? "-" + t2 : t2;
}
var Ue = function(e) {
  return null == e || false === e || "" === e;
};
var Je = function(t2) {
  var n, o3, r3 = [];
  for (var s2 in t2) {
    var i2 = t2[s2];
    t2.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r3.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r3.push.apply(r3, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r3.push("".concat(He(s2), ": ").concat((n = s2, null == (o3 = i2) || "boolean" == typeof o3 || "" === o3 ? "" : "number" != typeof o3 || 0 === o3 || n in unitlessKeys || n.startsWith("--") ? String(o3).trim() : "".concat(o3, "px")), ";")));
  }
  return r3;
};
function Xe(e, t2, n, o3) {
  if (Ue(e)) return [];
  if (se(e)) return [".".concat(e.styledComponentId)];
  if (re(e)) {
    if (!re(s2 = e) || s2.prototype && s2.prototype.isReactComponent || !t2) return [e];
    var r3 = e(t2);
    return "object" != typeof r3 || Array.isArray(r3) || r3 instanceof We || ce(r3) || null === r3 || console.error("".concat(B(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(r3, t2, n, o3);
  }
  var s2;
  return e instanceof We ? n ? (e.inject(n, o3), [e.getName(o3)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e2) {
    return Xe(e2, t2, n, o3);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t2 = 0; t2 < e.length; t2 += 1) {
    var n = e[t2];
    if (re(n) && !se(n)) return false;
  }
  return true;
}
var Ke = z(v);
var Qe = function() {
  function e(e2, t2, n) {
    this.rules = e2, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = M(Ke, t2), this.baseStyle = n, ke.registerId(t2);
  }
  return e.prototype.generateAndInjectStyles = function(e2, t2, n) {
    var o3 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e2, t2, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId)) o3 = ie(o3, this.staticRulesId);
    else {
      var r3 = ae(Xe(this.rules, e2, t2, n)), s2 = x(M(this.baseHash, r3) >>> 0);
      if (!t2.hasNameForId(this.componentId, s2)) {
        var i2 = n(r3, ".".concat(s2), void 0, this.componentId);
        t2.insertRules(this.componentId, s2, i2);
      }
      o3 = ie(o3, s2), this.staticRulesId = s2;
    }
    else {
      for (var a3 = M(this.baseHash, n.hash), c3 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2) c3 += u2, a3 = M(a3, u2);
        else if (u2) {
          var p2 = ae(Xe(u2, e2, t2, n));
          a3 = M(a3, p2 + l2), c3 += p2;
        }
      }
      if (c3) {
        var d = x(a3 >>> 0);
        t2.hasNameForId(this.componentId, d) || t2.insertRules(this.componentId, d, n(c3, ".".concat(d), void 0, this.componentId)), o3 = ie(o3, d);
      }
    }
    return o3;
  }, e;
}();
var et = import_react2.default.createContext(void 0);
var tt = et.Consumer;
var rt = {};
var st = /* @__PURE__ */ new Set();
function it(e, r3, s2) {
  var i2 = se(e), a3 = e, c3 = !L(e), p2 = r3.attrs, d = void 0 === p2 ? _ : p2, h = r3.componentId, f2 = void 0 === h ? function(e2, t2) {
    var n = "string" != typeof e2 ? "sc" : R(e2);
    rt[n] = (rt[n] || 0) + 1;
    var o3 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t2 ? "".concat(t2, "-").concat(o3) : o3;
  }(r3.displayName, r3.parentComponentId) : h, m2 = r3.displayName, y3 = void 0 === m2 ? function(e2) {
    return L(e2) ? "styled.".concat(e2) : "Styled(".concat(B(e2), ")");
  }(e) : m2, g2 = r3.displayName && r3.componentId ? "".concat(R(r3.displayName), "-").concat(r3.componentId) : r3.componentId || f2, S2 = i2 && a3.attrs ? a3.attrs.concat(d).filter(Boolean) : d, w2 = r3.shouldForwardProp;
  if (i2 && a3.shouldForwardProp) {
    var b = a3.shouldForwardProp;
    if (r3.shouldForwardProp) {
      var E2 = r3.shouldForwardProp;
      w2 = function(e2, t2) {
        return b(e2, t2) && E2(e2, t2);
      };
    } else w2 = b;
  }
  var N2 = new Qe(s2, g2, i2 ? a3.componentStyle : void 0);
  function O2(e2, r4) {
    return function(e3, r5, s3) {
      var i3 = e3.attrs, a4 = e3.componentStyle, c4 = e3.defaultProps, p3 = e3.foldedComponentIds, d2 = e3.styledComponentId, h2 = e3.target, f3 = import_react2.default.useContext(et), m3 = Ge(), y4 = e3.shouldForwardProp || m3.shouldForwardProp;
      (0, import_react2.useDebugValue)(d2);
      var v2 = I(r5, f3, c4) || C, g3 = function(e4, n, o3) {
        for (var r6, s4 = __assign(__assign({}, n), { className: void 0, theme: o3 }), i4 = 0; i4 < e4.length; i4 += 1) {
          var a5 = re(r6 = e4[i4]) ? r6(s4) : r6;
          for (var c5 in a5) s4[c5] = "className" === c5 ? ie(s4[c5], a5[c5]) : "style" === c5 ? __assign(__assign({}, s4[c5]), a5[c5]) : a5[c5];
        }
        return n.className && (s4.className = ie(s4.className, n.className)), s4;
      }(i3, r5, v2), S3 = g3.as || h2, w3 = {};
      for (var b2 in g3) void 0 === g3[b2] || "$" === b2[0] || "as" === b2 || "theme" === b2 && g3.theme === v2 || ("forwardedAs" === b2 ? w3.as = g3.forwardedAs : y4 && !y4(b2, S3) || (w3[b2] = g3[b2], y4 || false || isPropValid(b2) || st.has(b2) || !A.has(S3) || (st.add(b2), console.warn('styled-components: it looks like an unknown prop "'.concat(b2, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E3 = function(e4, t2) {
        var n = Ge(), o3 = e4.generateAndInjectStyles(t2, n.styleSheet, n.stylis);
        return (0, import_react2.useDebugValue)(o3), o3;
      }(a4, g3);
      e3.warnTooManyClasses && e3.warnTooManyClasses(E3);
      var N3 = ie(p3, d2);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, s3 && (w3.ref = s3), (0, import_react2.createElement)(S3, w3);
    }(D2, e2, r4);
  }
  O2.displayName = y3;
  var D2 = import_react2.default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y3, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a3.foldedComponentIds, a3.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a3.target : e, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e2) {
    this._foldedDefaultProps = i2 ? function(e3) {
      for (var t2 = [], n = 1; n < arguments.length; n++) t2[n - 1] = arguments[n];
      for (var o3 = 0, r4 = t2; o3 < r4.length; o3++) le(e3, r4[o3], true);
      return e3;
    }({}, a3.defaultProps, e2) : e2;
  } }), P(y3, g2), D2.warnTooManyClasses = /* @__PURE__ */ function(e2, t2) {
    var n = {}, o3 = false;
    return function(r4) {
      if (!o3 && (n[r4] = true, Object.keys(n).length >= 200)) {
        var s3 = t2 ? ' with the id of "'.concat(t2, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e2).concat(s3, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o3 = true, n = {};
      }
    };
  }(y3, g2), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c3 && oe(D2, e, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function at(e, t2) {
  for (var n = [e[0]], o3 = 0, r3 = t2.length; o3 < r3; o3 += 1) n.push(t2[o3], e[o3 + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: true });
};
function lt(t2) {
  for (var n = [], o3 = 1; o3 < arguments.length; o3++) n[o3 - 1] = arguments[o3];
  if (re(t2) || ce(t2)) return ct(Xe(at(_, __spreadArray([t2], n, true))));
  var r3 = t2;
  return 0 === n.length && 1 === r3.length && "string" == typeof r3[0] ? Xe(r3) : ct(Xe(at(r3, n)));
}
function ut(n, o3, r3) {
  if (void 0 === r3 && (r3 = C), !o3) throw he(1, o3);
  var s2 = function(t2) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
    return n(o3, r3, lt.apply(void 0, __spreadArray([t2], s3, false)));
  };
  return s2.attrs = function(e) {
    return ut(n, o3, __assign(__assign({}, r3), { attrs: Array.prototype.concat(r3.attrs, e).filter(Boolean) }));
  }, s2.withConfig = function(e) {
    return ut(n, o3, __assign(__assign({}, r3), e));
  }, s2;
}
var pt = function(e) {
  return ut(it, e);
};
var dt = pt;
A.forEach(function(e) {
  dt[e] = pt(e);
});
var ht = function() {
  function e(e2, t2) {
    this.rules = e2, this.componentId = t2, this.isStatic = Ze(e2), ke.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(e2, t2, n, o3) {
    var r3 = o3(ae(Xe(this.rules, t2, n, o3)), ""), s2 = this.componentId + e2;
    n.insertRules(s2, s2, r3);
  }, e.prototype.removeStyles = function(e2, t2) {
    t2.clearRules(this.componentId + e2);
  }, e.prototype.renderStyles = function(e2, t2, n, o3) {
    e2 > 2 && ke.registerId(this.componentId + e2), this.removeStyles(e2, n), this.createStyles(e2, t2, n, o3);
  }, e;
}();
var vt = function() {
  function e() {
    var e2 = this;
    this._emitSheetCSS = function() {
      var t2 = e2.instance.toString();
      if (!t2) return "";
      var n = Ce(), o3 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y2, '="').concat(v, '"')].filter(Boolean), " ");
      return "<style ".concat(o3, ">").concat(t2, "</style>");
    }, this.getStyleTags = function() {
      if (e2.sealed) throw he(2);
      return e2._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n;
      if (e2.sealed) throw he(2);
      var r3 = e2.instance.toString();
      if (!r3) return [];
      var s2 = ((n = {})[f] = "", n[y2] = v, n.dangerouslySetInnerHTML = { __html: r3 }, n), i2 = Ce();
      return i2 && (s2.nonce = i2), [import_react2.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e2.sealed = true;
    }, this.instance = new ke({ isServer: true }), this.sealed = false;
  }
  return e.prototype.collectStyles = function(e2) {
    if (this.sealed) throw he(2);
    return import_react2.default.createElement(Ye, { sheet: this.instance }, e2);
  }, e.prototype.interleaveWithNodeStream = function(e2) {
    throw he(3);
  }, e;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
var St = "__sc-".concat(f, "__");
"undefined" != typeof window && (window[St] || (window[St] = 0), 1 === window[St] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[St] += 1);

// node_modules/@iwer/devui/lib/components/styled.js
var Colors = {
  textWhite: "rgba(223, 223, 223, 1)",
  textGrey: "rgba(156, 156, 156, 1)",
  dangerRed: "rgba(243, 151, 143, 1)",
  dangerRedPressed: "rgba(240, 97, 84,1)",
  panelBackground: "rgba(38, 38, 38, 0.7)",
  panelBorder: "rgba(61, 61, 63, 0.7)",
  buttonBackground: "rgba(61, 61, 63, 0.6)",
  buttonHovered: "rgba(61, 61, 63, 0.8)",
  buttonPressed: "rgba(61, 61, 63, 1)",
  gradientGrey: "linear-gradient(to bottom, #343434, #393939)",
  gradientGreyTranslucent: "linear-gradient(to bottom, rgba(52, 52, 52, 0.75), rgba(57, 57, 57, 0.75))",
  gradientLightGreyTranslucent: "linear-gradient(to bottom, rgba(75, 75, 75, 0.75), rgba(80, 80, 80, 0.75))"
};
var ControlButtonStyles = {
  height: "30px",
  minWidth: "30px",
  fontSize: "14px",
  radiusMiddle: "3px",
  radiusSolo: "10px",
  radiusFirst: "10px 3px 3px 10px",
  radiusLast: "3px 10px 10px 3px",
  widthLong: "70px",
  widthShort: "30px",
  gap: "3px"
};
var Button = dt.button`
	background: ${Colors.gradientGreyTranslucent};
	border: none;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: ${Colors.textWhite};
	border: 1px solid transparent;
	border-radius: ${ControlButtonStyles.radiusMiddle};
	font-size: ${ControlButtonStyles.fontSize};
	height: ${ControlButtonStyles.height};
	min-width: ${ControlButtonStyles.minWidth};
	transition: all 0.2s ease-in-out;
	text-transform: none;
	box-shadow: none;
	font-family: Arial, sans-serif;

	&:first-child {
		border-radius: ${({ $reverse }) => $reverse ? ControlButtonStyles.radiusLast : ControlButtonStyles.radiusFirst};
	}

	&:last-child {
		border-radius: ${({ $reverse }) => $reverse ? ControlButtonStyles.radiusFirst : ControlButtonStyles.radiusLast};
	}

	&:first-child:last-child {
		border-radius: ${ControlButtonStyles.radiusSolo};
	}
`;
var HeaderButtonsContainer = dt.div`
	padding: 2px;
	display: flex;
	background-color: ${Colors.panelBackground};
	border: 1px solid ${Colors.panelBorder};
	backdrop-filter: blur(40px);
	-webkit-backdrop-filter: blur(40px);
	justify-content: center;
	pointer-events: all;
	border-radius: 14px;
	align-items: center;
	height: 24px;
`;
var HeaderButton = dt.button`
	background-color: transparent;
	border: none;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: ${Colors.textWhite};
	border-radius: 4px;
	font-size: 16px;
	height: 24px;
	min-width: 24px;
	transition: all 0.2s ease-in-out;
	text-transform: none;
	box-shadow: none;
	padding: 1px 5px;
	font-family: Arial, sans-serif;

	&:hover {
		background-color: ${Colors.buttonPressed};
	}

	&:active {
		background-color: ${Colors.buttonPressed};
	}

	&:focus {
		outline: none;
	}

	&:first-child {
		border-radius: 12px 4px 4px 12px;
	}

	&:last-child {
		border-radius: 4px 12px 12px 4px;
	}

	&:first-child:last-child {
		border-radius: 12px;
	}
`;
var MappedKeyBlock = dt.div`
	background-color: ${({ $pressed }) => $pressed ? Colors.buttonPressed : Colors.buttonBackground};
	border: none;
	display: flex;
	align-items: center;
	justify-content: center;
	color: ${Colors.textWhite};
	border-radius: 8px;
	font-size: 14px;
	font-family: Arial, sans-serif;
	height: 30px;
	width: 30px;
	transition: all 0.2s ease-in-out;
`;
var ButtonContainer = dt.div`
	display: flex;
	align-items: center;
	height: 30px;
	margin-bottom: 3px;
	justify-content: flex-start;
	flex-direction: ${({ $reverse }) => $reverse ? "row-reverse" : "row"};

	&:last-child {
		margin-bottom: 0;
	}
`;
var ButtonGroup = dt.div`
	display: flex;
	flex-direction: ${({ $reverse }) => $reverse ? "row-reverse" : "row"};
	height: 100%;
	justify-content: space-between;
	align-items: center;
	margin: ${({ $reverse }) => $reverse ? "0 5px 0 0" : "0 0 0 5px"};
	gap: 3px;
`;
var JoystickButton = dt.button`
	background-color: rgba(255, 255, 255, 0.3);
	border: none;
	display: flex;
	justify-content: center;
	align-items: center;
	padding: 0;
	pointer-events: none;
	width: 50px;
	height: 50px;
	border-radius: 50%;
	position: relative;
	margin: 0 5px;
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
`;
var JoystickInner = dt.div`
	position: absolute;
	background-color: ${Colors.textWhite};
	border-radius: 50%;
	width: 36px;
	height: 36px;
	cursor: pointer;
	pointer-events: auto;
`;
var RangeSelector = dt.input.attrs({ type: "range" })`
	-webkit-appearance: none;
	appearance: none;
	background: ${Colors.gradientGreyTranslucent};
	border: none;
	height: 100%;
	width: ${ControlButtonStyles.widthLong};
	cursor: pointer;
	margin: 0;
	transition: all 0.2s ease-in-out;
	border-radius: ${({ $reverse }) => $reverse ? ControlButtonStyles.radiusFirst : ControlButtonStyles.radiusLast};

	&::-webkit-slider-thumb {
		-webkit-appearance: none;
		appearance: none;
		width: 8px;
		height: 30px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}

	&::-moz-range-thumb {
		width: 10px;
		height: 30px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}

	&::-ms-thumb {
		width: 8px;
		height: 24px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}
`;
var KeyBlockContainer = dt.div`
	display: flex;
	flex-direction: column;
	align-items: ${({ $reverse }) => $reverse ? "flex-start" : "flex-end"};
	justify-content: center;
	margin: ${({ $reverse }) => $reverse ? "2px -26px 0 0" : "2px 0 0 -26px"};
`;
var KeyRow = dt.div`
	display: flex;
	flex-direction: ${({ $reverse }) => $reverse ? "row-reverse" : "row"};
	align-items: center;
	justify-content: center;
`;
var FAIcon = dt(FontAwesomeIcon)`
	height: ${({ $size = 14 }) => `${$size}px`};
	min-height: ${({ $size = 14 }) => `${$size}px`};
	max-height: ${({ $size = 14 }) => `${$size}px`};
	width: ${({ $size = 14 }) => `${$size}px`};
	min-width: ${({ $size = 14 }) => `${$size}px`};
	max-width: ${({ $size = 14 }) => `${$size}px`};
	transform: ${({ $reverse }) => $reverse ? "scaleX(-1)" : "unset"};
`;
var FAControlIcon = dt(FontAwesomeIcon)`
	height: 18px;
	min-height: 18px;
	max-height: 18px;
	width: 18px;
	min-width: 18px;
	max-width: 18px;
	margin: 6px;
	transform: ${({ $reverse }) => $reverse ? "scaleX(-1)" : "unset"};
`;
var ControlPanel = dt.div`
	position: fixed;
	padding: 5px;
	font-family: Arial, sans-serif;
	color: ${Colors.textWhite};
	pointer-events: all;
	background-color: ${Colors.panelBackground};
	border: 1px solid ${Colors.panelBorder};
	backdrop-filter: blur(40px);
	-webkit-backdrop-filter: blur(40px);
	border-radius: 12px;
	box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
	overflow: hidden;
	display: flex;
	flex-direction: column;
`;
var SectionBreak = dt.hr`
	width: ${({ $horizontal = true }) => $horizontal ? "unset" : "1px"};
	height: ${({ $horizontal = true }) => $horizontal ? "1px" : "unset"};
	background-color: ${Colors.panelBorder};
	margin: 5px 3px;
	border: none;
`;
var PanelHeaderButton = dt.button`
	background-color: transparent;
	border: none;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: ${({ $isRed }) => $isRed ? Colors.dangerRed : Colors.textWhite};
	font-size: 12px;
	padding: 3px;
	text-transform: none;
	box-shadow: none;

	&:hover {
		color: ${({ $isRed }) => $isRed ? Colors.dangerRedPressed : "#ffffff"};
	}

	&:active {
		color: ${({ $isRed }) => $isRed ? Colors.dangerRedPressed : "#ffffff"};
	}

	&:focus {
		outline: none;
	}
`;
var ValuesContainer = dt.div`
	display: flex;
	flex-direction: row;
	gap: ${ControlButtonStyles.gap};
	height: 25px;
`;
var ValueInput = dt.input.attrs({ type: "text" })`
	width: 50px;
	outline: none;
	background: ${Colors.gradientGrey};
	border: 1px solid transparent;
	border-radius: 5px;
	height: 25px;
	color: ${Colors.textWhite};
	padding: 0 10px 0 5px;
	box-sizing: border-box;
	font-size: 10px;

	&:read-only {
		background: ${Colors.gradientGreyTranslucent};
	}

	&:invalid {
		background-color: ${Colors.dangerRed};
	}
`;
var InputSuffix = dt.span`
	position: absolute;
	right: 5px;
	top: 50%;
	transform: translateY(-50%);
	pointer-events: none;
	color: ${Colors.textGrey};
	font-size: 10px;
`;

// node_modules/@iwer/devui/lib/components/mapper.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/@iwer/devui/lib/components/icons.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faRightFromBracket = {
  prefix: "fas",
  iconName: "right-from-bracket",
  icon: [512, 512, ["sign-out-alt"], "f2f5", "M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z"]
};
var faFingerprint = {
  prefix: "fas",
  iconName: "fingerprint",
  icon: [512, 512, [], "f577", "M48 256C48 141.1 141.1 48 256 48c63.1 0 119.6 28.1 157.8 72.5c8.6 10.1 23.8 11.2 33.8 2.6s11.2-23.8 2.6-33.8C403.3 34.6 333.7 0 256 0C114.6 0 0 114.6 0 256l0 40c0 13.3 10.7 24 24 24s24-10.7 24-24l0-40zm458.5-52.9c-2.7-13-15.5-21.3-28.4-18.5s-21.3 15.5-18.5 28.4c2.9 13.9 4.5 28.3 4.5 43.1l0 40c0 13.3 10.7 24 24 24s24-10.7 24-24l0-40c0-18.1-1.9-35.8-5.5-52.9zM256 80c-19 0-37.4 3-54.5 8.6c-15.2 5-18.7 23.7-8.3 35.9c7.1 8.3 18.8 10.8 29.4 7.9c10.6-2.9 21.8-4.4 33.4-4.4c70.7 0 128 57.3 128 128l0 24.9c0 25.2-1.5 50.3-4.4 75.3c-1.7 14.6 9.4 27.8 24.2 27.8c11.8 0 21.9-8.6 23.3-20.3c3.3-27.4 5-55 5-82.7l0-24.9c0-97.2-78.8-176-176-176zM150.7 148.7c-9.1-10.6-25.3-11.4-33.9-.4C93.7 178 80 215.4 80 256l0 24.9c0 24.2-2.6 48.4-7.8 71.9C68.8 368.4 80.1 384 96.1 384c10.5 0 19.9-7 22.2-17.3c6.4-28.1 9.7-56.8 9.7-85.8l0-24.9c0-27.2 8.5-52.4 22.9-73.1c7.2-10.4 8-24.6-.2-34.2zM256 160c-53 0-96 43-96 96l0 24.9c0 35.9-4.6 71.5-13.8 106.1c-3.8 14.3 6.7 29 21.5 29c9.5 0 17.9-6.2 20.4-15.4c10.5-39 15.9-79.2 15.9-119.7l0-24.9c0-28.7 23.3-52 52-52s52 23.3 52 52l0 24.9c0 36.3-3.5 72.4-10.4 107.9c-2.7 13.9 7.7 27.2 21.8 27.2c10.2 0 19-7 21-17c7.7-38.8 11.6-78.3 11.6-118.1l0-24.9c0-53-43-96-96-96zm24 96c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 24.9c0 59.9-11 119.3-32.5 175.2l-5.9 15.3c-4.8 12.4 1.4 26.3 13.8 31s26.3-1.4 31-13.8l5.9-15.3C267.9 411.9 280 346.7 280 280.9l0-24.9z"]
};
var faCaretRight = {
  prefix: "fas",
  iconName: "caret-right",
  icon: [256, 512, [], "f0da", "M246.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 256c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l128-128z"]
};
var faCaretLeft = {
  prefix: "fas",
  iconName: "caret-left",
  icon: [256, 512, [], "f0d9", "M9.4 278.6c-12.5-12.5-12.5-32.8 0-45.3l128-128c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 256c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-128-128z"]
};
var faGamepad = {
  prefix: "fas",
  iconName: "gamepad",
  icon: [640, 512, [], "f11b", "M192 64C86 64 0 150 0 256S86 448 192 448l256 0c106 0 192-86 192-192s-86-192-192-192L192 64zM496 168a40 40 0 1 1 0 80 40 40 0 1 1 0-80zM392 304a40 40 0 1 1 80 0 40 40 0 1 1 -80 0zM168 200c0-13.3 10.7-24 24-24s24 10.7 24 24l0 32 32 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-32 0 0 32c0 13.3-10.7 24-24 24s-24-10.7-24-24l0-32-32 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l32 0 0-32z"]
};
var faHand = {
  prefix: "fas",
  iconName: "hand",
  icon: [512, 512, [129306, 9995, "hand-paper"], "f256", "M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 208c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-176c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 272c0 1.5 0 3.1 .1 4.6L67.6 283c-16-15.2-41.3-14.6-56.6 1.4s-14.6 41.3 1.4 56.6L124.8 448c43.1 41.1 100.4 64 160 64l19.2 0c97.2 0 176-78.8 176-176l0-208c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 112c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-176c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 176c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-208z"]
};
var faPlug = {
  prefix: "fas",
  iconName: "plug",
  icon: [384, 512, [128268], "f1e6", "M96 0C78.3 0 64 14.3 64 32l0 96 64 0 0-96c0-17.7-14.3-32-32-32zM288 0c-17.7 0-32 14.3-32 32l0 96 64 0 0-96c0-17.7-14.3-32-32-32zM32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l0 32c0 77.4 55 142 128 156.8l0 67.2c0 17.7 14.3 32 32 32s32-14.3 32-32l0-67.2C297 398 352 333.4 352 256l0-32c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160z"]
};
var faBan = {
  prefix: "fas",
  iconName: "ban",
  icon: [512, 512, [128683, "cancel"], "f05e", "M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"]
};
var faArrowRightToBracket = {
  prefix: "fas",
  iconName: "arrow-right-to-bracket",
  icon: [512, 512, ["sign-in"], "f090", "M352 96l64 0c17.7 0 32 14.3 32 32l0 256c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0c53 0 96-43 96-96l0-256c0-53-43-96-96-96l-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32zm-9.4 182.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L242.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l210.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z"]
};
var faCaretUp = {
  prefix: "fas",
  iconName: "caret-up",
  icon: [320, 512, [], "f0d8", "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"]
};
var faRotateLeft = {
  prefix: "fas",
  iconName: "rotate-left",
  icon: [512, 512, ["rotate-back", "rotate-backward", "undo-alt"], "f2ea", "M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"]
};
var faCirclePlay = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
};
var faPersonShelter = {
  prefix: "fas",
  iconName: "person-shelter",
  icon: [512, 512, [], "e54f", "M271.9 4.2c-9.8-5.6-21.9-5.6-31.8 0l-224 128C6.2 137.9 0 148.5 0 160L0 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-301.4L256 68.9 448 178.6 448 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-320c0-11.5-6.2-22.1-16.1-27.8l-224-128zM256 208a40 40 0 1 0 0-80 40 40 0 1 0 0 80zm-8 280l0-88 16 0 0 88c0 13.3 10.7 24 24 24s24-10.7 24-24l0-174.5 26.9 49.9c6.3 11.7 20.8 16 32.5 9.8s16-20.8 9.8-32.5l-37.9-70.3c-15.3-28.5-45.1-46.3-77.5-46.3l-19.5 0c-32.4 0-62.1 17.8-77.5 46.3l-37.9 70.3c-6.3 11.7-1.9 26.2 9.8 32.5s26.2 1.9 32.5-9.8L200 313.5 200 488c0 13.3 10.7 24 24 24s24-10.7 24-24z"]
};
var faHandScissors = {
  prefix: "fas",
  iconName: "hand-scissors",
  icon: [512, 512, [], "f257", "M40 208c-22.1 0-40 17.9-40 40s17.9 40 40 40l180.2 0c-7.6 8.5-12.2 19.7-12.2 32c0 25.3 19.5 46 44.3 47.9c-7.7 8.5-12.3 19.8-12.3 32.1c0 26.5 21.5 48 48 48l32 0 64 0c70.7 0 128-57.3 128-128l0-113.1c0-40.2-16-78.8-44.4-107.3C444.8 76.8 413.9 64 381.7 64L336 64c-21.3 0-39.3 13.9-45.6 33.1l74.5 23.7c8.4 2.7 13.1 11.7 10.4 20.1s-11.7 13.1-20.1 10.4L288 129.9c0 0 0 .1 0 .1L84 65.8C62.9 59.2 40.5 70.9 33.8 92s5.1 43.5 26.2 50.2L269.5 208 40 208z"]
};
var faStreetView = {
  prefix: "fas",
  iconName: "street-view",
  icon: [512, 512, [], "f21d", "M320 64A64 64 0 1 0 192 64a64 64 0 1 0 128 0zm-96 96c-35.3 0-64 28.7-64 64l0 48c0 17.7 14.3 32 32 32l1.8 0 11.1 99.5c1.8 16.2 15.5 28.5 31.8 28.5l38.7 0c16.3 0 30-12.3 31.8-28.5L318.2 304l1.8 0c17.7 0 32-14.3 32-32l0-48c0-35.3-28.7-64-64-64l-64 0zM132.3 394.2c13-2.4 21.7-14.9 19.3-27.9s-14.9-21.7-27.9-19.3c-32.4 5.9-60.9 14.2-82 24.8c-10.5 5.3-20.3 11.7-27.8 19.6C6.4 399.5 0 410.5 0 424c0 21.4 15.5 36.1 29.1 45c14.7 9.6 34.3 17.3 56.4 23.4C130.2 504.7 190.4 512 256 512s125.8-7.3 170.4-19.6c22.1-6.1 41.8-13.8 56.4-23.4c13.7-8.9 29.1-23.6 29.1-45c0-13.5-6.4-24.5-14-32.6c-7.5-7.9-17.3-14.3-27.8-19.6c-21-10.6-49.5-18.9-82-24.8c-13-2.4-25.5 6.3-27.9 19.3s6.3 25.5 19.3 27.9c30.2 5.5 53.7 12.8 69 20.5c3.2 1.6 5.8 3.1 7.9 4.5c3.6 2.4 3.6 7.2 0 9.6c-8.8 5.7-23.1 11.8-43 17.3C374.3 457 318.5 464 256 464s-118.3-7-157.7-17.9c-19.9-5.5-34.2-11.6-43-17.3c-3.6-2.4-3.6-7.2 0-9.6c2.1-1.4 4.8-2.9 7.9-4.5c15.3-7.7 38.8-14.9 69-20.5z"]
};
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
};
var faCaretDown = {
  prefix: "fas",
  iconName: "caret-down",
  icon: [320, 512, [], "f0d7", "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"]
};
var faDeleteLeft = {
  prefix: "fas",
  iconName: "delete-left",
  icon: [576, 512, [9003, "backspace"], "f55a", "M576 128c0-35.3-28.7-64-64-64L205.3 64c-17 0-33.3 6.7-45.3 18.7L9.4 233.4c-6 6-9.4 14.1-9.4 22.6s3.4 16.6 9.4 22.6L160 429.3c12 12 28.3 18.7 45.3 18.7L512 448c35.3 0 64-28.7 64-64l0-256zM271 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"]
};
var faBug = {
  prefix: "fas",
  iconName: "bug",
  icon: [512, 512, [], "f188", "M256 0c53 0 96 43 96 96l0 3.6c0 15.7-12.7 28.4-28.4 28.4l-135.1 0c-15.7 0-28.4-12.7-28.4-28.4l0-3.6c0-53 43-96 96-96zM41.4 105.4c12.5-12.5 32.8-12.5 45.3 0l64 64c.7 .7 1.3 1.4 1.9 2.1c14.2-7.3 30.4-11.4 47.5-11.4l112 0c17.1 0 33.2 4.1 47.5 11.4c.6-.7 1.2-1.4 1.9-2.1l64-64c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-64 64c-.7 .7-1.4 1.3-2.1 1.9c6.2 12 10.1 25.3 11.1 39.5l64.3 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c0 24.6-5.5 47.8-15.4 68.6c2.2 1.3 4.2 2.9 6 4.8l64 64c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0l-63.1-63.1c-24.5 21.8-55.8 36.2-90.3 39.6L272 240c0-8.8-7.2-16-16-16s-16 7.2-16 16l0 239.2c-34.5-3.4-65.8-17.8-90.3-39.6L86.6 502.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l64-64c1.9-1.9 3.9-3.4 6-4.8C101.5 367.8 96 344.6 96 320l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64.3 0c1.1-14.1 5-27.5 11.1-39.5c-.7-.6-1.4-1.2-2.1-1.9l-64-64c-12.5-12.5-12.5-32.8 0-45.3z"]
};
var faAngleUp = {
  prefix: "fas",
  iconName: "angle-up",
  icon: [448, 512, [8963], "f106", "M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z"]
};
var faChevronLeft = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
};
var faHandLizard = {
  prefix: "fas",
  iconName: "hand-lizard",
  icon: [512, 512, [], "f258", "M0 112C0 85.5 21.5 64 48 64l112 0 80 0 46.5 0c36.8 0 71.2 18 92.1 48.2l113.5 164c13 18.7 19.9 41 19.9 63.8l0 12 0 16 0 48c0 17.7-14.3 32-32 32l-96 0c-17.7 0-32-14.3-32-32l0-13.8L273.9 352 240 352l-80 0-48 0c-26.5 0-48-21.5-48-48s21.5-48 48-48l48 0 80 0c26.5 0 48-21.5 48-48s-21.5-48-48-48l-80 0L48 160c-26.5 0-48-21.5-48-48z"]
};
var faChevronRight = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
};
var faVrCardboard = {
  prefix: "fas",
  iconName: "vr-cardboard",
  icon: [640, 512, [], "f729", "M576 64L64 64C28.7 64 0 92.7 0 128L0 384c0 35.3 28.7 64 64 64l120.4 0c24.2 0 46.4-13.7 57.2-35.4l32-64c8.8-17.5 26.7-28.6 46.3-28.6s37.5 11.1 46.3 28.6l32 64c10.8 21.7 33 35.4 57.2 35.4L576 448c35.3 0 64-28.7 64-64l0-256c0-35.3-28.7-64-64-64zM96 240a64 64 0 1 1 128 0A64 64 0 1 1 96 240zm384-64a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"]
};
var faArrowTurnDown = {
  prefix: "fas",
  iconName: "arrow-turn-down",
  icon: [384, 512, ["level-down"], "f149", "M32 64C14.3 64 0 49.7 0 32S14.3 0 32 0l96 0c53 0 96 43 96 96l0 306.7 73.4-73.4c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-128 128c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 402.7 160 96c0-17.7-14.3-32-32-32L32 64z"]
};
var faCircleXmark = {
  prefix: "fas",
  iconName: "circle-xmark",
  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"]
};
var faVideo = {
  prefix: "fas",
  iconName: "video",
  icon: [576, 512, ["video-camera"], "f03d", "M0 128C0 92.7 28.7 64 64 64l256 0c35.3 0 64 28.7 64 64l0 256c0 35.3-28.7 64-64 64L64 448c-35.3 0-64-28.7-64-64L0 128zM559.1 99.8c10.4 5.6 16.9 16.4 16.9 28.2l0 256c0 11.8-6.5 22.6-16.9 28.2s-23 5-32.9-1.6l-96-64L416 337.1l0-17.1 0-128 0-17.1 14.2-9.5 96-64c9.8-6.5 22.4-7.2 32.9-1.6z"]
};

// node_modules/@iwer/devui/lib/components/icons.js
var IconSize = ControlButtonStyles.height;
var ButtonX = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M7 13.125a7 7 0 1 0 14 0v1.75a7 7 0 0 1-14 0v-1.75Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.55, d: "M14 19.863a6.738 6.738 0 1 0 0-13.476 6.738 6.738 0 0 0 0 13.476Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M16.529 16.1h-.893l-1.653-2.713-1.68 2.713h-.832l2.074-3.255-1.942-2.992h.875l1.531 2.45 1.54-2.45h.831l-1.933 2.975 2.082 3.272Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ButtonY = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M7 13.125a7 7 0 1 0 14 0v1.75a7 7 0 0 1-14 0v-1.75Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.55, d: "M14 19.863a6.738 6.738 0 1 0 0-13.476 6.738 6.738 0 0 0 0 13.476Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "m14.086 12.924 1.627-3.071h.849l-2.083 3.823V16.1h-.787v-2.389L11.61 9.853h.857l1.619 3.07Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ButtonA = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M7 13.125a7 7 0 1 0 14 0v1.75a7 7 0 0 1-14 0v-1.75Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.55, d: "M14 19.863a6.738 6.738 0 1 0 0-13.476 6.738 6.738 0 0 0 0 13.476Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "m15.975 16.1-.753-1.934h-2.476l-.744 1.934h-.796l2.441-6.274h.709l2.432 6.274h-.813Zm-1.69-4.524a29.052 29.052 0 0 1-.21-.63 5.175 5.175 0 0 0-.087-.306c-.029.117-.06.236-.096.359-.03.116-.061.224-.096.323-.03.1-.056.184-.079.254l-.709 1.89h1.978l-.7-1.89Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ButtonB = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M7 13.125a7 7 0 1 0 14 0v1.75a7 7 0 0 1-14 0v-1.75Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.55, d: "M14 19.863a6.738 6.738 0 1 0 0-13.476 6.738 6.738 0 0 0 0 13.476Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.876 9.853c.519 0 .954.05 1.304.148.355.1.62.263.796.49.18.228.271.531.271.91 0 .245-.047.464-.14.656a1.198 1.198 0 0 1-.402.473 1.62 1.62 0 0 1-.648.254v.043c.262.041.499.117.709.228.216.11.385.268.507.473.123.204.184.47.184.796 0 .379-.088.703-.262.971a1.663 1.663 0 0 1-.753.604c-.32.134-.706.201-1.155.201h-2.196V9.853h1.785Zm.157 2.66c.537 0 .905-.085 1.103-.254.198-.175.297-.432.297-.77 0-.344-.122-.59-.367-.735-.24-.152-.624-.228-1.155-.228h-1.033v1.986h1.155Zm-1.155.656v2.266h1.26c.555 0 .94-.108 1.155-.324.216-.216.324-.498.324-.849 0-.221-.05-.414-.149-.577-.093-.163-.254-.289-.481-.376-.222-.093-.525-.14-.91-.14h-1.199Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickL = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.5, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M12.642 17.325v-6.247h.787v5.547h2.73v.7h-3.517ZM14.479 6.389a.525.525 0 0 1-.782 0l-2.235-2.495a.525.525 0 0 1 .39-.875h4.47c.454 0 .694.537.391.875L14.478 6.39Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "m13.045 6.711-1.093-1.22a8.75 8.75 0 1 0 4.24.036L15.11 6.733A7.352 7.352 0 0 1 14 21.35a7.35 7.35 0 0 1-.955-14.639Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickR = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.7, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.938 11.077c.52 0 .945.068 1.278.202.338.128.59.323.752.586.164.262.245.592.245.989 0 .332-.06.61-.183.83-.123.223-.28.4-.473.535a2.61 2.61 0 0 1-.595.306l1.715 2.8h-.919l-1.513-2.581h-1.243v2.58h-.787v-6.247h1.723Zm-.043.683h-.893v2.319h.936c.339 0 .616-.044.832-.132a.956.956 0 0 0 .472-.402c.105-.175.158-.394.158-.656 0-.274-.056-.493-.167-.657a.905.905 0 0 0-.49-.358c-.221-.076-.504-.114-.848-.114ZM14.479 6.389a.525.525 0 0 1-.782 0l-2.235-2.495a.525.525 0 0 1 .39-.875h4.47c.454 0 .694.537.391.875L14.478 6.39Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "m13.045 6.711-1.093-1.22a8.75 8.75 0 1 0 4.24.036L15.11 6.733A7.352 7.352 0 0 1 14 21.35a7.35 7.35 0 0 1-.955-14.639Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickLUp = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M12.642 17.325v-6.248h.787v5.548h2.73v.7h-3.517ZM13.697.611a.525.525 0 0 1 .782 0l2.234 2.495a.525.525 0 0 1-.39.875h-4.47a.525.525 0 0 1-.391-.875L13.697.61Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickLDown = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M12.642 17.325v-6.248h.787v5.548h2.73v.7h-3.517ZM14.479 27.389a.525.525 0 0 1-.782 0l-2.235-2.495a.525.525 0 0 1 .39-.875h4.47c.454 0 .694.537.391.875l-2.235 2.495Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickLLeft = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M12.642 17.325v-6.248h.787v5.548h2.73v.7h-3.517ZM.611 14.303a.525.525 0 0 1 0-.782l2.495-2.234a.525.525 0 0 1 .875.39v4.47a.525.525 0 0 1-.875.391L.61 14.303Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickLRight = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M12.642 17.325v-6.248h.787v5.548h2.73v.7h-3.517ZM27.389 13.521a.525.525 0 0 1 0 .782l-2.495 2.235a.525.525 0 0 1-.875-.39v-4.47c0-.454.537-.694.875-.391l2.495 2.234Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickRUp = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.938 11.077c.52 0 .945.068 1.278.202.338.128.59.323.752.586.164.262.245.592.245.989 0 .332-.06.61-.183.83-.123.223-.28.4-.473.535a2.61 2.61 0 0 1-.595.306l1.715 2.8h-.919l-1.513-2.581h-1.243v2.58h-.787v-6.247h1.723Zm-.043.683h-.893v2.319h.936c.339 0 .616-.044.832-.132a.956.956 0 0 0 .472-.402c.105-.175.158-.394.158-.656 0-.274-.056-.493-.167-.657a.905.905 0 0 0-.49-.358c-.221-.076-.504-.114-.848-.114ZM13.697.611a.525.525 0 0 1 .782 0l2.234 2.495a.525.525 0 0 1-.39.875h-4.47a.525.525 0 0 1-.391-.875L13.697.61Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickRDown = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.938 11.077c.52 0 .945.068 1.278.202.338.128.59.323.752.586.164.262.245.592.245.989 0 .332-.06.61-.183.83-.123.223-.28.4-.473.535a2.61 2.61 0 0 1-.595.306l1.715 2.8h-.919l-1.513-2.581h-1.243v2.58h-.787v-6.247h1.723Zm-.043.683h-.893v2.319h.936c.339 0 .616-.044.832-.132a.956.956 0 0 0 .472-.402c.105-.175.158-.394.158-.656 0-.274-.056-.493-.167-.657a.905.905 0 0 0-.49-.358c-.221-.076-.504-.114-.848-.114ZM14.479 27.389a.525.525 0 0 1-.782 0l-2.235-2.495a.525.525 0 0 1 .39-.875h4.47c.454 0 .694.537.391.875l-2.235 2.495Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickRLeft = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.938 11.077c.52 0 .945.068 1.278.202.338.128.59.323.752.586.164.262.245.592.245.989 0 .332-.06.61-.183.83-.123.223-.28.4-.473.535a2.61 2.61 0 0 1-.595.306l1.715 2.8h-.919l-1.513-2.581h-1.243v2.58h-.787v-6.247h1.723Zm-.043.683h-.893v2.319h.936c.339 0 .616-.044.832-.132a.956.956 0 0 0 .472-.402c.105-.175.158-.394.158-.656 0-.274-.056-.493-.167-.657a.905.905 0 0 0-.49-.358c-.221-.076-.504-.114-.848-.114ZM.611 14.303a.525.525 0 0 1 0-.782l2.495-2.234a.525.525 0 0 1 .875.39v4.47a.525.525 0 0 1-.875.391L.61 14.303Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbstickRRight = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 1.5, d: "M14 22.05a8.05 8.05 0 1 0 0-16.1 8.05 8.05 0 0 0 0 16.1Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.75, d: "M14 19.95a5.95 5.95 0 1 0 0-11.9 5.95 5.95 0 0 0 0 11.9Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M13.938 11.077c.52 0 .945.068 1.278.202.338.128.59.323.752.586.164.262.245.592.245.989 0 .332-.06.61-.183.83-.123.223-.28.4-.473.535a2.61 2.61 0 0 1-.595.306l1.715 2.8h-.919l-1.513-2.581h-1.243v2.58h-.787v-6.247h1.723Zm-.043.683h-.893v2.319h.936c.339 0 .616-.044.832-.132a.956.956 0 0 0 .472-.402c.105-.175.158-.394.158-.656 0-.274-.056-.493-.167-.657a.905.905 0 0 0-.49-.358c-.221-.076-.504-.114-.848-.114ZM27.389 13.521a.525.525 0 0 1 0 .782l-2.495 2.235a.525.525 0 0 1-.875-.39v-4.47c0-.454.537-.694.875-.391l2.495 2.234Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var GripL = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M7.525 7.875c-2.283 1.22-3.82 3.507-3.82 6.125s1.537 4.904 3.82 6.125C4.405 19.425 2.1 16.948 2.1 14s2.306-5.425 5.425-6.125Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.7, d: "M24.702 10.954a2.187 2.187 0 0 0-2.095-2.817H11.025a5.863 5.863 0 0 0 0 11.726h9.377c.966 0 1.818-.634 2.095-1.56l2.205-7.35Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M10.594 17.15v-6.248h.788v5.548h2.73v.7h-3.518Zm7.13-3.299h2.162v3.063c-.338.11-.68.192-1.024.245a7.837 7.837 0 0 1-1.172.078c-.648 0-1.193-.128-1.637-.385a2.567 2.567 0 0 1-1.015-1.11c-.227-.485-.34-1.057-.34-1.716 0-.653.127-1.219.384-1.697a2.699 2.699 0 0 1 1.103-1.112c.484-.268 1.067-.402 1.75-.402.35 0 .68.032.988.096.315.064.607.155.875.271l-.297.683a4.55 4.55 0 0 0-.753-.254 3.453 3.453 0 0 0-.857-.105c-.496 0-.922.102-1.278.306a2.004 2.004 0 0 0-.813.875c-.187.374-.28.82-.28 1.34 0 .495.078.935.236 1.32.163.38.417.677.761.893.344.21.796.315 1.356.315.187 0 .35-.006.49-.018.146-.017.277-.037.394-.06.123-.024.236-.047.341-.07V14.55h-1.373v-.7Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var GripR = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M20.441 7.875c2.283 1.22 3.82 3.507 3.82 6.125s-1.537 4.904-3.82 6.125c3.12-.7 5.425-3.177 5.425-6.125s-2.305-5.425-5.425-6.125Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.7, d: "M3.264 10.954a2.187 2.187 0 0 1 2.095-2.817h11.582a5.862 5.862 0 0 1 0 11.726H7.564a2.188 2.188 0 0 1-2.095-1.56l-2.205-7.35Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M9.497 10.902c.519 0 .945.068 1.277.202.339.128.59.323.753.586.163.262.245.592.245.989 0 .332-.062.61-.184.83-.122.223-.28.4-.472.535-.187.128-.386.23-.595.306l1.714 2.8h-.918l-1.514-2.581H8.56v2.58h-.787v-6.247h1.724Zm-.044.683H8.56v2.319h.937c.338 0 .615-.044.831-.132a.956.956 0 0 0 .473-.402c.104-.175.157-.394.157-.656 0-.274-.055-.493-.166-.657a.905.905 0 0 0-.49-.358c-.222-.076-.505-.114-.849-.114Zm6.476 2.266h2.16v3.063c-.337.11-.679.192-1.023.245a7.837 7.837 0 0 1-1.172.078c-.648 0-1.193-.128-1.637-.385a2.568 2.568 0 0 1-1.015-1.11c-.227-.485-.34-1.057-.34-1.716 0-.653.127-1.219.384-1.697a2.699 2.699 0 0 1 1.103-1.112c.484-.268 1.067-.402 1.75-.402.35 0 .68.032.988.096.315.064.607.155.875.271l-.297.683a4.551 4.551 0 0 0-.753-.254 3.453 3.453 0 0 0-.857-.105c-.496 0-.922.102-1.278.306a2.004 2.004 0 0 0-.813.875c-.187.374-.28.82-.28 1.34 0 .495.078.935.236 1.32.163.38.417.677.761.893.344.21.796.315 1.356.315.187 0 .35-.006.49-.018a5.17 5.17 0 0 0 .394-.06c.123-.024.236-.047.341-.07V14.55H15.93v-.7Z", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var TriggerL = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.7, d: "M14 20.212a7.612 7.612 0 1 0 0-15.224 7.612 7.612 0 0 0 0 15.224Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M10.209 15.662V9.415h.787v5.548h2.73v.7H10.21Zm6.395 0h-.787v-5.556h-1.952v-.691h4.682v.691h-1.943v5.556Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M21.235 17.5a8.31 8.31 0 0 1-7.205 4.165A8.31 8.31 0 0 1 6.825 17.5c.823 3.4 3.737 5.915 7.205 5.915 3.469 0 6.382-2.514 7.205-5.915Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var TriggerR = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", strokeWidth: 0.7, d: "M14 20.212a7.612 7.612 0 1 0 0-15.224 7.612 7.612 0 0 0 0 15.224Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M11.42 9.415c.52 0 .945.067 1.277.201.339.129.59.324.753.587.163.262.245.592.245.988 0 .333-.061.61-.184.832-.122.221-.28.4-.472.533-.187.129-.385.23-.595.307l1.715 2.8h-.92l-1.513-2.582h-1.242v2.582h-.788V9.415h1.724Zm-.044.683h-.892v2.318h.936c.338 0 .615-.043.831-.131a.956.956 0 0 0 .473-.402c.105-.175.157-.394.157-.657 0-.274-.055-.493-.166-.656a.905.905 0 0 0-.49-.359c-.222-.075-.505-.114-.849-.114Zm5.74 5.564h-.787v-5.556h-1.951v-.691h4.681v.691h-1.942v5.556Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M21.235 17.5a8.31 8.31 0 0 1-7.205 4.165A8.31 8.31 0 0 1 6.825 17.5c.823 3.4 3.737 5.915 7.205 5.915 3.469 0 6.382-2.514 7.205-5.915Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbrestL = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", d: "m20.01 15.768-4.242 4.242a5.5 5.5 0 1 1-7.778-7.778l4.242-4.242a5.5 5.5 0 1 1 7.778 7.778Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M11.172 16.828a1 1 0 0 0 1.414 0L15.414 14l.707.707-2.828 2.828a2 2 0 1 1-2.829-2.828l.708.707a1 1 0 0 0 0 1.414ZM12.586 14l2.828-2.829a1 1 0 1 1 1.414 1.415l.708.707a2 2 0 0 0-2.829-2.829l-2.828 2.829.707.707Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M15.414 16.828 18.243 14a3 3 0 0 0-2.289-5.117l-.869-.869a4 4 0 0 1 3.864 6.693l-2.828 2.828-.707-.707Zm-.707 2.122a4 4 0 1 1-5.657-5.657l4.243-4.243.707.707L9.757 14A3 3 0 1 0 14 18.242l.707.708Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var ThumbrestR = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: IconSize, height: IconSize, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("path", { stroke: "#fff", d: "m15.768 7.99 4.242 4.242a5.5 5.5 0 1 1-7.778 7.778L7.99 15.768a5.5 5.5 0 1 1 7.778-7.778Z", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M16.828 16.828a1 1 0 0 0 0-1.414L14 12.586l.707-.707 2.828 2.828a2 2 0 1 1-2.828 2.828l.707-.707a1 1 0 0 0 1.414 0ZM14 15.414l-2.828-2.828a1 1 0 0 1 1.414-1.414l.707-.708a2 2 0 0 0-2.829 2.829l2.829 2.828.707-.707Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", fillRule: "evenodd", d: "M16.828 12.586 14 9.757a3 3 0 0 0-5.117 2.289l-.869.869a4 4 0 0 1 6.693-3.864l2.828 2.828-.707.707Zm2.122.707a4 4 0 1 1-5.657 5.657L9.05 14.707 9.757 14 14 18.243A3 3 0 1 0 18.243 14l.707-.707Z", clipRule: "evenodd", style: {
  fill: "#fff",
  fillOpacity: 1
} })] });
var PoseL = () => (0, import_jsx_runtime.jsx)(FAControlIcon, { icon: faHandScissors, "$reverse": true });
var PoseR = () => (0, import_jsx_runtime.jsx)(FAControlIcon, { icon: faHandScissors, "$reverse": false });
var PinchL = () => (0, import_jsx_runtime.jsx)(FAControlIcon, { icon: faHandLizard, "$reverse": true });
var PinchR = () => (0, import_jsx_runtime.jsx)(FAControlIcon, { icon: faHandLizard, "$reverse": false });
var buttonIdToIcon = {
  "x-button-left": ButtonX,
  "y-button-left": ButtonY,
  "a-button-right": ButtonA,
  "b-button-right": ButtonB,
  "thumbstick-left": ThumbstickL,
  "thumbstick-up-left": ThumbstickLUp,
  "thumbstick-down-left": ThumbstickLDown,
  "thumbstick-right-left": ThumbstickLRight,
  "thumbstick-left-left": ThumbstickLLeft,
  "pose-left": PoseL,
  "pinch-left": PinchL,
  "thumbstick-right": ThumbstickR,
  "thumbstick-up-right": ThumbstickRUp,
  "thumbstick-down-right": ThumbstickRDown,
  "thumbstick-right-right": ThumbstickRRight,
  "thumbstick-left-right": ThumbstickRLeft,
  "trigger-left": TriggerL,
  "trigger-right": TriggerR,
  "squeeze-left": GripL,
  "squeeze-right": GripR,
  "thumbrest-left": ThumbrestL,
  "thumbrest-right": ThumbrestR,
  "pose-right": PoseR,
  "pinch-right": PinchR
};
var GamepadIcon = ({ buttonName, handedness }) => {
  const buttonId = `${buttonName}-${handedness}`;
  const IconComponent = buttonIdToIcon[buttonId];
  return IconComponent ? (0, import_jsx_runtime.jsx)(IconComponent, {}) : (0, import_jsx_runtime.jsx)("div", { style: {
    width: ControlButtonStyles.height,
    height: ControlButtonStyles.height
  } });
};
var MouseLeft = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12, height: 16, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", d: "M.5 6.5H6m-5.5 0V5C.5 2.237 2.237.5 5 .5h1m-5.5 6V11c0 2.762 1.737 4.5 4.5 4.5h2c2.762 0 4.5-1.738 4.5-4.5V6.5M6 6.5v-6m0 6h5.5M6 .5h1c2.762 0 4.5 1.737 4.5 4.5v1.5", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }) }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M.5 6.5H6v-6H5C2.237.5.5 2.237.5 5v1.5Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h12v16H0z", style: {
  fill: "#fff",
  fillOpacity: 1
} }) }) })] });
var MouseRight = ({ scale: scale5 = 1.2 }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12, height: 16, fill: "none", transform: `scale(${scale5}, ${scale5})`, children: [(0, import_jsx_runtime.jsx)("g", { clipPath: "url(#a)", children: (0, import_jsx_runtime.jsx)("path", { stroke: "#fff", d: "M.5 6.5H6m-5.5 0V5C.5 2.237 2.237.5 5 .5h1m-5.5 6V11c0 2.762 1.737 4.5 4.5 4.5h2c2.762 0 4.5-1.738 4.5-4.5V6.5M6 6.5v-6m0 6h5.5M6 .5h1c2.762 0 4.5 1.737 4.5 4.5v1.5", style: {
  stroke: "#fff",
  strokeOpacity: 1
} }) }), (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M11.5 6.5H6v-6h1c2.762 0 4.5 1.737 4.5 4.5v1.5Z", style: {
  fill: "#fff",
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h12v16H0z", style: {
  fill: "#fff",
  fillOpacity: 1
} }) }) })] });
var BoxIcon = ({ size = 14, color = Colors.textWhite }) => (0, import_jsx_runtime.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 14 14", fill: "none", children: (0, import_jsx_runtime.jsx)("path", { stroke: color, strokeWidth: 1.5, d: "M7 13.037V5.512m-.324.289 6.3-2.275m-11.952 0 6.3 2.275m.23 6.937 4.233-1.528a1.627 1.627 0 0 0 1.076-1.53V4.396c0-.685-.43-1.297-1.076-1.53L7.553 1.339a1.63 1.63 0 0 0-1.106 0L2.213 2.867a1.627 1.627 0 0 0-1.075 1.53V9.68c0 .686.43 1.298 1.075 1.53l4.234 1.529a1.63 1.63 0 0 0 1.106 0Z", style: {
  stroke: color,
  strokeOpacity: 1
} }) });
var MeshIcon = ({ size = 14, color = Colors.textWhite }) => (0, import_jsx_runtime.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 14 14", fill: "none", children: (0, import_jsx_runtime.jsx)("path", { stroke: color, strokeWidth: 1.2, d: "M7 13.037V5.512M3.937 11.9V4.375m6.126 7.525V4.375M6.675 5.8l6.3-2.275m-9.275.962 6.3-2.275M1.024 3.526l6.3 2.275M6.85 9.388l6.3-2.275m-12.302 0 6.3 2.276m-3.15-7.176 6.3 2.276m-2.746 8.248 4.234-1.527a1.627 1.627 0 0 0 1.075-1.53V4.396c0-.685-.43-1.297-1.075-1.53L7.553 1.339a1.63 1.63 0 0 0-1.106 0L2.213 2.867a1.627 1.627 0 0 0-1.076 1.53V9.68c0 .686.43 1.298 1.076 1.53l4.234 1.529a1.63 1.63 0 0 0 1.106 0Z", style: {
  stroke: color,
  strokeOpacity: 1
} }) });
var PlaneIcon = ({ size = 14, color = Colors.textWhite }) => (0, import_jsx_runtime.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 14 14", fill: "none", children: (0, import_jsx_runtime.jsx)("path", { stroke: color, strokeWidth: 1.2, d: "M1.225 8.225h11.55M2.1 5.075h9.8m-7 7L5.6 2.1m3.5 9.975L8.4 2.1m-5.708 9.712h8.617a1.75 1.75 0 0 0 1.696-2.183l-1.567-6.125a1.75 1.75 0 0 0-1.695-1.317H4.258c-.8 0-1.498.542-1.696 1.317L.996 9.629a1.75 1.75 0 0 0 1.696 2.183Z", style: {
  stroke: color,
  strokeOpacity: 1
} }) });
var IWERIcon = ({ size = 14, color = Colors.textWhite }) => (0, import_jsx_runtime.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: size, height: size, viewBox: "0 0 14 14", fill: "none", children: [(0, import_jsx_runtime.jsx)("path", { fill: color, d: "M10.5 8.367a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8Z", style: {
  fill: color,
  fillOpacity: 1
} }), (0, import_jsx_runtime.jsx)("path", { fill: color, fillRule: "evenodd", d: "M0 5.8A2.8 2.8 0 0 1 2.8 3h8.4A2.8 2.8 0 0 1 14 5.8v2.8a2.8 2.8 0 0 1-2.8 2.8H9.526c-.619 0-1.184-.35-1.46-.903l-.108-.214a.933.933 0 0 0-.835-.516h-.246c-.354 0-.677.2-.835.516l-.107.214a1.633 1.633 0 0 1-1.461.903H2.8A2.8 2.8 0 0 1 0 8.6V5.8Zm4.9 1.167a1.4 1.4 0 1 1-2.8 0 1.4 1.4 0 0 1 2.8 0Zm8.367-.768a.268.268 0 0 0 .076-.292 2.942 2.942 0 0 0-.187-.407l-.055-.096a3.012 3.012 0 0 0-.262-.37.27.27 0 0 0-.29-.08l-.66.21a2.279 2.279 0 0 0-.522-.302l-.148-.676a.268.268 0 0 0-.215-.211 3.062 3.062 0 0 0-1.008.001.268.268 0 0 0-.215.21l-.148.677a2.28 2.28 0 0 0-.522.301l-.66-.21a.268.268 0 0 0-.29.081c-.096.116-.184.24-.262.37l-.056.096c-.072.13-.135.265-.187.406a.268.268 0 0 0 .076.292l.513.467a2.293 2.293 0 0 0 0 .603l-.513.467a.268.268 0 0 0-.076.291c.052.141.115.276.187.407l.056.096c.078.13.166.253.262.37a.27.27 0 0 0 .29.08l.66-.211c.158.122.333.224.52.3l.149.677a.268.268 0 0 0 .215.211 3.06 3.06 0 0 0 1.007 0 .268.268 0 0 0 .216-.21l.148-.677a2.28 2.28 0 0 0 .521-.301l.66.21c.105.033.22.004.29-.08.097-.117.184-.24.263-.37l.055-.097c.073-.13.135-.265.188-.406a.268.268 0 0 0-.076-.292l-.513-.466a2.299 2.299 0 0 0 0-.602l.513-.467Z", clipRule: "evenodd", style: {
  fill: color,
  fillOpacity: 1
} })] });

// node_modules/@iwer/devui/lib/components/keys.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var MappedKeyDisplay = {
  KeyA: "A",
  KeyB: "B",
  KeyC: "C",
  KeyD: "D",
  KeyE: "E",
  KeyF: "F",
  KeyG: "G",
  KeyH: "H",
  KeyI: "I",
  KeyJ: "J",
  KeyK: "K",
  KeyL: "L",
  KeyM: "M",
  KeyN: "N",
  KeyO: "O",
  KeyP: "P",
  KeyQ: "Q",
  KeyR: "R",
  KeyS: "S",
  KeyT: "T",
  KeyU: "U",
  KeyV: "V",
  KeyW: "W",
  KeyX: "X",
  KeyY: "Y",
  KeyZ: "Z",
  Digit0: "0",
  Digit1: "1",
  Digit2: "2",
  Digit3: "3",
  Digit4: "4",
  Digit5: "5",
  Digit6: "6",
  Digit7: "7",
  Digit8: "8",
  Digit9: "9",
  Tab: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faArrowRightToBracket }),
  Backspace: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faDeleteLeft }),
  Enter: (0, import_jsx_runtime2.jsx)(FAIcon, { style: {
    transform: "rotate(90deg)"
  }, icon: faArrowTurnDown }),
  ShiftLeft: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faAngleUp }),
  ShiftRight: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faAngleUp }),
  Space: " ",
  ArrowUp: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faCaretUp }),
  ArrowDown: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faCaretDown }),
  ArrowLeft: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faCaretLeft }),
  ArrowRight: (0, import_jsx_runtime2.jsx)(FAIcon, { icon: faCaretRight }),
  Semicolon: ";",
  Equal: "=",
  Comma: ",",
  Minus: "-",
  Period: ".",
  Slash: "/",
  Backquote: "`",
  BracketLeft: "[",
  Backslash: "\\",
  BracketRight: "]",
  Quote: "'",
  MouseLeft: (0, import_jsx_runtime2.jsx)(MouseLeft, {}),
  MouseRight: (0, import_jsx_runtime2.jsx)(MouseRight, {})
};

// node_modules/@iwer/devui/lib/components/mapper.js
var DEFAULT_KEYMAP = {
  left: {
    "thumbstick-up": "KeyW",
    "thumbstick-down": "KeyS",
    "thumbstick-left": "KeyA",
    "thumbstick-right": "KeyD",
    thumbstick: "KeyR",
    "x-button": "KeyX",
    "y-button": "KeyZ",
    trigger: "KeyQ",
    squeeze: "KeyE",
    pinch: "MouseLeft",
    pose: "KeyF"
  },
  right: {
    "thumbstick-up": "ArrowUp",
    "thumbstick-down": "ArrowDown",
    "thumbstick-left": "ArrowLeft",
    "thumbstick-right": "ArrowRight",
    thumbstick: "Slash",
    "a-button": "Enter",
    "b-button": "ShiftRight",
    trigger: "MouseLeft",
    squeeze: "MouseRight",
    pinch: "MouseRight",
    pose: "Backslash"
  }
};
var useKeyMapStore = create((set5) => ({
  keyMap: DEFAULT_KEYMAP,
  bindKey: (handedness, action, keyCode = "Unmapped") => set5((state) => ({
    keyMap: {
      ...state.keyMap,
      [handedness]: {
        ...state.keyMap[handedness],
        [action]: keyCode
      }
    }
  }))
}));
var Row = dt.div`
	display: flex;
	height: ${ControlButtonStyles.height};
	align-items: center;
	justify-content: space-between;
	margin-bottom: ${ControlButtonStyles.gap};

	&:last-child {
		margin-bottom: 0;
	}
`;
var ControlsMapper = ({ handedness, actions }) => {
  const { keyMap, bindKey } = useKeyMapStore();
  const [currentMapping, setCurrentMapping] = (0, import_react3.useState)(null);
  const startMapping = (action) => {
    setCurrentMapping({ action });
  };
  (0, import_react3.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (currentMapping && MappedKeyDisplay[event.code]) {
        bindKey(handedness, currentMapping.action, event.code);
        setCurrentMapping(null);
      }
    };
    const handleMouseDown = (event) => {
      if (currentMapping) {
        const mouseButton = event.button === 0 ? "MouseLeft" : event.button === 2 ? "MouseRight" : null;
        if (mouseButton && MappedKeyDisplay[mouseButton]) {
          bindKey(handedness, currentMapping.action, mouseButton);
          setCurrentMapping(null);
        }
      }
    };
    const preventDefaultContextMenu = (event) => {
      event.preventDefault();
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("mousedown", handleMouseDown);
    window.addEventListener("contextmenu", preventDefaultContextMenu);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("mousedown", handleMouseDown);
      window.removeEventListener("contextmenu", preventDefaultContextMenu);
    };
  }, [currentMapping]);
  return Object.keys(keyMap[handedness]).filter((action) => actions.includes(action)).map((action) => (0, import_jsx_runtime3.jsxs)(Row, { children: [(0, import_jsx_runtime3.jsx)(GamepadIcon, { buttonName: action === "up" ? "thumbstick" : action, handedness }), (0, import_jsx_runtime3.jsxs)(ButtonGroup, { "$reverse": false, children: [(0, import_jsx_runtime3.jsx)(Button, { "$reverse": false, style: {
    width: "100px",
    background: currentMapping && currentMapping.action === action ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent
  }, onClick: () => startMapping(action), onContextMenu: (e) => e.preventDefault(), children: keyMap[handedness][action] }), (0, import_jsx_runtime3.jsx)(Button, { style: { width: ControlButtonStyles.widthShort }, "$reverse": false, onClick: () => bindKey(handedness, action), onContextMenu: (e) => e.preventDefault(), children: (0, import_jsx_runtime3.jsx)(FontAwesomeIcon, { icon: faBan }) })] })] }, action));
};

// node_modules/@iwer/devui/lib/components/analog.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var AnalogButton = ({ xrController, buttonId, pointerLocked, mappedKey }) => {
  const [isTouched, setIsTouched] = (0, import_react4.useState)(false);
  const [isPressed, setIsPressed] = (0, import_react4.useState)(false);
  const [isKeyPressed, setIsKeyPressed] = (0, import_react4.useState)(false);
  const [analogValue, setAnalogValue] = (0, import_react4.useState)(0);
  const handedness = xrController.inputSource.handedness;
  (0, import_react4.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.code === mappedKey) {
        xrController.updateButtonValue(buttonId, 1);
        setIsKeyPressed(true);
      }
    };
    const handleKeyUp = (event) => {
      if (event.code === mappedKey) {
        xrController.updateButtonValue(buttonId, 0);
        setIsKeyPressed(false);
      }
    };
    const handleMouseDown = (event) => {
      if (mappedKey === "MouseLeft" && event.button === 0) {
        xrController.updateButtonValue(buttonId, 1);
        setIsKeyPressed(true);
      } else if (mappedKey === "MouseRight" && event.button === 2) {
        xrController.updateButtonValue(buttonId, 1);
        setIsKeyPressed(true);
      }
    };
    const handleMouseUp = (event) => {
      if (mappedKey === "MouseLeft" && event.button === 0) {
        xrController.updateButtonValue(buttonId, 0);
        setIsKeyPressed(false);
      } else if (mappedKey === "MouseRight" && event.button === 2) {
        xrController.updateButtonValue(buttonId, 0);
        setIsKeyPressed(false);
      }
    };
    if (pointerLocked) {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.addEventListener("mousedown", handleMouseDown);
        window.addEventListener("mouseup", handleMouseUp);
      } else {
        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);
      }
    } else {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.removeEventListener("mousedown", handleMouseDown);
        window.removeEventListener("mouseup", handleMouseUp);
      } else {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
      }
    }
    return () => {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.removeEventListener("mousedown", handleMouseDown);
        window.removeEventListener("mouseup", handleMouseUp);
      } else {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
      }
    };
  }, [mappedKey, pointerLocked, buttonId, xrController]);
  return (0, import_jsx_runtime4.jsxs)(ButtonContainer, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime4.jsx)(GamepadIcon, { buttonName: buttonId, handedness }), (0, import_jsx_runtime4.jsx)(ButtonGroup, { "$reverse": handedness === "right", children: pointerLocked ? (0, import_jsx_runtime4.jsx)(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] }) : (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [(0, import_jsx_runtime4.jsx)(Button, { "$reverse": handedness === "right", style: {
    background: isPressed ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthLong
  }, onClick: () => {
    setIsPressed(true);
    xrController.updateButtonValue(buttonId, 1);
    setTimeout(() => {
      setIsPressed(false);
      xrController.updateButtonValue(buttonId, 0);
    }, 250);
  }, children: "Press" }), (0, import_jsx_runtime4.jsx)(Button, { title: "Click to toggle touch state", "$reverse": handedness === "right", style: {
    background: isTouched ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthShort
  }, onClick: () => {
    setIsTouched(!isTouched);
    xrController.updateButtonTouch(buttonId, !isTouched);
  }, children: (0, import_jsx_runtime4.jsx)(FAIcon, { icon: faFingerprint }) }), (0, import_jsx_runtime4.jsx)(RangeSelector, { "$reverse": handedness === "right", value: analogValue, onChange: (e) => {
    const value = Number(e.target.value);
    setAnalogValue(value);
    xrController.updateButtonValue(buttonId, value / 100);
  }, min: "0", max: "100" })] }) })] });
};

// node_modules/@iwer/devui/lib/components/binary.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var BinaryButton = ({ xrController, buttonId, pointerLocked, mappedKey }) => {
  const [isTouched, setIsTouched] = (0, import_react5.useState)(false);
  const [isOnHold, setIsOnHold] = (0, import_react5.useState)(false);
  const [isPressed, setIsPressed] = (0, import_react5.useState)(false);
  const [isKeyPressed, setIsKeyPressed] = (0, import_react5.useState)(false);
  const handedness = xrController.inputSource.handedness;
  (0, import_react5.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.code === mappedKey) {
        xrController.updateButtonValue(buttonId, 1);
        setIsKeyPressed(true);
      }
    };
    const handleKeyUp = (event) => {
      if (event.code === mappedKey) {
        xrController.updateButtonValue(buttonId, 0);
        setIsKeyPressed(false);
      }
    };
    if (pointerLocked) {
      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);
    } else {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    }
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [mappedKey, pointerLocked, buttonId, xrController]);
  return (0, import_jsx_runtime5.jsxs)(ButtonContainer, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime5.jsx)(GamepadIcon, { buttonName: buttonId, handedness }), (0, import_jsx_runtime5.jsx)(ButtonGroup, { "$reverse": handedness === "right", children: pointerLocked ? (0, import_jsx_runtime5.jsx)(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] }) : (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [(0, import_jsx_runtime5.jsx)(Button, { "$reverse": handedness === "right", style: {
    background: isPressed ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthLong
  }, onClick: () => {
    setIsPressed(true);
    xrController.updateButtonValue(buttonId, 1);
    setTimeout(() => {
      setIsPressed(false);
      xrController.updateButtonValue(buttonId, 0);
    }, 250);
  }, children: "Press" }), (0, import_jsx_runtime5.jsx)(Button, { title: "Click to toggle touch state", "$reverse": handedness === "right", style: {
    background: isTouched ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthShort
  }, onClick: () => {
    setIsTouched(!isTouched);
    xrController.updateButtonTouch(buttonId, !isTouched);
  }, children: (0, import_jsx_runtime5.jsx)(FAIcon, { icon: faFingerprint }) }), (0, import_jsx_runtime5.jsx)(Button, { "$reverse": handedness === "right", style: {
    background: isOnHold ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthLong
  }, onClick: () => {
    setIsOnHold(!isOnHold);
    xrController.updateButtonValue(buttonId, isOnHold ? 0 : 1);
  }, children: "Hold" })] }) })] });
};

// node_modules/@iwer/devui/lib/components/joystick.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var JoystickContainer = dt.div`
	display: flex;
	align-items: center;
	margin-bottom: ${ControlButtonStyles.gap};
`;
var joystickSize = `calc(2 * ${ControlButtonStyles.height} + ${ControlButtonStyles.gap})`;
var JoystickButton2 = dt.button`
	background: ${Colors.gradientGreyTranslucent};
	border: none;
	display: flex;
	justify-content: center;
	align-items: center;
	padding: 0;
	pointer-events: none;
	width: ${joystickSize};
	height: ${joystickSize};
	border-radius: 50%;
	position: relative;
	margin: 0 5px;
`;
var JoystickInner2 = dt.div`
	position: absolute;
	font-size: 50px;
	display: flex;
	align-items: center;
	justify-content: center;
	color: ${Colors.textWhite};
	cursor: pointer;
	pointer-events: auto;
`;
var SmallButton = dt(Button)`
	width: ${ControlButtonStyles.widthLong};
	font-size: ${ControlButtonStyles.fontSize};

	${({ $reverse }) => $reverse ? `
    &:first-child {
      border-radius: ${ControlButtonStyles.radiusLast};
    }

    &:last-child {
      border-radius: ${ControlButtonStyles.radiusFirst};
    }
  ` : `
    &:first-child {
      border-radius: ${ControlButtonStyles.radiusFirst};
    }

    &:last-child {
      border-radius: ${ControlButtonStyles.radiusLast};
    }
  `}
`;
var Joystick = ({ xrController, pointerLocked, buttonId, mappedKeyUp, mappedKeyDown, mappedKeyLeft, mappedKeyRight, mappedKeyPressed }) => {
  const joystickRef = (0, import_react6.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react6.useState)(false);
  const [isTouched, setIsTouched] = (0, import_react6.useState)(false);
  const [isOnHold, setIsOnHold] = (0, import_react6.useState)(false);
  const [isPressed, setIsPressed] = (0, import_react6.useState)(false);
  const [initialPosition, setInitialPosition] = (0, import_react6.useState)({ x: 0, y: 0 });
  const [keyStates, setKeyStates] = (0, import_react6.useState)({
    up: false,
    down: false,
    left: false,
    right: false,
    pressed: false
  });
  const handedness = xrController.inputSource.handedness;
  const handleMouseDown = () => {
    if (joystickRef.current) {
      const rect = joystickRef.current.getBoundingClientRect();
      setInitialPosition({
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      });
      setIsDragging(true);
    }
  };
  const handleMouseMove = (event) => {
    if (isDragging && joystickRef.current) {
      const dx = event.clientX - initialPosition.x;
      const dy = event.clientY - initialPosition.y;
      const distance3 = Math.sqrt(dx * dx + dy * dy);
      const maxDistance = 12;
      let limitedX, limitedY;
      if (distance3 < maxDistance) {
        limitedX = dx;
        limitedY = dy;
      } else {
        const angle2 = Math.atan2(dy, dx);
        limitedX = Math.cos(angle2) * maxDistance;
        limitedY = Math.sin(angle2) * maxDistance;
      }
      joystickRef.current.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
      const normalizedX = limitedX / maxDistance;
      const normalizedY = limitedY / maxDistance;
      xrController.updateAxes(buttonId, normalizedX, normalizedY);
    }
  };
  const handleMouseUp = () => {
    setIsDragging(false);
    if (joystickRef.current) {
      joystickRef.current.style.transform = "translate(0, 0)";
      xrController.updateAxes(buttonId, 0, 0);
    }
  };
  (0, import_react6.useEffect)(() => {
    const handleKeyDown = (event) => {
      const newKeyStates = { ...keyStates };
      if (event.code === mappedKeyUp)
        newKeyStates.up = true;
      if (event.code === mappedKeyDown)
        newKeyStates.down = true;
      if (event.code === mappedKeyLeft)
        newKeyStates.left = true;
      if (event.code === mappedKeyRight)
        newKeyStates.right = true;
      if (event.code === mappedKeyPressed) {
        newKeyStates.pressed = true;
        xrController.updateButtonValue(buttonId, 1);
      }
      setKeyStates(newKeyStates);
      updateAxes(newKeyStates);
    };
    const handleKeyUp = (event) => {
      const newKeyStates = { ...keyStates };
      if (event.code === mappedKeyUp)
        newKeyStates.up = false;
      if (event.code === mappedKeyDown)
        newKeyStates.down = false;
      if (event.code === mappedKeyLeft)
        newKeyStates.left = false;
      if (event.code === mappedKeyRight)
        newKeyStates.right = false;
      if (event.code === mappedKeyPressed) {
        newKeyStates.pressed = false;
        xrController.updateButtonValue(buttonId, 0);
      }
      setKeyStates(newKeyStates);
      updateAxes(newKeyStates);
    };
    const updateAxes = (keyStates2) => {
      const deltaX = (keyStates2.right ? 1 : 0) - (keyStates2.left ? 1 : 0);
      const deltaY = (keyStates2.down ? 1 : 0) - (keyStates2.up ? 1 : 0);
      const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (magnitude === 0) {
        xrController.updateAxes(buttonId, 0, 0);
        return;
      }
      const normalizedX = deltaX / magnitude;
      const normalizedY = deltaY / magnitude;
      xrController.updateAxes(buttonId, normalizedX, normalizedY);
    };
    if (pointerLocked) {
      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);
    } else {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    }
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [
    mappedKeyUp,
    mappedKeyDown,
    mappedKeyLeft,
    mappedKeyRight,
    pointerLocked,
    keyStates
  ]);
  (0, import_react6.useEffect)(() => {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging, initialPosition]);
  return pointerLocked ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsxs)(ButtonContainer, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime6.jsx)(GamepadIcon, { buttonName: "thumbstick", handedness: xrController.inputSource.handedness }), (0, import_jsx_runtime6.jsxs)(ButtonGroup, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime6.jsx)(MappedKeyBlock, { "$pressed": keyStates.up, children: MappedKeyDisplay[mappedKeyUp] }), (0, import_jsx_runtime6.jsx)(MappedKeyBlock, { "$pressed": keyStates.pressed, children: MappedKeyDisplay[mappedKeyPressed] })] })] }), (0, import_jsx_runtime6.jsx)(ButtonContainer, { "$reverse": handedness === "right", style: handedness === "right" ? { marginRight: "2px" } : { marginLeft: "2px" }, children: (0, import_jsx_runtime6.jsxs)(ButtonGroup, { "$reverse": false, style: { margin: 0 }, children: [(0, import_jsx_runtime6.jsx)(MappedKeyBlock, { "$pressed": keyStates.left, children: MappedKeyDisplay[mappedKeyLeft] }), (0, import_jsx_runtime6.jsx)(MappedKeyBlock, { "$pressed": keyStates.down, children: MappedKeyDisplay[mappedKeyDown] }), (0, import_jsx_runtime6.jsx)(MappedKeyBlock, { "$pressed": keyStates.right, children: MappedKeyDisplay[mappedKeyRight] })] }) })] }) : (0, import_jsx_runtime6.jsx)(JoystickContainer, { style: {
    flexDirection: xrController.inputSource.handedness === "left" ? "row" : "row-reverse",
    alignItems: "flex-start"
  }, children: (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(GamepadIcon, { buttonName: "thumbstick", handedness: xrController.inputSource.handedness }), (0, import_jsx_runtime6.jsx)(JoystickButton2, { style: { margin: "0 5px" }, children: (0, import_jsx_runtime6.jsx)(JoystickInner2, { ref: joystickRef, onMouseDown: handleMouseDown, children: (0, import_jsx_runtime6.jsx)(FAIcon, { icon: faCircleXmark, "$size": 50 }) }) }), (0, import_jsx_runtime6.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "column",
    alignItems: handedness === "right" ? "start" : "end"
  }, children: [(0, import_jsx_runtime6.jsx)(Button, { "$reverse": handedness === "right", style: {
    background: isPressed ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: `calc(${ControlButtonStyles.widthLong} + ${ControlButtonStyles.widthShort} + ${ControlButtonStyles.gap})`,
    marginBottom: ControlButtonStyles.gap,
    borderRadius: ControlButtonStyles.radiusSolo
  }, onClick: () => {
    setIsPressed(true);
    xrController.updateButtonValue(buttonId, 1);
    setTimeout(() => {
      setIsPressed(false);
      xrController.updateButtonValue(buttonId, 0);
    }, 250);
  }, children: "Press" }), (0, import_jsx_runtime6.jsxs)(ButtonGroup, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime6.jsx)(SmallButton, { title: "Click to toggle touch state", "$reverse": xrController.inputSource.handedness !== "left", style: {
    background: isTouched ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthShort
  }, onClick: () => {
    setIsTouched(!isTouched);
    xrController.updateButtonTouch(buttonId, !isTouched);
  }, children: (0, import_jsx_runtime6.jsx)(FAIcon, { icon: faFingerprint }) }), (0, import_jsx_runtime6.jsx)(SmallButton, { "$reverse": xrController.inputSource.handedness !== "left", style: {
    background: isOnHold ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthLong
  }, onClick: () => {
    setIsOnHold(!isOnHold);
    xrController.updateButtonValue(buttonId, isOnHold ? 0 : 1);
  }, children: "Hold" })] })] })] }) });
};

// node_modules/@iwer/devui/lib/components/controller.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/@iwer/devui/lib/components/vec3.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
function round(number, decimalPlaces) {
  const factor = Math.pow(10, decimalPlaces);
  return Math.round(number * factor) / factor;
}
var Vector3Container = dt.div`
	width: 100%;
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	margin: 0;
	font-size: 12px;
`;
var Vector3Input = ({ vector, label = "", icon: icon2, multiplier = 1, precision = 2, onValidInput = () => {
}, marginBottom = "0" }) => {
  const [displayValues, setDisplayValues] = (0, import_react7.useState)({
    x: (vector.x / multiplier).toFixed(precision),
    y: (vector.y / multiplier).toFixed(precision),
    z: (vector.z / multiplier).toFixed(precision)
  });
  const actualValuesRef = (0, import_react7.useRef)({
    x: round(vector.x / multiplier, precision),
    y: round(vector.y / multiplier, precision),
    z: round(vector.z / multiplier, precision)
  });
  const animationFrameId = (0, import_react7.useRef)(null);
  const syncValues = () => {
    const currentActualValues = {
      x: round(vector.x / multiplier, precision),
      y: round(vector.y / multiplier, precision),
      z: round(vector.z / multiplier, precision)
    };
    const { x: x2, y: y3, z: z2 } = actualValuesRef.current;
    if (currentActualValues.x !== x2 || currentActualValues.y !== y3 || currentActualValues.z !== z2) {
      actualValuesRef.current = currentActualValues;
      setDisplayValues({
        x: currentActualValues.x.toFixed(precision),
        y: currentActualValues.y.toFixed(precision),
        z: currentActualValues.z.toFixed(precision)
      });
    }
    animationFrameId.current = requestAnimationFrame(syncValues);
  };
  (0, import_react7.useEffect)(() => {
    animationFrameId.current = requestAnimationFrame(syncValues);
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [vector, multiplier, precision]);
  const handleInputChange = (axis) => (event) => {
    const newValue = event.target.value;
    const parsedValue = parseFloat(newValue);
    setDisplayValues((prev2) => ({ ...prev2, [axis]: newValue }));
    if (!isNaN(parsedValue)) {
      actualValuesRef.current[axis] = parsedValue;
      vector[axis] = parsedValue * multiplier;
      onValidInput();
    }
  };
  return (0, import_jsx_runtime7.jsxs)(Vector3Container, { style: { marginBottom }, children: [icon2 ? (0, import_jsx_runtime7.jsx)(FAIcon, { icon: icon2, style: { marginRight: "5px" } }) : (0, import_jsx_runtime7.jsx)("span", { style: { marginRight: "5px" }, children: label }), (0, import_jsx_runtime7.jsx)(ValuesContainer, { children: ["x", "y", "z"].map((axis) => (0, import_jsx_runtime7.jsxs)("div", { style: {
    position: "relative",
    display: "inline-block",
    height: "25px"
  }, children: [(0, import_jsx_runtime7.jsx)(ValueInput, { value: displayValues[axis], onChange: handleInputChange(axis), className: parseFloat(displayValues[axis]) !== actualValuesRef.current[axis] ? "invalid" : void 0 }), (0, import_jsx_runtime7.jsx)(InputSuffix, { children: axis.toUpperCase() })] }, `${label}-${axis}`)) })] });
};

// node_modules/@iwer/devui/lib/components/controller.js
function transformGamepadConfig(gamepadConfig) {
  const axesSet = /* @__PURE__ */ new Set();
  for (const axis of gamepadConfig.axes) {
    if (axis && axis.id) {
      axesSet.add(axis.id);
    }
  }
  const transformed = gamepadConfig.buttons.filter((button) => button !== null).map((button) => ({
    id: button.id,
    type: button.type,
    hasAxes: axesSet.has(button.id)
  }));
  transformed.sort((a3, b) => {
    if (a3.hasAxes && !b.hasAxes)
      return -1;
    if (!a3.hasAxes && b.hasAxes)
      return 1;
    return 0;
  });
  return transformed;
}
var ControllerUI = ({ controller, handle, handedness, pointerLocked }) => {
  const { keyMap } = useKeyMapStore();
  const [connected, setConnected] = import_react8.default.useState(controller.connected);
  const [settingsOpen, setSettingsOpen] = import_react8.default.useState(false);
  const transformedConfig = transformGamepadConfig(controller.gamepadConfig);
  const actions = transformedConfig.flatMap((config3) => {
    if (config3.hasAxes) {
      return [
        `${config3.id}-left`,
        `${config3.id}-right`,
        `${config3.id}-up`,
        `${config3.id}-down`,
        config3.id
      ];
    } else {
      return config3.id;
    }
  });
  import_react8.default.useEffect(() => {
    if (pointerLocked) {
      setSettingsOpen(false);
    }
  }, [pointerLocked]);
  return (0, import_jsx_runtime8.jsxs)(ControlPanel, { style: handedness === "left" ? { left: "8px", bottom: "8px" } : { right: "8px", bottom: "8px" }, children: [!pointerLocked && (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: (0, import_jsx_runtime8.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime8.jsxs)("div", { style: {
    fontSize: "13px",
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime8.jsx)(FAIcon, { icon: faGamepad, style: { marginRight: "5px" } }), "Controller", (0, import_jsx_runtime8.jsxs)("span", { style: { fontWeight: "bold" }, children: ["[", handedness === "left" ? "L" : "R", "]"] })] }), (0, import_jsx_runtime8.jsx)("div", { style: {
    display: "flex",
    flexDirection: "row",
    gap: "1px"
  }, children: connected ? (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsx)(PanelHeaderButton, { title: `Click to ${settingsOpen ? "close" : "change"} key bindings`, onClick: () => {
    setSettingsOpen(!settingsOpen);
  }, children: (0, import_jsx_runtime8.jsx)(FAIcon, { icon: faGear }) }), (0, import_jsx_runtime8.jsx)(PanelHeaderButton, { title: `Click to disconnect ${handedness} controller`, "$isRed": true, onClick: () => {
    controller.connected = false;
    setConnected(false);
  }, children: (0, import_jsx_runtime8.jsx)(FAIcon, { icon: faCircleXmark }) })] }) : (0, import_jsx_runtime8.jsx)(PanelHeaderButton, { title: `Click to reconnect ${handedness} controller`, onClick: () => {
    controller.connected = true;
    setConnected(true);
  }, style: { marginLeft: "5px" }, children: (0, import_jsx_runtime8.jsx)(FAIcon, { icon: faPlug }) }) })] }) }), connected && !pointerLocked && (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [!settingsOpen && (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsx)(SectionBreak, {}), (0, import_jsx_runtime8.jsx)(Vector3Input, { vector: handle.position, label: "Position", marginBottom: ControlButtonStyles.gap }), (0, import_jsx_runtime8.jsx)(Vector3Input, { vector: handle.rotation, label: "Rotation" })] }), (0, import_jsx_runtime8.jsx)(SectionBreak, {})] }), connected && (settingsOpen ? (0, import_jsx_runtime8.jsx)(ControlsMapper, { handedness, actions }) : transformedConfig.map((buttonConfig) => {
    const mapping = keyMap[handedness];
    if (buttonConfig.hasAxes) {
      return (0, import_jsx_runtime8.jsx)(Joystick, { xrController: controller, pointerLocked, buttonId: buttonConfig.id, mappedKeyUp: keyMap[handedness][`${buttonConfig.id}-up`], mappedKeyDown: mapping[`${buttonConfig.id}-down`], mappedKeyLeft: mapping[`${buttonConfig.id}-left`], mappedKeyRight: mapping[`${buttonConfig.id}-right`], mappedKeyPressed: mapping[buttonConfig.id] }, buttonConfig.id);
    } else if (buttonConfig.type === "analog") {
      return (0, import_jsx_runtime8.jsx)(AnalogButton, { xrController: controller, buttonId: buttonConfig.id, mappedKey: mapping[buttonConfig.id], pointerLocked }, buttonConfig.id);
    } else {
      return (0, import_jsx_runtime8.jsx)(BinaryButton, { xrController: controller, buttonId: buttonConfig.id, mappedKey: mapping[buttonConfig.id], pointerLocked }, buttonConfig.id);
    }
  }))] }, handedness);
};

// node_modules/@iwer/devui/lib/components/hand.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@iwer/devui/lib/components/pinch.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var pinchSliderWidth = `calc(${ControlButtonStyles.widthLong} + ${ControlButtonStyles.widthShort} + ${ControlButtonStyles.gap})`;
var PinchControl = ({ hand, pointerLocked, mappedKey }) => {
  const [isPressed, setIsPressed] = (0, import_react9.useState)(false);
  const [isKeyPressed, setIsKeyPressed] = (0, import_react9.useState)(false);
  const [analogValue, setAnalogValue] = (0, import_react9.useState)(0);
  const handedness = hand.inputSource.handedness;
  (0, import_react9.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.code === mappedKey) {
        hand.updatePinchValue(1);
        setIsKeyPressed(true);
      }
    };
    const handleKeyUp = (event) => {
      if (event.code === mappedKey) {
        hand.updatePinchValue(0);
        setIsKeyPressed(false);
      }
    };
    const handleMouseDown = (event) => {
      if (mappedKey === "MouseLeft" && event.button === 0 || mappedKey === "MouseRight" && event.button === 2) {
        hand.updatePinchValue(1);
        setIsKeyPressed(true);
      }
    };
    const handleMouseUp = (event) => {
      if (mappedKey === "MouseLeft" && event.button === 0 || mappedKey === "MouseRight" && event.button === 2) {
        hand.updatePinchValue(0);
        setIsKeyPressed(false);
      }
    };
    if (pointerLocked) {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.addEventListener("mousedown", handleMouseDown);
        window.addEventListener("mouseup", handleMouseUp);
      } else {
        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);
      }
    } else {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.removeEventListener("mousedown", handleMouseDown);
        window.removeEventListener("mouseup", handleMouseUp);
      } else {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
      }
    }
    return () => {
      if (mappedKey === "MouseLeft" || mappedKey === "MouseRight") {
        window.removeEventListener("mousedown", handleMouseDown);
        window.removeEventListener("mouseup", handleMouseUp);
      } else {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
      }
    };
  }, [mappedKey, pointerLocked, hand]);
  return (0, import_jsx_runtime9.jsxs)(ButtonContainer, { "$reverse": handedness === "right", children: [(0, import_jsx_runtime9.jsx)(FAControlIcon, { icon: faHandLizard, "$reverse": handedness === "left" }), (0, import_jsx_runtime9.jsx)(ButtonGroup, { "$reverse": handedness === "right", children: pointerLocked ? (0, import_jsx_runtime9.jsx)(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] }) : (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsx)(Button, { "$reverse": handedness === "right", style: {
    background: isPressed ? Colors.gradientLightGreyTranslucent : Colors.gradientGreyTranslucent,
    width: ControlButtonStyles.widthLong
  }, onClick: () => {
    setIsPressed(true);
    hand.updatePinchValue(1);
    setTimeout(() => {
      setIsPressed(false);
      hand.updatePinchValue(0);
    }, 250);
  }, children: "Pinch" }), (0, import_jsx_runtime9.jsx)(RangeSelector, { "$reverse": handedness === "right", value: analogValue, onChange: (e) => {
    const value = Number(e.target.value);
    setAnalogValue(value);
    hand.updatePinchValue(value / 100);
  }, style: { width: pinchSliderWidth }, min: "0", max: "100" })] }) })] });
};

// node_modules/@iwer/devui/lib/components/pose.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var poses = ["default", "point"];
var poseButtonWidth = `calc(2 * ${ControlButtonStyles.widthLong} - ${ControlButtonStyles.widthShort})`;
var PoseSelector = ({ hand, pointerLocked, mappedKey }) => {
  const [poseId, setPoseId] = (0, import_react10.useState)(hand.poseId);
  const [isKeyPressed, setIsKeyPressed] = (0, import_react10.useState)(false);
  const handedness = hand.inputSource.handedness;
  const cyclePose = (delta) => {
    const poseIdx = poses.indexOf(hand.poseId);
    const newPoseIdx = (poseIdx + poses.length + delta) % poses.length;
    setPoseId(poses[newPoseIdx]);
    hand.poseId = poses[newPoseIdx];
  };
  const layoutReverse = handedness === "right";
  (0, import_react10.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.code === mappedKey) {
        cyclePose(1);
        setIsKeyPressed(true);
      }
    };
    const handleKeyUp = (event) => {
      if (event.code === mappedKey) {
        setIsKeyPressed(false);
      }
    };
    if (pointerLocked) {
      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);
    } else {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    }
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [mappedKey, pointerLocked, hand]);
  return (0, import_jsx_runtime10.jsxs)(ButtonContainer, { "$reverse": layoutReverse, children: [(0, import_jsx_runtime10.jsx)(FAControlIcon, { icon: faHandScissors, "$reverse": handedness === "left" }), (0, import_jsx_runtime10.jsx)(ButtonGroup, { "$reverse": layoutReverse, children: pointerLocked ? (0, import_jsx_runtime10.jsx)(MappedKeyBlock, { "$pressed": isKeyPressed, children: MappedKeyDisplay[mappedKey] }) : (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [(0, import_jsx_runtime10.jsx)(Button, { "$reverse": layoutReverse, style: {
    width: ControlButtonStyles.widthShort
  }, onClick: () => {
    cyclePose(layoutReverse ? 1 : -1);
  }, children: (0, import_jsx_runtime10.jsx)(FAIcon, { icon: layoutReverse ? faChevronRight : faChevronLeft }) }), (0, import_jsx_runtime10.jsxs)(Button, { "$reverse": layoutReverse, style: {
    width: poseButtonWidth
  }, disabled: true, children: ["Pose: ", poseId] }), (0, import_jsx_runtime10.jsx)(Button, { "$reverse": layoutReverse, style: {
    width: ControlButtonStyles.widthShort
  }, onClick: () => {
    cyclePose(layoutReverse ? -1 : 1);
  }, children: (0, import_jsx_runtime10.jsx)(FAIcon, { icon: layoutReverse ? faChevronLeft : faChevronRight }) })] }) })] });
};

// node_modules/@iwer/devui/lib/components/hand.js
var import_react11 = __toESM(require_react(), 1);
var HandUI = ({ hand, handle, handedness, pointerLocked }) => {
  const { keyMap } = useKeyMapStore();
  const [connected, setConnected] = import_react11.default.useState(hand.connected);
  const [settingsOpen, setSettingsOpen] = import_react11.default.useState(false);
  import_react11.default.useEffect(() => {
    if (pointerLocked) {
      setSettingsOpen(false);
    }
  }, [pointerLocked]);
  return (0, import_jsx_runtime11.jsxs)(ControlPanel, { style: handedness === "left" ? { left: "8px", bottom: "8px" } : { right: "8px", bottom: "8px" }, children: [!pointerLocked && (0, import_jsx_runtime11.jsx)(import_jsx_runtime11.Fragment, { children: (0, import_jsx_runtime11.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime11.jsxs)("div", { style: {
    fontSize: "13px",
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  }, children: [(0, import_jsx_runtime11.jsx)(FAIcon, { icon: faHand, "$reverse": handedness === "left", style: { marginRight: "5px" } }), "Hand", (0, import_jsx_runtime11.jsxs)("span", { style: { fontWeight: "bold" }, children: ["[", handedness === "left" ? "L" : "R", "]"] })] }), (0, import_jsx_runtime11.jsx)("div", { style: {
    display: "flex",
    flexDirection: "row",
    gap: "1px"
  }, children: connected ? (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [(0, import_jsx_runtime11.jsx)(PanelHeaderButton, { title: `Click to ${settingsOpen ? "close" : "change"} key bindings`, onClick: () => {
    setSettingsOpen(!settingsOpen);
  }, children: (0, import_jsx_runtime11.jsx)(FAIcon, { icon: faGear }) }), (0, import_jsx_runtime11.jsx)(PanelHeaderButton, { title: `Click to disconnect ${handedness} controller`, "$isRed": true, onClick: () => {
    hand.connected = false;
    setConnected(false);
  }, children: (0, import_jsx_runtime11.jsx)(FAIcon, { icon: faCircleXmark }) })] }) : (0, import_jsx_runtime11.jsx)(PanelHeaderButton, { title: `Click to reconnect ${handedness} controller`, onClick: () => {
    hand.connected = true;
    setConnected(true);
  }, style: { marginLeft: "5px" }, children: (0, import_jsx_runtime11.jsx)(FAIcon, { icon: faPlug }) }) })] }) }), connected && !pointerLocked && (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [!settingsOpen && (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [(0, import_jsx_runtime11.jsx)(SectionBreak, {}), (0, import_jsx_runtime11.jsx)(Vector3Input, { vector: handle.position, label: "Position", marginBottom: ControlButtonStyles.gap }), (0, import_jsx_runtime11.jsx)(Vector3Input, { vector: handle.rotation, label: "Rotation" })] }), (0, import_jsx_runtime11.jsx)(SectionBreak, {})] }), connected && (settingsOpen ? (0, import_jsx_runtime11.jsx)(ControlsMapper, { handedness, actions: ["pose", "pinch"] }) : (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [(0, import_jsx_runtime11.jsx)(PoseSelector, { hand, pointerLocked, mappedKey: keyMap[handedness].pose }), (0, import_jsx_runtime11.jsx)(PinchControl, { hand, pointerLocked, mappedKey: keyMap[handedness].pinch })] }))] }, handedness);
};

// node_modules/@iwer/devui/lib/components/controls.js
var useInputModeStore = create((set5) => ({
  inputMode: "controller",
  setInputMode: (mode) => set5(() => ({
    inputMode: mode
  }))
}));
var ControlsUI = ({ xrDevice, inputLayer, pointerLocked }) => {
  const { inputMode } = useInputModeStore();
  return (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children: inputMode === "controller" ? Object.entries(xrDevice.controllers).map(([handedness, controller]) => (0, import_jsx_runtime12.jsx)(ControllerUI, { controller, handle: inputLayer.transformHandles.get(handedness), handedness, pointerLocked }, `controller-${handedness}`)) : Object.entries(xrDevice.hands).map(([handedness, hand]) => (0, import_jsx_runtime12.jsx)(HandUI, { hand, handle: inputLayer.transformHandles.get(handedness), handedness, pointerLocked }, `hand-${handedness}`)) });
};

// node_modules/@iwer/devui/lib/index.js
var import_react14 = __toESM(require_react());

// node_modules/@iwer/devui/lib/components/header.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var VersionTableCol1 = dt.td`
	text-align: right;
	color: ${Colors.textWhite};
	padding: 0 8px 0 0;
	font-weight: bold;
`;
var VersionTableCol2 = dt.td`
	text-align: left;
	color: ${Colors.textGrey};
	padding: 0;
`;
var envNames = [
  "meeting_room",
  "living_room",
  "music_room",
  "office_large",
  "office_small"
];
var useHeaderStateStore = create((set5) => ({
  infoPanelOpen: false,
  envDropDownOpen: false,
  setInfoPanelOpen: (open) => set5(() => ({ infoPanelOpen: open })),
  setEnvDropDownOpen: (open) => set5(() => ({ envDropDownOpen: open }))
}));
function underscoreToTitleCase(str5) {
  return str5.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
}
var HeaderUI = ({ xrDevice, inputLayer }) => {
  var _a2, _b, _c;
  const [planesVisible, setPlanesVisible] = import_react12.default.useState(Boolean((_a2 = xrDevice.sem) === null || _a2 === void 0 ? void 0 : _a2.planesVisible));
  const [boxesVisible, setBoxesVisible] = import_react12.default.useState(Boolean((_b = xrDevice.sem) === null || _b === void 0 ? void 0 : _b.boundingBoxesVisible));
  const [meshesVisible, setMeshesVisible] = import_react12.default.useState(Boolean((_c = xrDevice.sem) === null || _c === void 0 ? void 0 : _c.meshesVisible));
  const { inputMode, setInputMode } = useInputModeStore();
  const { infoPanelOpen, setInfoPanelOpen, envDropDownOpen, setEnvDropDownOpen } = useHeaderStateStore();
  return (0, import_jsx_runtime13.jsxs)("div", { style: {
    display: "flex",
    justifyContent: "center",
    flexDirection: "row",
    alignItems: "center",
    gap: "6px",
    padding: "8px"
  }, children: [(0, import_jsx_runtime13.jsx)(HeaderButtonsContainer, { children: (0, import_jsx_runtime13.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "row",
    gap: "1px"
  }, children: [(0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to reset device transforms", onClick: () => {
    inputLayer.resetDeviceTransforms();
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faRotateLeft, "$size": 16 }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to activate play mode", onClick: () => {
    inputLayer.lockPointer();
    setEnvDropDownOpen(false);
    setInfoPanelOpen(false);
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faCirclePlay, "$size": 16 }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to toggle input mode", onClick: () => {
    if (inputMode === "controller") {
      setInputMode("hand");
      xrDevice.primaryInputMode = "hand";
    } else {
      setInputMode("controller");
      xrDevice.primaryInputMode = "controller";
    }
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: inputMode === "controller" ? faGamepad : faHand, "$size": 16 }) }), xrDevice.sem && (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [(0, import_jsx_runtime13.jsx)(SectionBreak, { "$horizontal": false }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to select/change emulated environment", onClick: () => setEnvDropDownOpen(!envDropDownOpen), children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faPersonShelter, "$size": 16 }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to toggle visibility of planes", onClick: () => {
    xrDevice.sem.planesVisible = !planesVisible;
    setPlanesVisible(!planesVisible);
  }, children: (0, import_jsx_runtime13.jsx)(PlaneIcon, { size: 16, color: planesVisible ? Colors.textWhite : Colors.textGrey }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to toggle visibility of bounding boxes", onClick: () => {
    xrDevice.sem.boundingBoxesVisible = !boxesVisible;
    setBoxesVisible(!boxesVisible);
  }, children: (0, import_jsx_runtime13.jsx)(BoxIcon, { size: 16, color: boxesVisible ? Colors.textWhite : Colors.textGrey }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to toggle visibility of meshes", onClick: () => {
    xrDevice.sem.meshesVisible = !meshesVisible;
    setMeshesVisible(!meshesVisible);
  }, children: (0, import_jsx_runtime13.jsx)(MeshIcon, { size: 16, color: meshesVisible ? Colors.textWhite : Colors.textGrey }) })] }), (0, import_jsx_runtime13.jsx)(SectionBreak, { "$horizontal": false }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Click to exit XR session", onClick: () => {
    const xrSession = xrDevice.activeSession;
    xrSession === null || xrSession === void 0 ? void 0 : xrSession.end();
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faRightFromBracket, "$size": 16 }) })] }) }), (0, import_jsx_runtime13.jsx)(HeaderButtonsContainer, { children: (0, import_jsx_runtime13.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "row",
    gap: "1px"
  }, children: [(0, import_jsx_runtime13.jsx)(HeaderButton, { title: "About IWER", onClick: () => {
    setInfoPanelOpen(!infoPanelOpen);
  }, children: (0, import_jsx_runtime13.jsx)(IWERIcon, { size: 16 }) }), (0, import_jsx_runtime13.jsx)(HeaderButton, { title: "Report issues", onClick: () => {
    window.open("https://github.com/meta-quest/immersive-web-emulation-runtime/issues", "_blank");
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faBug, "$size": 16 }) })] }) }), infoPanelOpen && (0, import_jsx_runtime13.jsxs)(ControlPanel, { style: {
    top: "50vh",
    left: "50vw",
    transform: "translate(-50%, -50%)",
    maxWidth: "240px",
    gap: "4px"
  }, children: [(0, import_jsx_runtime13.jsx)("div", { style: { display: "flex", justifyContent: "end" }, children: (0, import_jsx_runtime13.jsx)(PanelHeaderButton, { "$isRed": true, onClick: () => {
    setInfoPanelOpen(false);
  }, children: (0, import_jsx_runtime13.jsx)(FAIcon, { icon: faCircleXmark }) }) }), (0, import_jsx_runtime13.jsx)("div", { style: { display: "flex", justifyContent: "center" }, children: (0, import_jsx_runtime13.jsx)(IWERIcon, { size: 100 }) }), (0, import_jsx_runtime13.jsxs)("p", { style: { textAlign: "center", padding: "0 5px", margin: "0" }, children: [(0, import_jsx_runtime13.jsx)("b", { children: "Immersive Web Emulation Runtime" }), " (IWER) is a free, open-source WebXR developer tool created by Meta Platforms, Inc."] }), (0, import_jsx_runtime13.jsx)("table", { style: {
    width: "100%",
    borderCollapse: "collapse",
    display: "flex",
    justifyContent: "center",
    fontSize: "12px",
    padding: "8px"
  }, children: (0, import_jsx_runtime13.jsxs)("tbody", { children: [(0, import_jsx_runtime13.jsxs)("tr", { children: [(0, import_jsx_runtime13.jsx)(VersionTableCol1, { children: "IWER" }), (0, import_jsx_runtime13.jsxs)(VersionTableCol2, { children: ["v", xrDevice.version] })] }), (0, import_jsx_runtime13.jsxs)("tr", { children: [(0, import_jsx_runtime13.jsx)(VersionTableCol1, { children: "DevUI" }), (0, import_jsx_runtime13.jsxs)(VersionTableCol2, { children: ["v", xrDevice.devui.version] })] }), xrDevice.sem && (0, import_jsx_runtime13.jsxs)("tr", { children: [(0, import_jsx_runtime13.jsx)(VersionTableCol1, { children: "SEM" }), (0, import_jsx_runtime13.jsxs)(VersionTableCol2, { children: ["v", xrDevice.sem.version] })] })] }) }), (0, import_jsx_runtime13.jsx)(Button, { style: {
    borderRadius: ControlButtonStyles.radiusSolo
  }, onClick: () => {
    window.open("https://github.com/meta-quest/immersive-web-emulation-runtime/blob/main/LICENSE", "_blank");
  }, children: "MIT License" }), (0, import_jsx_runtime13.jsx)(Button, { style: {
    borderRadius: ControlButtonStyles.radiusSolo
  }, onClick: () => {
    window.open("https://github.com/meta-quest/immersive-web-emulation-runtime", "_blank");
  }, children: "View Source on GitHub" })] }), envDropDownOpen && (0, import_jsx_runtime13.jsx)(ControlPanel, { style: {
    position: "absolute",
    top: "40px"
  }, children: envNames.map((name) => (0, import_jsx_runtime13.jsx)("div", { children: (0, import_jsx_runtime13.jsx)(HeaderButton, { style: {
    fontSize: "12px",
    width: "100%",
    justifyContent: "start",
    borderRadius: "8px"
  }, onClick: () => {
    xrDevice.sem.loadDefaultEnvironment(name);
  }, children: underscoreToTitleCase(name) }) }, name)) })] });
};

// node_modules/@iwer/devui/lib/components/headset.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var HeadsetOptionContainer = dt.div`
	width: 100%;
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	margin-top: ${ControlButtonStyles.gap};
	font-size: 12px;
`;
var RangeSelector2 = dt.input.attrs({ type: "range" })`
	-webkit-appearance: none;
	appearance: none;
	background: ${Colors.gradientGrey};
	border: 1px solid transparent;
	height: 25px;
	color: ${Colors.textWhite};
	width: ${ControlButtonStyles.widthLong};
	cursor: pointer;
	margin: 0;
	border-radius: 5px;
	padding: 0 10px 0 5px;
	box-sizing: border-box;
	font-size: 10px;

	&::-webkit-slider-thumb {
		-webkit-appearance: none;
		appearance: none;
		width: 8px;
		height: 25px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}

	&::-moz-range-thumb {
		width: 8px;
		height: 25px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}

	&::-ms-thumb {
		width: 8px;
		height: 25px;
		background-color: ${Colors.textWhite};
		border-radius: ${ControlButtonStyles.radiusMiddle};
	}
`;
var HeadsetUI = ({ xrDevice, inputLayer, pointerLocked }) => {
  const [fovy, setFovy] = import_react13.default.useState(xrDevice.fovy);
  return (0, import_jsx_runtime14.jsxs)(ControlPanel, { style: { left: "8px", top: "8px" }, children: [(0, import_jsx_runtime14.jsxs)("div", { style: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    height: "20px"
  }, children: [(0, import_jsx_runtime14.jsxs)("div", { style: {
    fontSize: "13px",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyItems: "start"
  }, children: [(0, import_jsx_runtime14.jsx)(FAIcon, { icon: faVrCardboard, style: { marginRight: "5px" } }), (0, import_jsx_runtime14.jsx)("div", { style: { alignItems: "end" }, children: xrDevice.name })] }), (0, import_jsx_runtime14.jsx)("div", { style: {
    display: "flex",
    flexDirection: "row",
    gap: "1px"
  } })] }), (0, import_jsx_runtime14.jsx)(SectionBreak, {}), (0, import_jsx_runtime14.jsx)(Vector3Input, { vector: inputLayer.combinedCameraPosition, icon: faStreetView }), !pointerLocked && (0, import_jsx_runtime14.jsxs)(HeadsetOptionContainer, { children: [(0, import_jsx_runtime14.jsx)(FAIcon, { icon: faVideo, style: { marginRight: "5px" } }), (0, import_jsx_runtime14.jsxs)(ValuesContainer, { children: [(0, import_jsx_runtime14.jsxs)("div", { style: {
    position: "relative",
    display: "inline-block",
    height: "25px"
  }, children: [(0, import_jsx_runtime14.jsx)(ValueInput, { type: "text", value: (fovy / Math.PI * 180).toFixed(0) + "", readOnly: true, style: { width: "73px" } }), (0, import_jsx_runtime14.jsx)(InputSuffix, { children: "FOV-Y" })] }), (0, import_jsx_runtime14.jsx)("div", { style: {
    position: "relative",
    display: "inline-block"
  }, children: (0, import_jsx_runtime14.jsx)(RangeSelector2, { value: fovy, onChange: (e) => {
    const value = Number(e.target.value);
    setFovy(value);
    xrDevice.fovy = value;
  }, min: Math.PI / 6, max: Math.PI / 1.5, step: Math.PI / 48, style: { width: "80px" } }) })] })] })] });
};

// node_modules/@iwer/devui/lib/scene.js
import { FrontSide, Group as Group9, Mesh as Mesh13, MeshBasicMaterial as MeshBasicMaterial13, PerspectiveCamera as PerspectiveCamera3, Quaternion as Quaternion14, RingGeometry, Scene, Vector3 as Vector320, WebGLRenderer } from "three";

// node_modules/@pmndrs/handle/dist/store.js
import { Euler as Euler3, Object3D, Quaternion as Quaternion5, Vector3 as Vector35 } from "three";

// node_modules/@pmndrs/handle/dist/computations/one-pointer.js
import { Matrix4 as Matrix42, Quaternion as Quaternion2, Vector3 as Vector32 } from "three";

// node_modules/@pmndrs/handle/dist/computations/utils.js
import { Euler, Matrix4, Plane, Quaternion, Vector3 } from "three";
import { clamp } from "three/src/math/MathUtils.js";
var matrixHelper1 = new Matrix4();
var matrixHelper2 = new Matrix4();
var axisFirstOrder = {
  x: "XYZ",
  y: "YXZ",
  z: "ZXY"
};
function computeHandleTransformState(time, pointerAmount, targetWorldMatrix, storeData, targetParentWorldMatrix, options) {
  matrixHelper1.copy(targetWorldMatrix);
  if (targetParentWorldMatrix != null) {
    matrixHelper1.premultiply(matrixHelper2.copy(targetParentWorldMatrix).invert());
  }
  const position2 = new Vector3();
  const quaternion = new Quaternion();
  const scale5 = new Vector3();
  matrixHelper1.decompose(position2, quaternion, scale5);
  applyTransformOptionsToVector(position2, storeData.initialTargetPosition, options.translate ?? true);
  let rotation;
  const rotateOptions = options.rotate ?? true;
  if (rotateOptions === false) {
    quaternion.copy(storeData.initialTargetQuaternion);
    rotation = storeData.initialTargetRotation.clone();
  } else if (Array.isArray(rotateOptions) || rotateOptions === true || typeof rotateOptions != "string" && !Array.isArray(rotateOptions) && rotateOptions.x === true && rotateOptions.y === true && rotateOptions.z === true) {
    rotation = new Euler().setFromQuaternion(quaternion, storeData.initialTargetRotation.order);
  } else if (typeof rotateOptions === "string") {
    const order = axisFirstOrder[rotateOptions];
    rotation = new Euler().setFromQuaternion(quaternion, order);
    for (const orderElement of order) {
      const axis = orderElement.toLowerCase();
      if (axis === rotateOptions) {
        continue;
      }
      rotation[axis] = 0;
    }
    rotation.order = storeData.initialTargetRotation.order;
    quaternion.setFromEuler(rotation);
  } else {
    rotation = applyTransformOptionsToRotation(quaternion, storeData.initialTargetRotation, rotateOptions);
  }
  if (typeof options.scale != "object" || !options.scale.uniform) {
    applyTransformOptionsToVector(scale5, storeData.initialTargetScale, options.scale ?? true);
  }
  return {
    pointerAmount,
    position: position2,
    quaternion,
    rotation,
    scale: scale5,
    time
  };
}
var pHelper = new Plane();
var v1Helper = new Vector3();
var v2Helper = new Vector3();
var v3Helper = new Vector3();
var qHelper = new Quaternion();
function getDeltaQuaternionOnAxis(normalizedAxis, from2, to) {
  pHelper.normal.copy(normalizedAxis);
  pHelper.constant = 0;
  getPerpendicular(v1Helper, pHelper.normal);
  v2Helper.copy(v1Helper);
  v2Helper.applyQuaternion(qHelper.copy(from2).invert().premultiply(to));
  pHelper.projectPoint(v1Helper, v1Helper).normalize();
  pHelper.projectPoint(v2Helper, v2Helper).normalize();
  return (v3Helper.crossVectors(v1Helper, pHelper.normal).dot(v2Helper) < 0 ? 1 : -1) * v1Helper.angleTo(v2Helper);
}
function getPerpendicular(target, from2) {
  if (from2.x === 0) {
    target.set(1, 0, 0);
    return;
  }
  if (from2.y === 0) {
    target.set(0, 1, 0);
    return;
  }
  if (from2.z === 0) {
    target.set(0, 0, 1);
    return;
  }
  target.set(-from2.y, from2.x, 0);
}
function applyTransformOptionsToRotation(currentRotation, initialRotation, options) {
  let orderEnabledAxis = "";
  let orderDisabledAxis = "";
  for (const orderElement of initialRotation.order) {
    if (options[orderElement.toLowerCase()] === false) {
      orderDisabledAxis += orderElement;
    } else {
      orderEnabledAxis += orderElement;
    }
  }
  const order = orderEnabledAxis + orderDisabledAxis;
  const result = new Euler().setFromQuaternion(currentRotation, order);
  for (const orderElement of order) {
    const axis = orderElement.toLowerCase();
    result[axis] = applyTransformOptionsToAxis(axis, result[axis], initialRotation[axis], options);
  }
  currentRotation.setFromEuler(result);
  return result;
}
var applyTransformNormal = new Vector3();
var applyTransformPlane = new Plane();
var applyTransformCross1 = new Vector3();
var applyTransformCross2 = new Vector3();
function applyTransformOptionsToVector(target, initialVector, options) {
  if (Array.isArray(options)) {
    switch (options.length) {
      case 0:
        target.copy(initialVector);
        return;
      case 1:
        target.sub(initialVector);
        projectPointOntoNormal(target, options[0] instanceof Vector3 ? options[0] : applyTransformNormal.fromArray(options[0]));
        target.add(initialVector);
        return;
      case 2:
        applyTransformNormal.crossVectors(options[0] instanceof Vector3 ? options[0] : applyTransformCross1.fromArray(options[0]), options[1] instanceof Vector3 ? options[1] : applyTransformCross2.fromArray(options[1]));
        applyTransformPlane.setFromNormalAndCoplanarPoint(applyTransformNormal, initialVector);
        applyTransformPlane.projectPoint(target, target);
        return;
    }
    return;
  }
  target.x = applyTransformOptionsToAxis("x", target.x, initialVector.x, options);
  target.y = applyTransformOptionsToAxis("y", target.y, initialVector.y, options);
  target.z = applyTransformOptionsToAxis("z", target.z, initialVector.z, options);
}
function applyTransformOptionsToAxis(axis, value, neutralValue, options) {
  if (typeof options === "boolean") {
    return options ? value : neutralValue;
  }
  if (typeof options === "string") {
    return options === axis ? value : neutralValue;
  }
  const option = options[axis];
  if (option === false) {
    return neutralValue;
  }
  if (Array.isArray(option)) {
    return clamp(value, ...option);
  }
  return value;
}
function projectOntoSpace(projectRays = true, space3, initialWorldPoint, worldPointerOrigin, worldPoint, worldDirection) {
  if (!projectRays) {
    return;
  }
  switch (space3.length) {
    case 0:
    case 3:
      return;
    case 1:
      projectOntoAxis(initialWorldPoint, ...space3, worldPointerOrigin, worldPoint, worldDirection);
      return;
    case 2:
      projectOntoPlane(...space3, initialWorldPoint, worldPointerOrigin, worldPoint, worldDirection);
      return;
  }
  throw new Error(`space cannot be ${space3.length}D but received (${space3.map((s2) => s2.toArray().join("/")).join("; ")})`);
}
var axisVectorMap = {
  x: new Vector3(1, 0, 0),
  y: new Vector3(0, 1, 0),
  z: new Vector3(0, 0, 1)
};
function addSpaceFromTransformOptions(target, parentWorldQuaternion, initialLocalRotation, options, type) {
  if (options === false) {
    return;
  }
  if (options === true) {
    target[0] = axisVectorMap.x;
    target[1] = axisVectorMap.y;
    target[2] = axisVectorMap.z;
    return;
  }
  if (typeof options === "string") {
    addSpaceFromAxis(target, parentWorldQuaternion, initialLocalRotation, options, type);
    return;
  }
  if (Array.isArray(options)) {
    for (const axis of options) {
      addSpaceFromAxis(target, parentWorldQuaternion, initialLocalRotation, axis, type);
    }
    return;
  }
  if (options.x !== false) {
    addSpaceFromAxis(target, parentWorldQuaternion, initialLocalRotation, "x", type);
  }
  if (options.y !== false) {
    addSpaceFromAxis(target, parentWorldQuaternion, initialLocalRotation, "y", type);
  }
  if (options.z !== false) {
    addSpaceFromAxis(target, parentWorldQuaternion, initialLocalRotation, "z", type);
  }
}
var rHelper = new Quaternion();
var eHelper = new Euler();
var axisHelper = new Vector3();
var otherVectorHelper = new Vector3();
var resultVectorHelper = new Vector3();
function addSpaceFromAxis(target, targetParentWorldQuaternion, initialTargetRotation, axis, type) {
  if (Array.isArray(axis)) {
    axisHelper.set(...axis);
  } else if (axis instanceof Vector3) {
    axisHelper.copy(axis);
  } else {
    axisHelper.copy(axisVectorMap[axis]);
  }
  if (type === "translate") {
    axisHelper.applyQuaternion(targetParentWorldQuaternion);
    addAxisToSpace(target, axisHelper);
    return;
  }
  if (type === "scale") {
    if (Array.isArray(axis)) {
      rHelper.identity();
    } else {
      rHelper.setFromEuler(initialTargetRotation);
    }
    rHelper.premultiply(targetParentWorldQuaternion);
    axisHelper.applyQuaternion(rHelper);
    addAxisToSpace(target, axisHelper);
    return;
  }
  if (Array.isArray(axis)) {
    eHelper.set(0, 0, 0);
  } else {
    eHelper.copy(initialTargetRotation);
    for (let i2 = 2; i2 >= 0; i2--) {
      const rotationAxis = initialTargetRotation.order[i2].toLowerCase();
      eHelper[rotationAxis] = 0;
      if (rotationAxis === axis) {
        break;
      }
    }
  }
  rHelper.setFromEuler(eHelper).premultiply(targetParentWorldQuaternion);
  axisHelper.normalize();
  otherVectorHelper.set(0, 1, 0);
  if (axisHelper.dot(otherVectorHelper) > 0.99) {
    otherVectorHelper.set(0, 0, 1);
  }
  resultVectorHelper.crossVectors(axisHelper, otherVectorHelper).normalize();
  otherVectorHelper.copy(resultVectorHelper);
  resultVectorHelper.applyQuaternion(rHelper);
  addAxisToSpace(target, resultVectorHelper);
  resultVectorHelper.crossVectors(axisHelper, otherVectorHelper).normalize();
  resultVectorHelper.applyQuaternion(rHelper);
  addAxisToSpace(target, resultVectorHelper);
}
var crossHelper = new Vector3();
function addAxisToSpace(target, axis) {
  if (target.length === 3) {
    return;
  }
  if (target.length === 0) {
    target.push(axis.clone());
    return;
  }
  if (target.length === 1) {
    if (Math.abs(target[0].dot(axis)) < 0.999) {
      target.push(axis.clone());
    }
    return;
  }
  crossHelper.crossVectors(target[0], target[1]);
  if (Math.abs(crossHelper.dot(axis)) < 1e-3) {
    return;
  }
  target.push(axis.clone());
}
var planeHelper = new Plane();
var normalHelper = new Vector3();
var vectorHelper = new Vector3();
function projectOntoPlane(_axis1, _axis2, initialWorldPoint, worldPointerOrigin, worldPoint, worldDirection) {
  normalHelper.crossVectors(_axis1, _axis2).normalize();
  planeHelper.setFromNormalAndCoplanarPoint(normalHelper, initialWorldPoint);
  const angleDifference = worldDirection == null ? 0 : Math.abs(normalHelper.dot(worldDirection));
  if (worldDirection == null || angleDifference < 0.01) {
    planeHelper.projectPoint(worldPoint, worldPoint);
    return;
  }
  const distanceToPlane = planeHelper.distanceToPoint(worldPointerOrigin);
  const distanceAlongDirection = -distanceToPlane / worldDirection.dot(planeHelper.normal);
  if (distanceAlongDirection < 0) {
    planeHelper.projectPoint(worldPoint, worldPoint);
    return;
  }
  vectorHelper.copy(worldPoint);
  worldPoint.copy(worldPointerOrigin).addScaledVector(worldDirection, distanceAlongDirection);
}
function projectOntoAxis(initialWorldPoint, axis, worldPointerOrigin, worldPoint, worldDirection) {
  const angleDifference = worldDirection == null ? 0 : 1 - Math.abs(axis.dot(worldDirection));
  if (worldDirection == null || angleDifference < 1e-3) {
    projectPointOntoAxis(worldPoint, initialWorldPoint, axis);
    return;
  }
  vectorHelper.subVectors(worldPointerOrigin, initialWorldPoint);
  const d1d2 = axis.dot(worldDirection);
  const d1p1p2 = axis.dot(vectorHelper);
  const d2p1p2 = worldDirection.dot(vectorHelper);
  const denominator = 1 - d1d2 * d1d2;
  const t2 = (d1p1p2 - d1d2 * d2p1p2) / denominator;
  const s2 = (d1d2 * d1p1p2 - d2p1p2) / denominator;
  if (s2 < 0) {
    projectPointOntoAxis(worldPoint, initialWorldPoint, axis);
    return;
  }
  vectorHelper.copy(worldPoint);
  worldPoint.copy(initialWorldPoint).addScaledVector(axis, t2);
}
function projectPointOntoAxis(target, axisOrigin, axisNormal) {
  target.sub(axisOrigin);
  projectPointOntoNormal(target, axisNormal);
  target.add(axisOrigin);
}
function projectPointOntoNormal(point, normal) {
  const dot4 = point.dot(normal);
  point.copy(normal).multiplyScalar(dot4);
}

// node_modules/@pmndrs/handle/dist/computations/one-pointer.js
var matrixHelper12 = new Matrix42();
var matrixHelper22 = new Matrix42();
var vectorHelper1 = new Vector32();
var vectorHelper2 = new Vector32();
var quaternionHelper = new Quaternion2();
var OneVector = new Vector32(1, 1, 1);
var spaceHelper = [];
function computeOnePointerHandleTransformState(time, pointerData, storeData, targetParentWorldMatrix, options) {
  if (targetParentWorldMatrix == null) {
    quaternionHelper.identity();
  } else {
    targetParentWorldMatrix.decompose(vectorHelper1, quaternionHelper, vectorHelper2);
  }
  spaceHelper.length = 0;
  addSpaceFromTransformOptions(spaceHelper, quaternionHelper, storeData.initialTargetRotation, options.translate ?? true, "translate");
  matrixHelper22.makeRotationFromQuaternion(quaternionHelper.copy(pointerData.initialPointerWorldQuaternion).invert()).multiply(matrixHelper12.makeTranslation(vectorHelper1.copy(pointerData.initialPointerWorldPoint).negate()));
  if (storeData.initialTargetParentWorldMatrix != null) {
    matrixHelper22.multiply(storeData.initialTargetParentWorldMatrix);
  }
  projectOntoSpace(options.projectRays, spaceHelper, pointerData.initialPointerWorldPoint, pointerData.pointerWorldOrigin, vectorHelper1.copy(pointerData.pointerWorldPoint), pointerData.pointerWorldDirection);
  quaternionHelper.copy(pointerData.pointerWorldQuaternion);
  if ((options.rotate ?? true) === false) {
    quaternionHelper.copy(pointerData.initialPointerWorldQuaternion);
  }
  matrixHelper12.compose(vectorHelper1, quaternionHelper, OneVector).multiply(matrixHelper22).multiply(matrixHelper22.compose(storeData.initialTargetPosition, storeData.initialTargetQuaternion, storeData.initialTargetScale));
  return computeHandleTransformState(time, 1, matrixHelper12, storeData, targetParentWorldMatrix, options);
}

// node_modules/@pmndrs/handle/dist/computations/two-pointer.js
import { Matrix4 as Matrix43, Quaternion as Quaternion3, Vector3 as Vector33 } from "three";
var deltaHelper1 = new Vector33();
var deltaHelper2 = new Vector33();
var vectorHelper12 = new Vector33();
var vectorHelper22 = new Vector33();
var vectorHelper3 = new Vector33();
var vectorHelper4 = new Vector33();
var scaleHelper = new Vector33();
var matrixHelper13 = new Matrix43();
var matrixHelper23 = new Matrix43();
var matrixHelper3 = new Matrix43();
var qHelper1 = new Quaternion3();
var quaterionHelper2 = new Quaternion3();
var space = [];
function computeTwoPointerHandleTransformState(time, pointer1Data, pointer2Data, storeData, targetParentWorldMatrix, options) {
  if (targetParentWorldMatrix == null) {
    qHelper1.identity();
  } else {
    targetParentWorldMatrix.decompose(vectorHelper12, qHelper1, vectorHelper22);
  }
  space.length = 0;
  addSpaceFromTransformOptions(space, qHelper1, storeData.initialTargetRotation, options.translate ?? true, "translate");
  addSpaceFromTransformOptions(space, qHelper1, storeData.initialTargetRotation, options.rotate ?? true, "rotate");
  addSpaceFromTransformOptions(space, qHelper1, storeData.initialTargetRotation, options.scale ?? true, "scale");
  projectOntoSpace(options.projectRays, space, pointer1Data.initialPointerWorldPoint, pointer1Data.pointerWorldOrigin, vectorHelper12.copy(pointer1Data.pointerWorldPoint), pointer1Data.pointerWorldDirection);
  projectOntoSpace(options.projectRays, space, pointer2Data.initialPointerWorldPoint, pointer2Data.pointerWorldOrigin, vectorHelper22.copy(pointer2Data.pointerWorldPoint), pointer2Data.pointerWorldDirection);
  deltaHelper1.copy(pointer2Data.initialPointerWorldPoint).sub(pointer1Data.initialPointerWorldPoint);
  deltaHelper2.copy(vectorHelper22).sub(vectorHelper12);
  vectorHelper12.copy(deltaHelper1);
  if (storeData.prevTwoPointerDeltaRotation != null) {
    vectorHelper12.applyQuaternion(storeData.prevTwoPointerDeltaRotation);
  }
  vectorHelper12.normalize();
  vectorHelper22.copy(deltaHelper2).normalize();
  qHelper1.setFromUnitVectors(vectorHelper12, vectorHelper22);
  if (storeData.prevTwoPointerDeltaRotation == null) {
    storeData.prevTwoPointerDeltaRotation = new Quaternion3();
  } else {
    qHelper1.multiply(storeData.prevTwoPointerDeltaRotation);
  }
  storeData.prevTwoPointerDeltaRotation.copy(qHelper1);
  const angle2 = (getDeltaQuaternionOnAxis(vectorHelper22, pointer1Data.prevPointerWorldQuaternion, pointer1Data.pointerWorldQuaternion) + getDeltaQuaternionOnAxis(vectorHelper22, pointer2Data.prevPointerWorldQuaternion, pointer2Data.pointerWorldQuaternion)) * 0.5 + (storeData.prevAngle ?? 0);
  storeData.prevAngle = angle2;
  qHelper1.premultiply(quaterionHelper2.setFromAxisAngle(vectorHelper22, angle2));
  matrixHelper3.compose(storeData.initialTargetPosition, storeData.initialTargetQuaternion, storeData.initialTargetScale);
  if (storeData.initialTargetParentWorldMatrix != null) {
    matrixHelper3.premultiply(storeData.initialTargetParentWorldMatrix);
  }
  if (typeof options.scale === "object" && (options.scale.uniform ?? false)) {
    scaleHelper.setScalar(deltaHelper2.length() / deltaHelper1.length());
  } else {
    matrixHelper3.decompose(vectorHelper3, quaterionHelper2, vectorHelper4);
    vectorHelper12.copy(deltaHelper1).applyQuaternion(quaterionHelper2.invert()).divide(vectorHelper4);
    vectorHelper12.x = Math.abs(vectorHelper12.x);
    vectorHelper12.y = Math.abs(vectorHelper12.y);
    vectorHelper12.z = Math.abs(vectorHelper12.z);
    const maxCompInitialDelta = Math.max(...vectorHelper12.toArray());
    vectorHelper12.divideScalar(maxCompInitialDelta);
    scaleHelper.set(1, 1, 1);
    scaleHelper.addScaledVector(vectorHelper12, deltaHelper2.length() / deltaHelper1.length() - 1);
  }
  matrixHelper13.makeTranslation(vectorHelper12.copy(deltaHelper2).multiplyScalar(0.5).add(pointer1Data.pointerWorldPoint)).multiply(matrixHelper23.makeRotationFromQuaternion(qHelper1)).multiply(matrixHelper23.makeRotationFromQuaternion(quaterionHelper2.invert())).multiply(matrixHelper23.makeScale(scaleHelper.x, scaleHelper.y, scaleHelper.z)).multiply(matrixHelper23.makeRotationFromQuaternion(quaterionHelper2.invert())).multiply(matrixHelper23.makeTranslation(vectorHelper12.copy(deltaHelper1).multiplyScalar(0.5).add(pointer1Data.initialPointerWorldPoint).negate())).multiply(matrixHelper3);
  return computeHandleTransformState(time, 2, matrixHelper13, storeData, targetParentWorldMatrix, options);
}

// node_modules/@pmndrs/handle/dist/computations/translate-as.js
import { Matrix4 as Matrix44, Quaternion as Quaternion4, Vector3 as Vector34 } from "three";
var vectorHelper13 = new Vector34();
var vectorHelper23 = new Vector34();
var vectorHelper32 = new Vector34();
var deltaHelper12 = new Vector34();
var deltaHelper22 = new Vector34();
var qHelper12 = new Quaternion4();
var qHelper2 = new Quaternion4();
var matrixHelper = new Matrix44();
var scaleHelper2 = new Vector34();
var space2 = [];
function computeTranslateAsHandleTransformState(time, pointerData, storeData, targetWorldMatrix, targetParentWorldMatrix, options) {
  if (targetParentWorldMatrix == null) {
    qHelper12.identity();
  } else {
    targetParentWorldMatrix.decompose(vectorHelper13, qHelper12, vectorHelper23);
  }
  space2.length = 0;
  if (options.translate === "as-scale") {
    addSpaceFromTransformOptions(space2, qHelper12, storeData.initialTargetRotation, options.scale ?? true, "scale");
  }
  if (options.translate != "as-scale") {
    addSpaceFromTransformOptions(space2, qHelper12, storeData.initialTargetRotation, options.rotate ?? true, "rotate");
  }
  matrixHelper.makeTranslation(storeData.initialTargetPosition);
  if (storeData.initialTargetParentWorldMatrix != null) {
    matrixHelper.premultiply(storeData.initialTargetParentWorldMatrix);
  }
  deltaHelper12.setFromMatrixPosition(matrixHelper);
  projectOntoSpace(options.projectRays, space2, pointerData.initialPointerWorldPoint, pointerData.pointerWorldOrigin, deltaHelper12, void 0);
  deltaHelper12.negate().add(pointerData.initialPointerWorldPoint);
  deltaHelper22.setFromMatrixPosition(targetWorldMatrix);
  projectOntoSpace(options.projectRays, space2, pointerData.initialPointerWorldPoint, pointerData.pointerWorldOrigin, deltaHelper22, void 0);
  projectOntoSpace(options.projectRays, space2, pointerData.initialPointerWorldPoint, pointerData.pointerWorldOrigin, vectorHelper23.copy(pointerData.pointerWorldPoint), pointerData.pointerWorldDirection);
  deltaHelper22.negate().add(vectorHelper23);
  if (options.translate === "as-scale") {
    qHelper12.copy(storeData.initialTargetQuaternion);
  } else {
    vectorHelper13.copy(deltaHelper12);
    if (storeData.prevTranslateAsDeltaRotation != null) {
      vectorHelper13.applyQuaternion(storeData.prevTranslateAsDeltaRotation);
    }
    vectorHelper13.normalize();
    vectorHelper23.copy(deltaHelper22).normalize();
    qHelper12.setFromUnitVectors(vectorHelper13, vectorHelper23);
    if (storeData.prevTranslateAsDeltaRotation == null) {
      storeData.prevTranslateAsDeltaRotation = new Quaternion4();
    } else {
      qHelper12.multiply(storeData.prevTranslateAsDeltaRotation);
    }
    storeData.prevTranslateAsDeltaRotation.copy(qHelper12);
    if (storeData.initialTargetParentWorldMatrix != null) {
      qHelper2.setFromRotationMatrix(storeData.initialTargetParentWorldMatrix);
      qHelper12.multiply(qHelper2.normalize());
      qHelper12.premultiply(qHelper2.invert());
    }
    qHelper12.multiply(storeData.initialTargetQuaternion);
  }
  if (options.translate === "as-rotate") {
    scaleHelper2.set(1, 1, 1);
  } else if (typeof options.scale === "object" && (options.scale.uniform ?? false)) {
    scaleHelper2.setScalar(deltaHelper22.length() / deltaHelper12.length());
  } else if (options.translate === "as-rotate-and-scale") {
    matrixHelper.compose(storeData.initialTargetPosition, storeData.initialTargetQuaternion, storeData.initialTargetScale);
    if (storeData.initialTargetParentWorldMatrix != null) {
      matrixHelper.premultiply(storeData.initialTargetParentWorldMatrix);
    }
    matrixHelper.decompose(vectorHelper23, qHelper2, vectorHelper32);
    vectorHelper13.copy(deltaHelper12).applyQuaternion(qHelper2.invert()).divide(vectorHelper32);
    vectorHelper13.x = Math.abs(vectorHelper13.x);
    vectorHelper13.y = Math.abs(vectorHelper13.y);
    vectorHelper13.z = Math.abs(vectorHelper13.z);
    const maxCompInitialDelta = Math.max(...vectorHelper13.toArray());
    vectorHelper13.divideScalar(maxCompInitialDelta);
    scaleHelper2.set(1, 1, 1);
    scaleHelper2.addScaledVector(vectorHelper13, deltaHelper22.length() / deltaHelper12.length() - 1);
  } else {
    if (storeData.initialTargetParentWorldMatrix != null) {
      storeData.initialTargetParentWorldMatrix.decompose(vectorHelper13, qHelper2, vectorHelper23);
      qHelper2.multiply(storeData.initialTargetQuaternion);
    } else {
      qHelper2.copy(storeData.initialTargetQuaternion);
    }
    vectorHelper13.copy(deltaHelper12).applyQuaternion(qHelper2.invert());
    if (targetParentWorldMatrix != null) {
      targetParentWorldMatrix.decompose(vectorHelper23, qHelper2, vectorHelper32);
      qHelper2.multiply(storeData.initialTargetQuaternion);
    } else {
      qHelper2.copy(storeData.initialTargetQuaternion);
    }
    vectorHelper23.copy(deltaHelper22).applyQuaternion(qHelper2.invert());
    scaleHelper2.x = Math.abs(vectorHelper13.x) < 1e-3 ? 1 : Math.abs(vectorHelper23.x / vectorHelper13.x);
    scaleHelper2.y = Math.abs(vectorHelper13.y) < 1e-3 ? 1 : Math.abs(vectorHelper23.y / vectorHelper13.y);
    scaleHelper2.z = Math.abs(vectorHelper13.z) < 1e-3 ? 1 : Math.abs(vectorHelper23.z / vectorHelper13.z);
  }
  scaleHelper2.multiply(storeData.initialTargetScale);
  matrixHelper.compose(storeData.initialTargetPosition, qHelper12, scaleHelper2);
  return computeHandleTransformState(time, 1, matrixHelper, storeData, void 0, options);
}

// node_modules/@pmndrs/handle/dist/state.js
import { Euler as Euler2 } from "three";
var SubtractedHandleTransformStateImpl = class {
  t1;
  t2;
  _position;
  _quaternion;
  _rotation;
  _scale;
  constructor(t1, t2) {
    this.t1 = t1;
    this.t2 = t2;
  }
  get time() {
    return this.t1.time - this.t2.time;
  }
  get position() {
    return this._position ??= this.t1.position.clone().sub(this.t2.position);
  }
  get quaternion() {
    return this._quaternion ??= this.t2.quaternion.clone().invert().premultiply(this.t1.quaternion);
  }
  get rotation() {
    return this._rotation ??= new Euler2().setFromQuaternion(this.quaternion);
  }
  get scale() {
    return this._scale ??= this.t1.scale.clone().sub(this.t2.scale);
  }
};
var HandleStateImpl = class {
  cancel;
  previous;
  memo;
  event;
  //will be set by start before the first read
  initial;
  current;
  first;
  last;
  //cache
  _delta;
  _offset;
  constructor(cancel) {
    this.cancel = cancel;
  }
  start(event, current) {
    this.event = event;
    this.previous = void 0;
    this.current = current;
    this.initial = current;
    this.first = true;
    this.last = false;
    this.memo = void 0;
    this._delta = void 0;
    this._offset = void 0;
  }
  update(event, current) {
    this.event = event;
    this.previous = this.current;
    this.current = current;
    this.first = false;
    this.last = false;
    this._delta = void 0;
    this._offset = void 0;
  }
  end(event) {
    this.event = event;
    this.first = false;
    this.last = true;
    this._delta = void 0;
    this._offset = void 0;
  }
  get delta() {
    if (this.previous == null) {
      return void 0;
    }
    return this._delta ??= new SubtractedHandleTransformStateImpl(this.current, this.previous);
  }
  get offset() {
    return this._offset ??= new SubtractedHandleTransformStateImpl(this.current, this.initial);
  }
};

// node_modules/@pmndrs/handle/dist/utils.js
function getWorldDirection(event, target) {
  if (event.details.type === "sphere") {
    return false;
  }
  if (event.details.type === "lines") {
    const { line: line2 } = event.details;
    target.copy(line2.end).sub(line2.start).normalize();
    return true;
  }
  if (event.details.type === "screen-ray") {
    target.copy(event.details.direction);
    return true;
  }
  target.set(0, 0, -1).applyQuaternion(event.pointerQuaternion);
  return true;
}

// node_modules/@pmndrs/handle/dist/store.js
var vectorHelper5 = new Vector35();
var HandleStore = class {
  target;
  getOptions;
  //internal out state (will be used to output the state)
  outputState;
  latestMoveEvent;
  //internal in state (will be written on save)
  inputState = /* @__PURE__ */ new Map();
  capturedObjects = /* @__PURE__ */ new Map();
  initialTargetPosition = new Vector35();
  initialTargetQuaternion = new Quaternion5();
  initialTargetRotation = new Euler3();
  initialTargetScale = new Vector35();
  initialTargetParentWorldMatrix;
  //prev state
  prevTwoPointerDeltaRotation;
  prevTranslateAsDeltaRotation;
  prevAngle;
  handlers = {
    onPointerDown: this.onPointerDown.bind(this),
    onPointerMove: this.onPointerMove.bind(this),
    onPointerUp: this.onPointerUp.bind(this)
  };
  constructor(target, getOptions = () => ({})) {
    this.target = target;
    this.getOptions = getOptions;
    this.outputState = new HandleStateImpl(this.cancel.bind(this));
  }
  /**
   * @requires that the pointerId is in this.capturedSet
   */
  firstOnPointer(event) {
    const target = this.getTarget();
    if (target == null) {
      return;
    }
    const pointerWorldDirection = getWorldDirection(event, vectorHelper5) ? vectorHelper5.clone() : void 0;
    event.intersection.details.type;
    this.inputState.set(event.pointerId, {
      pointerWorldDirection,
      pointerWorldPoint: event.point,
      pointerWorldOrigin: event.pointerPosition,
      pointerWorldQuaternion: event.pointerQuaternion,
      initialPointerWorldPoint: event.point.clone(),
      initialPointerWorldDirection: pointerWorldDirection?.clone(),
      initialPointerWorldQuaternion: event.pointerQuaternion.clone(),
      prevPointerWorldQuaternion: event.pointerQuaternion
    });
    this.save();
    if (this.inputState.size === 1) {
      this.outputState.start(event, {
        pointerAmount: 1,
        time: event.timeStamp,
        position: this.initialTargetPosition.clone(),
        quaternion: this.initialTargetQuaternion.clone(),
        rotation: this.initialTargetRotation.clone(),
        scale: this.initialTargetScale.clone()
      });
    }
    this.outputState.memo = this.apply(target);
  }
  onPointerDown(event) {
    this.stopPropagation(event);
    if (!this.capturePointer(event.pointerId, event.object)) {
      return;
    }
    this.firstOnPointer(event);
  }
  onPointerMove(event) {
    if (!this.capturedObjects.has(event.pointerId)) {
      return;
    }
    this.stopPropagation(event);
    const entry = this.inputState.get(event.pointerId);
    if (entry == null) {
      this.firstOnPointer(event);
      return;
    }
    this.latestMoveEvent = event;
    entry.pointerWorldPoint = event.point;
    entry.prevPointerWorldQuaternion = entry.pointerWorldQuaternion;
    entry.pointerWorldQuaternion = event.pointerQuaternion;
    entry.pointerWorldOrigin = event.pointerPosition;
    if (entry.pointerWorldDirection != null) {
      getWorldDirection(event, entry.pointerWorldDirection);
    }
  }
  cancel() {
    if (this.capturedObjects.size === 0) {
      return;
    }
    for (const [pointerId, object] of this.capturedObjects) {
      object.releasePointerCapture(pointerId);
    }
    this.capturedObjects.clear();
    this.inputState.clear();
    this.outputState.end(void 0);
    const target = this.getTarget();
    if (target != null) {
      this.apply(target);
    }
  }
  onPointerUp(event) {
    if (!this.capturedObjects.has(event.pointerId)) {
      return;
    }
    this.stopPropagation(event);
    this.releasePointer(event.pointerId, event.object, event);
  }
  update(time) {
    const target = this.getTarget();
    if (target == null || this.inputState.size === 0 || this.latestMoveEvent == null && (this.getOptions().alwaysUpdate ?? false) === false) {
      return;
    }
    const options = this.getOptions();
    let transformState;
    if (options.translate === "as-rotate" || options.translate === "as-rotate-and-scale" || options.translate === "as-scale") {
      options.translate;
      this.prevTwoPointerDeltaRotation = void 0;
      this.prevAngle = void 0;
      const [p1] = this.inputState.values();
      const matrixWorld = target.matrixWorld;
      const parentMatrixWorld = target.parent?.matrixWorld;
      transformState = computeTranslateAsHandleTransformState(time, p1, this, matrixWorld, parentMatrixWorld, options);
    } else if (this.inputState.size === 1) {
      this.prevTwoPointerDeltaRotation = void 0;
      this.prevAngle = void 0;
      this.prevTranslateAsDeltaRotation = void 0;
      const [p1] = this.inputState.values();
      transformState = computeOnePointerHandleTransformState(time, p1, this, target.parent?.matrixWorld, options);
    } else {
      this.prevTranslateAsDeltaRotation = void 0;
      const [p1, p2] = this.inputState.values();
      transformState = computeTwoPointerHandleTransformState(time, p1, p2, this, target.parent?.matrixWorld, options);
    }
    this.outputState.update(this.latestMoveEvent, transformState);
    this.outputState.memo = this.apply(target);
    this.latestMoveEvent = void 0;
  }
  getTarget() {
    return this.target instanceof Object3D ? this.target : this.target?.current;
  }
  capturePointer(pointerId, object) {
    if (this.capturedObjects.has(pointerId)) {
      return false;
    }
    const { multitouch, translate: translate2 } = this.getOptions();
    if (((multitouch ?? true) === false || typeof translate2 === "string") && this.capturedObjects.size === 1) {
      return false;
    }
    this.capturedObjects.set(pointerId, object);
    object.setPointerCapture(pointerId);
    return true;
  }
  releasePointer(pointerId, object, event) {
    const target = this.getTarget();
    if (target == null || !this.capturedObjects.delete(pointerId)) {
      return;
    }
    this.inputState.delete(pointerId);
    object.releasePointerCapture(pointerId);
    if (this.inputState.size > 0) {
      this.save();
      return;
    }
    this.outputState.end(event);
    this.apply(target);
  }
  stopPropagation(event) {
    if (event == null || !(this.getOptions()?.stopPropagation ?? true)) {
      return;
    }
    event.stopPropagation();
  }
  apply(target) {
    const apply = this.getOptions().apply ?? defaultApply;
    return apply(this.outputState, target);
  }
  getState() {
    return this.inputState.size === 0 ? void 0 : this.outputState;
  }
  save() {
    const target = this.getTarget();
    if (target == null) {
      return;
    }
    target.updateWorldMatrix(true, false);
    this.prevAngle = void 0;
    this.prevTwoPointerDeltaRotation = void 0;
    this.prevTranslateAsDeltaRotation = void 0;
    this.initialTargetParentWorldMatrix = target.parent?.matrixWorld.clone();
    if (target.matrixAutoUpdate) {
      this.initialTargetPosition.copy(target.position);
      this.initialTargetQuaternion.copy(target.quaternion);
      this.initialTargetRotation.copy(target.rotation);
      this.initialTargetScale.copy(target.scale);
    } else {
      target.matrix.decompose(this.initialTargetPosition, this.initialTargetQuaternion, this.initialTargetScale);
      this.initialTargetRotation.setFromQuaternion(this.initialTargetQuaternion, target.rotation.order);
    }
    for (const data of this.inputState.values()) {
      if (data.pointerWorldDirection != null) {
        data.initialPointerWorldDirection?.copy(data.pointerWorldDirection);
      }
      data.initialPointerWorldPoint.copy(data.pointerWorldPoint);
      data.initialPointerWorldQuaternion.copy(data.pointerWorldQuaternion);
    }
  }
  bind(handle) {
    const { onPointerDown, onPointerMove, onPointerUp } = this.handlers;
    handle.addEventListener("pointerdown", onPointerDown);
    handle.addEventListener("pointermove", onPointerMove);
    handle.addEventListener("pointerup", onPointerUp);
    return () => {
      handle.removeEventListener("pointerdown", onPointerDown);
      handle.removeEventListener("pointermove", onPointerMove);
      handle.removeEventListener("pointerup", onPointerUp);
      this.cancel();
    };
  }
  capture(pointerId, object) {
    if (!this.capturePointer(pointerId, object)) {
      return noop2;
    }
    return () => this.releasePointer(pointerId, object, void 0);
  }
};
function noop2() {
}
function defaultApply(state, target) {
  target.position.copy(state.current.position);
  target.rotation.order = state.current.rotation.order;
  target.quaternion.copy(state.current.quaternion);
  target.scale.copy(state.current.scale);
}

// node_modules/@pmndrs/handle/dist/handles/context.js
import { Object3D as Object3D2 } from "three";
var HandlesContext = class {
  target;
  getOptions;
  handles = [];
  hoveredTagMap = /* @__PURE__ */ new Map();
  hoverSubscriptions = [];
  applySubscriptions = [];
  space;
  constructor(target, getOptions) {
    this.target = target;
    this.getOptions = getOptions;
  }
  getSpace() {
    return this.space ?? "world";
  }
  getTarget() {
    if (this.target instanceof Object3D2) {
      return this.target;
    }
    return this.target.current;
  }
  getHandleOptions(tag, getOverrideOptions) {
    const providedOptions = this.getOptions?.();
    const overrideOptions = getOverrideOptions?.();
    return {
      ...providedOptions,
      ...overrideOptions,
      apply: (state, target) => {
        this.onApply(tag, state, target);
        return (overrideOptions?.apply ?? providedOptions?.apply ?? defaultApply)?.(state, target);
      }
    };
  }
  registerHandle(store, object, tag) {
    const entry = {
      object,
      store,
      tag
    };
    this.handles.push(entry);
    const unbind = store.bind(object);
    const enterListener = this.onPointerEnter.bind(this, tag);
    const leaveListener = this.onPointerLeave.bind(this);
    object.addEventListener("pointerenter", enterListener);
    object.addEventListener("pointerleave", leaveListener);
    return () => {
      const index = this.handles.indexOf(entry);
      if (index != -1) {
        this.handles.splice(index, 1);
      }
      unbind();
      store.cancel();
    };
  }
  subscribeHover(fn) {
    this.hoverSubscriptions.push(fn);
    fn(Array.from(this.hoveredTagMap.values()));
    return () => {
      const index = this.hoverSubscriptions.indexOf(fn);
      if (index === -1) {
        return;
      }
      this.hoverSubscriptions.splice(index, 1);
    };
  }
  subscribeApply(fn) {
    this.applySubscriptions.push(fn);
    return () => {
      const index = this.applySubscriptions.indexOf(fn);
      if (index === -1) {
        return;
      }
      this.applySubscriptions.splice(index, 1);
    };
  }
  update(time) {
    for (const { store } of this.handles) {
      store.update(time);
    }
  }
  onPointerEnter(tag, e) {
    this.hoveredTagMap.set(e.pointerId, tag);
    this.updateHover();
  }
  onPointerLeave(e) {
    this.hoveredTagMap.delete(e.pointerId);
    this.updateHover();
  }
  updateHover() {
    const tags = Array.from(this.hoveredTagMap.values());
    for (const hoverSubscription of this.hoverSubscriptions) {
      hoverSubscription(tags);
    }
  }
  onApply(tag, state, target) {
    for (const applySubscription of this.applySubscriptions) {
      applySubscription(tag, state, target);
    }
  }
};

// node_modules/@pmndrs/handle/dist/handles/material.js
import { Color } from "three";
var handleXRayMaterialProperties = {
  depthTest: false,
  depthWrite: false,
  fog: false,
  toneMapped: false,
  transparent: true
};
function setupHandlesContextHoverMaterial(context, material, tag, { color, hoverColor, hoverOpacity, opacity, disabled: disabled2 = false }) {
  if (hoverColor == null && hoverOpacity == null || disabled2) {
    material.color.set(color);
    material.opacity = opacity ?? 1;
    if (disabled2) {
      material.opacity *= 0.5;
      material.color.lerp(new Color(1, 1, 1), 0.5);
    }
    return;
  }
  hoverColor ??= color;
  return context.subscribeHover((tags) => {
    const isHovered = tags.some((activeTag) => activeTag.includes(tag));
    material.color.set(isHovered ? hoverColor : color);
    material.opacity = (isHovered ? hoverOpacity : opacity) ?? 1;
  });
}

// node_modules/@pmndrs/handle/dist/handles/axis.js
import { BufferGeometry, Float32BufferAttribute, LineBasicMaterial, LineSegments, Quaternion as Quaternion6 } from "three";
var quaternionHelper2 = new Quaternion6();
var geometry = new BufferGeometry();
geometry.setAttribute("position", new Float32BufferAttribute([-1e3, 0, 0, 1e3, 0, 0], 3));
var HandlesAxisHighlight = class extends LineSegments {
  context;
  rotationOffset;
  constructor(context, rotationOffset) {
    super(geometry);
    this.context = context;
    this.rotationOffset = rotationOffset;
    this.renderOrder = Infinity;
  }
  update() {
    this.quaternion.setFromEuler(this.rotationOffset);
    const target = this.context.getTarget();
    if (this.context.getSpace() === "world" && target != null) {
      target.getWorldQuaternion(quaternionHelper2).invert();
      this.quaternion.premultiply(quaternionHelper2);
    }
  }
  bind(tag) {
    this.material = new LineBasicMaterial({
      ...handleXRayMaterialProperties,
      color: this.material.color ?? "white",
      opacity: this.material.opacity ?? 1
    });
    const unsubscribeHover = this.context.subscribeHover((tags) => {
      const isHovered = tags.some((activeTag) => activeTag.includes(tag));
      this.visible = isHovered;
    });
    const unsubscribeApply = this.context.subscribeApply((_2, state) => {
      if (state.last) {
        this.position.set(0, 0, 0);
        return;
      }
      this.position.copy(state.initial.position).sub(state.current.position);
      const target = this.context.getTarget();
      if (target != null) {
        quaternionHelper2.copy(target.quaternion).invert();
        this.position.applyQuaternion(quaternionHelper2);
      }
    });
    return () => {
      this.material.dispose();
      unsubscribeHover();
      unsubscribeApply();
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/registered.js
import { Group } from "three";
var RegisteredHandle = class extends Group {
  context;
  axis;
  store;
  options;
  tag;
  constructor(context, axis, tagPrefix, getOptions) {
    super();
    this.context = context;
    this.axis = axis;
    this.tag = (tagPrefix ?? "") + axis;
    this.store = new HandleStore(context.target, () => context.getHandleOptions(this.tag, getOptions));
  }
};

// node_modules/@pmndrs/handle/dist/handles/pivot/index.js
import { Group as Group2, Vector3 as Vector37 } from "three";

// node_modules/@pmndrs/handle/dist/handles/pivot/scale.js
import { Mesh, MeshBasicMaterial, SphereGeometry } from "three";

// node_modules/@pmndrs/handle/dist/handles/utils.js
import { OrthographicCamera, Vector3 as Vector36 } from "three";
function extractHandleTransformOptions(key, properties = true) {
  if (properties === false) {
    return { options: false, disabled: true };
  }
  if (properties === true) {
    const result2 = {
      x: false,
      y: false,
      z: false,
      e: false
    };
    for (const axis of key) {
      result2[axis] = true;
    }
    return { options: result2, disabled: false };
  }
  if (properties === "disabled") {
    return { options: { x: true, y: true, z: true, e: true }, disabled: true };
  }
  if (typeof properties === "string") {
    return {
      options: properties === key ? {
        x: false,
        y: false,
        z: false,
        e: false,
        [key]: true
      } : false,
      disabled: false
    };
  }
  const result = {
    x: false,
    y: false,
    z: false,
    e: false
  };
  let disabled2 = false;
  for (const axis of key) {
    let axisOption = properties[axis] ?? true;
    if (axisOption === false) {
      return { options: false, disabled: true };
    }
    if (axisOption === "disabled") {
      disabled2 = true;
      axisOption = true;
    }
    result[axis] = axisOption;
  }
  return { options: result, disabled: disabled2 };
}
var worldPositionHelper = new Vector36();
var cameraPositionHelper = new Vector36();
function computeHandlesScale(handlesCenter, camera, fixed, size) {
  if (!fixed) {
    return size;
  }
  let factor;
  if (camera instanceof OrthographicCamera) {
    factor = (camera.top - camera.bottom) / camera.zoom;
  } else {
    camera.getWorldPosition(worldPositionHelper);
    handlesCenter.getWorldPosition(cameraPositionHelper);
    factor = worldPositionHelper.distanceTo(cameraPositionHelper) * Math.min(1.9 * Math.tan(Math.PI * camera.fov / 360) / camera.zoom, 7);
  }
  return factor * size / 4;
}

// node_modules/@pmndrs/handle/dist/handles/pivot/rotate.js
import { Mesh as Mesh2, MeshBasicMaterial as MeshBasicMaterial2, TorusGeometry } from "three";

// node_modules/@pmndrs/handle/dist/handles/translate/axis.js
import { CylinderGeometry, Euler as Euler4, Mesh as Mesh3, MeshBasicMaterial as MeshBasicMaterial3 } from "three";
var arrowHeadGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
arrowHeadGeometry.translate(0, 0.05, 0);
var arrowBodyGeometry = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
arrowBodyGeometry.translate(0, 0.25, 0);
var normalRotation = new Euler4(0, 0, -Math.PI / 2);
var invertedRotation = new Euler4(0, 0, Math.PI / 2);
var AxisTranslateHandle = class extends RegisteredHandle {
  invert;
  showArrowBody;
  constructor(context, axis, tagPrefix = "", axisVector, invert3 = false, showArrowBody = true) {
    super(context, axis, tagPrefix, () => ({
      scale: false,
      rotate: false,
      translate: axisVector != null ? [axisVector] : this.options,
      multitouch: false
    }));
    this.invert = invert3;
    this.showArrowBody = showArrowBody;
  }
  bind(defaultColor, defaultHoverColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const rotation = this.invert ? invertedRotation : normalRotation;
    const material = new MeshBasicMaterial3(handleXRayMaterialProperties);
    const cleanupHeadHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: defaultColor,
      hoverColor: defaultHoverColor,
      disabled: disabled2
    });
    const visualizationHeadMesh = new Mesh3(arrowHeadGeometry, material);
    visualizationHeadMesh.renderOrder = Infinity;
    visualizationHeadMesh.position.x = this.invert ? -0.5 : 0.5;
    visualizationHeadMesh.rotation.copy(rotation);
    this.add(visualizationHeadMesh);
    let cleanupBodyHover;
    let visualizationBodyMesh;
    if (this.showArrowBody) {
      const material2 = new MeshBasicMaterial3(handleXRayMaterialProperties);
      cleanupBodyHover = setupHandlesContextHoverMaterial(this.context, material2, this.tag, {
        color: defaultColor,
        hoverColor: 16777024,
        disabled: disabled2
      });
      visualizationBodyMesh = new Mesh3(arrowBodyGeometry, material2);
      visualizationBodyMesh.renderOrder = Infinity;
      visualizationBodyMesh.rotation.copy(rotation);
      this.add(visualizationBodyMesh);
    }
    const interactionMesh = new Mesh3(new CylinderGeometry(0.13, 0, 0.6, 4));
    interactionMesh.pointerEventsOrder = Infinity;
    interactionMesh.position.x = this.invert ? -0.3 : 0.3;
    interactionMesh.rotation.copy(rotation);
    interactionMesh.visible = false;
    this.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      material.dispose();
      unregister?.();
      cleanupHeadHover?.();
      cleanupBodyHover?.();
      this.remove(visualizationHeadMesh);
      if (visualizationBodyMesh != null) {
        this.remove(visualizationBodyMesh);
      }
      this.remove(interactionMesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/translate/plane.js
import { MeshBasicMaterial as MeshBasicMaterial4, Mesh as Mesh4, BoxGeometry } from "three";
var PlaneTranslateHandle = class extends RegisteredHandle {
  constructor(context, tag, tagPrefix = "", axisVectors) {
    super(context, tag, tagPrefix, () => ({
      translate: axisVectors ?? this.options,
      scale: false,
      rotate: false,
      multitouch: false
    }));
  }
  bind(defaultColor, defaultHoverColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial4(handleXRayMaterialProperties);
    const cleanupHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      opacity: 0.5,
      hoverOpacity: 1,
      color: defaultColor,
      hoverColor: defaultHoverColor,
      disabled: disabled2
    });
    const mesh = new Mesh4(new BoxGeometry(0.2, 0.2, 0.01), material);
    mesh.renderOrder = Infinity;
    mesh.pointerEventsOrder = Infinity;
    mesh.position.set(0.15, 0.15, 0);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, mesh, this.tag);
    this.add(mesh);
    return () => {
      material.dispose();
      mesh.geometry.dispose();
      unregister?.();
      cleanupHover?.();
      this.remove(mesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/pivot/index.js
var vectorHelper6 = new Vector37();

// node_modules/@pmndrs/handle/dist/handles/translate/index.js
import { Group as Group3, Vector3 as Vector38, Euler as Euler5, Quaternion as Quaternion8 } from "three";

// node_modules/@pmndrs/handle/dist/handles/translate/delta.js
import { BufferGeometry as BufferGeometry2, Float32BufferAttribute as Float32BufferAttribute2, LineBasicMaterial as LineBasicMaterial2, LineSegments as LineSegments2, Mesh as Mesh5, MeshBasicMaterial as MeshBasicMaterial5, OctahedronGeometry, Quaternion as Quaternion7 } from "three";
var quaternionHelper3 = new Quaternion7();
function setupTranslateHandleDelta(group, context) {
  const startMesh = new Mesh5(new OctahedronGeometry(0.01, 2), new MeshBasicMaterial5(handleXRayMaterialProperties));
  startMesh.renderOrder = Infinity;
  startMesh.visible = false;
  group.add(startMesh);
  const endMesh = new Mesh5(new OctahedronGeometry(0.01, 2), new MeshBasicMaterial5(handleXRayMaterialProperties));
  endMesh.renderOrder = Infinity;
  endMesh.visible = false;
  group.add(endMesh);
  const geometry2 = new BufferGeometry2();
  geometry2.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 1, 1, 1], 3));
  const lineSegments = new LineSegments2(geometry2, new LineBasicMaterial2(handleXRayMaterialProperties));
  lineSegments.renderOrder = Infinity;
  lineSegments.visible = false;
  group.add(lineSegments);
  const unsubscribe = context.subscribeApply((_2, state) => {
    endMesh.position.set(0, 0, 0);
    startMesh.position.copy(state.initial.position).sub(state.current.position);
    const target = context.getTarget();
    if (target != null) {
      quaternionHelper3.copy(target.quaternion).invert();
      startMesh.position.applyQuaternion(quaternionHelper3);
    }
    lineSegments.position.set(0, 0, 0);
    lineSegments.scale.copy(startMesh.position);
    startMesh.visible = !state.last;
    lineSegments.visible = !state.last;
    endMesh.visible = !state.last;
  });
  return () => {
    startMesh.geometry.dispose();
    startMesh.material.dispose();
    endMesh.geometry.dispose();
    endMesh.material.dispose();
    lineSegments.geometry.dispose();
    lineSegments.material.dispose();
    group.remove(startMesh);
    group.remove(endMesh);
    group.remove(lineSegments);
    unsubscribe();
  };
}

// node_modules/@pmndrs/handle/dist/handles/translate/free.js
import { MeshBasicMaterial as MeshBasicMaterial6, Mesh as Mesh6, OctahedronGeometry as OctahedronGeometry2 } from "three";
var FreeTranslateHandle = class extends RegisteredHandle {
  constructor(context) {
    super(context, "xyz", "", () => ({
      translate: this.options,
      scale: false,
      rotate: false,
      multitouch: false
    }));
  }
  bind(config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial6(handleXRayMaterialProperties);
    const cleanupHeadHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: 16777215,
      hoverColor: 16776960,
      opacity: 0.25,
      hoverOpacity: 1,
      disabled: disabled2
    });
    const visualizationMesh = new Mesh6(new OctahedronGeometry2(0.1, 0), material);
    visualizationMesh.renderOrder = Infinity;
    this.add(visualizationMesh);
    const interactionMesh = new Mesh6(new OctahedronGeometry2(0.2, 0));
    interactionMesh.pointerEventsOrder = Infinity;
    interactionMesh.visible = false;
    this.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      material.dispose();
      visualizationMesh.geometry.dispose();
      interactionMesh.geometry.dispose();
      unregister?.();
      cleanupHeadHover?.();
      this.remove(visualizationMesh);
      this.remove(interactionMesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/translate/index.js
var vectorHelper7 = new Vector38();
var quaternionHelper4 = new Quaternion8();
var xRotationOffset = new Quaternion8();
var yRotationOffset = new Quaternion8().setFromEuler(new Euler5(0, 0, Math.PI / 2));
var zRotationOffset = new Quaternion8().setFromEuler(new Euler5(0, -Math.PI / 2, 0));
var xyRotationOffset = new Quaternion8();
var yzRotationOffset = new Quaternion8().setFromEuler(new Euler5(0, -Math.PI / 2, 0));
var xzRotationOffset = new Quaternion8().setFromEuler(new Euler5(Math.PI / 2, 0, 0));
var TranslateHandles = class extends Group3 {
  context;
  size;
  fixed;
  free;
  translationX;
  translationY;
  translationZ;
  translationNegX;
  translationNegY;
  translationNegZ;
  translationXY;
  translationYZ;
  translationXZ;
  scaleGroup = new Group3();
  xAxis = new Vector38();
  yAxis = new Vector38();
  zAxis = new Vector38();
  negXAxis = new Vector38();
  negYAxis = new Vector38();
  negZAxis = new Vector38();
  constructor(context, size, fixed) {
    super();
    this.context = context;
    this.size = size;
    this.fixed = fixed;
    this.add(this.scaleGroup);
    this.free = new FreeTranslateHandle(this.context);
    this.scaleGroup.add(this.free);
    this.translationX = new AxisTranslateHandle(this.context, "x", void 0, this.xAxis);
    this.scaleGroup.add(this.translationX);
    this.translationY = new AxisTranslateHandle(this.context, "y", void 0, this.yAxis);
    this.scaleGroup.add(this.translationY);
    this.translationZ = new AxisTranslateHandle(this.context, "z", void 0, this.zAxis);
    this.scaleGroup.add(this.translationZ);
    this.translationNegX = new AxisTranslateHandle(this.context, "x", void 0, this.negXAxis, true, false);
    this.scaleGroup.add(this.translationNegX);
    this.translationNegY = new AxisTranslateHandle(this.context, "y", void 0, this.negYAxis, true, false);
    this.scaleGroup.add(this.translationNegY);
    this.translationNegZ = new AxisTranslateHandle(this.context, "z", void 0, this.negZAxis, true, false);
    this.scaleGroup.add(this.translationNegZ);
    this.translationXY = new PlaneTranslateHandle(this.context, "xy", void 0, [this.xAxis, this.yAxis]);
    this.scaleGroup.add(this.translationXY);
    this.translationXZ = new PlaneTranslateHandle(this.context, "xz", void 0, [this.xAxis, this.zAxis]);
    this.scaleGroup.add(this.translationXZ);
    this.translationYZ = new PlaneTranslateHandle(this.context, "yz", void 0, [this.yAxis, this.zAxis]);
    this.scaleGroup.add(this.translationYZ);
  }
  update(camera) {
    this.updateWorldMatrix(true, false);
    this.xAxis.set(1, 0, 0);
    this.yAxis.set(0, 1, 0);
    this.zAxis.set(0, 0, 1);
    this.free.quaternion.identity();
    this.translationX.quaternion.copy(xRotationOffset);
    this.translationY.quaternion.copy(yRotationOffset);
    this.translationZ.quaternion.copy(zRotationOffset);
    this.translationNegX.quaternion.copy(xRotationOffset);
    this.translationNegY.quaternion.copy(yRotationOffset);
    this.translationNegZ.quaternion.copy(zRotationOffset);
    this.translationXY.quaternion.copy(xyRotationOffset);
    this.translationYZ.quaternion.copy(yzRotationOffset);
    this.translationXZ.quaternion.copy(xzRotationOffset);
    const space3 = this.context.getSpace();
    const target = this.context.getTarget();
    if (space3 == "world" && target != null) {
      target.getWorldQuaternion(quaternionHelper4).invert();
      this.free.quaternion.premultiply(quaternionHelper4);
      this.translationX.quaternion.premultiply(quaternionHelper4);
      this.translationY.quaternion.premultiply(quaternionHelper4);
      this.translationZ.quaternion.premultiply(quaternionHelper4);
      this.translationNegX.quaternion.premultiply(quaternionHelper4);
      this.translationNegY.quaternion.premultiply(quaternionHelper4);
      this.translationNegZ.quaternion.premultiply(quaternionHelper4);
      this.translationXY.quaternion.premultiply(quaternionHelper4);
      this.translationYZ.quaternion.premultiply(quaternionHelper4);
      this.translationXZ.quaternion.premultiply(quaternionHelper4);
      if (target.parent != null) {
        target.parent.getWorldQuaternion(quaternionHelper4).invert();
        this.xAxis.applyQuaternion(quaternionHelper4);
        this.yAxis.applyQuaternion(quaternionHelper4);
        this.zAxis.applyQuaternion(quaternionHelper4);
      }
    } else if (target != null) {
      this.xAxis.applyQuaternion(target.quaternion);
      this.yAxis.applyQuaternion(target.quaternion);
      this.zAxis.applyQuaternion(target.quaternion);
    }
    this.negXAxis.copy(this.xAxis).negate();
    this.negYAxis.copy(this.yAxis).negate();
    this.negZAxis.copy(this.zAxis).negate();
    this.scaleGroup.scale.setScalar(1);
    if (target != null) {
      target.getWorldScale(vectorHelper7);
      this.scaleGroup.scale.divide(vectorHelper7);
    }
    this.scaleGroup.scale.multiplyScalar(computeHandlesScale(this, camera, this.fixed ?? true, this.size ?? 1));
  }
  bind(options) {
    const cleanupDelta = setupTranslateHandleDelta(this, this.context);
    const unbindTranslationX = this.translationX.bind(16711680, 16776960, options);
    const unbindTranslationY = this.translationY.bind(65280, 16776960, options);
    const unbindTranslationZ = this.translationZ.bind(255, 16776960, options);
    const unbindTranslationNegX = this.translationNegX.bind(16711680, 16776960, options);
    const unbindTranslationNegY = this.translationNegY.bind(65280, 16776960, options);
    const unbindTranslationNegZ = this.translationNegZ.bind(255, 16776960, options);
    const unbindTranslationXY = this.translationXY.bind(255, 16776960, options);
    const unbindTranslationYZ = this.translationYZ.bind(16711680, 16776960, options);
    const unbindTranslationXZ = this.translationXZ.bind(65280, 16776960, options);
    const unbindFree = this.free.bind(options);
    return () => {
      cleanupDelta();
      unbindTranslationX?.();
      unbindTranslationY?.();
      unbindTranslationZ?.();
      unbindTranslationNegX?.();
      unbindTranslationNegY?.();
      unbindTranslationNegZ?.();
      unbindTranslationXY?.();
      unbindTranslationYZ?.();
      unbindTranslationXZ?.();
      unbindFree?.();
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/scale/index.js
import { Group as Group6, Vector3 as Vector39 } from "three";

// node_modules/@pmndrs/handle/dist/handles/scale/axis.js
import { BoxGeometry as BoxGeometry2, CylinderGeometry as CylinderGeometry2, Euler as Euler6, Group as Group4, Mesh as Mesh7, MeshBasicMaterial as MeshBasicMaterial7 } from "three";
var normalRotation2 = new Euler6(0, 0, -Math.PI / 2);
var invertedRotation2 = new Euler6(0, 0, Math.PI / 2);
var AxisScaleHandle = class extends RegisteredHandle {
  invert;
  showHandleLine;
  constructor(context, axis, tagPrefix = "", invert3 = false, showHandleLine = true) {
    super(context, axis, tagPrefix, () => ({
      scale: this.options,
      rotate: false,
      translate: "as-scale",
      multitouch: false
    }));
    this.invert = invert3;
    this.showHandleLine = showHandleLine;
  }
  bind(defaultColor, defaultHoverColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const rotation = this.invert ? invertedRotation2 : normalRotation2;
    const visualizationHeadGroup = new Group4();
    visualizationHeadGroup.position.x = this.invert ? -0.5 : 0.5;
    visualizationHeadGroup.rotation.copy(rotation);
    this.add(visualizationHeadGroup);
    const material = new MeshBasicMaterial7(handleXRayMaterialProperties);
    const cleanupHeadHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: defaultColor,
      hoverColor: defaultHoverColor,
      disabled: disabled2
    });
    const visualizationHeadMesh = new Mesh7(new BoxGeometry2(0.08, 0.08, 0.08), material);
    visualizationHeadMesh.renderOrder = Infinity;
    visualizationHeadMesh.rotation.copy(rotation);
    visualizationHeadGroup.add(visualizationHeadMesh);
    let cleanupLineHover;
    let visualizationLineMesh;
    let visualizationLineGroup;
    if (this.showHandleLine) {
      visualizationLineGroup = new Group4();
      visualizationLineGroup.rotation.copy(rotation);
      this.add(visualizationLineGroup);
      const material2 = new MeshBasicMaterial7(handleXRayMaterialProperties);
      cleanupLineHover = setupHandlesContextHoverMaterial(this.context, material2, this.tag, {
        color: defaultColor,
        hoverColor: defaultHoverColor,
        disabled: disabled2
      });
      visualizationLineMesh = new Mesh7(new CylinderGeometry2(75e-4, 75e-4, 0.5, 3), material2);
      visualizationLineMesh.renderOrder = Infinity;
      visualizationLineMesh.position.y = 0.25;
      visualizationLineGroup.add(visualizationLineMesh);
    }
    const interactionGroup = new Group4();
    interactionGroup.visible = false;
    interactionGroup.rotation.copy(rotation);
    interactionGroup.position.x = this.invert ? -0.3 : 0.3;
    this.add(interactionGroup);
    const interactionMesh = new Mesh7(new CylinderGeometry2(0.2, 0, 0.5, 4));
    interactionMesh.pointerEventsOrder = Infinity;
    interactionMesh.position.y = 0.04;
    interactionGroup.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      material.dispose();
      interactionMesh.geometry.dispose();
      visualizationHeadMesh.geometry.dispose();
      visualizationLineMesh?.geometry.dispose();
      unregister?.();
      cleanupHeadHover?.();
      cleanupLineHover?.();
      if (visualizationLineGroup != null) {
        this.remove(visualizationLineGroup);
      }
      this.remove(interactionGroup);
      this.remove(visualizationHeadGroup);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/scale/plane.js
import { MeshBasicMaterial as MeshBasicMaterial8, Mesh as Mesh8, BoxGeometry as BoxGeometry3 } from "three";
var PlaneScaleHandle = class extends RegisteredHandle {
  constructor(context, tag, tagPrefix = "") {
    super(context, tag, tagPrefix, () => ({
      translate: "as-scale",
      scale: this.options,
      rotate: false,
      multitouch: false
    }));
  }
  bind(defaultColor, defaultHoverColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial8(handleXRayMaterialProperties);
    const cleanupHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      opacity: 0.5,
      hoverOpacity: 1,
      color: defaultColor,
      hoverColor: defaultHoverColor,
      disabled: disabled2
    });
    const mesh = new Mesh8(new BoxGeometry3(0.2, 0.2, 0.01), material);
    mesh.renderOrder = Infinity;
    mesh.pointerEventsOrder = Infinity;
    mesh.position.set(0.15, 0.15, 0);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, mesh, this.tag);
    this.add(mesh);
    return () => {
      material.dispose();
      mesh.geometry.dispose();
      unregister?.();
      cleanupHover?.();
      this.remove(mesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/scale/uniform.js
import { BoxGeometry as BoxGeometry4, Euler as Euler7, Group as Group5, Mesh as Mesh9, MeshBasicMaterial as MeshBasicMaterial9 } from "three";
var normalRotation3 = new Euler7(0, 0, -Math.PI / 2);
var invertedRotation3 = new Euler7(0, 0, Math.PI / 2);
var UniformAxisScaleHandle = class extends RegisteredHandle {
  actualAxis;
  invert;
  constructor(context, tagPrefix = "", actualAxis, invert3 = false) {
    super(context, "xyz", tagPrefix, () => ({
      scale: { uniform: true, ...this.options },
      rotate: false,
      translate: "as-scale",
      multitouch: false
    }));
    this.actualAxis = actualAxis;
    this.invert = invert3;
  }
  bind(defaultColor, defaultHoverColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.actualAxis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const rotation = this.invert ? invertedRotation3 : normalRotation3;
    const headGroup = new Group5();
    headGroup.position.x = this.invert ? -0.7 : 0.7;
    headGroup.rotation.copy(rotation);
    this.add(headGroup);
    const material = new MeshBasicMaterial9(handleXRayMaterialProperties);
    const cleanupHeadHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: defaultColor,
      hoverColor: defaultHoverColor,
      opacity: 0.5,
      hoverOpacity: 1,
      disabled: disabled2
    });
    const visualizationHeadMesh = new Mesh9(new BoxGeometry4(0.08, 0.08, 0.08), material);
    visualizationHeadMesh.renderOrder = Infinity;
    visualizationHeadMesh.rotation.copy(rotation);
    headGroup.add(visualizationHeadMesh);
    const interactionHeadMesh = new Mesh9(new BoxGeometry4(0.15, 0.15, 0.15), material);
    interactionHeadMesh.visible = false;
    interactionHeadMesh.pointerEventsOrder = Infinity;
    interactionHeadMesh.rotation.copy(rotation);
    headGroup.add(interactionHeadMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionHeadMesh, this.tag);
    return () => {
      material.dispose();
      visualizationHeadMesh.geometry.dispose();
      unregister?.();
      cleanupHeadHover?.();
      this.remove(headGroup);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/scale/index.js
var vectorHelper8 = new Vector39();
var ScaleHandles = class extends Group6 {
  context;
  size;
  fixed;
  scaleX;
  scaleY;
  scaleZ;
  scaleNegX;
  scaleNegY;
  scaleNegZ;
  translationX;
  translationY;
  translationZ;
  translationNegX;
  translationNegY;
  translationNegZ;
  translationXY;
  translationYZ;
  translationXZ;
  constructor(context, size, fixed) {
    super();
    this.context = context;
    this.size = size;
    this.fixed = fixed;
    this.scaleX = new UniformAxisScaleHandle(this.context, void 0, "x");
    this.add(this.scaleX);
    this.scaleY = new UniformAxisScaleHandle(this.context, void 0, "y");
    this.scaleY.rotation.z = Math.PI / 2;
    this.add(this.scaleY);
    this.scaleZ = new UniformAxisScaleHandle(this.context, void 0, "z");
    this.scaleZ.rotation.y = -Math.PI / 2;
    this.add(this.scaleZ);
    this.scaleNegX = new UniformAxisScaleHandle(this.context, void 0, "x", true);
    this.add(this.scaleNegX);
    this.scaleNegY = new UniformAxisScaleHandle(this.context, void 0, "y", true);
    this.scaleNegY.rotation.z = Math.PI / 2;
    this.add(this.scaleNegY);
    this.scaleNegZ = new UniformAxisScaleHandle(this.context, void 0, "z", true);
    this.scaleNegZ.rotation.y = -Math.PI / 2;
    this.add(this.scaleNegZ);
    this.translationX = new AxisScaleHandle(this.context, "x");
    this.add(this.translationX);
    this.translationY = new AxisScaleHandle(this.context, "y");
    this.translationY.rotation.z = Math.PI / 2;
    this.add(this.translationY);
    this.translationZ = new AxisScaleHandle(this.context, "z");
    this.translationZ.rotation.y = -Math.PI / 2;
    this.add(this.translationZ);
    this.translationNegX = new AxisScaleHandle(this.context, "x", void 0, true, false);
    this.add(this.translationNegX);
    this.translationNegY = new AxisScaleHandle(this.context, "y", void 0, true, false);
    this.translationNegY.rotation.z = Math.PI / 2;
    this.add(this.translationNegY);
    this.translationNegZ = new AxisScaleHandle(this.context, "z", void 0, true, false);
    this.translationNegZ.rotation.y = -Math.PI / 2;
    this.add(this.translationNegZ);
    this.translationXY = new PlaneScaleHandle(this.context, "xy");
    this.add(this.translationXY);
    this.translationXZ = new PlaneScaleHandle(this.context, "xz");
    this.translationXZ.rotation.x = Math.PI / 2;
    this.add(this.translationXZ);
    this.translationYZ = new PlaneScaleHandle(this.context, "yz");
    this.translationYZ.rotation.y = -Math.PI / 2;
    this.add(this.translationYZ);
  }
  update(camera) {
    this.updateWorldMatrix(true, false);
    this.scale.setScalar(1);
    const target = this.context.getTarget();
    if (target != null) {
      target.getWorldScale(vectorHelper8);
      this.scale.divide(vectorHelper8);
    }
    this.scale.multiplyScalar(computeHandlesScale(this, camera, this.fixed ?? true, this.size ?? 1));
  }
  bind(options) {
    const unbindScaleX = this.scaleX.bind(16777215, 16776960, options);
    const unbindScaleY = this.scaleY.bind(16777215, 16776960, options);
    const unbindScaleZ = this.scaleZ.bind(16777215, 16776960, options);
    const unbindScaleNegX = this.scaleNegX.bind(16777215, 16776960, options);
    const unbindScaleNegY = this.scaleNegY.bind(16777215, 16776960, options);
    const unbindScaleNegZ = this.scaleNegZ.bind(16777215, 16776960, options);
    const unbindTranslationX = this.translationX.bind(16711680, 16776960, options);
    const unbindTranslationY = this.translationY.bind(65280, 16776960, options);
    const unbindTranslationZ = this.translationZ.bind(255, 16776960, options);
    const unbindTranslationNegX = this.translationNegX.bind(16711680, 16776960, options);
    const unbindTranslationNegY = this.translationNegY.bind(65280, 16776960, options);
    const unbindTranslationNegZ = this.translationNegZ.bind(255, 16776960, options);
    const unbindTranslationXY = this.translationXY.bind(255, 16776960, options);
    const unbindTranslationYZ = this.translationYZ.bind(16711680, 16776960, options);
    const unbindTranslationXZ = this.translationXZ.bind(65280, 16776960, options);
    return () => {
      unbindTranslationX?.();
      unbindTranslationY?.();
      unbindTranslationZ?.();
      unbindTranslationNegX?.();
      unbindTranslationNegY?.();
      unbindTranslationNegZ?.();
      unbindTranslationXY?.();
      unbindTranslationYZ?.();
      unbindTranslationXZ?.();
      unbindScaleX?.();
      unbindScaleY?.();
      unbindScaleZ?.();
      unbindScaleNegX?.();
      unbindScaleNegY?.();
      unbindScaleNegZ?.();
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/rotate/index.js
import { Group as Group7, TorusGeometry as TorusGeometry4, Vector3 as Vector313 } from "three";

// node_modules/@pmndrs/handle/dist/handles/rotate/axis.js
import { Euler as Euler8, Mesh as Mesh10, MeshBasicMaterial as MeshBasicMaterial10, Quaternion as Quaternion9, TorusGeometry as TorusGeometry2, Vector3 as Vector310 } from "three";
var config2 = {
  x: {
    vector1: new Vector310(0, 0, -1),
    vector2: new Vector310(0, -1, 0),
    rotationOffset: new Quaternion9(),
    axis: [1, 0, 0]
  },
  y: {
    vector1: new Vector310(0, 0, -1),
    vector2: new Vector310(-1, 0, -1),
    rotationOffset: new Quaternion9().setFromEuler(new Euler8(0, 0, Math.PI / 2)),
    axis: [0, 1, 0]
  },
  z: {
    vector1: new Vector310(-1, 0, 0),
    vector2: new Vector310(0, -1, 0),
    rotationOffset: new Quaternion9().setFromEuler(new Euler8(0, Math.PI / 2, 0)),
    axis: [0, 0, 1]
  }
};
var vector1Helper = new Vector310();
var vector2Helper = new Vector310();
var vector3Helper = new Vector310();
var vector4Helper = new Vector310();
var quaternionHelper5 = new Quaternion9();
var AxisRotateHandle = class extends RegisteredHandle {
  direction = new Vector310(1, 0, 0);
  constructor(context, axis, tagPrefix = "") {
    super(context, axis, tagPrefix, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: [this.direction],
      multitouch: false
    }));
  }
  update(camera) {
    const { rotationOffset, vector1, vector2 } = config2[this.axis];
    camera.getWorldPosition(vector1Helper);
    this.getWorldPosition(vector2Helper).sub(vector1Helper);
    vector3Helper.copy(vector1);
    vector4Helper.copy(vector2);
    const target = this.context.getTarget();
    const space3 = this.context.getSpace();
    if (space3 === "local" && target != null) {
      target.getWorldQuaternion(quaternionHelper5);
      vector3Helper.applyQuaternion(quaternionHelper5);
      vector4Helper.applyQuaternion(quaternionHelper5);
    }
    vector4Helper.crossVectors(vector3Helper, vector4Helper);
    const dotProduct = vector2Helper.dot(vector4Helper);
    vector4Helper.multiplyScalar(dotProduct);
    vector2Helper.sub(vector4Helper);
    this.quaternion.setFromUnitVectors(vector3Helper, vector2Helper.normalize());
    if (space3 === "local" && target != null) {
      target.getWorldQuaternion(quaternionHelper5);
      this.quaternion.multiply(quaternionHelper5);
    }
    this.quaternion.multiply(rotationOffset);
    if (target?.parent != null) {
      target.parent.matrixWorld.decompose(vector1Helper, quaternionHelper5, vector2Helper);
      quaternionHelper5.invert();
      this.quaternion.premultiply(quaternionHelper5);
    } else {
      quaternionHelper5.identity();
    }
    if (this.store.getState() == null) {
      this.direction.fromArray(config2[this.axis].axis);
      this.direction.applyQuaternion(space3 === "local" && target != null ? target?.quaternion : quaternionHelper5);
    }
    if (target != null) {
      this.quaternion.premultiply(quaternionHelper5.copy(target.quaternion).invert());
    }
  }
  bind(defaultColor, config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial10(handleXRayMaterialProperties);
    const cleanupHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: defaultColor,
      hoverColor: 16776960,
      disabled: disabled2
    });
    const visualizationMesh = new Mesh10(createCircleGeometry(0.5, 0.5), material);
    visualizationMesh.renderOrder = Infinity;
    this.add(visualizationMesh);
    const interactionMesh = new Mesh10(new TorusGeometry2(0.5, 0.1, 4, 24));
    interactionMesh.visible = false;
    interactionMesh.pointerEventsOrder = Infinity;
    interactionMesh.rotation.set(0, -Math.PI / 2, -Math.PI / 2);
    this.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      material.dispose();
      interactionMesh.geometry.dispose();
      visualizationMesh.geometry.dispose();
      unregister?.();
      cleanupHover?.();
      this.remove(interactionMesh);
      this.remove(visualizationMesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/rotate/free.js
import { Mesh as Mesh11, MeshBasicMaterial as MeshBasicMaterial11, Quaternion as Quaternion10, SphereGeometry as SphereGeometry2, Vector3 as Vector311 } from "three";
var vector1Helper2 = new Vector311();
var vector2Helper2 = new Vector311();
var xAxis = new Vector311(1, 0, 0);
var quaternionHelper6 = new Quaternion10();
var FreeRotateHandle = class extends RegisteredHandle {
  constructor(context, tagPrefix = "") {
    super(context, "xyz", tagPrefix, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: this.options,
      multitouch: false
    }));
  }
  update(camera) {
    camera.getWorldPosition(vector1Helper2);
    this.getWorldPosition(vector2Helper2).sub(vector1Helper2);
    this.quaternion.setFromUnitVectors(xAxis, vector2Helper2.normalize());
    const target = this.context.getTarget();
    if (target?.parent != null) {
      target.parent.matrixWorld.decompose(vector1Helper2, quaternionHelper6, vector2Helper2);
      quaternionHelper6.invert();
      this.quaternion.premultiply(quaternionHelper6);
    }
    if (target != null) {
      quaternionHelper6.copy(target.quaternion).invert();
      this.quaternion.premultiply(quaternionHelper6);
    }
  }
  bind(config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial11(handleXRayMaterialProperties);
    const cleanupHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: 16777215,
      hoverColor: 16776960,
      opacity: 0.25,
      disabled: disabled2
    });
    const visualizationMesh = new Mesh11(createCircleGeometry(0.5, 1), material);
    visualizationMesh.renderOrder = Infinity;
    this.add(visualizationMesh);
    const interactionMesh = new Mesh11(new SphereGeometry2(0.25, 10, 8));
    interactionMesh.visible = false;
    interactionMesh.pointerEventsOrder = Infinity;
    this.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      this.pointerEvents = "none";
      material.dispose();
      interactionMesh.geometry.dispose();
      visualizationMesh.geometry.dispose();
      unregister?.();
      cleanupHover?.();
      this.remove(interactionMesh);
      this.remove(visualizationMesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/rotate/screen.js
import { Mesh as Mesh12, MeshBasicMaterial as MeshBasicMaterial12, Quaternion as Quaternion11, TorusGeometry as TorusGeometry3, Vector3 as Vector312 } from "three";
var vector1Helper3 = new Vector312();
var vector2Helper3 = new Vector312();
var zAxis = new Vector312(1, 0, 0);
var quaternionHelper7 = new Quaternion11();
var ScreenSpaceRotateHandle = class extends RegisteredHandle {
  direction = new Vector312(1, 0, 0);
  constructor(context, tagPrefix = "") {
    super(context, "e", tagPrefix, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: [this.direction],
      multitouch: false
    }));
  }
  update(camera) {
    camera.getWorldPosition(vector1Helper3);
    this.getWorldPosition(this.direction).sub(vector1Helper3).normalize();
    this.quaternion.setFromUnitVectors(zAxis, this.direction);
    const target = this.context.getTarget();
    if (target?.parent != null) {
      target.parent.matrixWorld.decompose(vector1Helper3, quaternionHelper7, vector2Helper3);
      quaternionHelper7.invert();
      this.quaternion.premultiply(quaternionHelper7);
      this.direction.applyQuaternion(quaternionHelper7);
    }
    if (target != null) {
      quaternionHelper7.copy(target.quaternion).invert();
      this.quaternion.premultiply(quaternionHelper7);
    }
    this.direction.negate();
  }
  bind(config3) {
    const { options, disabled: disabled2 } = extractHandleTransformOptions(this.axis, config3);
    if (options === false) {
      return void 0;
    }
    this.options = options;
    const material = new MeshBasicMaterial12(handleXRayMaterialProperties);
    const cleanupHover = setupHandlesContextHoverMaterial(this.context, material, this.tag, {
      color: 16776960,
      hoverColor: 16776960,
      opacity: 0.5,
      disabled: disabled2
    });
    const visualizationMesh = new Mesh12(createCircleGeometry(0.75, 1), material);
    visualizationMesh.renderOrder = Infinity;
    this.add(visualizationMesh);
    const interactionMesh = new Mesh12(new TorusGeometry3(0.75, 0.1, 2, 24), new MeshBasicMaterial12({ color: "white" }));
    interactionMesh.visible = false;
    interactionMesh.rotation.y = Math.PI / 2;
    interactionMesh.pointerEventsOrder = Infinity;
    this.add(interactionMesh);
    const unregister = disabled2 ? void 0 : this.context.registerHandle(this.store, interactionMesh, this.tag);
    return () => {
      material.dispose();
      interactionMesh.geometry.dispose();
      visualizationMesh.geometry.dispose();
      unregister?.();
      cleanupHover?.();
      this.remove(interactionMesh);
      this.remove(visualizationMesh);
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/rotate/index.js
function createCircleGeometry(radius, arc) {
  const geometry2 = new TorusGeometry4(radius, 75e-4, 3, 64, arc * Math.PI * 2);
  geometry2.rotateY(Math.PI / 2);
  geometry2.rotateX(Math.PI / 2);
  return geometry2;
}
var vectorHelper9 = new Vector313();
var RotateHandles = class extends Group7 {
  context;
  fixed;
  size;
  rotationX;
  rotationY;
  rotationZ;
  free;
  screen;
  constructor(context, fixed, size) {
    super();
    this.context = context;
    this.fixed = fixed;
    this.size = size;
    this.rotationX = new AxisRotateHandle(this.context, "x");
    this.add(this.rotationX);
    this.rotationY = new AxisRotateHandle(this.context, "y");
    this.add(this.rotationY);
    this.rotationZ = new AxisRotateHandle(this.context, "z");
    this.add(this.rotationZ);
    this.free = new FreeRotateHandle(this.context);
    this.add(this.free);
    this.screen = new ScreenSpaceRotateHandle(this.context);
    this.add(this.screen);
  }
  update(camera) {
    this.updateWorldMatrix(true, false);
    this.rotationX.update(camera);
    this.rotationY.update(camera);
    this.rotationZ.update(camera);
    this.free.update(camera);
    this.screen.update(camera);
    this.scale.setScalar(1);
    const target = this.context.getTarget();
    if (target != null) {
      target.getWorldScale(vectorHelper9);
      this.scale.divide(vectorHelper9);
    }
    this.scale.multiplyScalar(computeHandlesScale(this, camera, this.fixed ?? true, this.size ?? 1));
  }
  bind(options) {
    const unbindTranslationX = this.rotationX.bind(16711680, options);
    const unbindTranslationY = this.rotationY.bind(65280, options);
    const unbindTranslationZ = this.rotationZ.bind(255, options);
    const unbindScreen = this.screen.bind(options);
    const unbindFree = this.free.bind(options);
    return () => {
      unbindTranslationX?.();
      unbindTranslationY?.();
      unbindTranslationZ?.();
      unbindScreen?.();
      unbindFree?.();
    };
  }
};

// node_modules/@pmndrs/handle/dist/handles/transform.js
import { Euler as Euler9, Group as Group8 } from "three";
var xRotationOffset2 = new Euler9();
var yRotationOffset2 = new Euler9(0, 0, Math.PI / 2);
var zRotationOffset2 = new Euler9(0, -Math.PI / 2, 0);
var TransformHandles = class extends Group8 {
  xAxisHighlight;
  yAxisHighlight;
  zAxisHighlight;
  handles;
  context;
  constructor(getOptions) {
    super();
    this.context = new HandlesContext(this, getOptions);
    this.xAxisHighlight = new HandlesAxisHighlight(this.context, xRotationOffset2);
    this.add(this.xAxisHighlight);
    this.yAxisHighlight = new HandlesAxisHighlight(this.context, yRotationOffset2);
    this.add(this.yAxisHighlight);
    this.zAxisHighlight = new HandlesAxisHighlight(this.context, zRotationOffset2);
    this.add(this.zAxisHighlight);
  }
  set space(space3) {
    this.context.space = space3;
  }
  get space() {
    return this.context.space;
  }
  update(time, camera) {
    this.context.update(time);
    this.xAxisHighlight.update();
    this.yAxisHighlight.update();
    this.zAxisHighlight.update();
    this.handles?.update(camera);
  }
  bind(mode, options) {
    const unbindXAxisHighlight = this.xAxisHighlight.bind("x");
    const unbindYAxisHighlight = this.yAxisHighlight.bind("y");
    const unbindZAxisHighlight = this.zAxisHighlight.bind("z");
    switch (mode) {
      case "rotate":
        this.handles = new RotateHandles(this.context);
        break;
      case "scale":
        this.handles = new ScaleHandles(this.context);
        break;
      case "translate":
        this.handles = new TranslateHandles(this.context);
        break;
    }
    this.add(this.handles);
    const unbind = this.handles.bind(options);
    return () => {
      if (this.handles != null) {
        this.remove(this.handles);
      }
      this.handles = void 0;
      unbind();
      unbindXAxisHighlight();
      unbindYAxisHighlight();
      unbindZAxisHighlight();
    };
  }
};

// node_modules/@pmndrs/handle/dist/screen/camera.js
import { ArrayCamera, Euler as Euler10, Object3D as Object3D3, Quaternion as Quaternion12, Vector3 as Vector314 } from "three";
import { damp } from "three/src/math/MathUtils.js";
var zAxis2 = new Vector314(0, 0, 1);
var yAxis = new Vector314(0, 1, 0);
var v1Helper2 = new Vector314();
var v2Helper2 = new Vector314();
var eHelper2 = new Euler10();
var qHelper3 = new Quaternion12();
var vectorHelper10 = new Vector314();
var yToUpHelper = new Quaternion12();
var upToYHelper = new Quaternion12();

// node_modules/@pmndrs/handle/dist/screen/store.js
import { Vector2 } from "three";

// node_modules/@pmndrs/handle/dist/screen/pan.js
import { Vector2 as Vector23, Vector3 as Vector316 } from "three";

// node_modules/@pmndrs/handle/dist/screen/utils.js
import { PerspectiveCamera, Quaternion as Quaternion13, Vector2 as Vector22, Vector3 as Vector315 } from "three";
var vector2Helper4 = new Vector22();
var quaternionHelper8 = new Quaternion13();
var vectorHelper11 = new Vector315();
var forwardHelper = new Vector315();
var upwardHelper = new Vector315();

// node_modules/@pmndrs/handle/dist/screen/pan.js
var vector2Helper5 = new Vector23();
var initialHelper = new Vector23();
var resultHelper = new Vector316();

// node_modules/@pmndrs/handle/dist/screen/zoom.js
import { Vector2 as Vector24, Vector3 as Vector317 } from "three";
var resultHelper2 = new Vector317();
var centerHelper = new Vector24();
var vector2Helper6 = new Vector24();

// node_modules/@pmndrs/handle/dist/screen/rotate.js
import { PerspectiveCamera as PerspectiveCamera2, Vector2 as Vector25 } from "three";
var vector2Helper7 = new Vector25();
var initialHelper2 = new Vector25();

// node_modules/@pmndrs/handle/dist/screen/orbit.js
import { Vector3 as Vector318 } from "three";
import { clamp as clamp2 } from "three/src/math/MathUtils.js";
var vectorHelper14 = new Vector318();

// node_modules/@pmndrs/handle/dist/screen/map.js
import { Vector3 as Vector319 } from "three";
import { clamp as clamp3 } from "three/src/math/MathUtils.js";
var vectorHelper15 = new Vector319();

// node_modules/@iwer/devui/lib/scene.js
var PRIVATE = Symbol("@@iwer/devui/input-scene");
var FREE_MOVEMENT_SPEED = 2;
var InputLayer = class {
  constructor(xrDevice) {
    this.xrDevice = xrDevice;
    this.combinedCameraPosition = new Vector320();
    this.isPointerLocked = false;
    this.vec3 = new Vector320();
    this.quat = new Quaternion14();
    this.keyState = {
      ShiftLeft: false,
      KeyW: false,
      KeyA: false,
      KeyS: false,
      KeyD: false,
      ArrowUp: false,
      ArrowDown: false
    };
    this.lastTime = 0;
    this.scene = new Scene();
    this.camera = new PerspectiveCamera3(50, window.innerWidth / window.innerHeight, 0.1, 40);
    this.playerRig = new Group9();
    this.cameraRig = new Group9();
    this.scene.add(this.playerRig);
    this.playerRig.add(this.cameraRig);
    this.cameraRig.position.fromArray(xrDevice.position.vec3);
    this.cameraRig.quaternion.fromArray(xrDevice.quaternion.quat);
    this.cameraRig.add(this.camera);
    this.camera.position.x -= xrDevice.ipd / 2;
    const spaceOriginIndicator = new Mesh13(new RingGeometry(0.25, 0.27, 32), new MeshBasicMaterial13({
      color: 16777215,
      side: FrontSide
    }));
    spaceOriginIndicator.rotateX(-Math.PI / 2);
    this.scene.add(spaceOriginIndicator);
    this.renderer = new WebGLRenderer({ alpha: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setClearColor(0, 0);
    this.renderer.domElement.style.position = "fixed";
    this.renderer.domElement.style.top = "50vh";
    this.renderer.domElement.style.left = "50vw";
    this.renderer.domElement.style.transform = "translate(-50%, -50%)";
    this.transformHandles = /* @__PURE__ */ new Map();
    ["left", "right"].forEach((handedness) => {
      const transformHandle = new TransformHandles();
      transformHandle.scale.setScalar(0.1);
      transformHandle.position.fromArray(xrDevice.controllers[handedness].position.vec3);
      transformHandle.quaternion.fromArray(xrDevice.controllers[handedness].quaternion.quat);
      this.cameraRig.attach(transformHandle);
      transformHandle.userData = {
        defaultPosition: transformHandle.position.toArray(),
        defaultQuaternion: transformHandle.quaternion.toArray()
      };
      transformHandle.userData.setMode = (mode) => {
        var _a2, _b;
        (_b = (_a2 = transformHandle.userData).modeCleanup) === null || _b === void 0 ? void 0 : _b.call(_a2);
        transformHandle.userData.modeCleanup = transformHandle.bind(mode);
        transformHandle.userData.mode = mode;
      };
      transformHandle.userData.setMode("translate");
      transformHandle.space = "local";
      this.transformHandles.set(handedness, transformHandle);
      transformHandle.addEventListener("click", () => {
        if (transformHandle.userData.mode === "translate") {
          transformHandle.userData.setMode("rotate");
        } else {
          transformHandle.userData.setMode("translate");
        }
      });
    });
    window.transformHandles = this.transformHandles;
    this.mouseMoveHandler = (event) => {
      if (!this.isPointerLocked)
        return;
      const movementX = (
        // @ts-ignore
        event.movementX || event.mozMovementX || event.webkitMovementX || 0
      );
      const movementY = (
        // @ts-ignore
        event.movementY || event.mozMovementY || event.webkitMovementY || 0
      );
      this.playerRig.rotation.y -= movementX * 2e-3;
      this.cameraRig.rotation.x -= movementY * 2e-3;
      xrDevice.quaternion.copy(this.cameraRig.getWorldQuaternion(new Quaternion14()));
    };
    this.cameraRig.getWorldPosition(this.combinedCameraPosition);
    this.headsetDefaultPosition = this.cameraRig.position.clone();
    this.headsetDefaultQuaternion = this.cameraRig.quaternion.clone();
    this.forwardHtmlEvents = forwardHtmlEvents(this.renderer.domElement, () => this.camera, this.scene).update;
    document.addEventListener("pointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.addEventListener("mozpointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.addEventListener("webkitpointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.addEventListener("keydown", this.keyDownHandler.bind(this), false);
    document.addEventListener("keyup", this.keyUpHandler.bind(this), false);
  }
  lockPointer() {
    this.renderer.domElement.requestPointerLock = this.renderer.domElement.requestPointerLock || // @ts-ignore
    this.renderer.domElement.mozRequestPointerLock || // @ts-ignore
    this.renderer.domElement.webkitRequestPointerLock;
    this.renderer.domElement.requestPointerLock();
  }
  pointerLockChangeHandler() {
    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement || // @ts-ignore
    document.mozPointerLockElement === this.renderer.domElement || // @ts-ignore
    document.webkitPointerLockElement === this.renderer.domElement;
    if (this.isPointerLocked) {
      document.addEventListener("mousemove", this.mouseMoveHandler, false);
      Object.values(this.transformHandles).forEach((transformHandle) => {
        transformHandle.visible = false;
      });
    } else {
      document.removeEventListener("mousemove", this.mouseMoveHandler, false);
      Object.values(this.transformHandles).forEach((transformHandle) => {
        transformHandle.visible = true;
      });
    }
  }
  keyDownHandler(event) {
    const { keyState } = this;
    if (event.code in keyState) {
      keyState[event.code] = true;
    }
    if (keyState.ShiftLeft && keyState.ArrowUp) {
      this.cameraRig.position.y += 0.05;
    }
    if (keyState.ShiftLeft && keyState.ArrowDown) {
      this.cameraRig.position.y -= 0.05;
    }
  }
  keyUpHandler(event) {
    const { keyState } = this;
    if (event.code in keyState) {
      keyState[event.code] = false;
    }
  }
  movePlayerRig(delta) {
    const { playerRig, keyState, vec3 } = this;
    vec3.set((keyState.KeyD ? 1 : 0) - (keyState.KeyA ? 1 : 0), 0, (keyState.KeyS ? 1 : 0) - (keyState.KeyW ? 1 : 0));
    if (vec3.lengthSq() > 0 && keyState.ShiftLeft) {
      vec3.normalize().multiplyScalar(FREE_MOVEMENT_SPEED * delta).applyQuaternion(playerRig.quaternion);
      playerRig.position.add(vec3);
    }
  }
  resetDeviceTransforms() {
    const { playerRig, cameraRig, transformHandles } = this;
    cameraRig.position.copy(this.headsetDefaultPosition);
    cameraRig.quaternion.copy(this.headsetDefaultQuaternion);
    playerRig.position.set(0, 0, 0);
    playerRig.quaternion.set(0, 0, 0, 1);
    transformHandles.forEach((transformHandle) => {
      transformHandle.position.fromArray(transformHandle.userData.defaultPosition);
      transformHandle.quaternion.fromArray(transformHandle.userData.defaultQuaternion);
    });
  }
  syncDeviceTransforms() {
    const { xrDevice, cameraRig, transformHandles } = this;
    xrDevice.position.copy(cameraRig.getWorldPosition(this.vec3));
    xrDevice.quaternion.copy(cameraRig.getWorldQuaternion(this.quat));
    transformHandles.forEach((transformHandle, handedness) => {
      const emulatedInput = xrDevice.primaryInputMode === "controller" ? xrDevice.controllers[handedness] : xrDevice.hands[handedness];
      emulatedInput.position.copy(transformHandle.getWorldPosition(this.vec3));
      emulatedInput.quaternion.copy(transformHandle.getWorldQuaternion(this.quat));
    });
  }
  renderScene(time) {
    const xrDeviceFOV = this.xrDevice.fovy / Math.PI * 180;
    let cameraMatrixNeedsUpdate = false;
    if (this.camera.fov !== xrDeviceFOV) {
      this.camera.fov = xrDeviceFOV;
      cameraMatrixNeedsUpdate = true;
    }
    const iwerCanvasDimension = this.xrDevice.canvasDimensions;
    if (iwerCanvasDimension) {
      const canvas = this.renderer.domElement;
      const resizeNeeded = canvas.width !== iwerCanvasDimension.width || canvas.height !== iwerCanvasDimension.height;
      if (resizeNeeded) {
        this.camera.aspect = iwerCanvasDimension.width / iwerCanvasDimension.height;
        this.renderer.setSize(iwerCanvasDimension.width, iwerCanvasDimension.height);
        cameraMatrixNeedsUpdate = true;
      }
    }
    if (cameraMatrixNeedsUpdate) {
      this.camera.updateProjectionMatrix();
    }
    if (!this.isPointerLocked) {
      this.cameraRig.position.y = this.combinedCameraPosition.y;
      this.playerRig.position.x = this.combinedCameraPosition.x;
      this.playerRig.position.z = this.combinedCameraPosition.z;
    } else {
      this.cameraRig.getWorldPosition(this.combinedCameraPosition);
    }
    this.forwardHtmlEvents();
    this.transformHandles.forEach((transformHandle, handedness) => {
      var _a2;
      const connected = Boolean((_a2 = this.xrDevice.controllers[handedness]) === null || _a2 === void 0 ? void 0 : _a2.connected);
      transformHandle.visible = connected && !this.isPointerLocked;
      if (connected) {
        transformHandle.update(time, this.camera);
      }
    });
    const delta = Math.min((time - this.lastTime) / 1e3, 0.1);
    this.movePlayerRig(delta);
    this.syncDeviceTransforms();
    this.renderer.render(this.scene, this.camera);
    this.lastTime = time;
  }
  get domElement() {
    return this.renderer.domElement;
  }
  dispose() {
    this.renderer.dispose();
    document.removeEventListener("pointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.removeEventListener("mozpointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.removeEventListener("webkitpointerlockchange", this.pointerLockChangeHandler.bind(this), false);
    document.removeEventListener("mousemove", this.mouseMoveHandler, false);
    document.removeEventListener("keydown", this.keyDownHandler.bind(this), false);
    document.removeEventListener("keyup", this.keyUpHandler.bind(this), false);
  }
};

// node_modules/@iwer/devui/lib/version.js
var VERSION = "1.1.1";

// node_modules/@iwer/devui/lib/index.js
var import_client = __toESM(require_client());
var DevUI = class {
  constructor(xrDevice) {
    this.version = VERSION;
    xrDevice.ipd = 0;
    useInputModeStore.getState().setInputMode(xrDevice.primaryInputMode);
    this.devUIContainer = document.createElement("div");
    this.devUIContainer.style.position = "fixed";
    this.devUIContainer.style.width = "100vw";
    this.devUIContainer.style.height = "100vh";
    this.devUIContainer.style.top = "50vh";
    this.devUIContainer.style.left = "50vw";
    this.devUIContainer.style.transform = "translate(-50%, -50%)";
    this.devUIContainer.style.pointerEvents = "none";
    const devUIShadowRoot = this.devUIContainer.attachShadow({
      mode: "open"
    });
    this.inputLayer = new InputLayer(xrDevice);
    const root = (0, import_client.createRoot)(devUIShadowRoot);
    root.render((0, import_jsx_runtime15.jsx)(Overlay, { xrDevice, inputLayer: this.inputLayer, shadowRoot: devUIShadowRoot }));
    const installOfferSessionUI = () => {
      const offerSessionUIContainer = document.createElement("div");
      document.body.appendChild(offerSessionUIContainer);
      const offerSessionShadowRoot = offerSessionUIContainer.attachShadow({
        mode: "open"
      });
      const offerSessionRoot = (0, import_client.createRoot)(offerSessionShadowRoot);
      offerSessionRoot.render((0, import_jsx_runtime15.jsx)(OfferSessionUI, { xrDevice, shadowRoot: offerSessionShadowRoot }));
    };
    if (document.body) {
      installOfferSessionUI();
    } else {
      window.onload = installOfferSessionUI;
    }
  }
  render(time) {
    this.inputLayer.renderScene(time);
  }
  get devUICanvas() {
    return this.inputLayer.domElement;
  }
};
var Overlay = ({ xrDevice, inputLayer, shadowRoot }) => {
  const [pointerLocked, setPointerLocked] = (0, import_react14.useState)(false);
  (0, import_react14.useEffect)(() => {
    const pointerLockChangeHandler = () => {
      const locked = document.pointerLockElement || // @ts-ignore
      document.mozPointerLockElement || // @ts-ignore
      document.webkitPointerLockElement;
      setPointerLocked(!!locked);
    };
    document.addEventListener("pointerlockchange", pointerLockChangeHandler, false);
    document.addEventListener("mozpointerlockchange", pointerLockChangeHandler, false);
    document.addEventListener("webkitpointerlockchange", pointerLockChangeHandler, false);
    return () => {
      document.removeEventListener("pointerlockchange", pointerLockChangeHandler, false);
      document.removeEventListener("mozpointerlockchange", pointerLockChangeHandler, false);
      document.removeEventListener("webkitpointerlockchange", pointerLockChangeHandler, false);
    };
  }, []);
  return (0, import_jsx_runtime15.jsx)(Ye, { target: shadowRoot, disableCSSOMInjection: true, children: (0, import_jsx_runtime15.jsxs)("div", { style: {
    width: "100vw",
    height: "100vh",
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-between",
    pointerEvents: "none"
  }, children: [(0, import_jsx_runtime15.jsx)(HeaderUI, { xrDevice, inputLayer }), (0, import_jsx_runtime15.jsx)(HeadsetUI, { xrDevice, inputLayer, pointerLocked }), (0, import_jsx_runtime15.jsx)(ControlsUI, { xrDevice, inputLayer, pointerLocked })] }) });
};
var OfferSessionUI = ({ xrDevice, shadowRoot }) => {
  const [showOffer, setShowOffer] = import_react14.default.useState(xrDevice.sessionOffered && !xrDevice.activeSession);
  import_react14.default.useEffect(() => {
    setInterval(() => {
      setShowOffer(xrDevice.sessionOffered && !xrDevice.activeSession);
    }, 1e3);
  }, []);
  return (0, import_jsx_runtime15.jsx)(Ye, { target: shadowRoot, disableCSSOMInjection: true, children: (0, import_jsx_runtime15.jsxs)(HeaderButtonsContainer, { style: {
    zIndex: 899,
    position: "fixed",
    top: showOffer ? "8px" : "-30px",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyItems: "space-between",
    left: "50vw",
    transform: "translateX(-50%)",
    transition: "all 0.2s ease-in-out",
    paddingLeft: "5px",
    gap: "3px"
  }, children: [(0, import_jsx_runtime15.jsx)(IWERIcon, { size: 24 }), (0, import_jsx_runtime15.jsx)(HeaderButton, { onClick: () => {
    xrDevice.grantOfferedSession();
  }, style: {
    fontSize: "16px"
  }, children: "Enter XR" })] }) });
};

// node_modules/@iwer/sem/lib/native/entity.js
import { Mesh as Mesh14, MeshMatcapMaterial } from "three";

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";
function round2(a3) {
  if (a3 >= 0) return Math.round(a3);
  return a3 % 0.5 === 0 ? Math.floor(a3) : Math.round(a3);
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

// node_modules/gl-matrix/esm/mat3.js
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy2,
  create: () => create3,
  decompose: () => decompose,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromQuat: () => fromQuat,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity,
  invert: () => invert,
  lookAt: () => lookAt,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  targetTo: () => targetTo,
  translate: () => translate,
  transpose: () => transpose
});
function create3() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone(a3) {
  var out = new ARRAY_TYPE(16);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  out[9] = a3[9];
  out[10] = a3[10];
  out[11] = a3[11];
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function copy2(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  out[4] = a3[4];
  out[5] = a3[5];
  out[6] = a3[6];
  out[7] = a3[7];
  out[8] = a3[8];
  out[9] = a3[9];
  out[10] = a3[10];
  out[11] = a3[11];
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a3) {
  if (out === a3) {
    var a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a12 = a3[6], a13 = a3[7];
    var a23 = a3[11];
    out[1] = a3[4];
    out[2] = a3[8];
    out[3] = a3[12];
    out[4] = a01;
    out[6] = a3[9];
    out[7] = a3[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a3[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a3[0];
    out[1] = a3[4];
    out[2] = a3[8];
    out[3] = a3[12];
    out[4] = a3[1];
    out[5] = a3[5];
    out[6] = a3[9];
    out[7] = a3[13];
    out[8] = a3[2];
    out[9] = a3[6];
    out[10] = a3[10];
    out[11] = a3[14];
    out[12] = a3[3];
    out[13] = a3[7];
    out[14] = a3[11];
    out[15] = a3[15];
  }
  return out;
}
function invert(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant(a3) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b0 = a00 * a11 - a01 * a10;
  var b1 = a00 * a12 - a02 * a10;
  var b2 = a01 * a12 - a02 * a11;
  var b3 = a20 * a31 - a21 * a30;
  var b4 = a20 * a32 - a22 * a30;
  var b5 = a21 * a32 - a22 * a31;
  var b6 = a00 * b5 - a01 * b4 + a02 * b3;
  var b7 = a10 * b5 - a11 * b4 + a12 * b3;
  var b8 = a20 * b2 - a21 * b1 + a22 * b0;
  var b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply(out, a3, b) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a3, v2) {
  var x2 = v2[0], y3 = v2[1], z2 = v2[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a3 === out) {
    out[12] = a3[0] * x2 + a3[4] * y3 + a3[8] * z2 + a3[12];
    out[13] = a3[1] * x2 + a3[5] * y3 + a3[9] * z2 + a3[13];
    out[14] = a3[2] * x2 + a3[6] * y3 + a3[10] * z2 + a3[14];
    out[15] = a3[3] * x2 + a3[7] * y3 + a3[11] * z2 + a3[15];
  } else {
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y3 + a20 * z2 + a3[12];
    out[13] = a01 * x2 + a11 * y3 + a21 * z2 + a3[13];
    out[14] = a02 * x2 + a12 * y3 + a22 * z2 + a3[14];
    out[15] = a03 * x2 + a13 * y3 + a23 * z2 + a3[15];
  }
  return out;
}
function scale(out, a3, v2) {
  var x2 = v2[0], y3 = v2[1], z2 = v2[2];
  out[0] = a3[0] * x2;
  out[1] = a3[1] * x2;
  out[2] = a3[2] * x2;
  out[3] = a3[3] * x2;
  out[4] = a3[4] * y3;
  out[5] = a3[5] * y3;
  out[6] = a3[6] * y3;
  out[7] = a3[7] * y3;
  out[8] = a3[8] * z2;
  out[9] = a3[9] * z2;
  out[10] = a3[10] * z2;
  out[11] = a3[11] * z2;
  out[12] = a3[12];
  out[13] = a3[13];
  out[14] = a3[14];
  out[15] = a3[15];
  return out;
}
function rotate(out, a3, rad, axis) {
  var x2 = axis[0], y3 = axis[1], z2 = axis[2];
  var len4 = Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
  var s2, c3, t2;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y3 *= len4;
  z2 *= len4;
  s2 = Math.sin(rad);
  c3 = Math.cos(rad);
  t2 = 1 - c3;
  a00 = a3[0];
  a01 = a3[1];
  a02 = a3[2];
  a03 = a3[3];
  a10 = a3[4];
  a11 = a3[5];
  a12 = a3[6];
  a13 = a3[7];
  a20 = a3[8];
  a21 = a3[9];
  a22 = a3[10];
  a23 = a3[11];
  b00 = x2 * x2 * t2 + c3;
  b01 = y3 * x2 * t2 + z2 * s2;
  b02 = z2 * x2 * t2 - y3 * s2;
  b10 = x2 * y3 * t2 - z2 * s2;
  b11 = y3 * y3 * t2 + c3;
  b12 = z2 * y3 * t2 + x2 * s2;
  b20 = x2 * z2 * t2 + y3 * s2;
  b21 = y3 * z2 * t2 - x2 * s2;
  b22 = z2 * z2 * t2 + c3;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a3 !== out) {
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  return out;
}
function rotateX(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a10 = a3[4];
  var a11 = a3[5];
  var a12 = a3[6];
  var a13 = a3[7];
  var a20 = a3[8];
  var a21 = a3[9];
  var a22 = a3[10];
  var a23 = a3[11];
  if (a3 !== out) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[4] = a10 * c3 + a20 * s2;
  out[5] = a11 * c3 + a21 * s2;
  out[6] = a12 * c3 + a22 * s2;
  out[7] = a13 * c3 + a23 * s2;
  out[8] = a20 * c3 - a10 * s2;
  out[9] = a21 * c3 - a11 * s2;
  out[10] = a22 * c3 - a12 * s2;
  out[11] = a23 * c3 - a13 * s2;
  return out;
}
function rotateY(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a03 = a3[3];
  var a20 = a3[8];
  var a21 = a3[9];
  var a22 = a3[10];
  var a23 = a3[11];
  if (a3 !== out) {
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[0] = a00 * c3 - a20 * s2;
  out[1] = a01 * c3 - a21 * s2;
  out[2] = a02 * c3 - a22 * s2;
  out[3] = a03 * c3 - a23 * s2;
  out[8] = a00 * s2 + a20 * c3;
  out[9] = a01 * s2 + a21 * c3;
  out[10] = a02 * s2 + a22 * c3;
  out[11] = a03 * s2 + a23 * c3;
  return out;
}
function rotateZ(out, a3, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  var a00 = a3[0];
  var a01 = a3[1];
  var a02 = a3[2];
  var a03 = a3[3];
  var a10 = a3[4];
  var a11 = a3[5];
  var a12 = a3[6];
  var a13 = a3[7];
  if (a3 !== out) {
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
  }
  out[0] = a00 * c3 + a10 * s2;
  out[1] = a01 * c3 + a11 * s2;
  out[2] = a02 * c3 + a12 * s2;
  out[3] = a03 * c3 + a13 * s2;
  out[4] = a10 * c3 - a00 * s2;
  out[5] = a11 * c3 - a01 * s2;
  out[6] = a12 * c3 - a02 * s2;
  out[7] = a13 * c3 - a03 * s2;
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x2 = axis[0], y3 = axis[1], z2 = axis[2];
  var len4 = Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
  var s2, c3, t2;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y3 *= len4;
  z2 *= len4;
  s2 = Math.sin(rad);
  c3 = Math.cos(rad);
  t2 = 1 - c3;
  out[0] = x2 * x2 * t2 + c3;
  out[1] = y3 * x2 * t2 + z2 * s2;
  out[2] = z2 * x2 * t2 - y3 * s2;
  out[3] = 0;
  out[4] = x2 * y3 * t2 - z2 * s2;
  out[5] = y3 * y3 * t2 + c3;
  out[6] = z2 * y3 * t2 + x2 * s2;
  out[7] = 0;
  out[8] = x2 * z2 * t2 + y3 * s2;
  out[9] = y3 * z2 * t2 - x2 * s2;
  out[10] = z2 * z2 * t2 + c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c3;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c3;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c3 = Math.cos(rad);
  out[0] = c3;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c3;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  var x2 = q2[0], y3 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a3) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a3, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S2;
    out_r[0] = (sm23 - sm32) / S2;
    out_r[1] = (sm31 - sm13) / S2;
    out_r[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S2;
    out_r[0] = 0.25 * S2;
    out_r[1] = (sm12 + sm21) / S2;
    out_r[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S2;
    out_r[0] = (sm12 + sm21) / S2;
    out_r[1] = 0.25 * S2;
    out_r[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S2;
    out_r[0] = (sm31 + sm13) / S2;
    out_r[1] = (sm23 + sm32) / S2;
    out_r[2] = 0.25 * S2;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  var x2 = q2[0], y3 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o3) {
  var x2 = q2[0], y3 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y3 * y22;
  var yz = y3 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o3[0];
  var oy = o3[1];
  var oz = o3[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q2) {
  var x2 = q2[0], y3 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt2;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt2;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y22, z0, z1, z2, len4;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len4 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len4;
  z1 *= len4;
  z2 *= len4;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len4 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y22 = z0 * x1 - z1 * x0;
  len4 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y22 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y22 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len4 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str(a3) {
  return "mat4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ", " + a3[9] + ", " + a3[10] + ", " + a3[11] + ", " + a3[12] + ", " + a3[13] + ", " + a3[14] + ", " + a3[15] + ")";
}
function frob(a3) {
  return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8] + a3[9] * a3[9] + a3[10] * a3[10] + a3[11] * a3[11] + a3[12] * a3[12] + a3[13] * a3[13] + a3[14] * a3[14] + a3[15] * a3[15]);
}
function add(out, a3, b) {
  out[0] = a3[0] + b[0];
  out[1] = a3[1] + b[1];
  out[2] = a3[2] + b[2];
  out[3] = a3[3] + b[3];
  out[4] = a3[4] + b[4];
  out[5] = a3[5] + b[5];
  out[6] = a3[6] + b[6];
  out[7] = a3[7] + b[7];
  out[8] = a3[8] + b[8];
  out[9] = a3[9] + b[9];
  out[10] = a3[10] + b[10];
  out[11] = a3[11] + b[11];
  out[12] = a3[12] + b[12];
  out[13] = a3[13] + b[13];
  out[14] = a3[14] + b[14];
  out[15] = a3[15] + b[15];
  return out;
}
function subtract(out, a3, b) {
  out[0] = a3[0] - b[0];
  out[1] = a3[1] - b[1];
  out[2] = a3[2] - b[2];
  out[3] = a3[3] - b[3];
  out[4] = a3[4] - b[4];
  out[5] = a3[5] - b[5];
  out[6] = a3[6] - b[6];
  out[7] = a3[7] - b[7];
  out[8] = a3[8] - b[8];
  out[9] = a3[9] - b[9];
  out[10] = a3[10] - b[10];
  out[11] = a3[11] - b[11];
  out[12] = a3[12] - b[12];
  out[13] = a3[13] - b[13];
  out[14] = a3[14] - b[14];
  out[15] = a3[15] - b[15];
  return out;
}
function multiplyScalar(out, a3, b) {
  out[0] = a3[0] * b;
  out[1] = a3[1] * b;
  out[2] = a3[2] * b;
  out[3] = a3[3] * b;
  out[4] = a3[4] * b;
  out[5] = a3[5] * b;
  out[6] = a3[6] * b;
  out[7] = a3[7] * b;
  out[8] = a3[8] * b;
  out[9] = a3[9] * b;
  out[10] = a3[10] * b;
  out[11] = a3[11] * b;
  out[12] = a3[12] * b;
  out[13] = a3[13] * b;
  out[14] = a3[14] * b;
  out[15] = a3[15] * b;
  return out;
}
function multiplyScalarAndAdd(out, a3, b, scale5) {
  out[0] = a3[0] + b[0] * scale5;
  out[1] = a3[1] + b[1] * scale5;
  out[2] = a3[2] + b[2] * scale5;
  out[3] = a3[3] + b[3] * scale5;
  out[4] = a3[4] + b[4] * scale5;
  out[5] = a3[5] + b[5] * scale5;
  out[6] = a3[6] + b[6] * scale5;
  out[7] = a3[7] + b[7] * scale5;
  out[8] = a3[8] + b[8] * scale5;
  out[9] = a3[9] + b[9] * scale5;
  out[10] = a3[10] + b[10] * scale5;
  out[11] = a3[11] + b[11] * scale5;
  out[12] = a3[12] + b[12] * scale5;
  out[13] = a3[13] + b[13] * scale5;
  out[14] = a3[14] + b[14] * scale5;
  out[15] = a3[15] + b[15] * scale5;
  return out;
}
function exactEquals(a3, b) {
  return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3] && a3[4] === b[4] && a3[5] === b[5] && a3[6] === b[6] && a3[7] === b[7] && a3[8] === b[8] && a3[9] === b[9] && a3[10] === b[10] && a3[11] === b[11] && a3[12] === b[12] && a3[13] === b[13] && a3[14] === b[14] && a3[15] === b[15];
}
function equals(a3, b) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7];
  var a8 = a3[8], a9 = a3[9], a10 = a3[10], a11 = a3[11];
  var a12 = a3[12], a13 = a3[13], a14 = a3[14], a15 = a3[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add4,
  calculateW: () => calculateW,
  clone: () => clone4,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create6,
  dot: () => dot3,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues4,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert2,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul4,
  multiply: () => multiply4,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale4,
  set: () => set4,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str4
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy3,
  create: () => create4,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length2,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round3,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create4() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a3) {
  var out = new ARRAY_TYPE(3);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  return out;
}
function length2(a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  return Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
}
function fromValues2(x2, y3, z2) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y3;
  out[2] = z2;
  return out;
}
function copy3(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  return out;
}
function set2(out, x2, y3, z2) {
  out[0] = x2;
  out[1] = y3;
  out[2] = z2;
  return out;
}
function add2(out, a3, b) {
  out[0] = a3[0] + b[0];
  out[1] = a3[1] + b[1];
  out[2] = a3[2] + b[2];
  return out;
}
function subtract2(out, a3, b) {
  out[0] = a3[0] - b[0];
  out[1] = a3[1] - b[1];
  out[2] = a3[2] - b[2];
  return out;
}
function multiply2(out, a3, b) {
  out[0] = a3[0] * b[0];
  out[1] = a3[1] * b[1];
  out[2] = a3[2] * b[2];
  return out;
}
function divide(out, a3, b) {
  out[0] = a3[0] / b[0];
  out[1] = a3[1] / b[1];
  out[2] = a3[2] / b[2];
  return out;
}
function ceil(out, a3) {
  out[0] = Math.ceil(a3[0]);
  out[1] = Math.ceil(a3[1]);
  out[2] = Math.ceil(a3[2]);
  return out;
}
function floor(out, a3) {
  out[0] = Math.floor(a3[0]);
  out[1] = Math.floor(a3[1]);
  out[2] = Math.floor(a3[2]);
  return out;
}
function min(out, a3, b) {
  out[0] = Math.min(a3[0], b[0]);
  out[1] = Math.min(a3[1], b[1]);
  out[2] = Math.min(a3[2], b[2]);
  return out;
}
function max(out, a3, b) {
  out[0] = Math.max(a3[0], b[0]);
  out[1] = Math.max(a3[1], b[1]);
  out[2] = Math.max(a3[2], b[2]);
  return out;
}
function round3(out, a3) {
  out[0] = round2(a3[0]);
  out[1] = round2(a3[1]);
  out[2] = round2(a3[2]);
  return out;
}
function scale2(out, a3, b) {
  out[0] = a3[0] * b;
  out[1] = a3[1] * b;
  out[2] = a3[2] * b;
  return out;
}
function scaleAndAdd(out, a3, b, scale5) {
  out[0] = a3[0] + b[0] * scale5;
  out[1] = a3[1] + b[1] * scale5;
  out[2] = a3[2] + b[2] * scale5;
  return out;
}
function distance(a3, b) {
  var x2 = b[0] - a3[0];
  var y3 = b[1] - a3[1];
  var z2 = b[2] - a3[2];
  return Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
}
function squaredDistance(a3, b) {
  var x2 = b[0] - a3[0];
  var y3 = b[1] - a3[1];
  var z2 = b[2] - a3[2];
  return x2 * x2 + y3 * y3 + z2 * z2;
}
function squaredLength(a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  return x2 * x2 + y3 * y3 + z2 * z2;
}
function negate(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  return out;
}
function inverse(out, a3) {
  out[0] = 1 / a3[0];
  out[1] = 1 / a3[1];
  out[2] = 1 / a3[2];
  return out;
}
function normalize(out, a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  var len4 = x2 * x2 + y3 * y3 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a3[0] * len4;
  out[1] = a3[1] * len4;
  out[2] = a3[2] * len4;
  return out;
}
function dot(a3, b) {
  return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
}
function cross(out, a3, b) {
  var ax = a3[0], ay = a3[1], az = a3[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a3, b, t2) {
  var ax = a3[0];
  var ay = a3[1];
  var az = a3[2];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  return out;
}
function slerp(out, a3, b, t2) {
  var angle2 = Math.acos(Math.min(Math.max(dot(a3, b), -1), 1));
  var sinTotal = Math.sin(angle2);
  var ratioA = Math.sin((1 - t2) * angle2) / sinTotal;
  var ratioB = Math.sin(t2 * angle2) / sinTotal;
  out[0] = ratioA * a3[0] + ratioB * b[0];
  out[1] = ratioA * a3[1] + ratioB * b[1];
  out[2] = ratioA * a3[2] + ratioB * b[2];
  return out;
}
function hermite(out, a3, b, c3, d, t2) {
  var factorTimes2 = t2 * t2;
  var factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  var factor2 = factorTimes2 * (t2 - 2) + t2;
  var factor3 = factorTimes2 * (t2 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a3[0] * factor1 + b[0] * factor2 + c3[0] * factor3 + d[0] * factor4;
  out[1] = a3[1] * factor1 + b[1] * factor2 + c3[1] * factor3 + d[1] * factor4;
  out[2] = a3[2] * factor1 + b[2] * factor2 + c3[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a3, b, c3, d, t2) {
  var inverseFactor = 1 - t2;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t2 * t2;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t2 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t2;
  out[0] = a3[0] * factor1 + b[0] * factor2 + c3[0] * factor3 + d[0] * factor4;
  out[1] = a3[1] * factor1 + b[1] * factor2 + c3[1] * factor3 + d[1] * factor4;
  out[2] = a3[2] * factor1 + b[2] * factor2 + c3[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale5) {
  scale5 = scale5 === void 0 ? 1 : scale5;
  var r3 = RANDOM() * 2 * Math.PI;
  var z2 = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z2 * z2) * scale5;
  out[0] = Math.cos(r3) * zScale;
  out[1] = Math.sin(r3) * zScale;
  out[2] = z2 * scale5;
  return out;
}
function transformMat4(out, a3, m2) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2];
  var w2 = m2[3] * x2 + m2[7] * y3 + m2[11] * z2 + m2[15];
  w2 = w2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y3 + m2[8] * z2 + m2[12]) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y3 + m2[9] * z2 + m2[13]) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y3 + m2[10] * z2 + m2[14]) / w2;
  return out;
}
function transformMat3(out, a3, m2) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2];
  out[0] = x2 * m2[0] + y3 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y3 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y3 * m2[5] + z2 * m2[8];
  return out;
}
function transformQuat(out, a3, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var vx = a3[0], vy = a3[1], vz = a3[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX2(out, a3, b, rad) {
  var p2 = [], r3 = [];
  p2[0] = a3[0] - b[0];
  p2[1] = a3[1] - b[1];
  p2[2] = a3[2] - b[2];
  r3[0] = p2[0];
  r3[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r3[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r3[0] + b[0];
  out[1] = r3[1] + b[1];
  out[2] = r3[2] + b[2];
  return out;
}
function rotateY2(out, a3, b, rad) {
  var p2 = [], r3 = [];
  p2[0] = a3[0] - b[0];
  p2[1] = a3[1] - b[1];
  p2[2] = a3[2] - b[2];
  r3[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r3[1] = p2[1];
  r3[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r3[0] + b[0];
  out[1] = r3[1] + b[1];
  out[2] = r3[2] + b[2];
  return out;
}
function rotateZ2(out, a3, b, rad) {
  var p2 = [], r3 = [];
  p2[0] = a3[0] - b[0];
  p2[1] = a3[1] - b[1];
  p2[2] = a3[2] - b[2];
  r3[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r3[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r3[2] = p2[2];
  out[0] = r3[0] + b[0];
  out[1] = r3[1] + b[1];
  out[2] = r3[2] + b[2];
  return out;
}
function angle(a3, b) {
  var ax = a3[0], ay = a3[1], az = a3[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a3, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a3) {
  return "vec3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ")";
}
function exactEquals2(a3, b) {
  return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2];
}
function equals2(a3, b) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length2;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create4();
  return function(a3, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a3.length);
    } else {
      l2 = a3.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a3[i2];
      vec[1] = a3[i2 + 1];
      vec[2] = a3[i2 + 2];
      fn(vec, vec, arg);
      a3[i2] = vec[0];
      a3[i2 + 1] = vec[1];
      a3[i2 + 2] = vec[2];
    }
    return a3;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add3,
  ceil: () => ceil2,
  clone: () => clone3,
  copy: () => copy4,
  create: () => create5,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues3,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round4,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set3,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone3(a3) {
  var out = new ARRAY_TYPE(4);
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function fromValues3(x2, y3, z2, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y3;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy4(out, a3) {
  out[0] = a3[0];
  out[1] = a3[1];
  out[2] = a3[2];
  out[3] = a3[3];
  return out;
}
function set3(out, x2, y3, z2, w2) {
  out[0] = x2;
  out[1] = y3;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function add3(out, a3, b) {
  out[0] = a3[0] + b[0];
  out[1] = a3[1] + b[1];
  out[2] = a3[2] + b[2];
  out[3] = a3[3] + b[3];
  return out;
}
function subtract3(out, a3, b) {
  out[0] = a3[0] - b[0];
  out[1] = a3[1] - b[1];
  out[2] = a3[2] - b[2];
  out[3] = a3[3] - b[3];
  return out;
}
function multiply3(out, a3, b) {
  out[0] = a3[0] * b[0];
  out[1] = a3[1] * b[1];
  out[2] = a3[2] * b[2];
  out[3] = a3[3] * b[3];
  return out;
}
function divide2(out, a3, b) {
  out[0] = a3[0] / b[0];
  out[1] = a3[1] / b[1];
  out[2] = a3[2] / b[2];
  out[3] = a3[3] / b[3];
  return out;
}
function ceil2(out, a3) {
  out[0] = Math.ceil(a3[0]);
  out[1] = Math.ceil(a3[1]);
  out[2] = Math.ceil(a3[2]);
  out[3] = Math.ceil(a3[3]);
  return out;
}
function floor2(out, a3) {
  out[0] = Math.floor(a3[0]);
  out[1] = Math.floor(a3[1]);
  out[2] = Math.floor(a3[2]);
  out[3] = Math.floor(a3[3]);
  return out;
}
function min2(out, a3, b) {
  out[0] = Math.min(a3[0], b[0]);
  out[1] = Math.min(a3[1], b[1]);
  out[2] = Math.min(a3[2], b[2]);
  out[3] = Math.min(a3[3], b[3]);
  return out;
}
function max2(out, a3, b) {
  out[0] = Math.max(a3[0], b[0]);
  out[1] = Math.max(a3[1], b[1]);
  out[2] = Math.max(a3[2], b[2]);
  out[3] = Math.max(a3[3], b[3]);
  return out;
}
function round4(out, a3) {
  out[0] = round2(a3[0]);
  out[1] = round2(a3[1]);
  out[2] = round2(a3[2]);
  out[3] = round2(a3[3]);
  return out;
}
function scale3(out, a3, b) {
  out[0] = a3[0] * b;
  out[1] = a3[1] * b;
  out[2] = a3[2] * b;
  out[3] = a3[3] * b;
  return out;
}
function scaleAndAdd2(out, a3, b, scale5) {
  out[0] = a3[0] + b[0] * scale5;
  out[1] = a3[1] + b[1] * scale5;
  out[2] = a3[2] + b[2] * scale5;
  out[3] = a3[3] + b[3] * scale5;
  return out;
}
function distance2(a3, b) {
  var x2 = b[0] - a3[0];
  var y3 = b[1] - a3[1];
  var z2 = b[2] - a3[2];
  var w2 = b[3] - a3[3];
  return Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2);
}
function squaredDistance2(a3, b) {
  var x2 = b[0] - a3[0];
  var y3 = b[1] - a3[1];
  var z2 = b[2] - a3[2];
  var w2 = b[3] - a3[3];
  return x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2;
}
function length3(a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  return Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2);
}
function squaredLength2(a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  return x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2;
}
function negate2(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = -a3[3];
  return out;
}
function inverse2(out, a3) {
  out[0] = 1 / a3[0];
  out[1] = 1 / a3[1];
  out[2] = 1 / a3[2];
  out[3] = 1 / a3[3];
  return out;
}
function normalize2(out, a3) {
  var x2 = a3[0];
  var y3 = a3[1];
  var z2 = a3[2];
  var w2 = a3[3];
  var len4 = x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x2 * len4;
  out[1] = y3 * len4;
  out[2] = z2 * len4;
  out[3] = w2 * len4;
  return out;
}
function dot2(a3, b) {
  return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2] + a3[3] * b[3];
}
function cross2(out, u2, v2, w2) {
  var A2 = v2[0] * w2[1] - v2[1] * w2[0], B2 = v2[0] * w2[2] - v2[2] * w2[0], C2 = v2[0] * w2[3] - v2[3] * w2[0], D2 = v2[1] * w2[2] - v2[2] * w2[1], E2 = v2[1] * w2[3] - v2[3] * w2[1], F2 = v2[2] * w2[3] - v2[3] * w2[2];
  var G2 = u2[0];
  var H2 = u2[1];
  var I2 = u2[2];
  var J2 = u2[3];
  out[0] = H2 * F2 - I2 * E2 + J2 * D2;
  out[1] = -(G2 * F2) + I2 * C2 - J2 * B2;
  out[2] = G2 * E2 - H2 * C2 + J2 * A2;
  out[3] = -(G2 * D2) + H2 * B2 - I2 * A2;
  return out;
}
function lerp2(out, a3, b, t2) {
  var ax = a3[0];
  var ay = a3[1];
  var az = a3[2];
  var aw = a3[3];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  out[3] = aw + t2 * (b[3] - aw);
  return out;
}
function random2(out, scale5) {
  scale5 = scale5 === void 0 ? 1 : scale5;
  var v1, v2, v3, v4;
  var s1, s2;
  var rand;
  rand = RANDOM();
  v1 = rand * 2 - 1;
  v2 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s1 = v1 * v1 + v2 * v2;
  rand = RANDOM();
  v3 = rand * 2 - 1;
  v4 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s2 = v3 * v3 + v4 * v4;
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale5 * v1;
  out[1] = scale5 * v2;
  out[2] = scale5 * v3 * d;
  out[3] = scale5 * v4 * d;
  return out;
}
function transformMat42(out, a3, m2) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2], w2 = a3[3];
  out[0] = m2[0] * x2 + m2[4] * y3 + m2[8] * z2 + m2[12] * w2;
  out[1] = m2[1] * x2 + m2[5] * y3 + m2[9] * z2 + m2[13] * w2;
  out[2] = m2[2] * x2 + m2[6] * y3 + m2[10] * z2 + m2[14] * w2;
  out[3] = m2[3] * x2 + m2[7] * y3 + m2[11] * z2 + m2[15] * w2;
  return out;
}
function transformQuat2(out, a3, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var vx = a3[0], vy = a3[1], vz = a3[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  out[3] = a3[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str3(a3) {
  return "vec4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
}
function exactEquals3(a3, b) {
  return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3];
}
function equals3(a3, b) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length3;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create5();
  return function(a3, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a3.length);
    } else {
      l2 = a3.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a3[i2];
      vec[1] = a3[i2 + 1];
      vec[2] = a3[i2 + 2];
      vec[3] = a3[i2 + 3];
      fn(vec, vec, arg);
      a3[i2] = vec[0];
      a3[i2 + 1] = vec[1];
      a3[i2 + 2] = vec[2];
      a3[i2 + 3] = vec[3];
    }
    return a3;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create6() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q2) {
  var rad = Math.acos(q2[3]) * 2;
  var s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q2[0] / s2;
    out_axis[1] = q2[1] / s2;
    out_axis[2] = q2[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a3, b) {
  var dotproduct = dot3(a3, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply4(out, a3, b) {
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a3, rad) {
  rad *= 0.5;
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a3) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2];
  out[0] = x2;
  out[1] = y3;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y3 * y3 - z2 * z2));
  return out;
}
function exp(out, a3) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2], w2 = a3[3];
  var r3 = Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
  var et2 = Math.exp(w2);
  var s2 = r3 > 0 ? et2 * Math.sin(r3) / r3 : 0;
  out[0] = x2 * s2;
  out[1] = y3 * s2;
  out[2] = z2 * s2;
  out[3] = et2 * Math.cos(r3);
  return out;
}
function ln(out, a3) {
  var x2 = a3[0], y3 = a3[1], z2 = a3[2], w2 = a3[3];
  var r3 = Math.sqrt(x2 * x2 + y3 * y3 + z2 * z2);
  var t2 = r3 > 0 ? Math.atan2(r3, w2) / r3 : 0;
  out[0] = x2 * t2;
  out[1] = y3 * t2;
  out[2] = z2 * t2;
  out[3] = 0.5 * Math.log(x2 * x2 + y3 * y3 + z2 * z2 + w2 * w2);
  return out;
}
function pow(out, a3, b) {
  ln(out, a3);
  scale4(out, out, b);
  exp(out, out);
  return out;
}
function slerp2(out, a3, b, t2) {
  var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert2(out, a3) {
  var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
  var dot4 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot4 ? 1 / dot4 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a3) {
  out[0] = -a3[0];
  out[1] = -a3[1];
  out[2] = -a3[2];
  out[3] = a3[3];
  return out;
}
function fromMat3(out, m2) {
  var fTrace = m2[0] + m2[4] + m2[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m2[4] > m2[0]) i2 = 1;
    if (m2[8] > m2[i2 * 3 + i2]) i2 = 2;
    var j2 = (i2 + 1) % 3;
    var k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m2[i2 * 3 + i2] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
    out[j2] = (m2[j2 * 3 + i2] + m2[i2 * 3 + j2]) * fRoot;
    out[k2] = (m2[k2 * 3 + i2] + m2[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x2, y3, z2) {
  var order = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x2 *= halfToRad;
  z2 *= halfToRad;
  y3 *= halfToRad;
  var sx = Math.sin(x2);
  var cx = Math.cos(x2);
  var sy = Math.sin(y3);
  var cy = Math.cos(y3);
  var sz = Math.sin(z2);
  var cz = Math.cos(z2);
  switch (order) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error("Unknown angle order " + order);
  }
  return out;
}
function str4(a3) {
  return "quat(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
}
var clone4 = clone3;
var fromValues4 = fromValues3;
var copy5 = copy4;
var set4 = set3;
var add4 = add3;
var mul4 = multiply4;
var scale4 = scale3;
var dot3 = dot2;
var lerp3 = lerp2;
var length4 = length3;
var len3 = length4;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals4 = exactEquals3;
function equals4(a3, b) {
  return Math.abs(dot2(a3, b)) >= 1 - EPSILON;
}
var rotationTo = function() {
  var tmpvec3 = create4();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a3, b) {
    var dot4 = dot(a3, b);
    if (dot4 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a3);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a3);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot4 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a3, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot4;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create6();
  var temp2 = create6();
  return function(out, a3, b, c3, d, t2) {
    slerp2(temp1, a3, d, t2);
    slerp2(temp2, b, c3, t2);
    slerp2(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  var matr = create2();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
function create7() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
var forEach3 = function() {
  var vec = create7();
  return function(a3, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a3.length);
    } else {
      l2 = a3.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a3[i2];
      vec[1] = a3[i2 + 1];
      fn(vec, vec, arg);
      a3[i2] = vec[0];
      a3[i2 + 1] = vec[1];
    }
    return a3;
  };
}();

// node_modules/iwer/lib/private.js
var P_ACTION_PLAYER = Symbol("@iwer/action-player");
var P_ACTION_RECORDER = Symbol("@iwer/action-recorder");
var P_ANCHOR = Symbol("@iwer/xr-anchor");
var P_CONTROLLER = Symbol("@iwer/xr-controller");
var P_DEVICE = Symbol("@iwer/xr-device");
var P_HAND_INPUT = Symbol("@iwer/xr-hand-input");
var P_TRACKED_INPUT = Symbol("@iwer/xr-tracked-input");
var P_FRAME = Symbol("@iwer/xr-frame");
var P_GAMEPAD = Symbol("@iwer/gamepad");
var P_SYSTEM = Symbol("@iwer/xr-system");
var P_INPUT_SOURCE = Symbol("@iwer/xr-input-source");
var P_WEBGL_LAYER = Symbol("@iwer/xr-webgl-layer");
var P_MESH = Symbol("@iwer/xr-mesh");
var P_PLANE = Symbol("@iwer/xr-plane");
var P_JOINT_POSE = Symbol("@iwer/xr-joint-pose");
var P_POSE = Symbol("@iwer/xr-pose");
var P_VIEWER_POSE = Symbol("@iwer/xr-viewer-pose");
var P_RIGID_TRANSFORM = Symbol("@iwer/xr-rigid-transform");
var P_RENDER_STATE = Symbol("@iwer/xr-render-state");
var P_SESSION = Symbol("@iwer/xr-session");
var P_JOINT_SPACE = Symbol("@iwer/xr-joint-space");
var P_REF_SPACE = Symbol("@iwer/xr-reference-space");
var P_SPACE = Symbol("@iwer/xr-space");
var P_VIEW = Symbol("@iwer/xr-view");
var P_VIEWPORT = Symbol("@iwer/xr-viewport");
var P_RAY = Symbol("@iwer/xr-ray");
var P_HIT_TEST = Symbol("@iwer/xr-hit-test");

// node_modules/iwer/lib/spaces/XRSpace.js
var XRSpace = class extends EventTarget {
  constructor(parentSpace, offsetMatrix) {
    super();
    this[P_SPACE] = {
      parentSpace,
      offsetMatrix: offsetMatrix ? mat4_exports.clone(offsetMatrix) : mat4_exports.create(),
      emulated: true
    };
  }
};
var GlobalSpace = class extends XRSpace {
  constructor() {
    super(void 0, mat4_exports.create());
  }
};
var XRSpaceUtils = class _XRSpaceUtils {
  // Update the position component of the offsetMatrix of a given XRSpace
  static updateOffsetPosition(space3, position2) {
    const offsetMatrix = space3[P_SPACE].offsetMatrix;
    mat4_exports.fromTranslation(offsetMatrix, position2);
  }
  // Update the rotation component of the offsetMatrix of a given XRSpace using a quaternion
  static updateOffsetQuaternion(space3, quaternion) {
    const offsetMatrix = space3[P_SPACE].offsetMatrix;
    const translation = vec3_exports.create();
    mat4_exports.getTranslation(translation, offsetMatrix);
    mat4_exports.fromRotationTranslation(offsetMatrix, quaternion, translation);
  }
  // Update the offsetMatrix of a given XRSpace directly
  static updateOffsetMatrix(space3, matrix) {
    const offsetMatrix = space3[P_SPACE].offsetMatrix;
    mat4_exports.copy(offsetMatrix, matrix);
  }
  // Calculate the global offset matrix for a given XRSpace
  static calculateGlobalOffsetMatrix(space3, globalOffset = mat4_exports.create()) {
    const parentOffset = space3[P_SPACE].parentSpace ? _XRSpaceUtils.calculateGlobalOffsetMatrix(space3[P_SPACE].parentSpace) : mat4_exports.create();
    mat4_exports.multiply(globalOffset, parentOffset, space3[P_SPACE].offsetMatrix);
    return globalOffset;
  }
};

// node_modules/iwer/lib/utils/Math.js
var Vector321 = class _Vector3 {
  constructor(x2 = 0, y3 = 0, z2 = 0) {
    this.vec3 = vec3_exports.fromValues(x2, y3, z2);
    this.tempVec3 = vec3_exports.create();
  }
  get x() {
    return this.vec3[0];
  }
  set x(value) {
    this.vec3[0] = value;
  }
  get y() {
    return this.vec3[1];
  }
  set y(value) {
    this.vec3[1] = value;
  }
  get z() {
    return this.vec3[2];
  }
  set z(value) {
    this.vec3[2] = value;
  }
  set(x2, y3, z2) {
    vec3_exports.set(this.vec3, x2, y3, z2);
    return this;
  }
  clone() {
    return new _Vector3(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  normalize() {
    vec3_exports.copy(this.tempVec3, this.vec3);
    vec3_exports.normalize(this.vec3, this.tempVec3);
    return this;
  }
  add(v2) {
    vec3_exports.copy(this.tempVec3, this.vec3);
    vec3_exports.add(this.vec3, this.tempVec3, v2.vec3);
    return this;
  }
  applyQuaternion(q2) {
    vec3_exports.copy(this.tempVec3, this.vec3);
    vec3_exports.transformQuat(this.vec3, this.tempVec3, q2.quat);
    return this;
  }
};
var Quaternion15 = class _Quaternion {
  constructor(x2 = 0, y3 = 0, z2 = 0, w2 = 1) {
    this.quat = quat_exports.fromValues(x2, y3, z2, w2);
    this.tempQuat = quat_exports.create();
  }
  get x() {
    return this.quat[0];
  }
  set x(value) {
    this.quat[0] = value;
  }
  get y() {
    return this.quat[1];
  }
  set y(value) {
    this.quat[1] = value;
  }
  get z() {
    return this.quat[2];
  }
  set z(value) {
    this.quat[2] = value;
  }
  get w() {
    return this.quat[3];
  }
  set w(value) {
    this.quat[3] = value;
  }
  set(x2, y3, z2, w2) {
    quat_exports.set(this.quat, x2, y3, z2, w2);
    return this;
  }
  clone() {
    return new _Quaternion(this.x, this.y, this.z, this.w);
  }
  copy(q2) {
    quat_exports.set(this.quat, q2.x, q2.y, q2.z, q2.w);
    return this;
  }
  normalize() {
    quat_exports.copy(this.tempQuat, this.quat);
    quat_exports.normalize(this.quat, this.tempQuat);
    return this;
  }
  invert() {
    quat_exports.copy(this.tempQuat, this.quat);
    quat_exports.conjugate(this.quat, this.tempQuat);
    return this;
  }
  multiply(q2) {
    quat_exports.copy(this.tempQuat, this.quat);
    quat_exports.multiply(this.quat, this.tempQuat, q2.quat);
    return this;
  }
  setFromAxisAngle(axis, angle2) {
    quat_exports.setAxisAngle(this.quat, axis.vec3, angle2);
    return this;
  }
};

// node_modules/iwer/lib/gamepad/Gamepad.js
var GamepadMappingType;
(function(GamepadMappingType2) {
  GamepadMappingType2["None"] = "";
  GamepadMappingType2["Standard"] = "standard";
  GamepadMappingType2["XRStandard"] = "xr-standard";
})(GamepadMappingType || (GamepadMappingType = {}));
var GamepadButton = class {
  constructor(type, eventTrigger) {
    this[P_GAMEPAD] = {
      type,
      eventTrigger,
      pressed: false,
      touched: false,
      value: 0,
      lastFrameValue: 0,
      pendingValue: null
    };
  }
  get pressed() {
    if (this[P_GAMEPAD].type === "manual") {
      return this[P_GAMEPAD].pressed;
    } else {
      return this[P_GAMEPAD].value > 0;
    }
  }
  get touched() {
    if (this[P_GAMEPAD].type === "manual") {
      return this[P_GAMEPAD].touched;
    } else {
      return this[P_GAMEPAD].touched || this.pressed;
    }
  }
  get value() {
    return this[P_GAMEPAD].value;
  }
};
var EmptyGamepadButton = class {
  constructor() {
    this.pressed = false;
    this.touched = false;
    this.value = 0;
  }
};
var Gamepad = class {
  constructor(gamepadConfig, id = "", index = -1) {
    this[P_GAMEPAD] = {
      id,
      index,
      connected: false,
      timestamp: performance.now(),
      mapping: gamepadConfig.mapping,
      buttonsMap: {},
      buttonsSequence: [],
      axesMap: {},
      axesSequence: [],
      hapticActuators: []
    };
    gamepadConfig.buttons.forEach((buttonConfig) => {
      var _a2;
      if (buttonConfig === null) {
        this[P_GAMEPAD].buttonsSequence.push(null);
      } else {
        this[P_GAMEPAD].buttonsSequence.push(buttonConfig.id);
        this[P_GAMEPAD].buttonsMap[buttonConfig.id] = new GamepadButton(buttonConfig.type, (_a2 = buttonConfig.eventTrigger) !== null && _a2 !== void 0 ? _a2 : null);
      }
    });
    gamepadConfig.axes.forEach((axisConfig) => {
      if (axisConfig === null) {
        this[P_GAMEPAD].axesSequence.push(null);
      } else {
        this[P_GAMEPAD].axesSequence.push(axisConfig.id + axisConfig.type);
        if (!this[P_GAMEPAD].axesMap[axisConfig.id]) {
          this[P_GAMEPAD].axesMap[axisConfig.id] = { x: 0, y: 0 };
        }
      }
    });
  }
  get id() {
    return this[P_GAMEPAD].id;
  }
  get index() {
    return this[P_GAMEPAD].index;
  }
  get connected() {
    return this[P_GAMEPAD].connected;
  }
  get timestamp() {
    return this[P_GAMEPAD].timestamp;
  }
  get mapping() {
    return this[P_GAMEPAD].mapping;
  }
  get axes() {
    const axes = [];
    this[P_GAMEPAD].axesSequence.forEach((id) => {
      if (id === null) {
        axes.push(null);
      } else {
        const axisId = id.substring(0, id.length - 6);
        const axisType = id.substring(id.length - 6);
        axes.push(
          // if axis type is manual, then return the x value
          axisType === "y-axis" ? this[P_GAMEPAD].axesMap[axisId].y : this[P_GAMEPAD].axesMap[axisId].x
        );
      }
    });
    return axes;
  }
  get buttons() {
    return this[P_GAMEPAD].buttonsSequence.map((id) => id === null ? new EmptyGamepadButton() : this[P_GAMEPAD].buttonsMap[id]);
  }
  get hapticActuators() {
    return this[P_GAMEPAD].hapticActuators;
  }
  get vibrationActuator() {
    return null;
  }
};

// node_modules/iwer/lib/input/XRInputSource.js
var XRHandedness;
(function(XRHandedness2) {
  XRHandedness2["None"] = "none";
  XRHandedness2["Left"] = "left";
  XRHandedness2["Right"] = "right";
})(XRHandedness || (XRHandedness = {}));
var XRTargetRayMode;
(function(XRTargetRayMode2) {
  XRTargetRayMode2["Gaze"] = "gaze";
  XRTargetRayMode2["TrackedPointer"] = "tracked-pointer";
  XRTargetRayMode2["Screen"] = "screen";
  XRTargetRayMode2["TransientPointer"] = "transient-pointer";
})(XRTargetRayMode || (XRTargetRayMode = {}));
var XRInputSourceArray = class extends Array {
};
var XRInputSource = class {
  constructor(handedness, targetRayMode, profiles, targetRaySpace, gamepad, gripSpace, hand) {
    this[P_INPUT_SOURCE] = {
      handedness,
      targetRayMode,
      targetRaySpace,
      gripSpace,
      profiles,
      gamepad,
      hand
    };
  }
  get handedness() {
    return this[P_INPUT_SOURCE].handedness;
  }
  get targetRayMode() {
    return this[P_INPUT_SOURCE].targetRayMode;
  }
  get targetRaySpace() {
    return this[P_INPUT_SOURCE].targetRaySpace;
  }
  get gripSpace() {
    return this[P_INPUT_SOURCE].gripSpace;
  }
  get profiles() {
    return this[P_INPUT_SOURCE].profiles;
  }
  get gamepad() {
    return this[P_INPUT_SOURCE].gamepad;
  }
  get hand() {
    return this[P_INPUT_SOURCE].hand;
  }
};

// node_modules/iwer/lib/events/XRInputSourceEvent.js
var XRInputSourceEvent = class extends Event {
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    if (!eventInitDict.frame) {
      throw new Error("XRInputSourceEventInit.frame is required");
    }
    if (!eventInitDict.inputSource) {
      throw new Error("XRInputSourceEventInit.inputSource is required");
    }
    this.frame = eventInitDict.frame;
    this.inputSource = eventInitDict.inputSource;
  }
};

// node_modules/iwer/lib/device/XRTrackedInput.js
var DEFAULT_TRANSFORM = {
  [XRHandedness.Left]: {
    position: new Vector321(-0.25, 1.5, -0.4),
    quaternion: new Quaternion15()
  },
  [XRHandedness.Right]: {
    position: new Vector321(0.25, 1.5, -0.4),
    quaternion: new Quaternion15()
  },
  [XRHandedness.None]: {
    position: new Vector321(0.25, 1.5, -0.4),
    quaternion: new Quaternion15()
  }
};
var XRTrackedInput = class {
  constructor(inputSource) {
    this[P_TRACKED_INPUT] = {
      inputSource,
      position: DEFAULT_TRANSFORM[inputSource.handedness].position.clone(),
      quaternion: DEFAULT_TRANSFORM[inputSource.handedness].quaternion.clone(),
      connected: true,
      lastFrameConnected: false,
      inputSourceChanged: true
    };
  }
  get position() {
    return this[P_TRACKED_INPUT].position;
  }
  get quaternion() {
    return this[P_TRACKED_INPUT].quaternion;
  }
  get inputSource() {
    return this[P_TRACKED_INPUT].inputSource;
  }
  get connected() {
    return this[P_TRACKED_INPUT].connected;
  }
  set connected(value) {
    this[P_TRACKED_INPUT].connected = value;
    this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].connected = value;
  }
  onFrameStart(frame) {
    const targetRaySpace = this[P_TRACKED_INPUT].inputSource.targetRaySpace;
    mat4_exports.fromRotationTranslation(targetRaySpace[P_SPACE].offsetMatrix, this[P_TRACKED_INPUT].quaternion.quat, this[P_TRACKED_INPUT].position.vec3);
    const session = frame.session;
    this[P_TRACKED_INPUT].inputSource.gamepad.buttons.forEach((button) => {
      if (button instanceof GamepadButton) {
        button[P_GAMEPAD].lastFrameValue = button[P_GAMEPAD].value;
        if (button[P_GAMEPAD].pendingValue != null) {
          button[P_GAMEPAD].value = button[P_GAMEPAD].pendingValue;
          button[P_GAMEPAD].pendingValue = null;
        }
        if (button[P_GAMEPAD].eventTrigger != null) {
          if (button[P_GAMEPAD].lastFrameValue === 0 && button[P_GAMEPAD].value > 0) {
            session.dispatchEvent(new XRInputSourceEvent(button[P_GAMEPAD].eventTrigger, {
              frame,
              inputSource: this[P_TRACKED_INPUT].inputSource
            }));
            session.dispatchEvent(new XRInputSourceEvent(button[P_GAMEPAD].eventTrigger + "start", {
              frame,
              inputSource: this[P_TRACKED_INPUT].inputSource
            }));
          } else if (button[P_GAMEPAD].lastFrameValue > 0 && button[P_GAMEPAD].value === 0) {
            session.dispatchEvent(new XRInputSourceEvent(button[P_GAMEPAD].eventTrigger + "end", {
              frame,
              inputSource: this[P_TRACKED_INPUT].inputSource
            }));
          }
        }
      }
    });
    this[P_TRACKED_INPUT].inputSourceChanged = this.connected !== this[P_TRACKED_INPUT].lastFrameConnected;
    this[P_TRACKED_INPUT].lastFrameConnected = this.connected;
  }
};

// node_modules/iwer/lib/device/XRController.js
var XRController = class extends XRTrackedInput {
  constructor(controllerConfig, handedness, globalSpace) {
    if (!controllerConfig.layout[handedness]) {
      throw new DOMException("Handedness not supported", "InvalidStateError");
    }
    const targetRaySpace = new XRSpace(globalSpace);
    const gripSpace = controllerConfig.layout[handedness].gripOffsetMatrix ? new XRSpace(targetRaySpace, controllerConfig.layout[handedness].gripOffsetMatrix) : void 0;
    const profiles = [
      controllerConfig.profileId,
      ...controllerConfig.fallbackProfileIds
    ];
    const inputSource = new XRInputSource(handedness, XRTargetRayMode.TrackedPointer, profiles, targetRaySpace, new Gamepad(controllerConfig.layout[handedness].gamepad), gripSpace);
    super(inputSource);
    this[P_CONTROLLER] = {
      profileId: controllerConfig.profileId,
      gamepadConfig: controllerConfig.layout[handedness].gamepad
    };
  }
  get gamepadConfig() {
    return this[P_CONTROLLER].gamepadConfig;
  }
  get profileId() {
    return this[P_CONTROLLER].profileId;
  }
  updateButtonValue(id, value) {
    if (value > 1 || value < 0) {
      console.warn(`Out-of-range value ${value} provided for button ${id}.`);
      return;
    }
    const gamepadButton = this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].buttonsMap[id];
    if (gamepadButton) {
      if (gamepadButton[P_GAMEPAD].type === "binary" && value != 1 && value != 0) {
        console.warn(`Non-binary value ${value} provided for binary button ${id}.`);
        return;
      }
      gamepadButton[P_GAMEPAD].pendingValue = value;
    } else {
      console.warn(`Current controller does not have button ${id}.`);
    }
  }
  updateButtonTouch(id, touched) {
    const gamepadButton = this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].buttonsMap[id];
    if (gamepadButton) {
      gamepadButton[P_GAMEPAD].touched = touched;
    } else {
      console.warn(`Current controller does not have button ${id}.`);
    }
  }
  updateAxis(id, type, value) {
    if (value > 1 || value < -1) {
      console.warn(`Out-of-range value ${value} provided for ${id} axes.`);
      return;
    }
    const axesById = this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].axesMap[id];
    if (axesById) {
      if (type === "x-axis") {
        axesById.x = value;
      } else if (type === "y-axis") {
        axesById.y = value;
      }
    } else {
      console.warn(`Current controller does not have ${id} axes.`);
    }
  }
  updateAxes(id, x2, y3) {
    if (x2 > 1 || x2 < -1 || y3 > 1 || y3 < -1) {
      console.warn(`Out-of-range value x:${x2}, y:${y3} provided for ${id} axes.`);
      return;
    }
    const axesById = this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].axesMap[id];
    if (axesById) {
      axesById.x = x2;
      axesById.y = y3;
    } else {
      console.warn(`Current controller does not have ${id} axes.`);
    }
  }
};

// node_modules/iwer/lib/meshes/XRMesh.js
var XRMesh = class {
  constructor(nativeMesh, meshSpace, vertices, indices, semanticLabel) {
    this[P_MESH] = {
      nativeMesh,
      frame: void 0,
      meshSpace,
      vertices,
      indices,
      lastChangedTime: performance.now(),
      semanticLabel
    };
  }
  get meshSpace() {
    return this[P_MESH].meshSpace;
  }
  get vertices() {
    return this[P_MESH].vertices;
  }
  get indices() {
    return this[P_MESH].indices;
  }
  get lastChangedTime() {
    return this[P_MESH].lastChangedTime;
  }
  get semanticLabel() {
    return this[P_MESH].semanticLabel;
  }
};
var XRMeshSet = class extends Set {
};
var NativeMesh = class {
  constructor(transform, vertices, indices, semanticLabel) {
    this.transform = transform;
    this.vertices = vertices;
    this.indices = indices;
    this.semanticLabel = semanticLabel;
  }
};

// node_modules/iwer/lib/labels/labels.js
var XRSemanticLabels;
(function(XRSemanticLabels2) {
  XRSemanticLabels2["Desk"] = "desk";
  XRSemanticLabels2["Couch"] = "couch";
  XRSemanticLabels2["Floor"] = "floor";
  XRSemanticLabels2["Ceiling"] = "ceiling";
  XRSemanticLabels2["Wall"] = "wall";
  XRSemanticLabels2["Door"] = "door";
  XRSemanticLabels2["Window"] = "window";
  XRSemanticLabels2["Table"] = "table";
  XRSemanticLabels2["Shelf"] = "shelf";
  XRSemanticLabels2["Bed"] = "bed";
  XRSemanticLabels2["Screen"] = "screen";
  XRSemanticLabels2["Lamp"] = "lamp";
  XRSemanticLabels2["Plant"] = "plant";
  XRSemanticLabels2["WallArt"] = "wall art";
  XRSemanticLabels2["GlobalMesh"] = "global mesh";
  XRSemanticLabels2["Other"] = "other";
})(XRSemanticLabels || (XRSemanticLabels = {}));

// node_modules/iwer/lib/planes/XRPlane.js
var XRPlaneOrientation;
(function(XRPlaneOrientation2) {
  XRPlaneOrientation2["Horizontal"] = "horizontal";
  XRPlaneOrientation2["Vertical"] = "vertical";
})(XRPlaneOrientation || (XRPlaneOrientation = {}));
var XREntityOrientation = {
  [XRSemanticLabels.Desk]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Couch]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Floor]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Ceiling]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Wall]: XRPlaneOrientation.Vertical,
  [XRSemanticLabels.Door]: XRPlaneOrientation.Vertical,
  [XRSemanticLabels.Window]: XRPlaneOrientation.Vertical,
  [XRSemanticLabels.Table]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Shelf]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Bed]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Screen]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Lamp]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.Plant]: XRPlaneOrientation.Horizontal,
  [XRSemanticLabels.WallArt]: XRPlaneOrientation.Vertical
};
var XRPlane = class {
  constructor(nativePlane, planeSpace, polygon, semanticLabel) {
    this[P_PLANE] = {
      nativePlane,
      frame: void 0,
      planeSpace,
      polygon,
      lastChangedTime: performance.now(),
      semanticLabel,
      orientation: semanticLabel ? XREntityOrientation[semanticLabel] : void 0
    };
  }
  get planeSpace() {
    return this[P_PLANE].planeSpace;
  }
  get polygon() {
    return this[P_PLANE].polygon;
  }
  get orientation() {
    return this[P_PLANE].orientation;
  }
  get lastChangedTime() {
    return this[P_PLANE].lastChangedTime;
  }
  get semanticLabel() {
    return this[P_PLANE].semanticLabel;
  }
};
var XRPlaneSet = class extends Set {
};
var NativePlane = class {
  constructor(transform, polygon, semanticLabel) {
    this.transform = transform;
    this.polygon = polygon;
    this.semanticLabel = semanticLabel;
  }
};

// node_modules/iwer/lib/anchors/XRAnchor.js
var XRAnchor = class {
  constructor(anchorSpace, session) {
    this[P_ANCHOR] = {
      anchorSpace,
      session,
      deleted: false
    };
    session[P_SESSION].trackedAnchors.add(this);
  }
  get anchorSpace() {
    if (this[P_ANCHOR].deleted) {
      throw new DOMException("XRAnchor has already been deleted.", "InvalidStateError");
    }
    return this[P_ANCHOR].anchorSpace;
  }
  requestPersistentHandle() {
    return new Promise((resolve, reject) => {
      if (this[P_ANCHOR].deleted) {
        reject(new DOMException("XRAnchor has already been deleted.", "InvalidStateError"));
      } else {
        const persistentAnchors = this[P_ANCHOR].session[P_SESSION].persistentAnchors;
        for (const [uuid2, anchor] of persistentAnchors.entries()) {
          if (anchor === this) {
            resolve(uuid2);
            return;
          }
        }
        const uuid = crypto.randomUUID();
        XRAnchorUtils.createPersistentAnchor(this[P_ANCHOR].session, this, uuid);
        resolve(uuid);
      }
    });
  }
  delete() {
    if (this[P_ANCHOR].deleted) {
      return;
    }
    this[P_ANCHOR].anchorSpace = null;
    this[P_ANCHOR].deleted = true;
    this[P_ANCHOR].session[P_SESSION].trackedAnchors.delete(this);
  }
};
var XRAnchorSet = class extends Set {
};
var PersistentAnchorsStorageKey = "@immersive-web-emulation-runtime/persistent-anchors";
var XRAnchorUtils = class {
  static recoverPersistentAnchorsFromStorage(session) {
    const persistentAnchors = JSON.parse(localStorage.getItem(PersistentAnchorsStorageKey) || "{}");
    Object.entries(persistentAnchors).forEach(([uuid, offsetMatrix]) => {
      const globalSpace = session[P_SESSION].device[P_DEVICE].globalSpace;
      const anchorSpace = new XRSpace(globalSpace, offsetMatrix);
      const anchor = new XRAnchor(anchorSpace, session);
      session[P_SESSION].persistentAnchors.set(uuid, anchor);
    });
  }
  static createPersistentAnchor(session, anchor, uuid) {
    session[P_SESSION].trackedAnchors.add(anchor);
    session[P_SESSION].persistentAnchors.set(uuid, anchor);
    const persistentAnchors = JSON.parse(localStorage.getItem(PersistentAnchorsStorageKey) || "{}");
    persistentAnchors[uuid] = Array.from(anchor[P_ANCHOR].anchorSpace[P_SPACE].offsetMatrix);
    localStorage.setItem(PersistentAnchorsStorageKey, JSON.stringify(persistentAnchors));
  }
};

// node_modules/iwer/lib/primitives/XRRigidTransform.js
var XRRigidTransform = class _XRRigidTransform {
  constructor(position2, orientation) {
    const defaultPosition = vec3_exports.fromValues(0, 0, 0);
    const defaultOrientation = quat_exports.create();
    this[P_RIGID_TRANSFORM] = {
      matrix: mat4_exports.create(),
      position: position2 ? vec3_exports.fromValues(position2.x, position2.y, position2.z) : defaultPosition,
      orientation: orientation ? quat_exports.normalize(quat_exports.create(), quat_exports.fromValues(orientation.x, orientation.y, orientation.z, orientation.w)) : defaultOrientation,
      inverse: null
    };
    this.updateMatrix();
  }
  updateMatrix() {
    mat4_exports.fromRotationTranslation(this[P_RIGID_TRANSFORM].matrix, this[P_RIGID_TRANSFORM].orientation, this[P_RIGID_TRANSFORM].position);
  }
  get matrix() {
    return this[P_RIGID_TRANSFORM].matrix;
  }
  get position() {
    const pos = this[P_RIGID_TRANSFORM].position;
    return new DOMPointReadOnly(pos[0], pos[1], pos[2], 1);
  }
  get orientation() {
    const ori = this[P_RIGID_TRANSFORM].orientation;
    return new DOMPointReadOnly(ori[0], ori[1], ori[2], ori[3]);
  }
  get inverse() {
    if (!this[P_RIGID_TRANSFORM].inverse) {
      const invMatrix = mat4_exports.create();
      if (!mat4_exports.invert(invMatrix, this[P_RIGID_TRANSFORM].matrix)) {
        throw new Error("Matrix is not invertible.");
      }
      let invPosition = vec3_exports.create();
      mat4_exports.getTranslation(invPosition, invMatrix);
      let invOrientation = quat_exports.create();
      mat4_exports.getRotation(invOrientation, invMatrix);
      this[P_RIGID_TRANSFORM].inverse = new _XRRigidTransform(new DOMPointReadOnly(invPosition[0], invPosition[1], invPosition[2], 1), new DOMPointReadOnly(invOrientation[0], invOrientation[1], invOrientation[2], invOrientation[3]));
      this[P_RIGID_TRANSFORM].inverse[P_RIGID_TRANSFORM].inverse = this;
    }
    return this[P_RIGID_TRANSFORM].inverse;
  }
};

// node_modules/iwer/lib/hittest/XRRay.js
var DOMPointReadOnly2 = class {
  constructor(x2 = 0, y3 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y3;
    this.z = z2;
    this.w = w2;
  }
};
var XRRay = class {
  constructor(origin, direction) {
    const _origin = { x: 0, y: 0, z: 0, w: 1 };
    const _direction = { x: 0, y: 0, z: -1, w: 0 };
    if (origin instanceof XRRigidTransform) {
      const transform = origin;
      const matrix = transform.matrix;
      const originVec4 = vec4_exports.set(vec4_exports.create(), _origin.x, _origin.y, _origin.z, _origin.w);
      const directionVec4 = vec4_exports.set(vec4_exports.create(), _direction.x, _direction.y, _direction.z, _direction.w);
      vec4_exports.transformMat4(originVec4, originVec4, matrix);
      vec4_exports.transformMat4(directionVec4, directionVec4, matrix);
      _origin.x = originVec4[0];
      _origin.y = originVec4[1];
      _origin.z = originVec4[2];
      _origin.w = originVec4[3];
      _direction.x = directionVec4[0];
      _direction.y = directionVec4[1];
      _direction.z = directionVec4[2];
      _direction.w = directionVec4[3];
    } else {
      if (origin) {
        _origin.x = origin.x;
        _origin.y = origin.y;
        _origin.z = origin.z;
        _origin.w = origin.w;
      }
      if (direction) {
        if (direction.x === 0 && direction.y === 0 && direction.z === 0 || direction.w !== 0) {
          throw new DOMException("Invalid direction value to construct XRRay", "TypeError");
        }
        _direction.x = direction.x;
        _direction.y = direction.y;
        _direction.z = direction.z;
        _direction.w = direction.w;
      }
    }
    const length5 = Math.sqrt(_direction.x * _direction.x + _direction.y * _direction.y + _direction.z * _direction.z) || 1;
    _direction.x = _direction.x / length5;
    _direction.y = _direction.y / length5;
    _direction.z = _direction.z / length5;
    this[P_RAY] = {
      origin: new DOMPointReadOnly2(_origin.x, _origin.y, _origin.z, _origin.w),
      direction: new DOMPointReadOnly2(_direction.x, _direction.y, _direction.z, _direction.w),
      matrix: null
    };
  }
  get origin() {
    return this[P_RAY].origin;
  }
  get direction() {
    return this[P_RAY].direction;
  }
  get matrix() {
    if (this[P_RAY].matrix) {
      return this[P_RAY].matrix;
    }
    const z2 = vec3_exports.set(vec3_exports.create(), 0, 0, -1);
    const origin = vec3_exports.set(vec3_exports.create(), this[P_RAY].origin.x, this[P_RAY].origin.y, this[P_RAY].origin.z);
    const direction = vec3_exports.set(vec3_exports.create(), this[P_RAY].direction.x, this[P_RAY].direction.y, this[P_RAY].direction.z);
    const axis = vec3_exports.cross(vec3_exports.create(), direction, z2);
    const cosAngle = vec3_exports.dot(direction, z2);
    const rotation = mat4_exports.create();
    if (cosAngle > -1 && cosAngle < 1) {
      mat4_exports.fromRotation(rotation, Math.acos(cosAngle), axis);
    } else if (cosAngle === -1) {
      mat4_exports.fromRotation(rotation, Math.acos(cosAngle), vec3_exports.set(vec3_exports.create(), 1, 0, 0));
    } else {
      mat4_exports.identity(rotation);
    }
    const translation = mat4_exports.fromTranslation(mat4_exports.create(), origin);
    const matrix = mat4_exports.multiply(mat4_exports.create(), translation, rotation);
    this[P_RAY].matrix = new Float32Array(matrix);
    return this[P_RAY].matrix;
  }
};

// node_modules/iwer/lib/hittest/XRHitTest.js
var XRHitTestSource = class {
  constructor(session, options) {
    var _a2;
    this[P_HIT_TEST] = {
      session,
      space: options.space,
      offsetRay: (_a2 = options.offsetRay) !== null && _a2 !== void 0 ? _a2 : new XRRay()
    };
  }
  cancel() {
    this[P_HIT_TEST].session[P_SESSION].hitTestSources.delete(this);
  }
};
var XRHitTestResult = class {
  constructor(frame, offsetSpace) {
    this[P_HIT_TEST] = { frame, offsetSpace };
  }
  getPose(baseSpace) {
    return this[P_HIT_TEST].frame.getPose(this[P_HIT_TEST].offsetSpace, baseSpace);
  }
  createAnchor() {
    return this[P_HIT_TEST].frame.createAnchor(new XRRigidTransform(), this[P_HIT_TEST].offsetSpace);
  }
};

// node_modules/iwer/lib/events/XRInputSourcesChangeEvent.js
var XRInputSourcesChangeEvent = class extends Event {
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    if (!eventInitDict.session) {
      throw new Error("XRInputSourcesChangeEventInit.session is required");
    }
    if (!eventInitDict.added) {
      throw new Error("XRInputSourcesChangeEventInit.added is required");
    }
    if (!eventInitDict.removed) {
      throw new Error("XRInputSourcesChangeEventInit.removed is required");
    }
    this.session = eventInitDict.session;
    this.added = eventInitDict.added;
    this.removed = eventInitDict.removed;
  }
};

// node_modules/iwer/lib/spaces/XRReferenceSpace.js
var _a;
var XRReferenceSpaceType;
(function(XRReferenceSpaceType2) {
  XRReferenceSpaceType2["Viewer"] = "viewer";
  XRReferenceSpaceType2["Local"] = "local";
  XRReferenceSpaceType2["LocalFloor"] = "local-floor";
  XRReferenceSpaceType2["BoundedFloor"] = "bounded-floor";
  XRReferenceSpaceType2["Unbounded"] = "unbounded";
})(XRReferenceSpaceType || (XRReferenceSpaceType = {}));
var XRReferenceSpace = class _XRReferenceSpace extends XRSpace {
  constructor(type, parentSpace, offsetMatrix) {
    super(parentSpace, offsetMatrix);
    this[_a] = {
      type: null,
      onreset: () => {
      }
    };
    this[P_REF_SPACE].type = type;
  }
  get onreset() {
    var _b;
    return (_b = this[P_REF_SPACE].onreset) !== null && _b !== void 0 ? _b : () => {
    };
  }
  set onreset(callback) {
    if (this[P_REF_SPACE].onreset) {
      this.removeEventListener("reset", this[P_REF_SPACE].onreset);
    }
    this[P_REF_SPACE].onreset = callback;
    if (callback) {
      this.addEventListener("reset", callback);
    }
  }
  // Create a new XRReferenceSpace with an offset from the current space
  getOffsetReferenceSpace(originOffset) {
    return new _XRReferenceSpace(this[P_REF_SPACE].type, this, originOffset);
  }
};
_a = P_REF_SPACE;

// node_modules/iwer/lib/session/XRRenderState.js
var XRRenderState = class {
  constructor(init = {}, oldState) {
    this[P_RENDER_STATE] = {
      depthNear: init.depthNear || (oldState === null || oldState === void 0 ? void 0 : oldState.depthNear) || 0.1,
      depthFar: init.depthFar || (oldState === null || oldState === void 0 ? void 0 : oldState.depthFar) || 1e3,
      inlineVerticalFieldOfView: init.inlineVerticalFieldOfView || (oldState === null || oldState === void 0 ? void 0 : oldState.inlineVerticalFieldOfView) || null,
      baseLayer: init.baseLayer || (oldState === null || oldState === void 0 ? void 0 : oldState.baseLayer) || null
    };
  }
  get depthNear() {
    return this[P_RENDER_STATE].depthNear;
  }
  get depthFar() {
    return this[P_RENDER_STATE].depthFar;
  }
  get inlineVerticalFieldOfView() {
    return this[P_RENDER_STATE].inlineVerticalFieldOfView;
  }
  get baseLayer() {
    return this[P_RENDER_STATE].baseLayer;
  }
};

// node_modules/iwer/lib/events/XRSessionEvent.js
var XRSessionEvent = class extends Event {
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    if (!eventInitDict.session) {
      throw new Error("XRSessionEventInit.session is required");
    }
    this.session = eventInitDict.session;
  }
};

// node_modules/iwer/lib/views/XRView.js
var XREye;
(function(XREye2) {
  XREye2["None"] = "none";
  XREye2["Left"] = "left";
  XREye2["Right"] = "right";
})(XREye || (XREye = {}));
var XRView = class {
  constructor(eye, projectionMatrix, transform, session) {
    this[P_VIEW] = {
      eye,
      projectionMatrix,
      transform,
      recommendedViewportScale: null,
      requestedViewportScale: 1,
      session
    };
  }
  get eye() {
    return this[P_VIEW].eye;
  }
  get projectionMatrix() {
    return this[P_VIEW].projectionMatrix;
  }
  get transform() {
    return this[P_VIEW].transform;
  }
  get recommendedViewportScale() {
    return this[P_VIEW].recommendedViewportScale;
  }
  requestViewportScale(scale5) {
    if (scale5 === null || scale5 <= 0 || scale5 > 1) {
      console.warn("Invalid scale value. Scale must be > 0 and <= 1.");
      return;
    }
    this[P_VIEW].requestedViewportScale = scale5;
  }
};

// node_modules/iwer/lib/pose/XRPose.js
var XRPose = class {
  constructor(transform, emulatedPosition = false, linearVelocity = void 0, angularVelocity = void 0) {
    this[P_POSE] = {
      transform,
      emulatedPosition,
      linearVelocity,
      angularVelocity
    };
  }
  get transform() {
    return this[P_POSE].transform;
  }
  get emulatedPosition() {
    return this[P_POSE].emulatedPosition;
  }
  get linearVelocity() {
    return this[P_POSE].linearVelocity;
  }
  get angularVelocity() {
    return this[P_POSE].angularVelocity;
  }
};

// node_modules/iwer/lib/pose/XRJointPose.js
var XRJointPose = class extends XRPose {
  constructor(transform, radius, emulatedPosition = false, linearVelocity = void 0, angularVelocity = void 0) {
    super(transform, emulatedPosition, linearVelocity, angularVelocity);
    this[P_JOINT_POSE] = { radius };
  }
  get radius() {
    return this[P_JOINT_POSE].radius;
  }
};

// node_modules/iwer/lib/pose/XRViewerPose.js
var XRViewerPose = class extends XRPose {
  constructor(transform, views, emulatedPosition = false, linearVelocity = void 0, angularVelocity = void 0) {
    super(transform, emulatedPosition, linearVelocity, angularVelocity);
    this[P_VIEWER_POSE] = {
      views: Object.freeze(views)
    };
  }
  get views() {
    return this[P_VIEWER_POSE].views;
  }
};

// node_modules/iwer/lib/frameloop/XRFrame.js
var spaceGlobalMatrix = mat4_exports.create();
var baseSpaceGlobalMatrix = mat4_exports.create();
var baseSpaceGlobalMatrixInverse = mat4_exports.create();
var getOffsetMatrix = (offsetMatrix, space3, baseSpace) => {
  XRSpaceUtils.calculateGlobalOffsetMatrix(space3, spaceGlobalMatrix);
  XRSpaceUtils.calculateGlobalOffsetMatrix(baseSpace, baseSpaceGlobalMatrix);
  mat4_exports.invert(baseSpaceGlobalMatrixInverse, baseSpaceGlobalMatrix);
  mat4_exports.multiply(offsetMatrix, baseSpaceGlobalMatrixInverse, spaceGlobalMatrix);
};
var XRFrame = class {
  constructor(session, id, active, animationFrame, predictedDisplayTime) {
    this[P_FRAME] = {
      session,
      id,
      active,
      animationFrame,
      predictedDisplayTime,
      tempMat4: mat4_exports.create(),
      detectedPlanes: new XRPlaneSet(),
      detectedMeshes: new XRMeshSet(),
      trackedAnchors: session[P_SESSION].frameTrackedAnchors,
      hitTestResultsMap: /* @__PURE__ */ new Map()
    };
  }
  get session() {
    return this[P_FRAME].session;
  }
  get predictedDisplayTime() {
    return this[P_FRAME].predictedDisplayTime;
  }
  getPose(space3, baseSpace) {
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    getOffsetMatrix(this[P_FRAME].tempMat4, space3, baseSpace);
    const position2 = vec3_exports.create();
    mat4_exports.getTranslation(position2, this[P_FRAME].tempMat4);
    const orientation = quat_exports.create();
    mat4_exports.getRotation(orientation, this[P_FRAME].tempMat4);
    return new XRPose(new XRRigidTransform({ x: position2[0], y: position2[1], z: position2[2], w: 1 }, {
      x: orientation[0],
      y: orientation[1],
      z: orientation[2],
      w: orientation[3]
    }), space3[P_SPACE].emulated);
  }
  getViewerPose(referenceSpace) {
    if (!this[P_FRAME].animationFrame) {
      throw new DOMException("getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.", "InvalidStateError");
    }
    const session = this[P_FRAME].session;
    const device = session[P_SESSION].device;
    const pose = this.getPose(device.viewerSpace, referenceSpace);
    const eyes = session[P_SESSION].mode === "inline" ? [XREye.None] : [XREye.Left, XREye.Right];
    const views = [];
    eyes.forEach((eye) => {
      const viewSpace = device.viewSpaces[eye];
      const viewPose = this.getPose(viewSpace, referenceSpace);
      const projectionMatrix = session[P_SESSION].getProjectionMatrix(eye);
      const view = new XRView(eye, new Float32Array(projectionMatrix), viewPose.transform, session);
      views.push(view);
    });
    return new XRViewerPose(pose.transform, views, false);
  }
  getJointPose(joint, baseSpace) {
    const xrPose = this.getPose(joint, baseSpace);
    const radius = joint[P_JOINT_SPACE].radius;
    return new XRJointPose(xrPose.transform, radius, false);
  }
  fillJointRadii(jointSpaces, radii) {
    jointSpaces = Array.from(jointSpaces);
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    if (jointSpaces.length > radii.length) {
      throw new DOMException("The length of jointSpaces is larger than the number of elements in radii", "TypeError");
    }
    let allValid = true;
    for (let offset = 0; offset < jointSpaces.length; offset++) {
      if (!jointSpaces[offset][P_JOINT_SPACE].radius) {
        radii[offset] = NaN;
        allValid = false;
      } else {
        radii[offset] = jointSpaces[offset][P_JOINT_SPACE].radius;
      }
    }
    return allValid;
  }
  fillPoses(spaces, baseSpace, transforms) {
    spaces = Array.from(spaces);
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    if (spaces.length * 16 > transforms.length) {
      throw new DOMException("The length of spaces multiplied by 16 is larger than the number of elements in transforms", "TypeError");
    }
    spaces.forEach((space3, i2) => {
      getOffsetMatrix(this[P_FRAME].tempMat4, space3, baseSpace);
      for (let j2 = 0; j2 < 16; j2++) {
        transforms[i2 * 16 + j2] = this[P_FRAME].tempMat4[j2];
      }
    });
    return true;
  }
  get detectedPlanes() {
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    return this[P_FRAME].detectedPlanes;
  }
  get detectedMeshes() {
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    return this[P_FRAME].detectedMeshes;
  }
  get trackedAnchors() {
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    }
    return this[P_FRAME].trackedAnchors;
  }
  createAnchor(pose, space3) {
    return new Promise((resolve, reject) => {
      if (!this[P_FRAME].active) {
        reject(new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError"));
      } else {
        const globalSpace = this[P_FRAME].session[P_SESSION].device[P_DEVICE].globalSpace;
        const tempSpace = new XRSpace(space3, pose.matrix);
        const globalOffsetMatrix = XRSpaceUtils.calculateGlobalOffsetMatrix(tempSpace);
        const anchorSpace = new XRSpace(globalSpace, globalOffsetMatrix);
        const anchor = new XRAnchor(anchorSpace, this[P_FRAME].session);
        this[P_FRAME].session[P_SESSION].trackedAnchors.add(anchor);
        this[P_FRAME].session[P_SESSION].newAnchors.set(anchor, {
          resolve,
          reject
        });
      }
    });
  }
  getHitTestResults(hitTestSource) {
    if (!this[P_FRAME].active) {
      throw new DOMException("XRFrame access outside the callback that produced it is invalid.", "InvalidStateError");
    } else if (!this[P_FRAME].hitTestResultsMap.has(hitTestSource)) {
      throw new DOMException("Requested hit test results are not available for current frame.", "InvalidStateError");
    } else {
      return [...this[P_FRAME].hitTestResultsMap.get(hitTestSource)];
    }
  }
};

// node_modules/iwer/lib/session/XRSession.js
var XREnvironmentBlendMode;
(function(XREnvironmentBlendMode2) {
  XREnvironmentBlendMode2["Opaque"] = "opaque";
  XREnvironmentBlendMode2["AlphaBlend"] = "alpha-blend";
  XREnvironmentBlendMode2["Additive"] = "additive";
})(XREnvironmentBlendMode || (XREnvironmentBlendMode = {}));
var XRInteractionMode;
(function(XRInteractionMode2) {
  XRInteractionMode2["ScreenSpace"] = "screen-space";
  XRInteractionMode2["WorldSpace"] = "world-space";
})(XRInteractionMode || (XRInteractionMode = {}));
var XRSession = class extends EventTarget {
  constructor(device, mode, enabledFeatures) {
    super();
    this[P_SESSION] = {
      device,
      mode,
      renderState: new XRRenderState(),
      pendingRenderState: null,
      enabledFeatures,
      isSystemKeyboardSupported: false,
      ended: false,
      projectionMatrices: {
        [XREye.Left]: mat4_exports.create(),
        [XREye.Right]: mat4_exports.create(),
        [XREye.None]: mat4_exports.create()
      },
      getProjectionMatrix: (eye) => {
        return this[P_SESSION].projectionMatrices[eye];
      },
      referenceSpaceIsSupported: (referenceSpaceType) => {
        if (!this[P_SESSION].enabledFeatures.includes(referenceSpaceType)) {
          return false;
        }
        switch (referenceSpaceType) {
          case XRReferenceSpaceType.Viewer:
            return true;
          case XRReferenceSpaceType.Local:
          case XRReferenceSpaceType.LocalFloor:
          case XRReferenceSpaceType.BoundedFloor:
          case XRReferenceSpaceType.Unbounded:
            return this[P_SESSION].mode != "inline";
        }
      },
      frameHandle: 0,
      frameCallbacks: [],
      currentFrameCallbacks: null,
      onDeviceFrame: () => {
        if (this[P_SESSION].ended) {
          return;
        }
        this[P_SESSION].deviceFrameHandle = globalThis.requestAnimationFrame(this[P_SESSION].onDeviceFrame);
        if (this[P_SESSION].pendingRenderState != null) {
          this[P_SESSION].renderState = this[P_SESSION].pendingRenderState;
          this[P_SESSION].pendingRenderState = null;
          this[P_SESSION].device[P_DEVICE].onBaseLayerSet(this[P_SESSION].renderState.baseLayer);
        }
        const baseLayer = this[P_SESSION].renderState.baseLayer;
        if (baseLayer === null) {
          return;
        }
        const context = baseLayer.context;
        const canvas = context.canvas;
        if (this[P_SESSION].mode != "inline") {
          const currentClearColor = context.getParameter(context.COLOR_CLEAR_VALUE);
          const currentClearDepth = context.getParameter(context.DEPTH_CLEAR_VALUE);
          const currentClearStencil = context.getParameter(context.STENCIL_CLEAR_VALUE);
          context.clearColor(0, 0, 0, 0);
          context.clearDepth(1);
          context.clearStencil(0);
          context.clear(context.DEPTH_BUFFER_BIT | context.COLOR_BUFFER_BIT | context.STENCIL_BUFFER_BIT);
          context.clearColor(currentClearColor[0], currentClearColor[1], currentClearColor[2], currentClearColor[3]);
          context.clearDepth(currentClearDepth);
          context.clearStencil(currentClearStencil);
        }
        const { depthNear, depthFar } = this[P_SESSION].renderState;
        const { width, height } = canvas;
        if (this[P_SESSION].mode !== "inline") {
          const aspect = width * (this[P_SESSION].device.stereoEnabled ? 0.5 : 1) / height;
          mat4_exports.perspective(this[P_SESSION].projectionMatrices[XREye.Left], this[P_SESSION].device.fovy, aspect, depthNear, depthFar);
          mat4_exports.copy(this[P_SESSION].projectionMatrices[XREye.Right], this[P_SESSION].projectionMatrices[XREye.Left]);
        } else {
          const aspect = width / height;
          mat4_exports.perspective(this[P_SESSION].projectionMatrices[XREye.None], this[P_SESSION].renderState.inlineVerticalFieldOfView, aspect, depthNear, depthFar);
        }
        const frame = new XRFrame(this, this[P_SESSION].frameHandle, true, true, performance.now());
        const time = performance.now();
        const devui = this[P_SESSION].device[P_DEVICE].devui;
        if (devui) {
          devui.render(time);
        }
        if (this[P_SESSION].mode === "immersive-ar") {
          const sem = this[P_SESSION].device[P_DEVICE].sem;
          if (sem) {
            sem.render(time);
          }
        }
        if (this[P_SESSION].enabledFeatures.includes("anchors")) {
          this[P_SESSION].updateTrackedAnchors();
        }
        if (this[P_SESSION].enabledFeatures.includes("plane-detection")) {
          this[P_SESSION].updateTrackedPlanes(frame);
        }
        if (this[P_SESSION].enabledFeatures.includes("mesh-detection")) {
          this[P_SESSION].updateTrackedMeshes(frame);
        }
        if (this[P_SESSION].enabledFeatures.includes("hit-test")) {
          this[P_SESSION].computeHitTestResults(frame);
        }
        this[P_SESSION].device[P_DEVICE].onFrameStart(frame);
        this[P_SESSION].updateActiveInputSources();
        const callbacks = this[P_SESSION].currentFrameCallbacks = this[P_SESSION].frameCallbacks;
        this[P_SESSION].frameCallbacks = [];
        const rightNow = performance.now();
        for (let i2 = 0; i2 < callbacks.length; i2++) {
          try {
            if (!callbacks[i2].cancelled) {
              callbacks[i2].callback(rightNow, frame);
            }
          } catch (err) {
            console.error(err);
          }
        }
        this[P_SESSION].currentFrameCallbacks = null;
        frame[P_FRAME].active = false;
      },
      nominalFrameRate: device.internalNominalFrameRate,
      referenceSpaces: [],
      inputSourceArray: [],
      activeInputSources: [],
      updateActiveInputSources: () => {
        const handTrackingOn = this[P_SESSION].enabledFeatures.includes("hand-tracking");
        const prevInputs = this[P_SESSION].activeInputSources;
        const currInputs = this[P_SESSION].device.inputSources.filter((inputSource) => !inputSource.hand || handTrackingOn);
        const added = currInputs.filter((item) => !prevInputs.includes(item));
        const removed = prevInputs.filter((item) => !currInputs.includes(item));
        this[P_SESSION].activeInputSources = currInputs;
        if (added.length > 0 || removed.length > 0) {
          this.dispatchEvent(new XRInputSourcesChangeEvent("inputsourceschange", {
            session: this,
            added,
            removed
          }));
        }
      },
      trackedAnchors: new XRAnchorSet(),
      persistentAnchors: /* @__PURE__ */ new Map(),
      newAnchors: /* @__PURE__ */ new Map(),
      frameTrackedAnchors: new XRAnchorSet(),
      updateTrackedAnchors: () => {
        if (this[P_SESSION].enabledFeatures.includes("anchors")) {
          this[P_SESSION].frameTrackedAnchors.clear();
          Array.from(this[P_SESSION].trackedAnchors).forEach((anchor) => {
            if (anchor[P_ANCHOR].deleted) {
              this[P_SESSION].trackedAnchors.delete(anchor);
              if (this[P_SESSION].newAnchors.has(anchor)) {
                const { reject } = this[P_SESSION].newAnchors.get(anchor);
                reject(new DOMException("Anchor is no longer tracked", "InvalidStateError"));
              }
            } else {
              this[P_SESSION].frameTrackedAnchors.add(anchor);
              if (this[P_SESSION].newAnchors.has(anchor)) {
                const { resolve } = this[P_SESSION].newAnchors.get(anchor);
                resolve(anchor);
                this[P_SESSION].newAnchors.delete(anchor);
              }
            }
          });
        }
      },
      trackedPlanes: /* @__PURE__ */ new Map(),
      updateTrackedPlanes: (frame) => {
        const sem = this[P_SESSION].device[P_DEVICE].sem;
        if (!sem) {
          return;
        }
        const trackedPlanes = Array.from(this[P_SESSION].trackedPlanes.keys());
        trackedPlanes.forEach((plane) => {
          if (!sem.trackedPlanes.has(plane)) {
            this[P_SESSION].trackedPlanes.delete(plane);
          }
        });
        sem.trackedPlanes.forEach((plane) => {
          let xrPlane = this[P_SESSION].trackedPlanes.get(plane);
          if (!xrPlane) {
            const planeSpace = new XRSpace(this[P_SESSION].device[P_DEVICE].globalSpace, plane.transform.matrix);
            xrPlane = new XRPlane(plane, planeSpace, plane.polygon, plane.semanticLabel);
            this[P_SESSION].trackedPlanes.set(plane, xrPlane);
          }
          xrPlane[P_PLANE].lastChangedTime = frame.predictedDisplayTime;
          xrPlane[P_PLANE].frame = frame;
          frame[P_FRAME].detectedPlanes.add(xrPlane);
        });
      },
      trackedMeshes: /* @__PURE__ */ new Map(),
      updateTrackedMeshes: (frame) => {
        const sem = this[P_SESSION].device[P_DEVICE].sem;
        if (!sem) {
          return;
        }
        const trackedMeshes = Array.from(this[P_SESSION].trackedMeshes.keys());
        trackedMeshes.forEach((mesh) => {
          if (!sem.trackedMeshes.has(mesh)) {
            this[P_SESSION].trackedMeshes.delete(mesh);
          }
        });
        sem.trackedMeshes.forEach((mesh) => {
          let xrMesh = this[P_SESSION].trackedMeshes.get(mesh);
          if (!xrMesh) {
            const meshSpace = new XRSpace(this[P_SESSION].device[P_DEVICE].globalSpace, mesh.transform.matrix);
            xrMesh = new XRMesh(mesh, meshSpace, mesh.vertices, mesh.indices, mesh.semanticLabel);
            this[P_SESSION].trackedMeshes.set(mesh, xrMesh);
          }
          xrMesh[P_MESH].lastChangedTime = frame.predictedDisplayTime;
          xrMesh[P_MESH].frame = frame;
          frame[P_FRAME].detectedMeshes.add(xrMesh);
        });
      },
      hitTestSources: /* @__PURE__ */ new Set(),
      computeHitTestResults: (frame) => {
        const sem = this[P_SESSION].device[P_DEVICE].sem;
        if (!sem)
          return;
        const globalSpace = this[P_SESSION].device[P_DEVICE].globalSpace;
        this[P_SESSION].hitTestSources.forEach((hitTestSource) => {
          const sourceSpace = hitTestSource[P_HIT_TEST].space;
          const sourceGlobalOffset = XRSpaceUtils.calculateGlobalOffsetMatrix(sourceSpace);
          const rayLocalOffset = hitTestSource[P_HIT_TEST].offsetRay.matrix;
          const rayGlobalOffset = mat4_exports.create();
          mat4_exports.multiply(rayGlobalOffset, sourceGlobalOffset, rayLocalOffset);
          const hitTestResults = [];
          sem.computeHitTestResults(rayGlobalOffset).forEach((matrix) => {
            const offsetSpace = new XRSpace(globalSpace, matrix);
            const hitTestResult = new XRHitTestResult(frame, offsetSpace);
            hitTestResults.push(hitTestResult);
          });
          frame[P_FRAME].hitTestResultsMap.set(hitTestSource, hitTestResults);
        });
      },
      onend: null,
      oninputsourceschange: null,
      onselect: null,
      onselectstart: null,
      onselectend: null,
      onsqueeze: null,
      onsqueezestart: null,
      onsqueezeend: null,
      onvisibilitychange: null,
      onframeratechange: null
    };
    XRAnchorUtils.recoverPersistentAnchorsFromStorage(this);
    this[P_SESSION].onDeviceFrame();
  }
  get visibilityState() {
    return this[P_SESSION].device.visibilityState;
  }
  get frameRate() {
    return this[P_SESSION].nominalFrameRate;
  }
  get supportedFrameRates() {
    return new Float32Array(this[P_SESSION].device.supportedFrameRates);
  }
  get renderState() {
    return this[P_SESSION].renderState;
  }
  get inputSources() {
    this[P_SESSION].inputSourceArray.length = 0;
    if (!this[P_SESSION].ended && this[P_SESSION].mode !== "inline") {
      this[P_SESSION].inputSourceArray.push(...this[P_SESSION].activeInputSources);
    }
    return this[P_SESSION].inputSourceArray;
  }
  get enabledFeatures() {
    return this[P_SESSION].enabledFeatures;
  }
  get isSystemKeyboardSupported() {
    return this[P_SESSION].isSystemKeyboardSupported;
  }
  get environmentBlendMode() {
    var _a2;
    return (_a2 = this[P_SESSION].device[P_DEVICE].environmentBlendModes[this[P_SESSION].mode]) !== null && _a2 !== void 0 ? _a2 : XREnvironmentBlendMode.Opaque;
  }
  get interactionMode() {
    return this[P_SESSION].device[P_DEVICE].interactionMode;
  }
  updateRenderState(state = {}) {
    var _a2, _b, _c, _d;
    if (this[P_SESSION].ended) {
      throw new DOMException("XRSession has already ended.", "InvalidStateError");
    }
    if (state.baseLayer && state.baseLayer[P_WEBGL_LAYER].session !== this) {
      throw new DOMException("Base layer was created by a different XRSession", "InvalidStateError");
    }
    if (state.inlineVerticalFieldOfView != null && this[P_SESSION].mode !== "inline") {
      throw new DOMException("InlineVerticalFieldOfView must not be set for an immersive session", "InvalidStateError");
    }
    const compoundStateInit = {
      baseLayer: state.baseLayer || ((_a2 = this[P_SESSION].pendingRenderState) === null || _a2 === void 0 ? void 0 : _a2.baseLayer) || void 0,
      depthFar: state.depthFar || ((_b = this[P_SESSION].pendingRenderState) === null || _b === void 0 ? void 0 : _b.depthFar) || void 0,
      depthNear: state.depthNear || ((_c = this[P_SESSION].pendingRenderState) === null || _c === void 0 ? void 0 : _c.depthNear) || void 0,
      inlineVerticalFieldOfView: state.inlineVerticalFieldOfView || ((_d = this[P_SESSION].pendingRenderState) === null || _d === void 0 ? void 0 : _d.inlineVerticalFieldOfView) || void 0
    };
    this[P_SESSION].pendingRenderState = new XRRenderState(compoundStateInit, this[P_SESSION].renderState);
  }
  // the nominal frame rate updates are emulated, no actual update to the
  // display frame rate of the device will be executed
  async updateTargetFrameRate(rate) {
    return new Promise((resolve, reject) => {
      if (this[P_SESSION].ended) {
        reject(new DOMException("XRSession has already ended.", "InvalidStateError"));
      } else if (!this[P_SESSION].device.supportedFrameRates.includes(rate)) {
        reject(new DOMException("Requested frame rate not supported.", "InvalidStateError"));
      } else {
        if (this[P_SESSION].nominalFrameRate === rate) {
          console.log(`Requested frame rate is the same as the current nominal frame rate, no update made`);
        } else {
          this[P_SESSION].nominalFrameRate = rate;
          this.dispatchEvent(new XRSessionEvent("frameratechange", { session: this }));
          console.log(`Nominal frame rate updated to ${rate}`);
        }
        resolve();
      }
    });
  }
  async requestReferenceSpace(type) {
    return new Promise((resolve, reject) => {
      if (this[P_SESSION].ended || !this[P_SESSION].referenceSpaceIsSupported(type)) {
        reject(new DOMException("The requested reference space type is not supported.", "NotSupportedError"));
        return;
      }
      let referenceSpace;
      switch (type) {
        case XRReferenceSpaceType.Viewer:
          referenceSpace = this[P_SESSION].device.viewerSpace;
          break;
        case XRReferenceSpaceType.Local:
          referenceSpace = new XRReferenceSpace(type, this[P_SESSION].device[P_DEVICE].globalSpace, this[P_SESSION].device.viewerSpace[P_SPACE].offsetMatrix);
          break;
        case XRReferenceSpaceType.LocalFloor:
        case XRReferenceSpaceType.BoundedFloor:
        case XRReferenceSpaceType.Unbounded:
          referenceSpace = new XRReferenceSpace(type, this[P_SESSION].device[P_DEVICE].globalSpace);
          break;
      }
      this[P_SESSION].referenceSpaces.push(referenceSpace);
      resolve(referenceSpace);
    });
  }
  requestAnimationFrame(callback) {
    if (this[P_SESSION].ended) {
      return 0;
    }
    const frameHandle = ++this[P_SESSION].frameHandle;
    this[P_SESSION].frameCallbacks.push({
      handle: frameHandle,
      callback,
      cancelled: false
    });
    return frameHandle;
  }
  cancelAnimationFrame(handle) {
    let callbacks = this[P_SESSION].frameCallbacks;
    let index = callbacks.findIndex((d) => d && d.handle === handle);
    if (index > -1) {
      callbacks[index].cancelled = true;
      callbacks.splice(index, 1);
    }
    callbacks = this[P_SESSION].currentFrameCallbacks;
    if (callbacks) {
      index = callbacks.findIndex((d) => d && d.handle === handle);
      if (index > -1) {
        callbacks[index].cancelled = true;
      }
    }
  }
  async end() {
    return new Promise((resolve, reject) => {
      if (this[P_SESSION].ended || this[P_SESSION].deviceFrameHandle === null) {
        reject(new DOMException("XRSession has already ended.", "InvalidStateError"));
      } else {
        globalThis.cancelAnimationFrame(this[P_SESSION].deviceFrameHandle);
        this[P_SESSION].device[P_DEVICE].onSessionEnd();
        this.dispatchEvent(new XRSessionEvent("end", { session: this }));
        resolve();
      }
    });
  }
  // anchors
  get persistentAnchors() {
    return Array.from(this[P_SESSION].persistentAnchors.keys());
  }
  restorePersistentAnchor(uuid) {
    return new Promise((resolve, reject) => {
      if (!this[P_SESSION].persistentAnchors.has(uuid)) {
        reject(new DOMException(`Persistent anchor with uuid ${uuid} not found.`, "InvalidStateError"));
      } else if (this[P_SESSION].ended) {
        reject(new DOMException("XRSession has already ended.", "InvalidStateError"));
      } else {
        const anchor = this[P_SESSION].persistentAnchors.get(uuid);
        if (this[P_SESSION].newAnchors.has(anchor)) {
          reject(new DOMException(`Multiple concurrent attempts detected to restore the anchor with UUID: ${uuid}.`, "InvalidStateError"));
        } else {
          this[P_SESSION].trackedAnchors.add(anchor);
          this[P_SESSION].newAnchors.set(anchor, { resolve, reject });
        }
      }
    });
  }
  deletePersistentAnchor(uuid) {
    return new Promise((resolve, reject) => {
      if (!this[P_SESSION].persistentAnchors.has(uuid)) {
        reject(new DOMException(`Persistent anchor with uuid ${uuid} not found.`, "InvalidStateError"));
      } else {
        const anchor = this[P_SESSION].persistentAnchors.get(uuid);
        this[P_SESSION].persistentAnchors.delete(uuid);
        anchor.delete();
        resolve(void 0);
      }
    });
  }
  requestHitTestSource(options) {
    return new Promise((resolve, reject) => {
      if (!this[P_SESSION].enabledFeatures.includes("hit-test")) {
        reject(new DOMException(`WebXR feature "hit-test" is not supported by current session`, "NotSupportedError"));
      } else if (this[P_SESSION].ended) {
        reject(new DOMException("XRSession has already ended.", "InvalidStateError"));
      } else if (!this[P_SESSION].device[P_DEVICE].sem) {
        reject(new DOMException("Synthethic Environment Module required for emulating hit-test", "OperationError"));
      } else {
        const xrHitTestSource = new XRHitTestSource(this, options);
        this[P_SESSION].hitTestSources.add(xrHitTestSource);
        resolve(xrHitTestSource);
      }
    });
  }
  // events
  get onend() {
    var _a2;
    return (_a2 = this[P_SESSION].onend) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onend(callback) {
    if (this[P_SESSION].onend) {
      this.removeEventListener("end", this[P_SESSION].onend);
    }
    this[P_SESSION].onend = callback;
    if (callback) {
      this.addEventListener("end", callback);
    }
  }
  get oninputsourceschange() {
    var _a2;
    return (_a2 = this[P_SESSION].oninputsourceschange) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set oninputsourceschange(callback) {
    if (this[P_SESSION].oninputsourceschange) {
      this.removeEventListener("inputsourceschange", this[P_SESSION].oninputsourceschange);
    }
    this[P_SESSION].oninputsourceschange = callback;
    if (callback) {
      this.addEventListener("inputsourceschange", callback);
    }
  }
  get onselect() {
    var _a2;
    return (_a2 = this[P_SESSION].onselect) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onselect(callback) {
    if (this[P_SESSION].onselect) {
      this.removeEventListener("select", this[P_SESSION].onselect);
    }
    this[P_SESSION].onselect = callback;
    if (callback) {
      this.addEventListener("select", callback);
    }
  }
  get onselectstart() {
    var _a2;
    return (_a2 = this[P_SESSION].onselectstart) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onselectstart(callback) {
    if (this[P_SESSION].onselectstart) {
      this.removeEventListener("selectstart", this[P_SESSION].onselectstart);
    }
    this[P_SESSION].onselectstart = callback;
    if (callback) {
      this.addEventListener("selectstart", callback);
    }
  }
  get onselectend() {
    var _a2;
    return (_a2 = this[P_SESSION].onselectend) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onselectend(callback) {
    if (this[P_SESSION].onselectend) {
      this.removeEventListener("selectend", this[P_SESSION].onselectend);
    }
    this[P_SESSION].onselectend = callback;
    if (callback) {
      this.addEventListener("selectend", callback);
    }
  }
  get onsqueeze() {
    var _a2;
    return (_a2 = this[P_SESSION].onsqueeze) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onsqueeze(callback) {
    if (this[P_SESSION].onsqueeze) {
      this.removeEventListener("squeeze", this[P_SESSION].onsqueeze);
    }
    this[P_SESSION].onsqueeze = callback;
    if (callback) {
      this.addEventListener("squeeze", callback);
    }
  }
  get onsqueezestart() {
    var _a2;
    return (_a2 = this[P_SESSION].onsqueezestart) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onsqueezestart(callback) {
    if (this[P_SESSION].onsqueezestart) {
      this.removeEventListener("squeezestart", this[P_SESSION].onsqueezestart);
    }
    this[P_SESSION].onsqueezestart = callback;
    if (callback) {
      this.addEventListener("squeezestart", callback);
    }
  }
  get onsqueezeend() {
    var _a2;
    return (_a2 = this[P_SESSION].onsqueezeend) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onsqueezeend(callback) {
    if (this[P_SESSION].onsqueezeend) {
      this.removeEventListener("squeezeend", this[P_SESSION].onsqueezeend);
    }
    this[P_SESSION].onsqueezeend = callback;
    if (callback) {
      this.addEventListener("squeezeend", callback);
    }
  }
  get onvisibilitychange() {
    var _a2;
    return (_a2 = this[P_SESSION].onvisibilitychange) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onvisibilitychange(callback) {
    if (this[P_SESSION].onvisibilitychange) {
      this.removeEventListener("visibilitychange", this[P_SESSION].onvisibilitychange);
    }
    this[P_SESSION].onvisibilitychange = callback;
    if (callback) {
      this.addEventListener("visibilitychange", callback);
    }
  }
  get onframeratechange() {
    var _a2;
    return (_a2 = this[P_SESSION].onframeratechange) !== null && _a2 !== void 0 ? _a2 : () => {
    };
  }
  set onframeratechange(callback) {
    if (this[P_SESSION].onframeratechange) {
      this.removeEventListener("frameratechange", this[P_SESSION].onframeratechange);
    }
    this[P_SESSION].onframeratechange = callback;
    if (callback) {
      this.addEventListener("frameratechange", callback);
    }
  }
};

// node_modules/iwer/lib/input/XRHand.js
var XRHandJoint;
(function(XRHandJoint2) {
  XRHandJoint2["Wrist"] = "wrist";
  XRHandJoint2["ThumbMetacarpal"] = "thumb-metacarpal";
  XRHandJoint2["ThumbPhalanxProximal"] = "thumb-phalanx-proximal";
  XRHandJoint2["ThumbPhalanxDistal"] = "thumb-phalanx-distal";
  XRHandJoint2["ThumbTip"] = "thumb-tip";
  XRHandJoint2["IndexFingerMetacarpal"] = "index-finger-metacarpal";
  XRHandJoint2["IndexFingerPhalanxProximal"] = "index-finger-phalanx-proximal";
  XRHandJoint2["IndexFingerPhalanxIntermediate"] = "index-finger-phalanx-intermediate";
  XRHandJoint2["IndexFingerPhalanxDistal"] = "index-finger-phalanx-distal";
  XRHandJoint2["IndexFingerTip"] = "index-finger-tip";
  XRHandJoint2["MiddleFingerMetacarpal"] = "middle-finger-metacarpal";
  XRHandJoint2["MiddleFingerPhalanxProximal"] = "middle-finger-phalanx-proximal";
  XRHandJoint2["MiddleFingerPhalanxIntermediate"] = "middle-finger-phalanx-intermediate";
  XRHandJoint2["MiddleFingerPhalanxDistal"] = "middle-finger-phalanx-distal";
  XRHandJoint2["MiddleFingerTip"] = "middle-finger-tip";
  XRHandJoint2["RingFingerMetacarpal"] = "ring-finger-metacarpal";
  XRHandJoint2["RingFingerPhalanxProximal"] = "ring-finger-phalanx-proximal";
  XRHandJoint2["RingFingerPhalanxIntermediate"] = "ring-finger-phalanx-intermediate";
  XRHandJoint2["RingFingerPhalanxDistal"] = "ring-finger-phalanx-distal";
  XRHandJoint2["RingFingerTip"] = "ring-finger-tip";
  XRHandJoint2["PinkyFingerMetacarpal"] = "pinky-finger-metacarpal";
  XRHandJoint2["PinkyFingerPhalanxProximal"] = "pinky-finger-phalanx-proximal";
  XRHandJoint2["PinkyFingerPhalanxIntermediate"] = "pinky-finger-phalanx-intermediate";
  XRHandJoint2["PinkyFingerPhalanxDistal"] = "pinky-finger-phalanx-distal";
  XRHandJoint2["PinkyFingerTip"] = "pinky-finger-tip";
})(XRHandJoint || (XRHandJoint = {}));
var XRHand = class extends Map {
};

// node_modules/iwer/lib/spaces/XRJointSpace.js
var XRJointSpace = class extends XRSpace {
  constructor(jointName, parentSpace, offsetMatrix) {
    super(parentSpace, offsetMatrix);
    this[P_JOINT_SPACE] = { jointName, radius: 0 };
  }
  get jointName() {
    return this[P_JOINT_SPACE].jointName;
  }
};

// node_modules/iwer/lib/device/configs/hand/pinch.js
var pinchHandPose = {
  jointTransforms: {
    wrist: {
      offsetMatrix: [
        0.9060805439949036,
        -0.1844543218612671,
        0.3807799518108368,
        0,
        -0.08027800172567368,
        0.8086723685264587,
        0.5827555656433105,
        0,
        -0.4154181182384491,
        -0.5585917234420776,
        0.7179155349731445,
        0,
        -0.06867414712905884,
        -0.009423808194696903,
        0.10627774149179459,
        1
      ],
      radius: 0.021460847929120064
    },
    "thumb-metacarpal": {
      offsetMatrix: [
        -0.5012241005897522,
        -0.8650535345077515,
        -0.0213695727288723,
        0,
        0.7415963411331177,
        -0.4421543478965759,
        0.5045139193534851,
        0,
        -0.44587990641593933,
        0.23702676594257355,
        0.8631392121315002,
        0,
        -0.032122574746608734,
        -0.01196830440312624,
        0.07194234430789948,
        1
      ],
      radius: 0.019382517784833908
    },
    "thumb-phalanx-proximal": {
      offsetMatrix: [
        -0.3175753057003021,
        -0.9460570216178894,
        -0.06419729441404343,
        0,
        0.8958902955055237,
        -0.32153913378715515,
        0.30658137798309326,
        0,
        -0.3106854259967804,
        0.03984907269477844,
        0.9496771097183228,
        0,
        -0.017625702545046806,
        -0.01967475935816765,
        0.04387917369604111,
        1
      ],
      radius: 0.01228295173496008
    },
    "thumb-phalanx-distal": {
      offsetMatrix: [
        -0.4944636821746826,
        -0.8691971898078918,
        0.001086252392269671,
        0,
        0.8307800889015198,
        -0.4722411036491394,
        0.2946045398712158,
        0,
        -0.25555649399757385,
        0.14657381176948547,
        0.9556186199188232,
        0,
        -0.007126678712666035,
        -0.021021386608481407,
        0.011786630377173424,
        1
      ],
      radius: 0.009768804535269737
    },
    "thumb-tip": {
      offsetMatrix: [
        -0.4944636821746826,
        -0.8691971898078918,
        0.001086252392269671,
        0,
        0.8307800889015198,
        -0.4722411036491394,
        0.2946045398712158,
        0,
        -0.25555649399757385,
        0.14657381176948547,
        0.9556186199188232,
        0,
        3423091256991029e-19,
        -0.024528030306100845,
        -0.011410919018089771,
        1
      ],
      radius: 0.008768804371356964
    },
    "index-finger-metacarpal": {
      offsetMatrix: [
        0.9060805439949036,
        -0.1844543218612671,
        0.3807799518108368,
        0,
        -0.08027800172567368,
        0.8086723685264587,
        0.5827555656433105,
        0,
        -0.4154181182384491,
        -0.5585917234420776,
        0.7179155349731445,
        0,
        -0.038037415593862534,
        -0.0020236473064869642,
        0.07626739144325256,
        1
      ],
      radius: 0.021228281781077385
    },
    "index-finger-phalanx-proximal": {
      offsetMatrix: [
        0.7986818552017212,
        -0.35985732078552246,
        0.48229536414146423,
        0,
        0.538311243057251,
        0.7854709625244141,
        -0.30537736415863037,
        0,
        -0.2689369022846222,
        0.5035246014595032,
        0.8210577368736267,
        0,
        -0.006869405973702669,
        0.033938243985176086,
        0.04206443578004837,
        1
      ],
      radius: 0.010295259766280651
    },
    "index-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.8285930156707764,
        -0.32672837376594543,
        0.4546217918395996,
        0,
        0.5577570199966431,
        0.4116027057170868,
        -0.7207564115524292,
        0,
        0.04836784675717354,
        0.8507823944091797,
        0.5232869386672974,
        0,
        0.0033306588884443045,
        0.014840902760624886,
        0.010923954658210278,
        1
      ],
      radius: 0.00853810179978609
    },
    "index-finger-phalanx-distal": {
      offsetMatrix: [
        0.8412464261054993,
        -0.35794928669929504,
        0.4051857888698578,
        0,
        0.5139996409416199,
        0.29711154103279114,
        -0.8046918511390686,
        0,
        0.16765329241752625,
        0.8852096796035767,
        0.4339304566383362,
        0,
        0.0021551470272243023,
        -0.0058362227864563465,
        -0.0017938464879989624,
        1
      ],
      radius: 0.007636196445673704
    },
    "index-finger-tip": {
      offsetMatrix: [
        0.8412464261054993,
        -0.35794928669929504,
        0.4051857888698578,
        0,
        0.5139996409416199,
        0.29711154103279114,
        -0.8046918511390686,
        0,
        0.16765329241752625,
        0.8852096796035767,
        0.4339304566383362,
        0,
        -0.00131594471167773,
        -0.025222131982445717,
        -0.012442642822861671,
        1
      ],
      radius: 0.006636196281760931
    },
    "middle-finger-metacarpal": {
      offsetMatrix: [
        0.9060805439949036,
        -0.1844543218612671,
        0.3807799518108368,
        0,
        -0.08027800172567368,
        0.8086723685264587,
        0.5827555656433105,
        0,
        -0.4154181182384491,
        -0.5585917234420776,
        0.7179155349731445,
        0,
        -0.05395089089870453,
        0.003063359996303916,
        0.07402937114238739,
        1
      ],
      radius: 0.021231964230537415
    },
    "middle-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9187911748886108,
        -0.1530158370733261,
        0.36387869715690613,
        0,
        0.038666240870952606,
        0.9522662162780762,
        0.302808940410614,
        0,
        -0.3928440511226654,
        -0.26414817571640015,
        0.8808513283729553,
        0,
        -0.02717282809317112,
        0.04162866622209549,
        0.03678669035434723,
        1
      ],
      radius: 0.01117393933236599
    },
    "middle-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9228746294975281,
        -0.12856416404247284,
        0.36300456523895264,
        0,
        0.14524033665657043,
        0.9892153143882751,
        -0.01890045404434204,
        0,
        -0.3566599190235138,
        0.07016586512327194,
        0.9315956234931946,
        0,
        -0.01030921470373869,
        0.05296773463487625,
        -0.0010256498353555799,
        1
      ],
      radius: 0.008030958473682404
    },
    "middle-finger-phalanx-distal": {
      offsetMatrix: [
        0.9325166344642639,
        -0.040404170751571655,
        0.35885775089263916,
        0,
        0.06836572289466858,
        0.995502769947052,
        -0.0655682161450386,
        0,
        -0.3545948565006256,
        0.08567725121974945,
        0.9310863614082336,
        0,
        -4833847051486373e-19,
        0.05103470757603645,
        -0.026690717786550522,
        1
      ],
      radius: 0.007629410829395056
    },
    "middle-finger-tip": {
      offsetMatrix: [
        0.9325166344642639,
        -0.040404170751571655,
        0.35885775089263916,
        0,
        0.06836572289466858,
        0.995502769947052,
        -0.0655682161450386,
        0,
        -0.3545948565006256,
        0.08567725121974945,
        0.9310863614082336,
        0,
        0.008158999495208263,
        0.05004044249653816,
        -0.050120558589696884,
        1
      ],
      radius: 0.006629410665482283
    },
    "ring-finger-metacarpal": {
      offsetMatrix: [
        0.9060805439949036,
        -0.1844543218612671,
        0.3807799518108368,
        0,
        -0.08027800172567368,
        0.8086723685264587,
        0.5827555656433105,
        0,
        -0.4154181182384491,
        -0.5585917234420776,
        0.7179155349731445,
        0,
        -0.06732909381389618,
        0.007902119308710098,
        0.07209732383489609,
        1
      ],
      radius: 0.019088275730609894
    },
    "ring-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9391821026802063,
        -0.027994679287075996,
        0.34227466583251953,
        0,
        -0.18282271921634674,
        0.8029410243034363,
        0.5673282742500305,
        0,
        -0.2907087206840515,
        -0.5954000353813171,
        0.7489906549453735,
        0,
        -0.047129884362220764,
        0.03806127607822418,
        0.032147664576768875,
        1
      ],
      radius: 0.00992213748395443
    },
    "ring-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9249380826950073,
        0.03699534013867378,
        0.3783116042613983,
        0,
        -0.12898847460746765,
        0.9667453765869141,
        0.2208271026611328,
        0,
        -0.3575615882873535,
        -0.25304901599884033,
        0.8989526629447937,
        0,
        -0.03579339757561684,
        0.06127955764532089,
        0.002939916681498289,
        1
      ],
      radius: 0.007611672393977642
    },
    "ring-finger-phalanx-distal": {
      offsetMatrix: [
        0.9001164436340332,
        0.03983335196971893,
        0.4338230490684509,
        0,
        -0.09662467986345291,
        0.9892624020576477,
        0.10964841395616531,
        0,
        -0.4247973561286926,
        -0.14061418175697327,
        0.8943013548851013,
        0,
        -0.026291755959391594,
        0.06800390034914017,
        -0.02094830758869648,
        1
      ],
      radius: 0.007231088820844889
    },
    "ring-finger-tip": {
      offsetMatrix: [
        0.9001164436340332,
        0.03983335196971893,
        0.4338230490684509,
        0,
        -0.09662467986345291,
        0.9892624020576477,
        0.10964841395616531,
        0,
        -0.4247973561286926,
        -0.14061418175697327,
        0.8943013548851013,
        0,
        -0.016345610842108727,
        0.07300511747598648,
        -0.04263874143362045,
        1
      ],
      radius: 0.0062310886569321156
    },
    "pinky-finger-metacarpal": {
      offsetMatrix: [
        0.8769711852073669,
        0.31462907791137695,
        0.36322021484375,
        0,
        -0.4506046175956726,
        0.801031768321991,
        0.39408499002456665,
        0,
        -0.16696058213710785,
        -0.5092697143554688,
        0.8442559838294983,
        0,
        -0.07460174709558487,
        0.0062340241856873035,
        0.06756893545389175,
        1
      ],
      radius: 0.01808827556669712
    },
    "pinky-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9498357176780701,
        0.1553308218717575,
        0.2714462876319885,
        0,
        -0.3019258379936218,
        0.6817675232887268,
        0.6663586497306824,
        0,
        -0.08155745267868042,
        -0.7148879170417786,
        0.694466233253479,
        0,
        -0.06697750836610794,
        0.029482364654541016,
        0.02902858518064022,
        1
      ],
      radius: 0.008483353070914745
    },
    "pinky-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9214097261428833,
        0.27928245067596436,
        0.2701927423477173,
        0,
        -0.3670244514942169,
        0.8538867831230164,
        0.36901235580444336,
        0,
        -0.12765564024448395,
        -0.43917882442474365,
        0.8892839550971985,
        0,
        -0.06447203457355499,
        0.05144399777054787,
        0.0076942890882492065,
        1
      ],
      radius: 0.0067641944624483585
    },
    "pinky-finger-phalanx-distal": {
      offsetMatrix: [
        0.9038633704185486,
        0.23618005216121674,
        0.3567195236682892,
        0,
        -0.3532794713973999,
        0.8823202252388,
        0.3109731376171112,
        0,
        -0.24129553139209747,
        -0.4070987403392792,
        0.8809353709220886,
        0,
        -0.06187915802001953,
        0.060364335775375366,
        -0.010368337854743004,
        1
      ],
      radius: 0.0064259846694767475
    },
    "pinky-finger-tip": {
      offsetMatrix: [
        0.9038633704185486,
        0.23618005216121674,
        0.3567195236682892,
        0,
        -0.3532794713973999,
        0.8823202252388,
        0.3109731376171112,
        0,
        -0.24129553139209747,
        -0.4070987403392792,
        0.8809353709220886,
        0,
        -0.056796226650476456,
        0.07042007893323898,
        -0.02921444922685623,
        1
      ],
      radius: 0.005425984505563974
    }
  },
  gripOffsetMatrix: [
    0.08027800917625427,
    -0.8086723685264587,
    -0.5827556252479553,
    0,
    -0.4154181480407715,
    -0.5585916638374329,
    0.7179154753684998,
    0,
    -0.9060805439949036,
    0.1844543218612671,
    -0.3807799518108368,
    0,
    -0.038054611533880234,
    -0.002910431008785963,
    0.03720742464065552,
    1
  ]
};

// node_modules/iwer/lib/device/configs/hand/point.js
var pointHandPose = {
  jointTransforms: {
    wrist: {
      offsetMatrix: [
        0.9340395331382751,
        -0.13936476409435272,
        0.32885703444480896,
        0,
        -0.005510995630174875,
        0.914999783039093,
        0.40341612696647644,
        0,
        -0.3571262061595917,
        -0.37861889600753784,
        0.8538784384727478,
        0,
        -0.05789132043719292,
        0.01670890860259533,
        0.11183350533246994,
        1
      ],
      radius: 0.021460847929120064
    },
    "thumb-metacarpal": {
      offsetMatrix: [
        0.02145560085773468,
        -0.9978390336036682,
        0.0621047280728817,
        0,
        0.41311800479888916,
        0.06541631370782852,
        0.9083252549171448,
        0,
        -0.9104245901107788,
        0.006167683284729719,
        0.4136286973953247,
        0,
        -0.016488194465637207,
        0.012708572670817375,
        0.08862338215112686,
        1
      ],
      radius: 0.019382517784833908
    },
    "thumb-phalanx-proximal": {
      offsetMatrix: [
        0.21270370483398438,
        -0.966137707233429,
        0.14606566727161407,
        0,
        0.49890995025634766,
        0.2359165996313095,
        0.8339261412620544,
        0,
        -0.8401462435722351,
        -0.10450579971075058,
        0.5321959853172302,
        0,
        0.013112368993461132,
        0.012508046813309193,
        0.07517509907484055,
        1
      ],
      radius: 0.01228295173496008
    },
    "thumb-phalanx-distal": {
      offsetMatrix: [
        0.01653280481696129,
        -0.9986647963523865,
        0.048943229019641876,
        0,
        0.26313456892967224,
        0.051570065319538116,
        0.9633802771568298,
        0,
        -0.9646173715591431,
        -0.0030490627977997065,
        0.26363563537597656,
        0,
        0.04150351136922836,
        0.016039609909057617,
        0.05719054117798805,
        1
      ],
      radius: 0.009768804535269737
    },
    "thumb-tip": {
      offsetMatrix: [
        0.01653280481696129,
        -0.9986647963523865,
        0.048943229019641876,
        0,
        0.26313456892967224,
        0.051570065319538116,
        0.9633802771568298,
        0,
        -0.9646173715591431,
        -0.0030490627977997065,
        0.26363563537597656,
        0,
        0.06548332422971725,
        0.01683700829744339,
        0.0516640841960907,
        1
      ],
      radius: 0.008768804371356964
    },
    "index-finger-metacarpal": {
      offsetMatrix: [
        0.9340395331382751,
        -0.13936476409435272,
        0.32885703444480896,
        0,
        -0.005510995630174875,
        0.914999783039093,
        0.40341612696647644,
        0,
        -0.3571262061595917,
        -0.37861889600753784,
        0.8538784384727478,
        0,
        -0.02592567168176174,
        0.019982583820819855,
        0.08479326963424683,
        1
      ],
      radius: 0.021228281781077385
    },
    "index-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9063700437545776,
        -0.21756279468536377,
        0.3621589243412018,
        0,
        0.0970839336514473,
        0.9415287375450134,
        0.3226419687271118,
        0,
        -0.41117796301841736,
        -0.2572731077671051,
        0.8744958639144897,
        0,
        -0.0015709538711234927,
        0.043078210204839706,
        0.034657616168260574,
        1
      ],
      radius: 0.010295259766280651
    },
    "index-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9159826040267944,
        -0.1651475727558136,
        0.36565208435058594,
        0,
        0.09755707532167435,
        0.9756820797920227,
        0.1962820291519165,
        0,
        -0.3891757130622864,
        -0.14411886036396027,
        0.9098196625709534,
        0,
        0.014023927971720695,
        0.052835866808891296,
        0.0014903299743309617,
        1
      ],
      radius: 0.00853810179978609
    },
    "index-finger-phalanx-distal": {
      offsetMatrix: [
        0.9378057718276978,
        -0.12329639494419098,
        0.3245268166065216,
        0,
        0.032558172941207886,
        0.9619227051734924,
        0.2713746726512909,
        0,
        -0.3456292748451233,
        -0.2439306229352951,
        0.9061115384101868,
        0,
        0.023482320830225945,
        0.05633850023150444,
        -0.020621655508875847,
        1
      ],
      radius: 0.007636196445673704
    },
    "index-finger-tip": {
      offsetMatrix: [
        0.9378057718276978,
        -0.12329639494419098,
        0.3245268166065216,
        0,
        0.032558172941207886,
        0.9619227051734924,
        0.2713746726512909,
        0,
        -0.3456292748451233,
        -0.2439306229352951,
        0.9061115384101868,
        0,
        0.03096788562834263,
        0.06281610578298569,
        -0.040703095495700836,
        1
      ],
      radius: 0.006636196281760931
    },
    "middle-finger-metacarpal": {
      offsetMatrix: [
        0.9340395331382751,
        -0.13936476409435272,
        0.32885703444480896,
        0,
        -0.005510995630174875,
        0.914999783039093,
        0.40341612696647644,
        0,
        -0.3571262061595917,
        -0.37861889600753784,
        0.8538784384727478,
        0,
        -0.04184452444314957,
        0.022474845871329308,
        0.08177298307418823,
        1
      ],
      radius: 0.021231964230537415
    },
    "middle-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9720265865325928,
        -0.08313076198101044,
        0.21966552734375,
        0,
        0.20477405190467834,
        0.7580050826072693,
        -0.6192700862884521,
        0,
        -0.11502730846405029,
        0.6469289064407349,
        0.7538246512413025,
        0,
        -0.022107340395450592,
        0.05035499855875969,
        0.02970452979207039,
        1
      ],
      radius: 0.01117393933236599
    },
    "middle-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9779140949249268,
        -0.07129573822021484,
        0.19646917283535004,
        0,
        0.1287083923816681,
        -0.5352076292037964,
        -0.8348574042320251,
        0,
        0.1646735966205597,
        0.8417060971260071,
        -0.5142109394073486,
        0,
        -0.017169542610645294,
        0.022584279999136925,
        -0.00265491777099669,
        1
      ],
      radius: 0.008030958473682404
    },
    "middle-finger-phalanx-distal": {
      offsetMatrix: [
        0.9774913787841797,
        -0.19657190144062042,
        0.07661263644695282,
        0,
        -0.1924918293952942,
        -0.9796126484870911,
        -0.05749811604619026,
        0,
        0.08635343611240387,
        0.041456472128629684,
        -0.995401918888092,
        0,
        -0.02170622907578945,
        -6043742760084569e-19,
        0.011511396616697311,
        1
      ],
      radius: 0.007629410829395056
    },
    "middle-finger-tip": {
      offsetMatrix: [
        0.9774913787841797,
        -0.19657190144062042,
        0.07661263644695282,
        0,
        -0.1924918293952942,
        -0.9796126484870911,
        -0.05749811604619026,
        0,
        0.08635343611240387,
        0.041456472128629684,
        -0.995401918888092,
        0,
        -0.02438267692923546,
        -0.0026927536819130182,
        0.03627248480916023,
        1
      ],
      radius: 0.006629410665482283
    },
    "ring-finger-metacarpal": {
      offsetMatrix: [
        0.9340395331382751,
        -0.13936476409435272,
        0.32885703444480896,
        0,
        -0.005510995630174875,
        0.914999783039093,
        0.40341612696647644,
        0,
        -0.3571262061595917,
        -0.37861889600753784,
        0.8538784384727478,
        0,
        -0.05944233387708664,
        0.0264605600386858,
        0.07478221505880356,
        1
      ],
      radius: 0.019088275730609894
    },
    "ring-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9842101335525513,
        0.024470895528793335,
        0.1753024309873581,
        0,
        0.12200043350458145,
        0.6237703561782837,
        -0.7720272541046143,
        0,
        -0.12824076414108276,
        0.7812241315841675,
        0.610936164855957,
        0,
        -0.04249368980526924,
        0.0467497780919075,
        0.027722163125872612,
        1
      ],
      radius: 0.00992213748395443
    },
    "ring-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9941774606704712,
        0.05949164181947708,
        0.08983955532312393,
        0,
        0.10504482686519623,
        -0.7208291888237,
        -0.6851072907447815,
        0,
        0.024001073092222214,
        0.6905553936958313,
        -0.7228817939758301,
        0,
        -0.0374927744269371,
        0.016285063698887825,
        0.0038980208337306976,
        1
      ],
      radius: 0.007611672393977642
    },
    "ring-finger-phalanx-distal": {
      offsetMatrix: [
        0.9995742440223694,
        0.01638498157262802,
        0.02412819117307663,
        0,
        0.007813597097992897,
        -0.9474818110466003,
        0.31971633434295654,
        0,
        0.028100071474909782,
        -0.31939181685447693,
        -0.9472070932388306,
        0,
        -0.038130562752485275,
        -0.0020653479732573032,
        0.02310742810368538,
        1
      ],
      radius: 0.007231088820844889
    },
    "ring-finger-tip": {
      offsetMatrix: [
        0.9995742440223694,
        0.01638498157262802,
        0.02412819117307663,
        0,
        0.007813597097992897,
        -0.9474818110466003,
        0.31971633434295654,
        0,
        0.028100071474909782,
        -0.31939181685447693,
        -0.9472070932388306,
        0,
        -0.0390593595802784,
        0.004176302347332239,
        0.0466572530567646,
        1
      ],
      radius: 0.0062310886569321156
    },
    "pinky-finger-metacarpal": {
      offsetMatrix: [
        0.9147363901138306,
        0.3458845317363739,
        0.20885537564754486,
        0,
        -0.3923271894454956,
        0.8839452862739563,
        0.2544005811214447,
        0,
        -0.09662359952926636,
        -0.3146490156650543,
        0.9442773461341858,
        0,
        -0.06715242564678192,
        0.024195827543735504,
        0.07137546688318253,
        1
      ],
      radius: 0.01808827556669712
    },
    "pinky-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9613109827041626,
        0.22439135611057281,
        0.15977802872657776,
        0,
        0.01002211682498455,
        0.5511574745178223,
        -0.8343409299850464,
        0,
        -0.27528178691864014,
        0.8036624789237976,
        0.5275853276252747,
        0,
        -0.06273911893367767,
        0.038559623062610626,
        0.028268879279494286,
        1
      ],
      radius: 0.008483353070914745
    },
    "pinky-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9820972084999084,
        0.18811029195785522,
        -0.00995189044624567,
        0,
        0.14063723385334015,
        -0.7673450708389282,
        -0.6256227493286133,
        0,
        -0.12532226741313934,
        0.6130226850509644,
        -0.7800630927085876,
        0,
        -0.05428232625126839,
        0.013870777562260628,
        0.012061242014169693,
        1
      ],
      radius: 0.0067641944624483585
    },
    "pinky-finger-phalanx-distal": {
      offsetMatrix: [
        0.9744614362716675,
        0.20454788208007812,
        -0.09265263378620148,
        0,
        0.22429193556308746,
        -0.9065253138542175,
        0.35764020681381226,
        0,
        -0.010836843401193619,
        -0.3692878782749176,
        -0.9292529225349426,
        0,
        -0.05173685774207115,
        0.0014194445684552193,
        0.02790539152920246,
        1
      ],
      radius: 0.0064259846694767475
    },
    "pinky-finger-tip": {
      offsetMatrix: [
        0.9744614362716675,
        0.20454788208007812,
        -0.09265263378620148,
        0,
        0.22429193556308746,
        -0.9065253138542175,
        0.35764020681381226,
        0,
        -0.010836843401193619,
        -0.3692878782749176,
        -0.9292529225349426,
        0,
        -0.05098633095622063,
        0.008463085629045963,
        0.048688892275094986,
        1
      ],
      radius: 0.005425984505563974
    }
  },
  gripOffsetMatrix: [
    0.005510995630174875,
    -0.9149997234344482,
    -0.40341615676879883,
    0,
    -0.3571262061595917,
    -0.37861889600753784,
    0.8538784384727478,
    0,
    -0.9340395331382751,
    0.13936474919319153,
    -0.32885703444480896,
    0,
    -0.031803809106349945,
    0.007837686687707901,
    0.04313928261399269,
    1
  ]
};

// node_modules/iwer/lib/device/configs/hand/relaxed.js
var relaxedHandPose = {
  jointTransforms: {
    wrist: {
      offsetMatrix: [
        0.9616971015930176,
        -0.13805118203163147,
        0.2368120402097702,
        0,
        5348679260350764e-19,
        0.8648636937141418,
        0.5020061135292053,
        0,
        -0.2741127610206604,
        -0.48265108466148376,
        0.8318111300468445,
        0,
        -0.04913589730858803,
        0.0021463718730956316,
        0.11701996624469757,
        1
      ],
      radius: 0.021460847929120064
    },
    "thumb-metacarpal": {
      offsetMatrix: [
        -0.07536252588033676,
        -0.9959676265716553,
        -0.04867160692811012,
        0,
        0.5877083539962769,
        -0.08379616588354111,
        0.8047218918800354,
        0,
        -0.8055551648139954,
        0.032041035592556,
        0.5916536450386047,
        0,
        -0.010643752291798592,
        6936835707165301e-19,
        0.08736639469861984,
        1
      ],
      radius: 0.019382517784833908
    },
    "thumb-phalanx-proximal": {
      offsetMatrix: [
        0.1374533325433731,
        -0.9904957413673401,
        0.004982374142855406,
        0,
        0.5534393787384033,
        0.08097179979085922,
        0.8289443850517273,
        0,
        -0.8214688897132874,
        -0.11118389666080475,
        0.559309184551239,
        0,
        0.015547193586826324,
        -3480653394944966e-19,
        0.0681300163269043,
        1
      ],
      radius: 0.01228295173496008
    },
    "thumb-phalanx-distal": {
      offsetMatrix: [
        -0.04659227654337883,
        -0.9974699020385742,
        -0.05369402840733528,
        0,
        0.6812446117401123,
        -0.07104194164276123,
        0.728600800037384,
        0,
        -0.7305715084075928,
        -0.002631746232509613,
        0.6828309893608093,
        0,
        0.04330715537071228,
        0.003409178927540779,
        0.0492292083799839,
        1
      ],
      radius: 0.009768804535269737
    },
    "thumb-tip": {
      offsetMatrix: [
        -0.04659227654337883,
        -0.9974699020385742,
        -0.05369402840733528,
        0,
        0.6812446117401123,
        -0.07104194164276123,
        0.728600800037384,
        0,
        -0.7305715084075928,
        -0.002631746232509613,
        0.6828309893608093,
        0,
        0.062003348022699356,
        0.004069602582603693,
        0.03322213143110275,
        1
      ],
      radius: 0.008768804371356964
    },
    "index-finger-metacarpal": {
      offsetMatrix: [
        0.9616971015930176,
        -0.13805118203163147,
        0.2368120402097702,
        0,
        5348679260350764e-19,
        0.8648636937141418,
        0.5020061135292053,
        0,
        -0.2741127610206604,
        -0.48265108466148376,
        0.8318111300468445,
        0,
        -0.02009812369942665,
        0.008770795539021492,
        0.08660387247800827,
        1
      ],
      radius: 0.021228281781077385
    },
    "index-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9001791477203369,
        -0.2598813474178314,
        0.3494834005832672,
        0,
        0.06073702871799469,
        0.8695210218429565,
        0.490146666765213,
        0,
        -0.4312632381916046,
        -0.41999316215515137,
        0.7985095381736755,
        0,
        -17739279428496957e-20,
        0.03890012577176094,
        0.039073407649993896,
        1
      ],
      radius: 0.010295259766280651
    },
    "index-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9082008600234985,
        -0.20898112654685974,
        0.36262574791908264,
        0,
        0.11045389622449875,
        0.9553793668746948,
        0.27395179867744446,
        0,
        -0.40369608998298645,
        -0.20874978601932526,
        0.8907597661018372,
        0,
        0.01617925800383091,
        0.05482936650514603,
        0.008788082748651505,
        1
      ],
      radius: 0.00853810179978609
    },
    "index-finger-phalanx-distal": {
      offsetMatrix: [
        0.9309692978858948,
        -0.16783711314201355,
        0.32423174381256104,
        0,
        0.1080828532576561,
        0.9749603867530823,
        0.1943446695804596,
        0,
        -0.34873148798942566,
        -0.14588497579097748,
        0.9257990717887878,
        0,
        0.02599053829908371,
        0.059902746230363846,
        -0.012860597111284733,
        1
      ],
      radius: 0.007636196445673704
    },
    "index-finger-tip": {
      offsetMatrix: [
        0.9309692978858948,
        -0.16783711314201355,
        0.32423174381256104,
        0,
        0.1080828532576561,
        0.9749603867530823,
        0.1943446695804596,
        0,
        -0.34873148798942566,
        -0.14588497579097748,
        0.9257990717887878,
        0,
        0.03362493962049484,
        0.06421422213315964,
        -0.033461250364780426,
        1
      ],
      radius: 0.006636196281760931
    },
    "middle-finger-metacarpal": {
      offsetMatrix: [
        0.9616971015930176,
        -0.13805118203163147,
        0.2368120402097702,
        0,
        5348679260350764e-19,
        0.8648636937141418,
        0.5020061135292053,
        0,
        -0.2741127610206604,
        -0.48265108466148376,
        0.8318111300468445,
        0,
        -0.03627845644950867,
        0.011579737067222595,
        0.08550142496824265,
        1
      ],
      radius: 0.021231964230537415
    },
    "middle-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9876697659492493,
        -0.06786545366048813,
        0.1410750150680542,
        0,
        -0.015095947310328484,
        0.855663537979126,
        0.5173118710517883,
        0,
        -0.15582047402858734,
        -0.5130629539489746,
        0.8440889716148376,
        0,
        -0.021259509027004242,
        0.04587256908416748,
        0.03659208118915558,
        1
      ],
      radius: 0.01117393933236599
    },
    "middle-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.988391637802124,
        -0.04354291781783104,
        0.14555205404758453,
        0,
        0.008894841186702251,
        0.9729899168014526,
        0.23067504167556763,
        0,
        -0.15166506171226501,
        -0.22670257091522217,
        0.9620829224586487,
        0,
        -0.014570588245987892,
        0.06789684295654297,
        3578895702958107e-19,
        1
      ],
      radius: 0.008030958473682404
    },
    "middle-finger-phalanx-distal": {
      offsetMatrix: [
        0.9853697419166565,
        0.044260796159505844,
        0.16458062827587128,
        0,
        -0.0757969319820404,
        0.9787378311157227,
        0.19059516489505768,
        0,
        -0.1526455283164978,
        -0.20028135180473328,
        0.9677740931510925,
        0,
        -0.010392282158136368,
        0.07414241135120392,
        -0.026147106662392616,
        1
      ],
      radius: 0.007629410829395056
    },
    "middle-finger-tip": {
      offsetMatrix: [
        0.9853697419166565,
        0.044260796159505844,
        0.16458062827587128,
        0,
        -0.0757969319820404,
        0.9787378311157227,
        0.19059516489505768,
        0,
        -0.1526455283164978,
        -0.20028135180473328,
        0.9677740931510925,
        0,
        -0.0069718430750072,
        0.08024183660745621,
        -0.05014154314994812,
        1
      ],
      radius: 0.006629410665482283
    },
    "ring-finger-metacarpal": {
      offsetMatrix: [
        0.9616971015930176,
        -0.13805118203163147,
        0.2368120402097702,
        0,
        5348679260350764e-19,
        0.8648636937141418,
        0.5020061135292053,
        0,
        -0.2741127610206604,
        -0.48265108466148376,
        0.8318111300468445,
        0,
        -0.05402477830648422,
        0.015797706320881844,
        0.08152295649051666,
        1
      ],
      radius: 0.019088275730609894
    },
    "ring-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9940828680992126,
        0.05735103040933609,
        0.09224652498960495,
        0,
        -0.10022822767496109,
        0.8116500377655029,
        0.5754809379577637,
        0,
        -0.041867565363645554,
        -0.5813214182853699,
        0.8125960826873779,
        0,
        -0.041623555123806,
        0.04171867296099663,
        0.03582974523305893,
        1
      ],
      radius: 0.00992213748395443
    },
    "ring-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9843675494194031,
        0.12044742703437805,
        0.12850022315979004,
        0,
        -0.15629759430885315,
        0.9337108135223389,
        0.3221098482608795,
        0,
        -0.08118485659360886,
        -0.3371586799621582,
        0.937940776348114,
        0,
        -0.039990875869989395,
        0.06438793987035751,
        0.004141641780734062,
        1
      ],
      radius: 0.007611672393977642
    },
    "ring-finger-phalanx-distal": {
      offsetMatrix: [
        0.9748351573944092,
        0.11857274919748306,
        0.18877571821212769,
        0,
        -0.15575434267520905,
        0.9681083559989929,
        0.19623035192489624,
        0,
        -0.15948788821697235,
        -0.22069483995437622,
        0.9622148275375366,
        0,
        -0.03783353418111801,
        0.07334739714860916,
        -0.020782606676220894,
        1
      ],
      radius: 0.007231088820844889
    },
    "ring-finger-tip": {
      offsetMatrix: [
        0.9748351573944092,
        0.11857274919748306,
        0.18877571821212769,
        0,
        -0.15575434267520905,
        0.9681083559989929,
        0.19623035192489624,
        0,
        -0.15948788821697235,
        -0.22069483995437622,
        0.9622148275375366,
        0,
        -0.03445569798350334,
        0.0802423357963562,
        -0.04392268508672714,
        1
      ],
      radius: 0.0062310886569321156
    },
    "pinky-finger-metacarpal": {
      offsetMatrix: [
        0.9181402921676636,
        0.35625091195106506,
        0.17350243031978607,
        0,
        -0.39615097641944885,
        0.8352503180503845,
        0.38134080171585083,
        0,
        -0.009065053425729275,
        -0.41885748505592346,
        0.9080066680908203,
        0,
        -0.06191859766840935,
        0.013620133511722088,
        0.07850203663110733,
        1
      ],
      radius: 0.01808827556669712
    },
    "pinky-finger-phalanx-proximal": {
      offsetMatrix: [
        0.9714386463165283,
        0.236698180437088,
        -0.016745081171393394,
        0,
        -0.18462024629116058,
        0.7982627749443054,
        0.5733163952827454,
        0,
        0.14906984567642212,
        -0.5538501739501953,
        0.8191629648208618,
        0,
        -0.061502378433942795,
        0.032741155475378036,
        0.03705105185508728,
        1
      ],
      radius: 0.008483353070914745
    },
    "pinky-finger-phalanx-intermediate": {
      offsetMatrix: [
        0.9337416291236877,
        0.35620439052581787,
        -0.03527557849884033,
        0,
        -0.33203884959220886,
        0.8987522721290588,
        0.28634607791900635,
        0,
        0.13370157778263092,
        -0.2556603252887726,
        0.9574766755104065,
        0,
        -0.06608185172080994,
        0.049755651503801346,
        0.011886020191013813,
        1
      ],
      radius: 0.0067641944624483585
    },
    "pinky-finger-phalanx-distal": {
      offsetMatrix: [
        0.9419984817504883,
        0.3303581774234772,
        0.059175245463848114,
        0,
        -0.33483216166496277,
        0.9130291938781738,
        0.23294763267040253,
        0,
        0.02292730286717415,
        -0.2392500638961792,
        0.970687210559845,
        0,
        -0.0687975287437439,
        0.054948460310697556,
        -0.007561664097011089,
        1
      ],
      radius: 0.0064259846694767475
    },
    "pinky-finger-tip": {
      offsetMatrix: [
        0.9419984817504883,
        0.3303581774234772,
        0.059175245463848114,
        0,
        -0.33483216166496277,
        0.9130291938781738,
        0.23294763267040253,
        0,
        0.02292730286717415,
        -0.2392500638961792,
        0.970687210559845,
        0,
        -0.06947512179613113,
        0.0613851435482502,
        -0.028543535619974136,
        1
      ],
      radius: 0.005425984505563974
    }
  },
  gripOffsetMatrix: [
    -5348679260350764e-19,
    -0.8648636937141418,
    -0.5020061135292053,
    0,
    -0.2741127908229828,
    -0.48265108466148376,
    0.8318111896514893,
    0,
    -0.9616971015930176,
    0.13805119693279266,
    -0.2368120402097702,
    0,
    -0.02878567762672901,
    0.0017147823236882687,
    0.04536811262369156,
    1
  ]
};

// node_modules/iwer/lib/device/XRHandInput.js
var oculusHandConfig = {
  profileId: "oculus-hand",
  fallbackProfileIds: [
    "generic-hand",
    "generic-hand-select",
    "generic-trigger"
  ],
  poses: {
    default: relaxedHandPose,
    pinch: pinchHandPose,
    point: pointHandPose
  }
};
var XRHandGamepadConfig = {
  mapping: GamepadMappingType.None,
  buttons: [{ id: "pinch", type: "analog", eventTrigger: "select" }],
  axes: []
};
var fromPosition = vec3_exports.create();
var fromQuaternion = quat_exports.create();
var fromScale = vec3_exports.create();
var toPosition = vec3_exports.create();
var toQuaternion = quat_exports.create();
var toScale = vec3_exports.create();
var interpolatedPosition = vec3_exports.create();
var interpolatedQuaternion = quat_exports.create();
var interpolatedScale = vec3_exports.create();
var interpolateMatrix = (out, fromMatrix, toMatrix, alpha) => {
  mat4_exports.getTranslation(fromPosition, fromMatrix);
  mat4_exports.getRotation(fromQuaternion, fromMatrix);
  mat4_exports.getScaling(fromScale, fromMatrix);
  mat4_exports.getTranslation(toPosition, toMatrix);
  mat4_exports.getRotation(toQuaternion, toMatrix);
  mat4_exports.getScaling(toScale, toMatrix);
  vec3_exports.lerp(interpolatedPosition, fromPosition, toPosition, alpha);
  quat_exports.slerp(interpolatedQuaternion, fromQuaternion, toQuaternion, alpha);
  vec3_exports.lerp(interpolatedScale, fromScale, toScale, alpha);
  mat4_exports.fromRotationTranslationScale(out, interpolatedQuaternion, interpolatedPosition, interpolatedScale);
  return out;
};
var mirrorMultiplierMatrix = [
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  1,
  1
];
var mirrorMatrixToRight = (matrixLeft) => {
  for (let i2 = 0; i2 < 16; i2++) {
    matrixLeft[i2] *= mirrorMultiplierMatrix[i2];
  }
};
var XRHandInput = class extends XRTrackedInput {
  constructor(handInputConfig, handedness, globalSpace) {
    if (handedness !== XRHandedness.Left && handedness !== XRHandedness.Right) {
      throw new DOMException('handedness for XRHandInput must be either "left" or "right"', "InvalidStateError");
    }
    if (!handInputConfig.poses.default || !handInputConfig.poses.pinch) {
      throw new DOMException('"default" and "pinch" hand pose configs are required', "InvalidStateError");
    }
    const targetRaySpace = new XRSpace(globalSpace);
    const gripSpace = new XRSpace(targetRaySpace);
    const profiles = [
      handInputConfig.profileId,
      ...handInputConfig.fallbackProfileIds
    ];
    const hand = new XRHand();
    Object.values(XRHandJoint).forEach((jointName) => {
      hand.set(jointName, new XRJointSpace(jointName, targetRaySpace));
    });
    const inputSource = new XRInputSource(handedness, XRTargetRayMode.TrackedPointer, profiles, targetRaySpace, new Gamepad(XRHandGamepadConfig), gripSpace, hand);
    super(inputSource);
    this[P_HAND_INPUT] = {
      poseId: "default",
      poses: handInputConfig.poses
    };
    this.updateHandPose();
  }
  get poseId() {
    return this[P_HAND_INPUT].poseId;
  }
  set poseId(poseId) {
    if (!this[P_HAND_INPUT].poses[poseId]) {
      console.warn(`Pose config ${poseId} not found`);
      return;
    }
    this[P_HAND_INPUT].poseId = poseId;
  }
  updateHandPose() {
    const targetPose = this[P_HAND_INPUT].poses[this[P_HAND_INPUT].poseId];
    const pinchPose = this[P_HAND_INPUT].poses.pinch;
    Object.values(XRHandJoint).forEach((jointName) => {
      const targetJointMatrix = targetPose.jointTransforms[jointName].offsetMatrix;
      const pinchJointMatrix = pinchPose.jointTransforms[jointName].offsetMatrix;
      const jointSpace = this.inputSource.hand.get(jointName);
      interpolateMatrix(jointSpace[P_SPACE].offsetMatrix, targetJointMatrix, pinchJointMatrix, this.pinchValue);
      if (this.inputSource.handedness === XRHandedness.Right) {
        mirrorMatrixToRight(jointSpace[P_SPACE].offsetMatrix);
      }
      jointSpace[P_JOINT_SPACE].radius = (1 - this.pinchValue) * targetPose.jointTransforms[jointName].radius + this.pinchValue * pinchPose.jointTransforms[jointName].radius;
    });
    if (targetPose.gripOffsetMatrix && pinchPose.gripOffsetMatrix) {
      interpolateMatrix(this.inputSource.gripSpace[P_SPACE].offsetMatrix, targetPose.gripOffsetMatrix, pinchPose.gripOffsetMatrix, this.pinchValue);
    }
  }
  get pinchValue() {
    return this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].buttonsMap["pinch"].value;
  }
  updatePinchValue(value) {
    if (value > 1 || value < 0) {
      console.warn(`Out-of-range value ${value} provided for pinch`);
      return;
    }
    const gamepadButton = this[P_TRACKED_INPUT].inputSource.gamepad[P_GAMEPAD].buttonsMap["pinch"];
    gamepadButton[P_GAMEPAD].pendingValue = value;
  }
  onFrameStart(frame) {
    super.onFrameStart(frame);
    this.updateHandPose();
  }
};

// node_modules/iwer/lib/layers/XRWebGLLayer.js
var XRLayer = class extends EventTarget {
};
var defaultLayerInit = {
  antialias: true,
  depth: true,
  stencil: false,
  alpha: true,
  ignoreDepthValues: false,
  framebufferScaleFactor: 1
};
var XRWebGLLayer = class extends XRLayer {
  constructor(session, context, layerInit = {}) {
    super();
    if (session[P_SESSION].ended) {
      throw new DOMException("Session has ended", "InvalidStateError");
    }
    const config3 = { ...defaultLayerInit, ...layerInit };
    this[P_WEBGL_LAYER] = {
      session,
      context,
      antialias: config3.antialias
    };
  }
  get context() {
    return this[P_WEBGL_LAYER].context;
  }
  get antialias() {
    return this[P_WEBGL_LAYER].antialias;
  }
  get ignoreDepthValues() {
    return true;
  }
  get framebuffer() {
    return null;
  }
  get framebufferWidth() {
    return this[P_WEBGL_LAYER].context.drawingBufferWidth;
  }
  get framebufferHeight() {
    return this[P_WEBGL_LAYER].context.drawingBufferHeight;
  }
  getViewport(view) {
    if (view[P_VIEW].session !== this[P_WEBGL_LAYER].session) {
      throw new DOMException("View's session differs from Layer's session", "InvalidStateError");
    }
    return this[P_WEBGL_LAYER].session[P_SESSION].device[P_DEVICE].getViewport(this, view);
  }
  static getNativeFramebufferScaleFactor(session) {
    if (!(session instanceof XRSession)) {
      throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");
    }
    if (session[P_SESSION].ended) {
      return 0;
    }
    return 1;
  }
};

// node_modules/iwer/lib/action/ActionPlayer.js
var ActionPlayer = class {
  constructor(refSpace, recording, ipd) {
    const { schema, frames } = recording;
    if (!frames || !schema || frames.length === 0) {
      throw new DOMException("wrong recording format", "NotSupportedError");
    }
    const viewerSpace = new XRReferenceSpace(XRReferenceSpaceType.Viewer, refSpace);
    const viewSpaces = {
      [XREye.Left]: new XRSpace(viewerSpace),
      [XREye.Right]: new XRSpace(viewerSpace),
      [XREye.None]: new XRSpace(viewerSpace)
    };
    this[P_ACTION_PLAYER] = {
      refSpace,
      inputSources: /* @__PURE__ */ new Map(),
      inputSchemas: /* @__PURE__ */ new Map(),
      frames,
      recordedFramePointer: 0,
      startingTimeStamp: frames[0][0],
      endingTimeStamp: frames[frames.length - 1][0],
      playbackTime: frames[0][0],
      playing: false,
      viewerSpace,
      viewSpaces,
      vec3: vec3_exports.create(),
      quat: quat_exports.create()
    };
    mat4_exports.fromTranslation(this[P_ACTION_PLAYER].viewSpaces[XREye.Left][P_SPACE].offsetMatrix, vec3_exports.fromValues(-ipd / 2, 0, 0));
    mat4_exports.fromTranslation(this[P_ACTION_PLAYER].viewSpaces[XREye.Right][P_SPACE].offsetMatrix, vec3_exports.fromValues(ipd / 2, 0, 0));
    schema.forEach((schemaEntry) => {
      const index = schemaEntry[0];
      const schema2 = schemaEntry[1];
      let gamepad;
      if (schema2.hasGamepad) {
        const buttons = [];
        for (let i2 = 0; i2 < schema2.numButtons; i2++) {
          buttons.push({ id: i2.toString(), type: "manual" });
        }
        const axes = [];
        for (let i2 = 0; i2 < schema2.numAxes; i2++) {
          axes.push({ id: i2.toString(), type: "manual" });
        }
        gamepad = new Gamepad({
          mapping: schema2.mapping,
          buttons,
          axes
        });
      }
      const targetRaySpace = new XRSpace(refSpace);
      let hand = void 0;
      if (schema2.hasHand) {
        hand = new XRHand();
        Object.values(XRHandJoint).forEach((jointName) => {
          hand.set(jointName, new XRJointSpace(jointName, targetRaySpace));
        });
      }
      const inputSource = new XRInputSource(schema2.handedness, schema2.targetRayMode, schema2.profiles, targetRaySpace, gamepad, schema2.hasGrip ? new XRSpace(refSpace) : void 0, schema2.hasHand ? hand : void 0);
      this[P_ACTION_PLAYER].inputSources.set(index, {
        active: false,
        source: inputSource
      });
      this[P_ACTION_PLAYER].inputSchemas.set(index, schema2);
    });
  }
  play() {
    this[P_ACTION_PLAYER].recordedFramePointer = 0;
    this[P_ACTION_PLAYER].playbackTime = this[P_ACTION_PLAYER].startingTimeStamp;
    this[P_ACTION_PLAYER].playing = true;
    this[P_ACTION_PLAYER].actualTimeStamp = performance.now();
  }
  stop() {
    this[P_ACTION_PLAYER].playing = false;
  }
  get playing() {
    return this[P_ACTION_PLAYER].playing;
  }
  get viewerSpace() {
    return this[P_ACTION_PLAYER].viewerSpace;
  }
  get viewSpaces() {
    return this[P_ACTION_PLAYER].viewSpaces;
  }
  get inputSources() {
    return Array.from(this[P_ACTION_PLAYER].inputSources.values()).filter((wrapper) => wrapper.active).map((wrapper) => wrapper.source);
  }
  playFrame() {
    const now = performance.now();
    const delta = now - this[P_ACTION_PLAYER].actualTimeStamp;
    this[P_ACTION_PLAYER].actualTimeStamp = now;
    this[P_ACTION_PLAYER].playbackTime += delta;
    if (this[P_ACTION_PLAYER].playbackTime > this[P_ACTION_PLAYER].endingTimeStamp) {
      this.stop();
      return;
    }
    while (this[P_ACTION_PLAYER].frames[this[P_ACTION_PLAYER].recordedFramePointer + 1][0] < this[P_ACTION_PLAYER].playbackTime) {
      this[P_ACTION_PLAYER].recordedFramePointer++;
    }
    const lastFrameData = this[P_ACTION_PLAYER].frames[this[P_ACTION_PLAYER].recordedFramePointer];
    const nextFrameData = this[P_ACTION_PLAYER].frames[this[P_ACTION_PLAYER].recordedFramePointer + 1];
    const alpha = (this[P_ACTION_PLAYER].playbackTime - lastFrameData[0]) / (nextFrameData[0] - lastFrameData[0]);
    this.updateXRSpaceFromMergedFrames(this[P_ACTION_PLAYER].viewerSpace, lastFrameData.slice(1, 8), nextFrameData.slice(1, 8), alpha);
    const lastFrameInputs = /* @__PURE__ */ new Map();
    for (let i2 = 8; i2 < lastFrameData.length; i2++) {
      const { index, inputData } = this.processRawInputData(lastFrameData[i2]);
      lastFrameInputs.set(index, inputData);
    }
    const nextFrameInputs = /* @__PURE__ */ new Map();
    for (let i2 = 8; i2 < nextFrameData.length; i2++) {
      const { index, inputData } = this.processRawInputData(nextFrameData[i2]);
      nextFrameInputs.set(index, inputData);
    }
    this[P_ACTION_PLAYER].inputSources.forEach((sourceWrapper) => {
      sourceWrapper.active = false;
    });
    nextFrameInputs.forEach((inputData, index) => {
      this[P_ACTION_PLAYER].inputSources.get(index).active = true;
      const inputSource = this[P_ACTION_PLAYER].inputSources.get(index).source;
      const schema = this[P_ACTION_PLAYER].inputSchemas.get(index);
      this.updateInputSource(inputSource, schema, lastFrameInputs.has(index) ? lastFrameInputs.get(index) : inputData, inputData, alpha);
    });
  }
  updateInputSource(inputSource, schema, lastInputData, nextInputData, alpha) {
    this.updateXRSpaceFromMergedFrames(inputSource.targetRaySpace, lastInputData.targetRayTransform, nextInputData.targetRayTransform, alpha);
    if (schema.hasGrip) {
      this.updateXRSpaceFromMergedFrames(inputSource.gripSpace, lastInputData.gripTransform, nextInputData.gripTransform, alpha);
    }
    if (schema.hasHand) {
      for (let i2 = 0; i2 < 25; i2++) {
        const lastTransformArray = lastInputData.handTransforms.slice(i2 * 8, i2 * 8 + 7);
        const nextTransformArray = nextInputData.handTransforms.slice(i2 * 8, i2 * 8 + 7);
        const lastRadius = lastInputData.handTransforms[i2 * 8 + 7];
        const nextRadius = nextInputData.handTransforms[i2 * 8 + 7];
        const jointSpace = inputSource.hand.get(schema.jointSequence[i2]);
        this.updateXRSpaceFromMergedFrames(jointSpace, lastTransformArray, nextTransformArray, alpha);
        jointSpace[P_JOINT_SPACE].radius = (nextRadius - lastRadius) * alpha + lastRadius;
      }
    }
    if (schema.hasGamepad) {
      const gamepad = inputSource.gamepad;
      nextInputData.buttons.forEach((states, index) => {
        const gamepadButton = gamepad.buttons[index];
        gamepadButton[P_GAMEPAD].pressed = states[0] === 1 ? true : false;
        gamepadButton[P_GAMEPAD].touched = states[1] === 1 ? true : false;
        const lastValue = lastInputData.buttons[index][2];
        const nextValue = states[2];
        gamepadButton[P_GAMEPAD].value = (nextValue - lastValue) * alpha + lastValue;
      });
      nextInputData.axes.forEach((nextValue, index) => {
        const lastValue = lastInputData.axes[index];
        gamepad[P_GAMEPAD].axesMap[index.toString()].x = (nextValue - lastValue) * alpha + lastValue;
      });
    }
  }
  updateXRSpaceFromMergedFrames(space3, lastTransform, nextTransform, alpha) {
    const f1p = vec3_exports.fromValues(lastTransform[0], lastTransform[1], lastTransform[2]);
    const f1q = quat_exports.fromValues(lastTransform[3], lastTransform[4], lastTransform[5], lastTransform[6]);
    const f2p = vec3_exports.fromValues(nextTransform[0], nextTransform[1], nextTransform[2]);
    const f2q = quat_exports.fromValues(nextTransform[3], nextTransform[4], nextTransform[5], nextTransform[6]);
    vec3_exports.lerp(this[P_ACTION_PLAYER].vec3, f1p, f2p, alpha);
    quat_exports.slerp(this[P_ACTION_PLAYER].quat, f1q, f2q, alpha);
    mat4_exports.fromRotationTranslation(space3[P_SPACE].offsetMatrix, this[P_ACTION_PLAYER].quat, this[P_ACTION_PLAYER].vec3);
  }
  processRawInputData(inputDataRaw) {
    const index = inputDataRaw[0];
    const schema = this[P_ACTION_PLAYER].inputSchemas.get(index);
    const targetRayTransform = inputDataRaw.slice(1, 8);
    const inputData = { targetRayTransform };
    let dataCounter = 8;
    if (schema.hasGrip) {
      inputData.gripTransform = inputDataRaw[dataCounter++];
    }
    if (schema.hasHand) {
      inputData.handTransforms = inputDataRaw[dataCounter++];
    }
    if (schema.hasGamepad) {
      const gamepadData = inputDataRaw[dataCounter];
      inputData.buttons = gamepadData.slice(0, schema.numButtons);
      inputData.axes = gamepadData.slice(schema.numButtons);
    }
    return { index, inputData };
  }
};

// node_modules/iwer/lib/version.js
var VERSION2 = "2.1.1";

// node_modules/iwer/lib/events/XRReferenceSpaceEvent.js
var XRReferenceSpaceEvent = class extends Event {
  constructor(type, eventInitDict) {
    super(type, eventInitDict);
    if (!eventInitDict.referenceSpace) {
      throw new Error("XRReferenceSpaceEventInit.referenceSpace is required");
    }
    this.referenceSpace = eventInitDict.referenceSpace;
    this.transform = eventInitDict.transform;
  }
};

// node_modules/iwer/lib/initialization/XRSystem.js
var XRSystem = class extends EventTarget {
  constructor(device) {
    super();
    this[P_SYSTEM] = {
      device,
      grantSession: ({ resolve, reject, mode, options }) => {
        if (this[P_SYSTEM].activeSession) {
          reject(new DOMException("An active XRSession already exists.", "InvalidStateError"));
          return;
        }
        const { requiredFeatures = [], optionalFeatures = [] } = options;
        const { supportedFeatures } = this[P_SYSTEM].device;
        const allRequiredSupported = requiredFeatures.every((feature) => supportedFeatures.includes(feature));
        if (!allRequiredSupported) {
          reject(new Error("One or more required features are not supported by the device."));
          return;
        }
        const supportedOptionalFeatures = optionalFeatures.filter((feature) => supportedFeatures.includes(feature));
        const enabledFeatures = Array.from(/* @__PURE__ */ new Set([
          ...requiredFeatures,
          ...supportedOptionalFeatures,
          "viewer",
          "local"
        ]));
        const session = new XRSession(this[P_SYSTEM].device, mode, enabledFeatures);
        this[P_SYSTEM].activeSession = session;
        session.addEventListener("end", () => {
          this[P_SYSTEM].activeSession = void 0;
        });
        resolve(session);
      }
    };
  }
  isSessionSupported(mode) {
    return new Promise((resolve, _reject) => {
      if (mode === "inline") {
        resolve(true);
      } else {
        resolve(this[P_SYSTEM].device.supportedSessionModes.includes(mode));
      }
    });
  }
  requestSession(mode, options = {}) {
    return new Promise((resolve, reject) => {
      this.isSessionSupported(mode).then((isSupported) => {
        if (!isSupported) {
          reject(new DOMException("The requested XRSession mode is not supported.", "NotSupportedError"));
          return;
        }
        const sessionGrantConfig = {
          resolve,
          reject,
          mode,
          options
        };
        this[P_SYSTEM].grantSession(sessionGrantConfig);
      }).catch(reject);
    });
  }
  offerSession(mode, options = {}) {
    return new Promise((resolve, reject) => {
      this.isSessionSupported(mode).then((isSupported) => {
        if (!isSupported) {
          reject(new DOMException("The requested XRSession mode is not supported.", "NotSupportedError"));
          return;
        }
        this[P_SYSTEM].offeredSessionConfig = {
          resolve,
          reject,
          mode,
          options
        };
      }).catch(reject);
    });
  }
};

// node_modules/iwer/lib/views/XRViewport.js
var XRViewport = class {
  constructor(x2, y3, width, height) {
    this[P_VIEWPORT] = { x: x2, y: y3, width, height };
  }
  get x() {
    return this[P_VIEWPORT].x;
  }
  get y() {
    return this[P_VIEWPORT].y;
  }
  get width() {
    return this[P_VIEWPORT].width;
  }
  get height() {
    return this[P_VIEWPORT].height;
  }
};

// node_modules/webxr-layers-polyfill/build/webxr-layers-polyfill.module.js
var XRTextureType;
(function(XRTextureType2) {
  XRTextureType2["texture"] = "texture";
  XRTextureType2["texture-array"] = "texture-array";
})(XRTextureType || (XRTextureType = {}));
var XRLayerLayout;
(function(XRLayerLayout2) {
  XRLayerLayout2["default"] = "default";
  XRLayerLayout2["mono"] = "mono";
  XRLayerLayout2["stereo"] = "stereo";
  XRLayerLayout2["stereo-left-right"] = "stereo-left-right";
  XRLayerLayout2["stereo-top-bottom"] = "stereo-top-bottom";
})(XRLayerLayout || (XRLayerLayout = {}));
var isReferenceSpace = (arg) => {
  return arg && typeof arg.getOffsetReferenceSpace === "function";
};
var getGlobal = () => {
  return typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
};
var getFormatsFromInternalFormat = (context, providedFormat) => {
  switch (providedFormat) {
    case context.RGBA8:
    case context.RGB5_A1:
    case context.RGBA4:
    case context.SRGB8_ALPHA8:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA,
        type: context.UNSIGNED_BYTE
      };
    case context.RGBA8_SNORM:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA,
        type: context.BYTE
      };
    case context.RGB10_A2:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA,
        type: context.UNSIGNED_INT_2_10_10_10_REV
      };
    case context.RGBA16F:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA,
        type: context.HALF_FLOAT
      };
    case context.RGBA32F:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA,
        type: context.FLOAT
      };
    case context.RGBA8UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.UNSIGNED_BYTE
      };
    case context.RGBA8I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.BYTE
      };
    case context.RGBA16UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.UNSIGNED_SHORT
      };
    case context.RGBA16I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.SHORT
      };
    case context.RGBA32UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.UNSIGNED_INT
      };
    case context.RGBA32I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.INT
      };
    case context.RGB10_A2UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGBA_INTEGER,
        type: context.UNSIGNED_INT_2_10_10_10_REV
      };
    case context.RGB8:
    case context.RGB565:
    case context.SRGB8:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB,
        type: context.UNSIGNED_BYTE
      };
    case context.RGB8_SNORM:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB,
        type: context.BYTE
      };
    case context.RGB16F:
    case context.R11F_G11F_B10F:
    case context.RGB9_E5:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB,
        type: context.HALF_FLOAT
      };
    case context.RGB32F:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB,
        type: context.FLOAT
      };
    case context.RGB8UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.UNSIGNED_BYTE
      };
    case context.RGB8I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.BYTE
      };
    case context.RGB16UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.UNSIGNED_SHORT
      };
    case context.RGB16I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.SHORT
      };
    case context.RGB32UI:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.UNSIGNED_INT
      };
    case context.RGB32I:
      return {
        internalFormat: providedFormat,
        textureFormat: context.RGB_INTEGER,
        type: context.INT
      };
    case context.DEPTH_COMPONENT16:
      return {
        internalFormat: providedFormat,
        textureFormat: context.DEPTH_COMPONENT,
        type: context.UNSIGNED_SHORT
      };
    case context.DEPTH_COMPONENT24:
      return {
        internalFormat: providedFormat,
        textureFormat: context.DEPTH_COMPONENT,
        type: context.UNSIGNED_INT
      };
    case context.DEPTH_COMPONENT32F:
      return {
        internalFormat: providedFormat,
        textureFormat: context.DEPTH_COMPONENT,
        type: context.FLOAT
      };
    case context.DEPTH24_STENCIL8:
      return {
        internalFormat: providedFormat,
        textureFormat: context.DEPTH_STENCIL,
        type: context.UNSIGNED_INT_24_8
      };
    case context.DEPTH32F_STENCIL8:
      return {
        internalFormat: providedFormat,
        textureFormat: context.DEPTH_STENCIL,
        type: context.FLOAT_32_UNSIGNED_INT_24_8_REV
      };
    case context.DEPTH_COMPONENT:
      return getFormatsFromInternalFormat(context, context.DEPTH_COMPONENT24);
    case context.DEPTH_STENCIL:
      return getFormatsFromInternalFormat(context, context.DEPTH24_STENCIL8);
    case context.RGBA:
    case context.RGB:
    case context.LUMINANCE_ALPHA:
    case context.LUMINANCE:
    case context.ALPHA:
      return {
        internalFormat: providedFormat,
        textureFormat: providedFormat,
        type: context.UNSIGNED_BYTE
      };
    default:
      throw new Error("Attempted to create polyfill with unsupported format.");
  }
};
var XRCompositionLayerPolyfill = class {
  constructor() {
    this._hasRunDeferredInitialize = false;
    this._media = null;
  }
  initialize(session, context) {
    this.session = session;
    if (context) {
      this.context = context;
    }
    this.blendTextureSourceAlpha = true;
  }
  destroy() {
    this._colorTextures = [];
    this._depthStencilTextures = [];
  }
  addEventListener(type, listener2, options) {
  }
  dispatchEvent(event) {
    return false;
  }
  removeEventListener(type, callback, options) {
  }
  getContext() {
    return this.context;
  }
  getTextureType() {
    throw new Error("Unimplemented");
  }
  get colorTextures() {
    return this._colorTextures;
  }
  get depthStencilTextures() {
    return this._depthStencilTextures;
  }
  get colorTexturesMeta() {
    return this._texturesMeta;
  }
  get media() {
    if (!this.isMediaLayer()) {
      console.warn("Attempted to retrieve media from a non-media layer");
    }
    return this._media;
  }
  determineLayoutAttribute(textureType, context, layout) {
    if (!(context instanceof WebGL2RenderingContext) && textureType === XRTextureType["texture-array"]) {
      throw new TypeError();
    }
    if (layout === XRLayerLayout.mono) {
      return layout;
    }
    if (layout === XRLayerLayout.default) {
      if (this.session.internalViews && this.session.internalViews.length === 1) {
        return XRLayerLayout["mono"];
      }
      if (textureType === XRTextureType["texture-array"]) {
        return layout;
      }
    }
    if (layout === XRLayerLayout.default || layout === XRLayerLayout.stereo) {
      return XRLayerLayout["stereo-left-right"];
    }
    return layout;
  }
  isMediaLayer() {
    return this._media !== null;
  }
  _deferredInitialize() {
  }
  initializeIfNeeded() {
    if (!this._hasRunDeferredInitialize) {
      this._hasRunDeferredInitialize = true;
      this._deferredInitialize();
    }
  }
  _allocateColorTexturesInternal(textureType, init) {
    let session = this.session;
    let views = session.internalViews;
    if (!views || views.length === 0) {
      console.warn("We can't allocate color textures without views");
      return;
    }
    this.initializeIfNeeded();
    if (this.layout === XRLayerLayout.mono) {
      if (textureType === XRTextureType["texture-array"]) {
        const newTexture = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.colorFormat);
        this._texturesMeta = [newTexture];
        this._colorTextures = [newTexture.texture];
        return;
      } else {
        const newTexture = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.colorFormat);
        this._texturesMeta = [newTexture];
        this._colorTextures = [newTexture.texture];
        return;
      }
    } else if (this.layout === XRLayerLayout.stereo) {
      if (textureType === XRTextureType["texture-array"]) {
        const newTexture = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.colorFormat, 2);
        this._texturesMeta = [newTexture];
        this._colorTextures = [newTexture.texture];
        return;
      } else {
        const texture1 = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.colorFormat);
        const texture2 = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.colorFormat);
        this._texturesMeta = [texture1, texture2];
        this._colorTextures = [texture1.texture, texture2.texture];
        return;
      }
    } else if (this.layout === XRLayerLayout["stereo-left-right"]) {
      const newTexture = this._createNewColorTexture(init.viewPixelWidth * 2, init.viewPixelHeight, textureType, init.colorFormat);
      this._texturesMeta = [newTexture];
      this._colorTextures = [newTexture.texture];
      return;
    } else if (this.layout === XRLayerLayout["stereo-top-bottom"]) {
      const newTexture = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight * 2, textureType, init.colorFormat);
      this._texturesMeta = [newTexture];
      this._colorTextures = [newTexture.texture];
      return;
    }
  }
  _allocateDepthStencilTexturesInternal(textureType, init) {
    if (!init.depthFormat) {
      this._depthStencilTextures = [];
      return;
    }
    if (this._getSupportedDepthFormats().indexOf(init.depthFormat) < 0) {
      throw new Error("Depth format provided is not supported in non-projection layers.");
    }
    if (init.mipLevels < 1) {
      throw new Error("Invalid miplevel. Miplevel needs to be >= 1");
    }
    if (this.layout === XRLayerLayout.mono) {
      if (textureType === XRTextureType["texture-array"]) {
        const newTexture = this._createNewDepthStencilTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.depthFormat);
        this._depthStencilTextures = [newTexture.texture];
        return;
      } else {
        const newTexture = this._createNewColorTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.depthFormat);
        this._depthStencilTextures = [newTexture.texture];
        return;
      }
    } else if (this.layout === XRLayerLayout.stereo) {
      if (textureType === XRTextureType["texture-array"]) {
        const newTexture = this._createNewDepthStencilTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.depthFormat, 2);
        this._depthStencilTextures = [newTexture.texture];
        return;
      } else {
        const texture1 = this._createNewDepthStencilTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.depthFormat);
        const texture2 = this._createNewDepthStencilTexture(init.viewPixelWidth, init.viewPixelHeight, textureType, init.depthFormat);
        this._depthStencilTextures = [texture1.texture, texture2.texture];
        return;
      }
    } else if (this.layout === XRLayerLayout["stereo-left-right"]) {
      const newTexture = this._createNewDepthStencilTexture(init.viewPixelWidth * 2, init.viewPixelHeight, textureType, init.depthFormat);
      this._depthStencilTextures = [newTexture.texture];
      return;
    } else if (this.layout === XRLayerLayout["stereo-top-bottom"]) {
      const newTexture = this._createNewDepthStencilTexture(init.viewPixelWidth, init.viewPixelHeight * 2, textureType, init.depthFormat);
      this._depthStencilTextures = [newTexture.texture];
      return;
    }
  }
  _createNewColorTexture(width, height, textureType, colorFormat, layers = 1) {
    return this._createGenericPolyfillTexture(textureType, width, height, colorFormat, 0, layers);
  }
  _createNewDepthStencilTexture(width, height, textureType, depthFormat, layers = 1) {
    return this._createGenericPolyfillTexture(textureType, width, height, depthFormat, 0, layers);
  }
  _createGenericPolyfillTexture(textureType, width, height, textureFormat, mipmapLevel = 0, numLayers = 1) {
    if (textureType === XRTextureType["texture-array"] && numLayers <= 1) {
      console.warn("creating a texture array with a single layer...");
    }
    if (textureType === XRTextureType["texture-array"] && this.context instanceof WebGLRenderingContext) {
      throw new Error("WebGL 1 does not support texture array");
    }
    let texture = this.context.createTexture();
    let textureMeta = {
      width,
      height,
      layers: numLayers,
      type: textureType,
      textureFormat,
      texture
    };
    let internalFormat = textureFormat;
    let texImageType = this.context.UNSIGNED_BYTE;
    if (this.context instanceof WebGL2RenderingContext) {
      const expectedFormats = getFormatsFromInternalFormat(this.context, textureFormat);
      internalFormat = expectedFormats.internalFormat;
      textureFormat = expectedFormats.textureFormat;
      texImageType = expectedFormats.type;
    } else {
      if (textureFormat === this.context.DEPTH_COMPONENT) {
        texImageType = this.context.UNSIGNED_INT;
      }
      if (textureFormat === this.context.DEPTH_STENCIL) {
        texImageType = this.context.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (textureType === XRTextureType["texture-array"] && this.context instanceof WebGL2RenderingContext) {
      console.warn("texture-array layers are supported...questionably in the polyfill at the moment. Use at your own risk.");
      const existingTextureBinding = this.context.getParameter(this.context.TEXTURE_BINDING_2D_ARRAY);
      this.context.bindTexture(this.context.TEXTURE_2D_ARRAY, texture);
      if (this._getSupportedDepthFormats().indexOf(textureFormat) >= 0) {
        this.context.texStorage3D(this.context.TEXTURE_2D_ARRAY, 1, internalFormat, width, height, numLayers);
      } else {
        this.context.texImage3D(this.context.TEXTURE_2D_ARRAY, 0, internalFormat, width, height, numLayers, 0, textureFormat, texImageType, null);
      }
      this.context.bindTexture(this.context.TEXTURE_2D_ARRAY, existingTextureBinding);
    } else {
      const existingTextureBinding = this.context.getParameter(this.context.TEXTURE_BINDING_2D);
      this.context.bindTexture(this.context.TEXTURE_2D, texture);
      this.context.texImage2D(this.context.TEXTURE_2D, 0, internalFormat, width, height, 0, textureFormat, texImageType, null);
      this.context.bindTexture(this.context.TEXTURE_2D, existingTextureBinding);
    }
    return textureMeta;
  }
  _getSupportedDepthFormats() {
    const supportedDepthFormats = [];
    if (this.context instanceof WebGLRenderingContext) {
      if (!this.context.getExtension("WEBGL_depth_texture")) {
        return supportedDepthFormats;
      }
    }
    supportedDepthFormats.push(this.context.DEPTH_COMPONENT, this.context.DEPTH_STENCIL);
    if (this.context instanceof WebGL2RenderingContext) {
      supportedDepthFormats.push(this.context.DEPTH_COMPONENT24, this.context.DEPTH24_STENCIL8);
    }
    return supportedDepthFormats;
  }
};
var defaultCylinderLayerInit = {
  colorFormat: 6408,
  mipLevels: 1,
  layout: XRLayerLayout.mono,
  isStatic: false,
  space: null,
  viewPixelHeight: 0,
  viewPixelWidth: 0,
  textureType: XRTextureType.texture,
  radius: 2,
  centralAngle: 0.78539,
  aspectRatio: 2
};
var defaultMediaCylinderLayerInit = {
  layout: XRLayerLayout.mono,
  invertStereo: false,
  space: null,
  radius: 2,
  centralAngle: 0.78539
};
var XRCylinderLayer = class extends XRCompositionLayerPolyfill {
  constructor(init, media) {
    super();
    this._media = media !== null && media !== void 0 ? media : null;
    if (this.isMediaLayer()) {
      this.init = Object.assign(Object.assign({}, defaultMediaCylinderLayerInit), init);
    } else {
      this.init = Object.assign(Object.assign({}, defaultCylinderLayerInit), init);
    }
    this.radius = this.init.radius;
    this.centralAngle = this.init.centralAngle;
    this.aspectRatio = this.init.aspectRatio;
    this.space = this.init.space;
    this.layout = this.init.layout;
    const _global = getGlobal();
    if (this.init.transform) {
      this.transform = new _global.XRRigidTransform(init.transform.position, init.transform.orientation);
    } else {
      this.transform = new _global.XRRigidTransform({
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
    }
    if (!this.isMediaLayer()) {
      this.isStatic = init.isStatic;
    }
  }
  getTextureType() {
    if (this.isMediaLayer()) {
      return XRTextureType.texture;
    }
    return this.init.textureType;
  }
  _deferredInitialize() {
    let layout = this.determineLayoutAttribute(this.init.textureType, this.context, this.init.layout);
    this.layout = layout;
    this.needsRedraw = true;
  }
  get colorTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._colorTextures;
  }
  get depthStencilTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._depthStencilTextures || !this._depthStencilTextures.length) {
      this._allocateDepthStencilTexturesInternal(this.getTextureType(), this.init);
    }
    return this._depthStencilTextures;
  }
  get colorTexturesMeta() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._texturesMeta;
  }
  get width() {
    const circumference = 2 * this.radius * Math.PI;
    const percentage = this.centralAngle / (2 * Math.PI);
    return circumference * percentage;
  }
  get height() {
    return this.width / this.aspectRatio;
  }
};
var defaultEquirectLayerInit = {
  colorFormat: 6408,
  mipLevels: 1,
  layout: XRLayerLayout.mono,
  isStatic: false,
  space: null,
  viewPixelHeight: 0,
  viewPixelWidth: 0,
  textureType: XRTextureType.texture,
  radius: 0,
  centralHorizontalAngle: 6.28318,
  upperVerticalAngle: 1.570795,
  lowerVerticalAngle: -1.570795
};
var defaultMediaEquirectLayerInit = {
  space: null,
  layout: XRLayerLayout.mono,
  invertStereo: false,
  radius: 0,
  centralHorizontalAngle: 6.28318,
  upperVerticalAngle: 1.570795,
  lowerVerticalAngle: -1.570795
};
var XREquirectLayer = class extends XRCompositionLayerPolyfill {
  constructor(init, media) {
    super();
    this._media = media !== null && media !== void 0 ? media : null;
    if (this.isMediaLayer()) {
      this.init = Object.assign(Object.assign({}, defaultMediaEquirectLayerInit), init);
    } else {
      this.init = Object.assign(Object.assign({}, defaultEquirectLayerInit), init);
    }
    if (!isReferenceSpace(this.init.space)) {
      throw new TypeError("Equirect layer's space needs to be an XRReferenceSpace");
    }
    this.radius = this.init.radius;
    this.centralHorizontalAngle = this.init.centralHorizontalAngle;
    this.upperVerticalAngle = this.init.upperVerticalAngle;
    this.lowerVerticalAngle = this.init.lowerVerticalAngle;
    this.space = this.init.space;
    this.layout = this.init.layout;
    const _global = getGlobal();
    if (init.transform) {
      this.transform = new _global.XRRigidTransform(init.transform.position, init.transform.orientation);
    } else {
      this.transform = new _global.XRRigidTransform({
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
    }
    if (!this.isMediaLayer()) {
      this.isStatic = init.isStatic;
    }
  }
  getTextureType() {
    if (this.isMediaLayer()) {
      return XRTextureType.texture;
    }
    return this.init.textureType;
  }
  _deferredInitialize() {
    let layout = this.determineLayoutAttribute(this.init.textureType, this.context, this.init.layout);
    this.layout = layout;
    this.needsRedraw = true;
  }
  get colorTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._colorTextures;
  }
  get depthStencilTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._depthStencilTextures || !this._depthStencilTextures.length) {
      this._allocateDepthStencilTexturesInternal(this.getTextureType(), this.init);
    }
    return this._depthStencilTextures;
  }
  get colorTexturesMeta() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._texturesMeta;
  }
};
var defaultQuadLayerInit = {
  colorFormat: 6408,
  mipLevels: 1,
  layout: XRLayerLayout.mono,
  isStatic: false,
  space: null,
  viewPixelHeight: 0,
  viewPixelWidth: 0,
  textureType: XRTextureType.texture,
  width: 1,
  height: 1
};
var defaultMediaQuadLayerInit = {
  space: null,
  layout: XRLayerLayout.mono,
  invertStereo: false
};
var XRQuadLayer = class extends XRCompositionLayerPolyfill {
  constructor(init, media) {
    super();
    this._media = media !== null && media !== void 0 ? media : null;
    if (this.isMediaLayer()) {
      this.init = Object.assign(Object.assign({}, defaultMediaQuadLayerInit), init);
    } else {
      this.init = Object.assign(Object.assign({}, defaultQuadLayerInit), init);
    }
    this.width = this.init.width;
    this.height = this.init.height;
    this.space = this.init.space;
    this.layout = this.init.layout;
    const _global = getGlobal();
    if (this.init.transform) {
      this.transform = new _global.XRRigidTransform(init.transform.position, init.transform.orientation);
    } else {
      this.transform = new _global.XRRigidTransform({
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
    }
    if (!this.isMediaLayer()) {
      this.isStatic = init.isStatic;
    }
  }
  getTextureType() {
    if (this.isMediaLayer()) {
      return XRTextureType.texture;
    }
    return this.init.textureType;
  }
  _deferredInitialize() {
    let layout = this.determineLayoutAttribute(this.init.textureType, this.context, this.init.layout);
    this.layout = layout;
    this.needsRedraw = true;
  }
  get colorTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._colorTextures;
  }
  get depthStencilTextures() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._depthStencilTextures || !this._depthStencilTextures.length) {
      this._allocateDepthStencilTexturesInternal(this.getTextureType(), this.init);
    }
    return this._depthStencilTextures;
  }
  get colorTexturesMeta() {
    if (this.isMediaLayer()) {
      throw new Error("Media layers do not have associated textures");
    }
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateColorTexturesInternal(this.getTextureType(), this.init);
    }
    return this._texturesMeta;
  }
};
var XRMediaBindingPolyfill = class {
  constructor(session) {
    this.session = session;
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
  }
  createQuadLayer(video, init) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Media Quad layer cannot be created with layout of default");
    }
    let aspectRatio = this.calculateAspectRatio(video, init.layout);
    if (init.width === void 0 && init.height === void 0) {
      init.width = 1;
    }
    if (init.height === void 0) {
      init.height = init.width / aspectRatio;
    }
    if (init.width === void 0) {
      init.width = init.height / aspectRatio;
    }
    let layer2 = new XRQuadLayer(init, video);
    layer2.needsRedraw = false;
    layer2.initialize(this.session);
    return layer2;
  }
  createCylinderLayer(video, init) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Media Cylinder layer cannot be created with layout of default");
    }
    let aspectRatio = this.calculateAspectRatio(video, init.layout);
    if (init.aspectRatio === void 0) {
      init.aspectRatio = aspectRatio;
    }
    let layer2 = new XRCylinderLayer(init, video);
    layer2.needsRedraw = false;
    layer2.initialize(this.session);
    return layer2;
  }
  createEquirectLayer(video, init) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Media Equirect layer cannot be created with layout of default");
    }
    if (!isReferenceSpace(init.space)) {
      throw new Error("Media Equirect layer's space must be of type XRReferenceSpace");
    }
    let layer2 = new XREquirectLayer(init, video);
    layer2.needsRedraw = false;
    layer2.initialize(this.session);
    return layer2;
  }
  calculateAspectRatio(video, layout) {
    let width = video.videoWidth;
    let height = video.videoHeight;
    if (layout === XRLayerLayout["stereo-left-right"]) {
      width /= 2;
    }
    if (layout === XRLayerLayout["stereo-top-bottom"]) {
      height /= 2;
    }
    return width / height;
  }
};
var defaultXRProjectionLayerInit = {
  textureType: XRTextureType.texture,
  colorFormat: 6408,
  depthFormat: 6402,
  scaleFactor: 1
};
var XRProjectionLayer = class extends XRCompositionLayerPolyfill {
  constructor(init = defaultXRProjectionLayerInit) {
    super();
    this.init = Object.assign(Object.assign({}, defaultXRProjectionLayerInit), init);
  }
  initialize(session, context) {
    super.initialize(session, context);
    this.initializeIfNeeded();
    let baseLayer = session.getBaseLayer();
    this.textureWidth = baseLayer.framebufferWidth * this.init.scaleFactor;
    this.textureHeight = baseLayer.framebufferHeight * this.init.scaleFactor;
  }
  _allocateProjectionColorTextures() {
    let array = [];
    let polyFillArray = [];
    const createTextureArray = () => {
      array = [];
      for (let tex of polyFillArray) {
        array.push(tex.texture);
      }
    };
    let session = this.session;
    let views = session.internalViews;
    if (!views || views.length === 0) {
      console.warn("We can't allocate color textures without views");
      return;
    }
    let baseLayer = session.getBaseLayer();
    let numViews = views.length;
    let width = baseLayer.framebufferWidth * this.init.scaleFactor / views.length;
    let height = baseLayer.framebufferHeight * this.init.scaleFactor;
    if (this.layout === XRLayerLayout.mono || this.layout === XRLayerLayout.default) {
      if (this.init.textureType === XRTextureType["texture-array"]) {
        let texture = this._createNewColorTexture(width, height, XRTextureType["texture-array"], this.init.colorFormat, numViews);
        polyFillArray = [texture];
      } else {
        for (let view of views) {
          let texture = this._createNewColorTexture(width, height, XRTextureType.texture, this.init.colorFormat);
          polyFillArray.push(texture);
        }
      }
      createTextureArray();
      this._colorTexturesMeta = polyFillArray;
      this._colorTextures = array;
      return;
    }
    if (this.layout === XRLayerLayout["stereo-left-right"]) {
      let texture = this._createNewColorTexture(width * numViews, height, this.init.textureType, this.init.colorFormat);
      polyFillArray = [texture];
    } else if (this.layout === XRLayerLayout["stereo-top-bottom"]) {
      let texture = this._createNewColorTexture(width, height * numViews, this.init.textureType, this.init.colorFormat);
      polyFillArray = [texture];
    }
    createTextureArray();
    this._colorTexturesMeta = polyFillArray;
    this._colorTextures = array;
    return;
  }
  _allocateProjectionDepthStencilTextures() {
    let session = this.session;
    let views = session.internalViews;
    if (!views || views.length === 0) {
      return;
    }
    if (this.init.depthFormat === 0) {
      this._depthStencilTextures = [];
      return;
    }
    if (this.context instanceof WebGLRenderingContext) {
      let depthExtension = this.context.getExtension("WEBGL_depth_texture");
      if (!depthExtension) {
        this._depthStencilTextures = [];
        return;
      }
    }
    let array = [];
    let polyFillArray = [];
    const createTextureArray = () => {
      array = [];
      for (let tex of polyFillArray) {
        array.push(tex.texture);
      }
    };
    this.initializeIfNeeded();
    let baseLayer = session.getBaseLayer();
    let numViews = views.length;
    let width = baseLayer.framebufferWidth * this.init.scaleFactor / views.length;
    let height = baseLayer.framebufferHeight * this.init.scaleFactor;
    if (this.layout === XRLayerLayout.mono || this.layout === XRLayerLayout.default) {
      if (this.init.textureType === XRTextureType["texture-array"]) {
        let texture = this._createNewDepthStencilTexture(width, height, this.init.textureType, this.init.depthFormat, numViews);
        polyFillArray = [texture];
      } else {
        for (let view of views) {
          let texture = this._createNewDepthStencilTexture(width, height, this.init.textureType, this.init.depthFormat);
          polyFillArray.push(texture);
        }
      }
      createTextureArray();
      this._depthStencilTextures = array;
      return;
    }
    if (this.layout === XRLayerLayout["stereo-left-right"]) {
      let texture = this._createNewDepthStencilTexture(width * numViews, height, this.init.textureType, this.init.depthFormat);
      polyFillArray = [texture];
    } else if (this.layout === XRLayerLayout["stereo-top-bottom"]) {
      let texture = this._createNewDepthStencilTexture(width, height * numViews, this.init.textureType, this.init.depthFormat);
      polyFillArray = [texture];
    }
    createTextureArray();
    this._depthStencilTextures = array;
    return;
  }
  get colorTextures() {
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateProjectionColorTextures();
    }
    return this._colorTextures;
  }
  get depthStencilTextures() {
    if (this._depthStencilTextures === void 0) {
      this._allocateProjectionDepthStencilTextures();
    }
    return this._depthStencilTextures || [];
  }
  get colorTexturesMeta() {
    if (!this._colorTextures || !this._colorTextures.length) {
      this._allocateProjectionColorTextures();
    }
    return this._colorTexturesMeta;
  }
  getTextureType() {
    return this.init.textureType;
  }
  _deferredInitialize() {
    this.isStatic = false;
    this.ignoreDepthValues = false;
    this.fixedFoveation = 0;
    let layout = this.determineLayoutAttribute(this.init.textureType, this.context, XRLayerLayout.default);
    this.layout = layout;
    this.needsRedraw = true;
    let maxScaleFactor = this.determineMaximumScaleFactor();
    let scaleFactor = Math.min(this.init.scaleFactor, maxScaleFactor);
    this.init.scaleFactor = scaleFactor;
  }
  determineMaximumScaleFactor() {
    let baseLayer = this.session.getBaseLayer(this.context);
    let largestWidth = baseLayer.framebufferWidth;
    let largestHeight = baseLayer.framebufferHeight;
    if (this.layout === XRLayerLayout["stereo-left-right"]) {
      largestWidth *= 2;
    }
    if (this.layout === XRLayerLayout["stereo-top-bottom"]) {
      largestHeight *= 2;
    }
    let largestViewDimension = Math.max(largestWidth, largestHeight);
    let largestTextureDimension = this.context.getParameter(this.context.MAX_TEXTURE_SIZE);
    return largestTextureDimension / largestViewDimension;
  }
};
var initializeViewport = (viewport, texture, layout, offset, numViews) => {
  let x2 = 0;
  let y3 = 0;
  let width = texture.width;
  let height = texture.height;
  if (layout === XRLayerLayout["stereo-left-right"]) {
    x2 = texture.width * offset / numViews;
    width = texture.width / numViews;
  } else if (layout === XRLayerLayout["stereo-top-bottom"]) {
    y3 = texture.height * offset / numViews;
    height = texture.height / numViews;
  }
  viewport.x = x2;
  viewport.y = y3;
  viewport.width = width;
  viewport.height = height;
};
var compileShader = (gl, shaderSource, shaderType) => {
  var shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!success) {
    throw "could not compile shader:" + gl.getShaderInfoLog(shader);
  }
  return shader;
};
var createProgram = (gl, vertexShader2, fragmentShader2) => {
  const program = gl.createProgram();
  const compiledVS = compileShader(gl, vertexShader2, gl.VERTEX_SHADER);
  const compiledFS = compileShader(gl, fragmentShader2, gl.FRAGMENT_SHADER);
  gl.attachShader(program, compiledVS);
  gl.attachShader(program, compiledFS);
  gl.deleteShader(compiledVS);
  gl.deleteShader(compiledFS);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!success) {
    throw "program failed to link:" + gl.getProgramInfoLog(program);
  }
  return program;
};
var setRectangle = (gl, x2, y3, width, height) => {
  var x1 = x2;
  var x22 = x2 + width;
  var y1 = y3;
  var y22 = y3 + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x22, y1, x1, y22, x1, y22, x22, y1, x22, y22]), gl.DYNAMIC_DRAW);
};
var applyVAOExtension = (gl) => {
  if (gl instanceof WebGL2RenderingContext) {
    return gl;
  }
  const ext = gl.getExtension("OES_vertex_array_object");
  if (!ext) {
    throw new Error("Cannot use VAOs.");
  }
  return {
    VERTEX_ARRAY_BINDING: ext.VERTEX_ARRAY_BINDING_OES,
    bindVertexArray: ext.bindVertexArrayOES.bind(ext),
    createVertexArray: ext.createVertexArrayOES.bind(ext),
    deleteVertexArray: ext.deleteVertexArrayOES.bind(ext),
    isVertexArray: ext.isVertexArrayOES.bind(ext)
  };
};
var glsl = (x2) => x2;
var vertexShader = glsl`
attribute vec2 a_position;
attribute vec2 a_texCoord;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
`;
var fragmentShader = glsl`
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
   	vec4 tex = texture2D(u_image, v_texCoord);
	gl_FragColor = vec4(tex.rgb, tex.a);
}
`;
var ProjectionRenderer = class {
  constructor(layer2, context) {
    this.gl = context;
    this.layer = layer2;
    this.program = createProgram(this.gl, vertexShader, fragmentShader);
    this.programInfo = {
      attribLocations: {
        a_position: this.gl.getAttribLocation(this.program, "a_position"),
        a_texCoord: this.gl.getAttribLocation(this.program, "a_texCoord")
      }
    };
    this._createVAOs();
  }
  render(session) {
    let gl = this.gl;
    let baseLayer = session.getBaseLayer();
    gl.viewport(0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight);
    const textureType = this.layer.getTextureType();
    const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_2D);
    const existingActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
    if (textureType === XRTextureType.texture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.layer.colorTextures[0]);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    } else {
      throw new Error(`Created a texture projection renderer instead of a texture-array projection renderer for a texture-array layer.
This is probably an error with the polyfill itself; please file an issue on Github if you run into this.`);
    }
    for (let view of session.internalViews) {
      let viewport = baseLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      if (this._shouldUseStereoTexturePoints()) {
        this._renderInternalStereo(view);
      } else {
        this._renderInternal();
      }
    }
    gl.activeTexture(existingActiveTexture);
    gl.bindTexture(gl.TEXTURE_2D, existingTextureBinding);
  }
  _renderInternal() {
    let gl = this.gl;
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    this.vaoGl.bindVertexArray(this.vao);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
    this.vaoGl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
  _renderInternalStereo(view) {
    if (view.eye === "none") {
      return this._renderInternal();
    }
    let gl = this.gl;
    this.vaoGl.bindVertexArray(this.vao);
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    this._setStereoTextureBuffer(view.eye === "right" ? 1 : 0);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
    this.vaoGl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
  _createVAOs() {
    this._createTextureUVs();
    let gl = this.gl;
    this.vaoGl = applyVAOExtension(gl);
    let positionBuffer = gl.createBuffer();
    this.vao = this.vaoGl.createVertexArray();
    this.vaoGl.bindVertexArray(this.vao);
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    setRectangle(gl, 0, 0, 1, 1);
    let size = 2;
    let type = gl.FLOAT;
    let normalize4 = false;
    let stride = 0;
    let offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_position, size, type, normalize4, stride, offset);
    this.texcoordBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.texturePoints, gl.DYNAMIC_DRAW);
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord, size, type, normalize4, stride, offset);
    this.vaoGl.bindVertexArray(null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  _setStereoTextureBuffer(index) {
    let gl = this.gl;
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.stereoTexturePoints[index], gl.STATIC_DRAW);
    var size = 2;
    var type = gl.FLOAT;
    var normalize4 = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord, size, type, normalize4, stride, offset);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  _createTextureUVs() {
    this.texturePoints = new Float32Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1
    ]);
    const viewport = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    };
    if (this._shouldUseStereoTexturePoints()) {
      this.stereoTexturePoints = [];
      initializeViewport(viewport, this.layer.colorTexturesMeta[0], this.layer.layout, 0, 2);
      this.stereoTexturePoints[0] = this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0], this.texturePoints, viewport);
      initializeViewport(viewport, this.layer.colorTexturesMeta[0], this.layer.layout, 1, 2);
      this.stereoTexturePoints[1] = this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0], this.texturePoints, viewport);
    }
  }
  _offsetTextureUVsByRect(texture, inArray, textureRect) {
    textureRect = textureRect !== null && textureRect !== void 0 ? textureRect : {
      x: 0,
      y: 0,
      width: texture.width,
      height: texture.height
    };
    const uX = textureRect.x / texture.width;
    const vY = textureRect.y / texture.height;
    const uW = textureRect.width / texture.width;
    const vH = textureRect.height / texture.height;
    const outArray = [];
    for (let i2 = 0; i2 < inArray.length; i2 += 2) {
      let u2 = inArray[i2];
      let v2 = inArray[i2 + 1];
      let newU = u2 * uW + uX;
      let newV = v2 * vH + vY;
      outArray[i2] = newU;
      outArray[i2 + 1] = newV;
    }
    return new Float32Array(outArray);
  }
  _shouldUseStereoTexturePoints() {
    return this.layer.layout === XRLayerLayout["stereo-left-right"] || this.layer.layout === XRLayerLayout["stereo-top-bottom"];
  }
};
var texArrayVertexShader = glsl`#version 300 es

in vec2 a_position;
in vec2 a_texCoord;

out vec2 v_texCoord;

void main() {
	// convert the rectangle from pixels to 0.0 to 1.0
	vec2 zeroToOne = a_position;

	// convert from 0->1 to 0->2
	vec2 zeroToTwo = zeroToOne * 2.0;

	// convert from 0->2 to -1->+1 (clipspace)
	vec2 clipSpace = zeroToTwo - 1.0;

	gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);

	// pass the texCoord to the fragment shader
	// The GPU will interpolate this value between points.
	v_texCoord = a_texCoord;
}
`;
var texArrayFragmentShader = glsl`#version 300 es
precision mediump float;
precision mediump int;
precision mediump sampler2DArray;

uniform sampler2DArray u_image;
uniform int u_layer;

in vec2 v_texCoord;

out vec4 fragColor;

void main() {
	vec4 tex = texture(u_image, vec3(v_texCoord.x, v_texCoord.y, u_layer));
 	fragColor = vec4(tex.rgb, tex.a);
}

`;
var ProjectionTextureArrayRenderer = class extends ProjectionRenderer {
  constructor(layer2, context) {
    super(layer2, context);
    this.program = createProgram(this.gl, texArrayVertexShader, texArrayFragmentShader);
    this._createVAOs();
    this.u_layerInfo = this.gl.getUniformLocation(this.program, "u_layer");
  }
  render(session) {
    let gl = this.gl;
    let textureType = this.layer.getTextureType();
    if (textureType === XRTextureType.texture) {
      throw new Error("Using texture array projection renderer on a layer without texture array.");
    }
    let baseLayer = session.getBaseLayer();
    const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_2D_ARRAY);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.layer.colorTextures[0]);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let view of session.internalViews) {
      let index = session.getViewIndex(view);
      let viewport = baseLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      this._renderInternal(index);
    }
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, existingTextureBinding);
  }
  _renderInternal(layer2 = 0) {
    let gl = this.gl;
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    gl.bindVertexArray(this.vao);
    gl.uniform1i(this.u_layerInfo, layer2);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
    gl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
};
var createProjectionRenderer = (layer2, context) => {
  if (layer2.getTextureType() === XRTextureType["texture-array"]) {
    if (context instanceof WebGL2RenderingContext) {
      return new ProjectionTextureArrayRenderer(layer2, context);
    }
  }
  return new ProjectionRenderer(layer2, context);
};
var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function() {
  var y3 = 0, i2 = arguments.length;
  while (i2--) {
    y3 += arguments[i2] * arguments[i2];
  }
  return Math.sqrt(y3);
};
function create8() {
  var out = new ARRAY_TYPE2(16);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function multiply5(out, a3, b) {
  var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
  var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function fromQuat3(out, q2) {
  var x2 = q2[0], y3 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y3 + y3;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function create$1() {
  var out = new ARRAY_TYPE2(2);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
(function() {
  var vec = create$1();
  return function(a3, stride, offset, count, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l2 = Math.min(count * stride + offset, a3.length);
    } else {
      l2 = a3.length;
    }
    for (i2 = offset; i2 < l2; i2 += stride) {
      vec[0] = a3[i2];
      vec[1] = a3[i2 + 1];
      fn(vec, vec, arg);
      a3[i2] = vec[0];
      a3[i2 + 1] = vec[1];
    }
    return a3;
  };
})();
var glsl$1 = (x2) => x2;
var vertexShader$1 = glsl$1`
attribute vec4 a_position;
attribute vec2 a_texCoord;

uniform mat4 u_matrix;
uniform mat4 u_projectionMatrix;

varying vec2 v_texCoord;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_projectionMatrix * u_matrix * a_position;

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
`;
var fragmentShader$1 = glsl$1`
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
   	vec4 tex = texture2D(u_image, v_texCoord);
	gl_FragColor = vec4(tex.rgb, tex.a);
	// gl_FragColor = vec4(1.0, 0, 0, 1.0);
}
`;
var texArrayVertexShader$1 = glsl$1`#version 300 es

in vec4 a_position;
in vec2 a_texCoord;

uniform mat4 u_matrix;
uniform mat4 u_projectionMatrix;

out vec2 v_texCoord;

void main() {
	// Multiply the position by the matrix.
    gl_Position = u_projectionMatrix * u_matrix * a_position;

	// pass the texCoord to the fragment shader
	// The GPU will interpolate this value between points.
	v_texCoord = a_texCoord;
}
`;
var texArrayFragmentShader$1 = glsl$1`#version 300 es
precision mediump float;
precision mediump int;
precision mediump sampler2DArray;

uniform sampler2DArray u_image;
uniform int u_layer;

in vec2 v_texCoord;

out vec4 fragColor;

void main() {
	vec4 tex = texture(u_image, vec3(v_texCoord.x, v_texCoord.y, u_layer));
 	fragColor = vec4(tex.rgb, tex.a);
}

`;
var CompositionLayerRenderer = class {
  constructor(layer2, context) {
    this.usesTextureArrayShaders = false;
    this.savedVaoState = { vao: null, arrayBuffer: null };
    this.hasMipmap = false;
    this.gl = context;
    this.layer = layer2;
    let gl = this.gl;
    this.transformMatrix = create8();
    if (context instanceof WebGL2RenderingContext && this.layer.getTextureType() === XRTextureType["texture-array"]) {
      this.usesTextureArrayShaders = true;
    }
    if (this.usesTextureArrayShaders) {
      this.program = createProgram(gl, texArrayVertexShader$1, texArrayFragmentShader$1);
    } else {
      this.program = createProgram(gl, vertexShader$1, fragmentShader$1);
    }
    this.programInfo = {
      attribLocations: {
        a_position: gl.getAttribLocation(this.program, "a_position"),
        a_texCoord: gl.getAttribLocation(this.program, "a_texCoord")
      },
      uniformLocations: {
        u_matrix: gl.getUniformLocation(this.program, "u_matrix"),
        u_projectionMatrix: gl.getUniformLocation(this.program, "u_projectionMatrix")
      }
    };
    if (this.usesTextureArrayShaders) {
      this.programInfo.uniformLocations.u_layer = gl.getUniformLocation(this.program, "u_layer");
    }
  }
  saveVaoState() {
    this.savedVaoState.vao = this.gl.getParameter(this.vaoGl.VERTEX_ARRAY_BINDING);
    this.savedVaoState.arrayBuffer = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);
  }
  restoreVaoState() {
    this.vaoGl.bindVertexArray(this.savedVaoState.vao);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.savedVaoState.arrayBuffer);
    this.savedVaoState.vao = this.savedVaoState.arrayBuffer = null;
  }
  initialize() {
    let gl = this.gl;
    if (this.layer.isMediaLayer()) {
      this.mediaTexture = gl.createTexture();
      this.mediaTexturePolyfill = {
        texture: this.mediaTexture,
        textureFormat: gl.RGBA,
        width: this.layer.media.videoWidth,
        height: this.layer.media.videoHeight,
        type: XRTextureType.texture
      };
      const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_2D);
      gl.bindTexture(gl.TEXTURE_2D, this.mediaTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.layer.media.videoWidth, this.layer.media.videoHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, existingTextureBinding);
    }
    this._createVAOs();
  }
  render(session, frame) {
    this.saveVaoState();
    let gl = this.gl;
    let baseLayer = session.getBaseLayer();
    let basePose = frame.getViewerPose(session.getReferenceSpace());
    const existingActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
    for (let view of basePose.views) {
      let viewport = baseLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      gl.activeTexture(gl.TEXTURE0);
      if (this.usesTextureArrayShaders) {
        if (gl instanceof WebGLRenderingContext) {
          throw new Error("This should never happen; texture-arrays only supported on WebGL2.");
        }
        if (this.layer.isMediaLayer()) {
          throw new Error("This should never happen. Media layers should never be created with texture-array");
        }
        const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_2D_ARRAY);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.layer.colorTextures[0]);
        if (this.layer.isStatic) {
          if (this.layer.needsRedraw === true) {
            gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
          }
          this.hasMipmap = true;
        } else {
          this.hasMipmap = this.layer.mipLevels > 0;
        }
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
        let layer2 = 0;
        if (this.layer.layout === XRLayerLayout.stereo) {
          switch (view.eye) {
            case "right":
              layer2 = 1;
              break;
          }
        }
        if (this._shouldUseStereoTexturePoints()) {
          this._renderInternalStereo(session, frame, view, layer2);
        } else {
          this._renderInternal(session, frame, view, layer2);
        }
        gl.activeTexture(existingActiveTexture);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, existingTextureBinding);
      } else {
        const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_2D);
        if (this.layer.isMediaLayer()) {
          gl.bindTexture(gl.TEXTURE_2D, this.mediaTexture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.layer.media.videoWidth, this.layer.media.videoHeight, gl.RGBA, gl.UNSIGNED_BYTE, this.layer.media);
        } else if (this.layer.layout === XRLayerLayout.stereo) {
          switch (view.eye) {
            case "right":
              gl.bindTexture(gl.TEXTURE_2D, this.layer.colorTextures[1]);
              break;
            default:
              gl.bindTexture(gl.TEXTURE_2D, this.layer.colorTextures[0]);
          }
        } else {
          gl.bindTexture(gl.TEXTURE_2D, this.layer.colorTextures[0]);
        }
        if (this.layer.isStatic) {
          if (this.layer.needsRedraw === true) {
            gl.generateMipmap(gl.TEXTURE_2D);
          }
          this.hasMipmap = true;
        } else {
          this.hasMipmap = this.layer.mipLevels > 0;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
        if (this._shouldUseStereoTexturePoints()) {
          this._renderInternalStereo(session, frame, view);
        } else {
          this._renderInternal(session, frame, view);
        }
        gl.activeTexture(existingActiveTexture);
        gl.bindTexture(gl.TEXTURE_2D, existingTextureBinding);
      }
    }
    this.restoreVaoState();
  }
  createPositionPoints() {
    return new Float32Array([]);
  }
  createTextureUVs() {
    return new Float32Array([]);
  }
  _offsetTextureUVsByRect(texture, inArray, textureRect) {
    textureRect = textureRect !== null && textureRect !== void 0 ? textureRect : {
      x: 0,
      y: 0,
      width: texture.width,
      height: texture.height
    };
    const uX = textureRect.x / texture.width;
    const vY = textureRect.y / texture.height;
    const uW = textureRect.width / texture.width;
    const vH = textureRect.height / texture.height;
    const outArray = [];
    for (let i2 = 0; i2 < inArray.length; i2 += 2) {
      let u2 = inArray[i2];
      let v2 = inArray[i2 + 1];
      let newU = u2 * uW + uX;
      let newV = v2 * vH + vY;
      outArray[i2] = newU;
      outArray[i2 + 1] = newV;
    }
    return new Float32Array(outArray);
  }
  _shouldUseStereoTexturePoints() {
    return this.layer.layout === XRLayerLayout["stereo-left-right"] || this.layer.layout === XRLayerLayout["stereo-top-bottom"];
  }
  _setStereoTextureBuffer(index) {
    let gl = this.gl;
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.stereoTexturePoints[index], gl.STATIC_DRAW);
    var size = 2;
    var type = gl.FLOAT;
    var normalize4 = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord, size, type, normalize4, stride, offset);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  _recalculateVertices() {
    this.positionPoints = this.createPositionPoints();
    this.texturePoints = this.createTextureUVs();
    const viewport = {
      x: 0,
      y: 0,
      width: 1,
      height: 1
    };
    if (this._shouldUseStereoTexturePoints()) {
      this.stereoTexturePoints = [];
      if (this.layer.isMediaLayer()) {
        initializeViewport(viewport, this.mediaTexturePolyfill, this.layer.layout, 0, 2);
        this.stereoTexturePoints[0] = this._offsetTextureUVsByRect(this.mediaTexturePolyfill, this.texturePoints, viewport);
        initializeViewport(viewport, this.mediaTexturePolyfill, this.layer.layout, 1, 2);
        this.stereoTexturePoints[1] = this._offsetTextureUVsByRect(this.mediaTexturePolyfill, this.texturePoints, viewport);
        if (this.layer.layout === XRLayerLayout["stereo-top-bottom"]) {
          [this.stereoTexturePoints[0], this.stereoTexturePoints[1]] = [
            this.stereoTexturePoints[1],
            this.stereoTexturePoints[0]
          ];
        }
        return;
      }
      initializeViewport(viewport, this.layer.colorTexturesMeta[0], this.layer.layout, 0, 2);
      this.stereoTexturePoints[0] = this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0], this.texturePoints, viewport);
      initializeViewport(viewport, this.layer.colorTexturesMeta[0], this.layer.layout, 1, 2);
      this.stereoTexturePoints[1] = this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0], this.texturePoints, viewport);
      if (this.layer.layout === XRLayerLayout["stereo-top-bottom"]) {
        [this.stereoTexturePoints[0], this.stereoTexturePoints[1]] = [
          this.stereoTexturePoints[1],
          this.stereoTexturePoints[0]
        ];
      }
    }
  }
  _createVAOs() {
    this._recalculateVertices();
    let gl = this.gl;
    this.vaoGl = applyVAOExtension(gl);
    this.saveVaoState();
    let positionBuffer = gl.createBuffer();
    this.vao = this.vaoGl.createVertexArray();
    this.vaoGl.bindVertexArray(this.vao);
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = this.positionPoints;
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    var size = 3;
    var type = gl.FLOAT;
    var normalize4 = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_position, size, type, normalize4, stride, offset);
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord);
    this.texcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.texturePoints, gl.STATIC_DRAW);
    var size = 2;
    var type = gl.FLOAT;
    var normalize4 = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord, size, type, normalize4, stride, offset);
    this.restoreVaoState();
  }
  _renderInternal(session, frame, view, layer2) {
    let gl = this.gl;
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    this.vaoGl.bindVertexArray(this.vao);
    if (this.usesTextureArrayShaders) {
      gl.uniform1i(this.programInfo.uniformLocations.u_layer, layer2);
    }
    this._setTransformMatrix(session, frame, view);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix, false, this.transformMatrix);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix, false, view.projectionMatrix);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = this.positionPoints.length / 3;
    gl.drawArrays(primitiveType, offset, count);
    this.vaoGl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
  _renderInternalStereo(session, frame, view, layer2) {
    if (view.eye === "none") {
      return this._renderInternal(session, frame, view);
    }
    let gl = this.gl;
    this.vaoGl.bindVertexArray(this.vao);
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    this._setStereoTextureBuffer(view.eye === "right" ? 1 : 0);
    if (this.usesTextureArrayShaders) {
      gl.uniform1i(this.programInfo.uniformLocations.u_layer, layer2);
    }
    this._setTransformMatrix(session, frame, view);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix, false, this.transformMatrix);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix, false, view.projectionMatrix);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = this.positionPoints.length / 3;
    gl.drawArrays(primitiveType, offset, count);
    this.vaoGl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
  _setTransformMatrix(session, frame, view) {
    let objPose = frame.getPose(this.layer.space, session.getReferenceSpace());
    multiply5(this.transformMatrix, objPose.transform.matrix, this.layer.transform.matrix);
    multiply5(this.transformMatrix, view.transform.inverse.matrix, this.transformMatrix);
  }
};
var QuadRenderer = class extends CompositionLayerRenderer {
  constructor(layer2, context) {
    super(layer2, context);
    this.initialize();
  }
  createPositionPoints() {
    const width = this.layer.width;
    const height = this.layer.height;
    const z2 = 0;
    const positions = [
      -width,
      -height,
      z2,
      width,
      -height,
      z2,
      -width,
      height,
      z2,
      -width,
      height,
      z2,
      width,
      -height,
      z2,
      width,
      height,
      z2
    ];
    return new Float32Array(positions);
  }
  createTextureUVs() {
    return new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);
  }
};
var CylinderRenderer = class extends CompositionLayerRenderer {
  constructor(layer2, context) {
    super(layer2, context);
    this.segments = 16;
    this.initialize();
  }
  createPositionPoints() {
    const positions = [];
    const angle2 = this.layer.centralAngle;
    const height = this.layer.height;
    const radius = this.layer.radius;
    const radiansPerSegment = angle2 / this.segments;
    const theta = Math.PI / 2 - angle2 / 2;
    const unitCirclePositions = [];
    const firstUnitPoint = create$1();
    firstUnitPoint[0] = radius * Math.cos(theta);
    firstUnitPoint[1] = -radius * Math.sin(theta);
    unitCirclePositions.push(firstUnitPoint);
    for (let i2 = 0; i2 < this.segments; i2++) {
      const nextPoint = create$1();
      nextPoint[0] = radius * Math.cos(theta + radiansPerSegment * (i2 + 1));
      nextPoint[1] = -radius * Math.sin(theta + radiansPerSegment * (i2 + 1));
      unitCirclePositions.push(nextPoint);
    }
    unitCirclePositions.reverse();
    for (let i2 = 0; i2 < this.segments; i2++) {
      const u2 = unitCirclePositions[i2];
      const v2 = unitCirclePositions[i2 + 1];
      positions.push(u2[0], -height / 2, u2[1]);
      positions.push(v2[0], -height / 2, v2[1]);
      positions.push(u2[0], height / 2, u2[1]);
      positions.push(u2[0], height / 2, u2[1]);
      positions.push(v2[0], -height / 2, v2[1]);
      positions.push(v2[0], height / 2, v2[1]);
    }
    return new Float32Array(positions);
  }
  createTextureUVs() {
    let textureUVs = [];
    const texturePercent = 1 / this.segments;
    for (let i2 = 0; i2 < this.segments; i2++) {
      let leftX = texturePercent * i2;
      let rightX = texturePercent * (i2 + 1);
      textureUVs.push(leftX, 0);
      textureUVs.push(rightX, 0);
      textureUVs.push(leftX, 1);
      textureUVs.push(leftX, 1);
      textureUVs.push(rightX, 0);
      textureUVs.push(rightX, 1);
    }
    return new Float32Array(textureUVs);
  }
};
var EquirectRenderer = class extends CompositionLayerRenderer {
  constructor(layer2, context) {
    super(layer2, context);
    this.segmentsPerAxis = 40;
    this.initialize();
  }
  createPositionPoints() {
    const positions = [];
    let radius = this.layer.radius;
    if (radius === 0) {
      radius = 25;
    }
    if (radius > 25) {
      radius = 25;
    }
    const horizAngle = this.layer.centralHorizontalAngle;
    const phi1 = this.layer.upperVerticalAngle + Math.PI / 2;
    const phi2 = this.layer.lowerVerticalAngle + Math.PI / 2;
    const startPhi = phi1;
    const endPhi = phi2;
    const startTheta = Math.PI / 2 - horizAngle / 2;
    const endTheta = startTheta + horizAngle;
    const phiRange = endPhi - startPhi;
    const thetaRange = endTheta - startTheta;
    const basePoints = [];
    for (let y3 = 0; y3 <= this.segmentsPerAxis; y3++) {
      for (let x2 = 0; x2 <= this.segmentsPerAxis; x2++) {
        const u2 = x2 / this.segmentsPerAxis;
        const v2 = y3 / this.segmentsPerAxis;
        let r3 = radius;
        let theta = endTheta - thetaRange * u2;
        let phi = phiRange * v2 + startPhi;
        const ux = Math.cos(theta) * Math.sin(phi);
        const uy = Math.cos(phi);
        const uz = -Math.sin(theta) * Math.sin(phi);
        basePoints.push([r3 * ux, r3 * uy, r3 * uz]);
      }
    }
    const numVertsAround = this.segmentsPerAxis + 1;
    for (let x2 = 0; x2 < this.segmentsPerAxis; x2++) {
      for (let y3 = 0; y3 < this.segmentsPerAxis; y3++) {
        positions.push(...basePoints[y3 * numVertsAround + x2]);
        positions.push(...basePoints[y3 * numVertsAround + x2 + 1]);
        positions.push(...basePoints[(y3 + 1) * numVertsAround + x2]);
        positions.push(...basePoints[(y3 + 1) * numVertsAround + x2]);
        positions.push(...basePoints[y3 * numVertsAround + x2 + 1]);
        positions.push(...basePoints[(y3 + 1) * numVertsAround + x2 + 1]);
      }
    }
    return new Float32Array(positions);
  }
  createTextureUVs() {
    const triUVs = [];
    const baseUVs = [];
    for (let y3 = 0; y3 <= this.segmentsPerAxis; y3++) {
      for (let x2 = 0; x2 <= this.segmentsPerAxis; x2++) {
        const u2 = x2 / this.segmentsPerAxis;
        const v2 = y3 / this.segmentsPerAxis;
        baseUVs.push([u2, v2]);
      }
    }
    const numVertsAround = this.segmentsPerAxis + 1;
    for (let x2 = 0; x2 < this.segmentsPerAxis; x2++) {
      for (let y3 = 0; y3 < this.segmentsPerAxis; y3++) {
        triUVs.push(...baseUVs[y3 * numVertsAround + x2]);
        triUVs.push(...baseUVs[y3 * numVertsAround + x2 + 1]);
        triUVs.push(...baseUVs[(y3 + 1) * numVertsAround + x2]);
        triUVs.push(...baseUVs[(y3 + 1) * numVertsAround + x2]);
        triUVs.push(...baseUVs[y3 * numVertsAround + x2 + 1]);
        triUVs.push(...baseUVs[(y3 + 1) * numVertsAround + x2 + 1]);
      }
    }
    return new Float32Array(triUVs);
  }
};
var defaultCubeLayerInit = {
  colorFormat: 6408,
  mipLevels: 1,
  layout: XRLayerLayout.mono,
  isStatic: false,
  space: null,
  viewPixelHeight: 0,
  viewPixelWidth: 0
};
var XRCubeLayer = class extends XRCompositionLayerPolyfill {
  constructor(init = defaultCubeLayerInit) {
    super();
    if (!isReferenceSpace(init.space)) {
      throw new TypeError("XRCubeLayer's space needs to be an XRReferenceSpace");
    }
    this.init = Object.assign(Object.assign({}, defaultCubeLayerInit), init);
    this.space = this.init.space;
    this.isStatic = this.init.isStatic;
    if (this.init.orientation) {
      this.orientation = DOMPointReadOnly.fromPoint(this.init.orientation);
    } else {
      this.orientation = new DOMPointReadOnly();
    }
    switch (this.init.layout) {
      case XRLayerLayout.default:
      case XRLayerLayout["stereo-left-right"]:
      case XRLayerLayout["stereo-top-bottom"]:
        throw new TypeError("Invalid layout format for XRCubeLayer");
    }
    this.layout = this.init.layout;
    this.needsRedraw = true;
  }
  initialize(session, context) {
    super.initialize(session, context);
    this._allocateColorTexturesInternal();
    this._allocateDepthStencilTexturesInternal();
  }
  _allocateColorTexturesInternal() {
    this._colorTextures = [];
    this._texturesMeta = [];
    if (this.layout === XRLayerLayout.mono) {
      const colorTexture = this._createCubeColorTexture();
      this._texturesMeta.push(colorTexture);
      this._colorTextures.push(colorTexture.texture);
      return;
    } else {
      const texture1 = this._createCubeColorTexture();
      const texture2 = this._createCubeColorTexture();
      this._texturesMeta.push(texture1, texture2);
      this._colorTextures.push(texture1.texture, texture2.texture);
      return;
    }
  }
  _allocateDepthStencilTexturesInternal() {
    this._depthStencilTextures = [];
    if (!this.init.depthFormat) {
      return;
    }
    if (this.context instanceof WebGLRenderingContext) {
      let depthExtension = this.context.getExtension("WEBGL_depth_texture");
      if (!depthExtension) {
        throw new TypeError("Depth textures not supported in the current context");
      }
    }
    if (this.layout === XRLayerLayout.mono) {
      const depthTexture = this._createCubeDepthTexture();
      this._depthStencilTextures.push(depthTexture.texture);
      return;
    } else {
      const texture1 = this._createCubeDepthTexture();
      const texture2 = this._createCubeDepthTexture();
      this._depthStencilTextures.push(texture1.texture, texture2.texture);
      return;
    }
  }
  _createCubeColorTexture() {
    let texture = this.context.createTexture();
    let textureMeta = {
      width: this.init.viewPixelWidth,
      height: this.init.viewPixelHeight,
      layers: 1,
      type: XRTextureType.texture,
      textureFormat: this.init.colorFormat,
      texture
    };
    const existingTextureBinding = this.context.getParameter(this.context.TEXTURE_BINDING_CUBE_MAP);
    this.context.bindTexture(this.context.TEXTURE_CUBE_MAP, texture);
    for (let i2 = 0; i2 < 6; i2++) {
      this.context.texImage2D(this.context.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, textureMeta.textureFormat, textureMeta.width, textureMeta.height, 0, textureMeta.textureFormat, this.context.UNSIGNED_BYTE, null);
    }
    this.context.bindTexture(this.context.TEXTURE_CUBE_MAP, existingTextureBinding);
    return textureMeta;
  }
  _createCubeDepthTexture() {
    let texture = this.context.createTexture();
    let textureMeta = {
      width: this.init.viewPixelWidth,
      height: this.init.viewPixelHeight,
      layers: 1,
      type: XRTextureType.texture,
      textureFormat: this.init.depthFormat,
      texture
    };
    const existingTextureBinding = this.context.getParameter(this.context.TEXTURE_BINDING_CUBE_MAP);
    this.context.bindTexture(this.context.TEXTURE_CUBE_MAP, texture);
    let internalFormat = this.init.depthFormat;
    if (this.context instanceof WebGL2RenderingContext) {
      if (internalFormat === this.context.DEPTH_COMPONENT) {
        internalFormat = this.context.DEPTH_COMPONENT24;
      }
      if (internalFormat === this.context.DEPTH_STENCIL) {
        internalFormat = this.context.DEPTH24_STENCIL8;
      }
    }
    for (let i2 = 0; i2 < 6; i2++) {
      this.context.texImage2D(this.context.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, internalFormat, textureMeta.width, textureMeta.height, 0, textureMeta.textureFormat, this.context.UNSIGNED_INT, null);
    }
    this.context.bindTexture(this.context.TEXTURE_CUBE_MAP, existingTextureBinding);
    return textureMeta;
  }
  getTextureType() {
    return XRTextureType.texture;
  }
};
var glsl$2 = (x2) => x2;
var vertexShader$2 = glsl$2`
attribute vec4 a_position;
uniform mat4 u_projectionMatrix;
uniform mat4 u_matrix;
varying vec3 v_normal;

void main() {
   gl_Position = u_projectionMatrix * u_matrix * a_position;

   v_normal = normalize(a_position.xyz);
}
`;
var fragmentShader$2 = glsl$2`
precision mediump float;

varying vec3 v_normal;

uniform samplerCube u_texture;

void main() {
   gl_FragColor = textureCube(u_texture, normalize(v_normal));
}
`;
var CubeRenderer = class {
  constructor(layer2, gl) {
    this.savedVaoState = { vao: null, arrayBuffer: null };
    this.hasMipmap = false;
    this.layer = layer2;
    this.gl = gl;
    this.transformMatrix = create8();
    this.program = createProgram(gl, vertexShader$2, fragmentShader$2);
    this.programInfo = {
      attribLocations: {
        a_position: gl.getAttribLocation(this.program, "a_position")
      },
      uniformLocations: {
        u_matrix: gl.getUniformLocation(this.program, "u_matrix"),
        u_texture: gl.getUniformLocation(this.program, "u_texture"),
        u_projectionMatrix: gl.getUniformLocation(this.program, "u_projectionMatrix")
      }
    };
    this._createVAOs();
  }
  saveVaoState() {
    this.savedVaoState.vao = this.gl.getParameter(this.vaoGl.VERTEX_ARRAY_BINDING);
    this.savedVaoState.arrayBuffer = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);
  }
  restoreVaoState() {
    this.vaoGl.bindVertexArray(this.savedVaoState.vao);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.savedVaoState.arrayBuffer);
    this.savedVaoState.vao = this.savedVaoState.arrayBuffer = null;
  }
  render(session, frame) {
    this.saveVaoState();
    let gl = this.gl;
    let baseLayer = session.getBaseLayer();
    let basePose = frame.getViewerPose(session.getReferenceSpace());
    const existingActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
    for (let view of basePose.views) {
      let viewport = baseLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      gl.activeTexture(gl.TEXTURE0);
      const existingTextureBinding = gl.getParameter(gl.TEXTURE_BINDING_CUBE_MAP);
      if (this.layer.layout === XRLayerLayout.stereo) {
        const index = view.eye === "right" ? 1 : 0;
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.layer.colorTextures[index]);
      } else {
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.layer.colorTextures[0]);
      }
      if (this.layer.isStatic) {
        if (this.layer.needsRedraw === true) {
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        this.hasMipmap = true;
      } else {
        this.hasMipmap = this.layer.mipLevels > 0;
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.hasMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      this._renderInternal(this.layer.orientation, view);
      gl.activeTexture(existingActiveTexture);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, existingTextureBinding);
    }
    this.restoreVaoState();
  }
  createPositionPoints() {
    const w2 = 0.5;
    const positions = [
      -w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      -w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      w2,
      w2,
      -w2,
      w2,
      w2,
      w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      w2,
      w2,
      w2,
      w2,
      -w2,
      -w2,
      w2,
      w2,
      w2,
      w2,
      w2,
      w2,
      w2,
      -w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      -w2,
      w2,
      w2,
      -w2,
      -w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      -w2,
      w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      -w2,
      w2,
      -w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      -w2,
      w2,
      w2,
      -w2,
      w2,
      w2,
      w2,
      -w2,
      w2,
      w2,
      w2
    ];
    return new Float32Array(positions);
  }
  _renderInternal(orientation, view) {
    let gl = this.gl;
    const existingProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.useProgram(this.program);
    this.vaoGl.bindVertexArray(this.vao);
    fromQuat3(this.transformMatrix, [
      orientation.x,
      orientation.y,
      orientation.z,
      orientation.w
    ]);
    if (!this._poseOrientationMatrix) {
      this._poseOrientationMatrix = create8();
    }
    fromQuat3(this._poseOrientationMatrix, [
      view.transform.inverse.orientation.x,
      view.transform.inverse.orientation.y,
      view.transform.inverse.orientation.z,
      view.transform.inverse.orientation.w
    ]);
    multiply5(this.transformMatrix, this.transformMatrix, this._poseOrientationMatrix);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix, false, this.transformMatrix);
    gl.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix, false, view.projectionMatrix);
    gl.uniform1i(this.programInfo.uniformLocations.u_texture, 0);
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = this.positionPoints.length / 3;
    gl.drawArrays(primitiveType, offset, count);
    this.vaoGl.bindVertexArray(null);
    gl.useProgram(existingProgram);
  }
  _recalculateVertices() {
    this.positionPoints = this.createPositionPoints();
  }
  _createVAOs() {
    this._recalculateVertices();
    let gl = this.gl;
    this.vaoGl = applyVAOExtension(gl);
    this.saveVaoState();
    let positionBuffer = gl.createBuffer();
    this.vao = this.vaoGl.createVertexArray();
    this.vaoGl.bindVertexArray(this.vao);
    gl.enableVertexAttribArray(this.programInfo.attribLocations.a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = this.positionPoints;
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    var size = 3;
    var type = gl.FLOAT;
    var normalize4 = false;
    var stride = 0;
    var offset = 0;
    gl.vertexAttribPointer(this.programInfo.attribLocations.a_position, size, type, normalize4, stride, offset);
    this.restoreVaoState();
  }
};
var XRSessionWithLayer = class {
  constructor() {
    this.mode = "inline";
    this.layers = [];
    this.views = [];
    this.initializedViews = false;
    this.isPolyfillActive = false;
    this.taskQueue = [];
  }
  requestAnimationFrame(animationFrameCallback) {
    if (!this.injectedFrameCallback) {
      this.injectedFrameCallback = (time, frame) => {
        let gl = this.context;
        if (!this.initializedViews && this.referenceSpace) {
          let pose = frame.getViewerPose(this.referenceSpace);
          if (pose) {
            this.views = pose.views;
            this.initializedViews = true;
          }
        }
        if (this.isPolyfillActive && this.initializedViews) {
          if (!this.tempFramebuffer) {
            this.tempFramebuffer = gl.createFramebuffer();
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.tempFramebuffer);
          const existingClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
          const existingFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
          gl.clearColor(0, 0, 0, 0);
          for (let layer2 of this.layers) {
            if (!(layer2 instanceof XRProjectionLayer)) {
              continue;
            }
            for (let i2 = 0; i2 < layer2.colorTextures.length; i2++) {
              let textureType = layer2.colorTexturesMeta[i2].type;
              if (textureType === XRTextureType["texture-array"]) ;
              else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, layer2.colorTextures[i2], 0);
                if (layer2.depthStencilTextures && i2 < layer2.depthStencilTextures.length) {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, layer2.depthStencilTextures[i2], 0);
                } else {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
              }
            }
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, existingFrameBuffer);
          gl.clearColor(existingClearColor[0], existingClearColor[1], existingClearColor[2], existingClearColor[3]);
        }
        animationFrameCallback(time, frame);
        if (this.isPolyfillActive && this.initializedViews) {
          let prevBlend = gl.isEnabled(gl.BLEND);
          let prevDepthTest = gl.isEnabled(gl.DEPTH_TEST);
          let prevCullFace = gl.isEnabled(gl.CULL_FACE);
          const existingFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
          const existingClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.getBaseLayer().framebuffer);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.clearColor(existingClearColor[0], existingClearColor[1], existingClearColor[2], existingClearColor[3]);
          gl.enable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          let prevBlendSrcRGB = gl.getParameter(gl.BLEND_SRC_RGB);
          let prevBlendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
          let prevBlendDestRGB = gl.getParameter(gl.BLEND_DST_RGB);
          let prevBlendDestAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          for (let layer2 of this.layers) {
            if (!this.renderers) {
              this.renderers = /* @__PURE__ */ new WeakMap();
            }
            if (layer2 instanceof XRProjectionLayer) {
              if (!this.renderers.has(layer2)) {
                this.renderers.set(layer2, createProjectionRenderer(layer2, this.context));
              }
              const renderer = this.renderers.get(layer2);
              renderer.render(this);
            } else if (layer2 instanceof XRQuadLayer) {
              if (!this.renderers.has(layer2)) {
                this.renderers.set(layer2, new QuadRenderer(layer2, this.context));
              }
              const renderer = this.renderers.get(layer2);
              renderer.render(this, frame);
            } else if (layer2 instanceof XRCylinderLayer) {
              if (!this.renderers.has(layer2)) {
                this.renderers.set(layer2, new CylinderRenderer(layer2, this.context));
              }
              const renderer = this.renderers.get(layer2);
              renderer.render(this, frame);
            } else if (layer2 instanceof XREquirectLayer) {
              if (!this.renderers.has(layer2)) {
                this.renderers.set(layer2, new EquirectRenderer(layer2, this.context));
              }
              const renderer = this.renderers.get(layer2);
              renderer.render(this, frame);
            } else if (layer2 instanceof XRCubeLayer) {
              if (!this.renderers.has(layer2)) {
                this.renderers.set(layer2, new CubeRenderer(layer2, this.context));
              }
              const renderer = this.renderers.get(layer2);
              renderer.render(this, frame);
            } else {
              const webglLayer = layer2;
              if (webglLayer.framebuffer === null) {
                continue;
              }
              if (gl instanceof WebGL2RenderingContext) {
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglLayer.framebuffer);
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.getBaseLayer().framebuffer);
                gl.blitFramebuffer(0, 0, webglLayer.framebufferWidth, webglLayer.framebufferHeight, 0, 0, this.getBaseLayer().framebufferWidth, this.getBaseLayer().framebufferHeight, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.LINEAR);
              } else {
                console.warn("GL blitFramebuffer is not supported on WebGL1, so XRWebGLLayers may not show up properly when polyfilled.");
              }
            }
          }
          if (!prevBlend) {
            gl.disable(gl.BLEND);
          }
          if (prevDepthTest) {
            gl.enable(gl.DEPTH_TEST);
          }
          if (prevCullFace) {
            gl.enable(gl.CULL_FACE);
          }
          gl.blendFuncSeparate(prevBlendSrcRGB, prevBlendDestRGB, prevBlendSrcAlpha, prevBlendDestAlpha);
          gl.bindFramebuffer(gl.FRAMEBUFFER, existingFrameBuffer);
          while (this.taskQueue.length > 0) {
            const task = this.taskQueue.shift();
            task();
          }
        }
      };
    }
    this._requestAnimationFrame(this.injectedFrameCallback);
  }
  updateRenderState(XRRenderStateInit) {
    this.existingBaseLayer = XRRenderStateInit.baseLayer;
    if (XRRenderStateInit.layers) {
      this.layers = XRRenderStateInit.layers;
    }
    if (!this.activeRenderState) {
      this.createActiveRenderState();
    }
    this.activeRenderState = Object.assign(Object.assign({}, this.activeRenderState), XRRenderStateInit);
    if (!XRRenderStateInit.layers) {
      this._updateRenderState(XRRenderStateInit);
      return;
    }
    let layerRenderStateInit = Object.assign({}, XRRenderStateInit);
    delete layerRenderStateInit.layers;
    let context = void 0;
    for (let layer2 of this.layers) {
      if (layer2 instanceof XRCompositionLayerPolyfill) {
        context = layer2.getContext();
        break;
      }
    }
    if (!context && !this.context) {
      let onResize = function() {
        context.canvas.width = context.canvas.clientWidth * window.devicePixelRatio;
        context.canvas.height = context.canvas.clientHeight * window.devicePixelRatio;
      };
      console.log("No existing context! Have the session make one");
      const canvas = document.createElement("canvas");
      context = canvas.getContext("webgl2", { xrCompatible: true });
      if (!context) {
        context = canvas.getContext("webgl", { xrCompatible: true });
      }
      if (!context) {
        throw new Error("No webGL support detected.");
      }
      document.body.appendChild(context.canvas);
      window.addEventListener("resize", onResize);
      onResize();
    }
    this.createInternalLayer(context);
    this.isPolyfillActive = true;
    this._updateRenderState(Object.assign(Object.assign({}, layerRenderStateInit), { baseLayer: this.internalLayer }));
  }
  initializeSession(mode) {
    this.mode = mode;
    this.requestReferenceSpace("local").then((refSpace) => {
      this.referenceSpace = refSpace;
    }).catch((e) => {
    });
    this.requestReferenceSpace("viewer").then((viewerSpace) => {
      this.viewerSpace = viewerSpace;
    });
  }
  getBaseLayer(context) {
    if (!this.internalLayer && !this.existingBaseLayer && context) {
      this.createInternalLayer(context);
    }
    return this.internalLayer || this.existingBaseLayer;
  }
  getReferenceSpace() {
    return !this.referenceSpace ? this.viewerSpace : this.referenceSpace;
  }
  getViewerSpace() {
    return this.viewerSpace;
  }
  queueTask(task) {
    this.taskQueue.push(task);
  }
  get renderState() {
    if (!this.activeRenderState) {
      this.createActiveRenderState();
    }
    return this.activeRenderState;
  }
  get internalViews() {
    return this.views;
  }
  getViewIndex(view) {
    for (let i2 = 0; i2 < this.views.length; i2++) {
      let testView = this.views[i2];
      if (view.eye === testView.eye && view.recommendedViewportScale === testView.recommendedViewportScale) {
        return i2;
      }
    }
    return -1;
  }
  createInternalLayer(context) {
    if (!context && this.internalLayer) {
      return this.internalLayer;
    }
    if (context === this.context && this.internalLayer) {
      return this.internalLayer;
    }
    const _global = getGlobal();
    this.internalLayer = new _global.XRWebGLLayer(this, context);
    this.setContext(context);
    return this.internalLayer;
  }
  setContext(context) {
    this.context = context;
    this.tempFramebuffer = context.createFramebuffer();
    this.renderers = /* @__PURE__ */ new WeakMap();
  }
  createActiveRenderState() {
    const _global = getGlobal();
    let prototypeNames = Object.getOwnPropertyNames(_global.XRRenderState.prototype);
    const renderStateClone = {};
    for (let item of prototypeNames) {
      renderStateClone[item] = this._renderState[item];
    }
    renderStateClone.layers = [];
    this.activeRenderState = renderStateClone;
  }
};
var XRWebGLSubImagePolyfill = class {
  constructor() {
    this.viewport = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
};
var XRWebGLBindingPolyfill = class {
  constructor(session, context) {
    this.session = session;
    this.context = context;
    this.subImageCache = new SubImageCache();
  }
  createProjectionLayer(init = defaultXRProjectionLayerInit) {
    const layer2 = new XRProjectionLayer(init);
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (this.context.isContextLost()) {
      throw new Error("context is lost");
    }
    layer2.initialize(this.session, this.context);
    return layer2;
  }
  createQuadLayer(init = defaultQuadLayerInit) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (this.context.isContextLost()) {
      throw new Error("context is lost");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Trying to create a quad layer with default layout");
    }
    const layer2 = new XRQuadLayer(init);
    layer2.initialize(this.session, this.context);
    return layer2;
  }
  createCylinderLayer(init = defaultCylinderLayerInit) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (this.context.isContextLost()) {
      throw new Error("context is lost");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Cylinder Layer cannot have a default layout");
    }
    const layer2 = new XRCylinderLayer(init);
    layer2.initialize(this.session, this.context);
    return layer2;
  }
  createEquirectLayer(init = defaultEquirectLayerInit) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (this.context.isContextLost()) {
      throw new Error("context is lost");
    }
    if (init.layout === XRLayerLayout.default) {
      throw new TypeError("Equirect Layer cannot have a default layout");
    }
    if (!isReferenceSpace(init.space)) {
      throw new TypeError("Equirect layer requires an XRReferenceSpace");
    }
    let layer2 = new XREquirectLayer(init);
    layer2.initialize(this.session, this.context);
    return layer2;
  }
  createCubeLayer(init) {
    if (this.session.ended) {
      throw new Error("Session has ended");
    }
    if (this.context.isContextLost()) {
      throw new Error("context is lost");
    }
    if (!(this.context instanceof WebGL2RenderingContext)) {
      throw new Error("XRCubeLayer only work on WebGL2");
    }
    if (!isReferenceSpace(init.space)) {
      throw new TypeError("XRCubeLayer requires a space of type XRReferenceSpace");
    }
    let layer2 = new XRCubeLayer(init);
    layer2.initialize(this.session, this.context);
    return layer2;
  }
  getSubImage(layer2, frame, eye = "none") {
    if (layer2.isStatic && layer2.needsRedraw === false) {
      throw new Error("Invalid state for subimage creation");
    }
    let existingSubImage = this.subImageCache.tryGetCachedSubImage(this.context, layer2, eye);
    if (existingSubImage) {
      return existingSubImage;
    }
    let subimage = new XRWebGLSubImagePolyfill();
    if (layer2 instanceof XRProjectionLayer) {
      throw new TypeError();
    }
    if (layer2.layout === XRLayerLayout.default) {
      throw new TypeError();
    }
    if (!this.validateStateofSubImageCreation(layer2, frame)) {
      throw new Error("Invalid state for subimage creation");
    }
    let index = 0;
    if (layer2.layout === XRLayerLayout.stereo) {
      if (eye === "none") {
        throw new TypeError();
      }
      if (eye === "right") {
        index = 1;
      }
    }
    if (layer2.getTextureType() === XRTextureType["texture-array"]) {
      subimage.imageIndex = index;
    } else {
      subimage.imageIndex = 0;
    }
    let _textureIndex = 0;
    if (layer2.getTextureType() === XRTextureType.texture) {
      subimage.colorTexture = layer2.colorTextures[index];
      _textureIndex = index;
    } else {
      subimage.colorTexture = layer2.colorTextures[0];
      _textureIndex = 0;
    }
    if (!layer2.depthStencilTextures || !layer2.depthStencilTextures.length) {
      subimage.depthStencilTexture = null;
    } else if (layer2.getTextureType() === XRTextureType.texture) {
      subimage.depthStencilTexture = layer2.depthStencilTextures[index];
    } else {
      subimage.depthStencilTexture = layer2.depthStencilTextures[0];
    }
    const layerMeta = layer2.colorTexturesMeta[_textureIndex];
    subimage.textureWidth = layerMeta.width;
    subimage.textureHeight = layerMeta.height;
    let viewsPerTexture = 1;
    if (layer2.layout === XRLayerLayout["stereo-left-right"] || layer2.layout === XRLayerLayout["stereo-top-bottom"]) {
      viewsPerTexture = 2;
    }
    initializeViewport(subimage.viewport, layerMeta, layer2.layout, index, viewsPerTexture);
    this.session.queueTask(() => {
      layer2.needsRedraw = false;
    });
    this.subImageCache.cacheSubImage(subimage, this.context, layer2, eye);
    return subimage;
  }
  getViewSubImage(layer2, view) {
    let existingSubImage = this.subImageCache.tryGetCachedViewSubImage(this.context, layer2, view);
    if (existingSubImage) {
      return existingSubImage;
    }
    let subimage = new XRWebGLSubImagePolyfill();
    let session = this.session;
    if (!session.internalViews || !session.internalViews.length) {
      console.warn("Tried to get view sub image before we have any views");
      return subimage;
    }
    let index = session.getViewIndex(view);
    let _textureIndex = 0;
    if (layer2.getTextureType() === XRTextureType["texture-array"]) {
      subimage.imageIndex = index;
    } else {
      subimage.imageIndex = 0;
    }
    if (layer2.layout === XRLayerLayout.default && layer2.getTextureType() === XRTextureType.texture) {
      subimage.colorTexture = layer2.colorTextures[index];
      _textureIndex = index;
    } else {
      subimage.colorTexture = layer2.colorTextures[0];
      _textureIndex = 0;
    }
    if (layer2.depthStencilTextures.length === 0) {
      subimage.depthStencilTexture = null;
    } else if (layer2.layout === XRLayerLayout.default && layer2.getTextureType() === XRTextureType.texture) {
      subimage.depthStencilTexture = layer2.depthStencilTextures[index];
    } else {
      subimage.depthStencilTexture = layer2.depthStencilTextures[0];
    }
    subimage.textureWidth = layer2.colorTexturesMeta[_textureIndex].width;
    subimage.textureHeight = layer2.colorTexturesMeta[_textureIndex].height;
    initializeViewport(subimage.viewport, layer2.colorTexturesMeta[_textureIndex], layer2.layout, index, session.internalViews.length);
    layer2.needsRedraw = false;
    this.subImageCache.cacheViewSubImage(subimage, this.context, layer2, view);
    return subimage;
  }
  validateStateofSubImageCreation(layer2, frame) {
    if (frame.session !== layer2.session) {
      return false;
    }
    if (this.session !== layer2.session) {
      return false;
    }
    if (this.context !== layer2.context) {
      return false;
    }
    if (!layer2.colorTextures || !layer2.colorTextures.length) {
      return false;
    }
    if (layer2.isStatic && layer2.needsRedraw === false) {
      return false;
    }
    return true;
  }
};
var SubImageCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.viewCache = /* @__PURE__ */ new Map();
  }
  cacheSubImage(subimage, context, layer2, eye) {
    let eyeMap = /* @__PURE__ */ new Map();
    eyeMap.set(eye, subimage);
    let layerMap = /* @__PURE__ */ new Map();
    layerMap.set(layer2, eyeMap);
    this.cache.set(context, layerMap);
  }
  tryGetCachedSubImage(context, layer2, eye) {
    var _a2, _b;
    return (_b = (_a2 = this.cache.get(context)) === null || _a2 === void 0 ? void 0 : _a2.get(layer2)) === null || _b === void 0 ? void 0 : _b.get(eye);
  }
  cacheViewSubImage(subimage, context, layer2, view) {
    let viewMap = /* @__PURE__ */ new Map();
    viewMap.set(view, subimage);
    let layerMap = /* @__PURE__ */ new Map();
    layerMap.set(layer2, viewMap);
    this.viewCache.set(context, layerMap);
  }
  tryGetCachedViewSubImage(context, layer2, view) {
    var _a2, _b;
    return (_b = (_a2 = this.viewCache.get(context)) === null || _a2 === void 0 ? void 0 : _a2.get(layer2)) === null || _b === void 0 ? void 0 : _b.get(view);
  }
};
var isLayersNativelySupported = (global2) => {
  if (!global2.navigator.xr) {
    return false;
  }
  if (global2.XRMediaBinding && global2.XRWebGLBinding) {
    return true;
  }
  return false;
};
var WebXRLayersPolyfill = class {
  constructor() {
    this.injected = false;
    const _global = getGlobal();
    this._injectPolyfill(_global);
  }
  _injectPolyfill(global2) {
    if (!("xr" in global2.navigator)) {
      throw new Error("WebXR Layers polyfill requires WebXR support.");
    }
    if (this.injected === true) {
      console.warn("Polyfill has already been injected...");
    }
    if (isLayersNativelySupported(global2)) {
      return;
    }
    this._polyfillRequiredLayersFeature(global2);
    this._polyfillXRSession(global2);
    global2.XRWebGLBinding = XRWebGLBindingPolyfill;
    global2.XRMediaBinding = XRMediaBindingPolyfill;
    this.injected = true;
    console.log("Injected Layers Polyfill");
  }
  _polyfillXRSession(global2) {
    global2.XRSession.prototype._updateRenderState = global2.XRSession.prototype.updateRenderState;
    global2.XRSession.prototype._requestAnimationFrame = global2.XRSession.prototype.requestAnimationFrame;
    let renderStateGetter = Object.getOwnPropertyDescriptor(global2.XRSession.prototype, "renderState");
    Object.defineProperty(global2.XRSession.prototype, "_renderState", renderStateGetter);
    let polyfillRenderStateGetter = Object.getOwnPropertyDescriptor(XRSessionWithLayer.prototype, "renderState");
    Object.defineProperty(global2.XRSession.prototype, "renderState", polyfillRenderStateGetter);
    let prototypeNames = Object.getOwnPropertyNames(XRSessionWithLayer.prototype);
    for (let item of prototypeNames) {
      let propertyDescriptor = Object.getOwnPropertyDescriptor(XRSessionWithLayer.prototype, item);
      Object.defineProperty(global2.XRSession.prototype, item, propertyDescriptor);
    }
  }
  _polyfillRequiredLayersFeature(global2) {
    const existingRequestSession = global2.navigator.xr.requestSession;
    Object.defineProperty(global2.navigator.xr, "requestSessionInternal", { writable: true });
    global2.navigator.xr.requestSessionInternal = existingRequestSession;
    const newRequestSession = (sessionMode, sessionInit) => {
      const modifiedSessionPromise = (mode, init) => {
        return global2.navigator.xr.requestSessionInternal(mode, init).then((session) => {
          Object.assign(session, new XRSessionWithLayer());
          let polyfilledSession = session;
          polyfilledSession.initializeSession(sessionMode);
          return Promise.resolve(polyfilledSession);
        });
      };
      if (sessionMode !== "immersive-vr") {
        return modifiedSessionPromise(sessionMode, sessionInit);
      }
      if (!sessionInit) {
        return modifiedSessionPromise(sessionMode, sessionInit);
      }
      if (sessionInit.requiredFeatures && sessionInit.requiredFeatures.indexOf("layers") > -1) {
        const sessionInitClone = Object.assign({}, sessionInit);
        const reqFeatures = [...sessionInit.requiredFeatures];
        const layersIndex = reqFeatures.indexOf("layers");
        reqFeatures.splice(layersIndex, 1);
        sessionInitClone.requiredFeatures = reqFeatures;
        return modifiedSessionPromise(sessionMode, sessionInitClone);
      }
      return modifiedSessionPromise(sessionMode, sessionInit);
    };
    Object.defineProperty(global2.navigator.xr, "requestSession", { writable: true });
    global2.navigator.xr.requestSession = newRequestSession;
  }
};
var webxr_layers_polyfill_module_default = WebXRLayersPolyfill;

// node_modules/iwer/lib/device/XRDevice.js
var DEFAULTS = {
  ipd: 0.063,
  fovy: Math.PI / 2,
  headsetPosition: new Vector321(0, 1.6, 0),
  headsetQuaternion: new Quaternion15(),
  stereoEnabled: false
};
var Z_INDEX_SEM_CANVAS = 1;
var Z_INDEX_APP_CANVAS = 2;
var Z_INDEX_DEVUI_CANVAS = 3;
var Z_INDEX_DEVUI_CONTAINER = 4;
var XRDevice = class {
  constructor(deviceConfig, deviceOptions = {}) {
    var _a2, _b, _c, _d, _e2, _f;
    this.version = VERSION2;
    const globalSpace = new GlobalSpace();
    const viewerSpace = new XRReferenceSpace(XRReferenceSpaceType.Viewer, globalSpace);
    const viewSpaces = {
      [XREye.Left]: new XRSpace(viewerSpace),
      [XREye.Right]: new XRSpace(viewerSpace),
      [XREye.None]: new XRSpace(viewerSpace)
    };
    const controllerConfig = deviceConfig.controllerConfig;
    const controllers = {};
    if (controllerConfig) {
      Object.values(XRHandedness).forEach((handedness) => {
        if (controllerConfig.layout[handedness]) {
          controllers[handedness] = new XRController(controllerConfig, handedness, globalSpace);
        }
      });
    }
    const hands = {
      [XRHandedness.Left]: new XRHandInput(oculusHandConfig, XRHandedness.Left, globalSpace),
      [XRHandedness.Right]: new XRHandInput(oculusHandConfig, XRHandedness.Right, globalSpace)
    };
    const canvasContainer = (_a2 = deviceOptions.canvasContainer) !== null && _a2 !== void 0 ? _a2 : document.createElement("div");
    canvasContainer.dataset.webxr_runtime = `Immersive Web Emulation Runtime v${VERSION2}`;
    canvasContainer.style.position = "fixed";
    canvasContainer.style.width = "100%";
    canvasContainer.style.height = "100%";
    canvasContainer.style.top = "0";
    canvasContainer.style.left = "0";
    canvasContainer.style.display = "flex";
    canvasContainer.style.justifyContent = "center";
    canvasContainer.style.alignItems = "center";
    canvasContainer.style.overflow = "hidden";
    canvasContainer.style.zIndex = "999";
    this[P_DEVICE] = {
      name: deviceConfig.name,
      supportedSessionModes: deviceConfig.supportedSessionModes,
      supportedFeatures: deviceConfig.supportedFeatures,
      supportedFrameRates: deviceConfig.supportedFrameRates,
      isSystemKeyboardSupported: deviceConfig.isSystemKeyboardSupported,
      internalNominalFrameRate: deviceConfig.internalNominalFrameRate,
      environmentBlendModes: deviceConfig.environmentBlendModes,
      interactionMode: deviceConfig.interactionMode,
      userAgent: deviceConfig.userAgent,
      position: (_b = deviceOptions.headsetPosition) !== null && _b !== void 0 ? _b : DEFAULTS.headsetPosition.clone(),
      quaternion: (_c = deviceOptions.headsetQuaternion) !== null && _c !== void 0 ? _c : DEFAULTS.headsetQuaternion.clone(),
      stereoEnabled: (_d = deviceOptions.stereoEnabled) !== null && _d !== void 0 ? _d : DEFAULTS.stereoEnabled,
      ipd: (_e2 = deviceOptions.ipd) !== null && _e2 !== void 0 ? _e2 : DEFAULTS.ipd,
      fovy: (_f = deviceOptions.fovy) !== null && _f !== void 0 ? _f : DEFAULTS.fovy,
      controllers,
      hands,
      primaryInputMode: "controller",
      pendingReferenceSpaceReset: false,
      visibilityState: "visible",
      pendingVisibilityState: null,
      xrSystem: null,
      matrix: mat4_exports.create(),
      globalSpace,
      viewerSpace,
      viewSpaces,
      canvasContainer,
      getViewport: (layer2, view) => {
        const canvas = layer2.context.canvas;
        const { width, height } = canvas;
        switch (view.eye) {
          case XREye.None:
            return new XRViewport(0, 0, width, height);
          case XREye.Left:
            return new XRViewport(0, 0, this[P_DEVICE].stereoEnabled ? width / 2 : width, height);
          case XREye.Right:
            return new XRViewport(width / 2, 0, this[P_DEVICE].stereoEnabled ? width / 2 : 0, height);
        }
      },
      updateViews: () => {
        const viewerSpace2 = this[P_DEVICE].viewerSpace;
        mat4_exports.fromRotationTranslation(viewerSpace2[P_SPACE].offsetMatrix, this[P_DEVICE].quaternion.quat, this[P_DEVICE].position.vec3);
        mat4_exports.fromTranslation(this[P_DEVICE].viewSpaces[XREye.Left][P_SPACE].offsetMatrix, vec3_exports.fromValues(-this[P_DEVICE].ipd / 2, 0, 0));
        mat4_exports.fromTranslation(this[P_DEVICE].viewSpaces[XREye.Right][P_SPACE].offsetMatrix, vec3_exports.fromValues(this[P_DEVICE].ipd / 2, 0, 0));
      },
      onBaseLayerSet: (baseLayer) => {
        if (!baseLayer)
          return;
        const canvas = baseLayer.context.canvas;
        if (canvas.parentElement !== this[P_DEVICE].canvasContainer) {
          const devui = this[P_DEVICE].devui;
          if (devui) {
            const { devUICanvas, devUIContainer } = devui;
            devUICanvas.style.zIndex = Z_INDEX_DEVUI_CANVAS.toString();
            devUIContainer.style.zIndex = Z_INDEX_DEVUI_CONTAINER.toString();
            this[P_DEVICE].canvasContainer.appendChild(devui.devUICanvas);
            this[P_DEVICE].canvasContainer.appendChild(devui.devUIContainer);
          }
          const sem = this[P_DEVICE].sem;
          if (sem) {
            sem.environmentCanvas.style.zIndex = Z_INDEX_SEM_CANVAS.toString();
            this[P_DEVICE].canvasContainer.appendChild(sem.environmentCanvas);
          }
          this[P_DEVICE].canvasData = {
            canvas,
            parent: canvas.parentElement,
            width: canvas.width,
            height: canvas.height,
            zIndex: canvas.style.zIndex
          };
          canvas.style.zIndex = Z_INDEX_APP_CANVAS.toString();
          this[P_DEVICE].canvasContainer.appendChild(canvas);
          document.body.appendChild(this[P_DEVICE].canvasContainer);
        }
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      },
      onSessionEnd: () => {
        if (this[P_DEVICE].canvasData) {
          const { canvas, parent, width, height, zIndex } = this[P_DEVICE].canvasData;
          canvas.width = width;
          canvas.height = height;
          canvas.style.zIndex = zIndex;
          if (parent) {
            parent.appendChild(canvas);
          } else {
            this[P_DEVICE].canvasContainer.removeChild(canvas);
          }
          const devui = this[P_DEVICE].devui;
          if (devui) {
            this[P_DEVICE].canvasContainer.removeChild(devui.devUICanvas);
            this[P_DEVICE].canvasContainer.removeChild(devui.devUIContainer);
          }
          const sem = this[P_DEVICE].sem;
          if (sem) {
            this[P_DEVICE].canvasContainer.removeChild(sem.environmentCanvas);
          }
          document.body.removeChild(this[P_DEVICE].canvasContainer);
          this[P_DEVICE].canvasData = void 0;
          window.dispatchEvent(new Event("resize"));
        }
      },
      onFrameStart: (frame) => {
        var _a3;
        if ((_a3 = this[P_DEVICE].actionPlayer) === null || _a3 === void 0 ? void 0 : _a3.playing) {
          this[P_DEVICE].actionPlayer.playFrame();
        } else {
          const session = frame.session;
          this[P_DEVICE].updateViews();
          if (this[P_DEVICE].pendingVisibilityState) {
            this[P_DEVICE].visibilityState = this[P_DEVICE].pendingVisibilityState;
            this[P_DEVICE].pendingVisibilityState = null;
            session.dispatchEvent(new XRSessionEvent("visibilitychange", { session }));
          }
          if (this[P_DEVICE].visibilityState === "visible") {
            this.activeInputs.forEach((activeInput) => {
              activeInput.onFrameStart(frame);
            });
          }
          if (this[P_DEVICE].pendingReferenceSpaceReset) {
            session[P_SESSION].referenceSpaces.forEach((referenceSpace) => {
              switch (referenceSpace[P_REF_SPACE].type) {
                case XRReferenceSpaceType.Local:
                case XRReferenceSpaceType.LocalFloor:
                case XRReferenceSpaceType.BoundedFloor:
                case XRReferenceSpaceType.Unbounded:
                  referenceSpace.dispatchEvent(new XRReferenceSpaceEvent("reset", { referenceSpace }));
                  break;
              }
            });
            this[P_DEVICE].pendingReferenceSpaceReset = false;
          }
        }
        this[P_DEVICE].updateViews();
      }
    };
    this[P_DEVICE].updateViews();
    globalThis;
  }
  installRuntime(options) {
    var _a2;
    const globalObject = (_a2 = options === null || options === void 0 ? void 0 : options.globalObject) !== null && _a2 !== void 0 ? _a2 : globalThis;
    const polyfillLayers = options === null || options === void 0 ? void 0 : options.polyfillLayers;
    Object.defineProperty(WebGL2RenderingContext.prototype, "makeXRCompatible", {
      value: function() {
        return new Promise((resolve, _reject) => {
          resolve(true);
        });
      },
      configurable: true
    });
    this[P_DEVICE].xrSystem = new XRSystem(this);
    Object.defineProperty(globalThis.navigator, "xr", {
      value: this[P_DEVICE].xrSystem,
      configurable: true
    });
    Object.defineProperty(navigator, "userAgent", {
      value: this[P_DEVICE].userAgent,
      writable: false,
      configurable: false,
      enumerable: true
    });
    globalObject["XRSystem"] = XRSystem;
    globalObject["XRSession"] = XRSession;
    globalObject["XRRenderState"] = XRRenderState;
    globalObject["XRFrame"] = XRFrame;
    globalObject["XRSpace"] = XRSpace;
    globalObject["XRReferenceSpace"] = XRReferenceSpace;
    globalObject["XRJointSpace"] = XRJointSpace;
    globalObject["XRView"] = XRView;
    globalObject["XRViewport"] = XRViewport;
    globalObject["XRRigidTransform"] = XRRigidTransform;
    globalObject["XRPose"] = XRPose;
    globalObject["XRViewerPose"] = XRViewerPose;
    globalObject["XRJointPose"] = XRJointPose;
    globalObject["XRInputSource"] = XRInputSource;
    globalObject["XRInputSourceArray"] = XRInputSourceArray;
    globalObject["XRHand"] = XRHand;
    globalObject["XRLayer"] = XRLayer;
    globalObject["XRWebGLLayer"] = XRWebGLLayer;
    globalObject["XRSessionEvent"] = XRSessionEvent;
    globalObject["XRInputSourceEvent"] = XRInputSourceEvent;
    globalObject["XRInputSourcesChangeEvent"] = XRInputSourcesChangeEvent;
    globalObject["XRReferenceSpaceEvent"] = XRReferenceSpaceEvent;
    if (polyfillLayers) {
      new webxr_layers_polyfill_module_default();
    } else {
      globalObject["XRMediaBinding"] = void 0;
      globalObject["XRWebGLBinding"] = void 0;
    }
  }
  installDevUI(devUIConstructor) {
    this[P_DEVICE].devui = new devUIConstructor(this);
  }
  installSEM(semConstructor) {
    this[P_DEVICE].sem = new semConstructor(this);
  }
  get supportedSessionModes() {
    return this[P_DEVICE].supportedSessionModes;
  }
  get supportedFeatures() {
    return this[P_DEVICE].supportedFeatures;
  }
  get supportedFrameRates() {
    return this[P_DEVICE].supportedFrameRates;
  }
  get isSystemKeyboardSupported() {
    return this[P_DEVICE].isSystemKeyboardSupported;
  }
  get internalNominalFrameRate() {
    return this[P_DEVICE].internalNominalFrameRate;
  }
  get stereoEnabled() {
    return this[P_DEVICE].stereoEnabled;
  }
  set stereoEnabled(value) {
    this[P_DEVICE].stereoEnabled = value;
  }
  get ipd() {
    return this[P_DEVICE].ipd;
  }
  set ipd(value) {
    this[P_DEVICE].ipd = value;
  }
  get fovy() {
    return this[P_DEVICE].fovy;
  }
  set fovy(value) {
    this[P_DEVICE].fovy = value;
  }
  get position() {
    return this[P_DEVICE].position;
  }
  get quaternion() {
    return this[P_DEVICE].quaternion;
  }
  get viewerSpace() {
    var _a2;
    if ((_a2 = this[P_DEVICE].actionPlayer) === null || _a2 === void 0 ? void 0 : _a2.playing) {
      return this[P_DEVICE].actionPlayer.viewerSpace;
    } else {
      return this[P_DEVICE].viewerSpace;
    }
  }
  get viewSpaces() {
    var _a2;
    if ((_a2 = this[P_DEVICE].actionPlayer) === null || _a2 === void 0 ? void 0 : _a2.playing) {
      return this[P_DEVICE].actionPlayer.viewSpaces;
    } else {
      return this[P_DEVICE].viewSpaces;
    }
  }
  get controllers() {
    return this[P_DEVICE].controllers;
  }
  get hands() {
    return this[P_DEVICE].hands;
  }
  get primaryInputMode() {
    return this[P_DEVICE].primaryInputMode;
  }
  set primaryInputMode(mode) {
    if (mode !== "controller" && mode !== "hand") {
      console.warn('primary input mode can only be "controller" or "hand"');
      return;
    }
    this[P_DEVICE].primaryInputMode = mode;
  }
  get activeInputs() {
    if (this[P_DEVICE].visibilityState !== "visible") {
      return [];
    }
    const activeInputs = this[P_DEVICE].primaryInputMode === "controller" ? Object.values(this[P_DEVICE].controllers) : Object.values(this[P_DEVICE].hands);
    return activeInputs.filter((input) => input.connected);
  }
  get inputSources() {
    var _a2;
    if ((_a2 = this[P_DEVICE].actionPlayer) === null || _a2 === void 0 ? void 0 : _a2.playing) {
      return this[P_DEVICE].actionPlayer.inputSources;
    } else {
      return this.activeInputs.map((input) => input.inputSource);
    }
  }
  get canvasContainer() {
    return this[P_DEVICE].canvasContainer;
  }
  get canvasDimensions() {
    if (this[P_DEVICE].canvasData) {
      const { width, height } = this[P_DEVICE].canvasData.canvas;
      return { width, height };
    }
    return;
  }
  get activeSession() {
    var _a2;
    return (_a2 = this[P_DEVICE].xrSystem) === null || _a2 === void 0 ? void 0 : _a2[P_SYSTEM].activeSession;
  }
  get sessionOffered() {
    var _a2;
    return Boolean((_a2 = this[P_DEVICE].xrSystem) === null || _a2 === void 0 ? void 0 : _a2[P_SYSTEM].offeredSessionConfig);
  }
  get name() {
    return this[P_DEVICE].name;
  }
  grantOfferedSession() {
    const xrSystem = this[P_DEVICE].xrSystem;
    const pSystem = xrSystem === null || xrSystem === void 0 ? void 0 : xrSystem[P_SYSTEM];
    if (pSystem && pSystem.offeredSessionConfig) {
      const { resolve, reject, mode, options } = pSystem.offeredSessionConfig;
      pSystem.offeredSessionConfig = void 0;
      xrSystem.requestSession(mode, options).then(resolve).catch(reject);
    }
  }
  recenter() {
    const deltaVec = new Vector321(-this.position.x, 0, -this.position.z);
    const forward = new Vector321(0, 0, -1).applyQuaternion(this.quaternion);
    forward.y = 0;
    forward.normalize();
    const angle2 = Math.atan2(forward.x, -forward.z);
    const deltaQuat = new Quaternion15().setFromAxisAngle(new Vector321(0, 1, 0), angle2);
    this.position.add(deltaVec);
    this.quaternion.multiply(deltaQuat);
    [
      ...Object.values(this[P_DEVICE].controllers),
      ...Object.values(this[P_DEVICE].hands)
    ].forEach((activeInput) => {
      activeInput.position.add(deltaVec);
      activeInput.quaternion.multiply(deltaQuat);
      activeInput.position.applyQuaternion(deltaQuat);
    });
    this[P_DEVICE].pendingReferenceSpaceReset = true;
  }
  get visibilityState() {
    return this[P_DEVICE].visibilityState;
  }
  // visibility state updates are queued until the XRSession produces frames
  updateVisibilityState(state) {
    if (!Object.values(["visible", "visible-blurred", "hidden"]).includes(state)) {
      throw new DOMException("Invalid XRVisibilityState value", "NotSupportedError");
    }
    if (state !== this[P_DEVICE].visibilityState) {
      this[P_DEVICE].pendingVisibilityState = state;
    }
  }
  createActionPlayer(refSpace, recording) {
    this[P_DEVICE].actionPlayer = new ActionPlayer(refSpace, recording, this[P_DEVICE].ipd);
    return this[P_DEVICE].actionPlayer;
  }
  get devui() {
    return this[P_DEVICE].devui;
  }
  get sem() {
    return this[P_DEVICE].sem;
  }
};

// node_modules/iwer/lib/device/configs/controller/meta.js
var gamepadConfigLeft = {
  mapping: GamepadMappingType.XRStandard,
  buttons: [
    { id: "trigger", type: "analog", eventTrigger: "select" },
    { id: "squeeze", type: "analog", eventTrigger: "squeeze" },
    null,
    { id: "thumbstick", type: "binary" },
    { id: "x-button", type: "binary" },
    { id: "y-button", type: "binary" },
    { id: "thumbrest", type: "binary" }
  ],
  axes: [
    null,
    null,
    { id: "thumbstick", type: "x-axis" },
    { id: "thumbstick", type: "y-axis" }
  ]
};
var gamepadConfigRight = {
  mapping: GamepadMappingType.XRStandard,
  buttons: [
    { id: "trigger", type: "analog", eventTrigger: "select" },
    { id: "squeeze", type: "analog", eventTrigger: "squeeze" },
    null,
    { id: "thumbstick", type: "binary" },
    { id: "a-button", type: "binary" },
    { id: "b-button", type: "binary" },
    { id: "thumbrest", type: "binary" }
  ],
  axes: [
    null,
    null,
    { id: "thumbstick", type: "x-axis" },
    { id: "thumbstick", type: "y-axis" }
  ]
};
var oculusTouchV2 = {
  profileId: "oculus-touch-v2",
  fallbackProfileIds: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
  layout: {
    left: {
      gamepad: gamepadConfigLeft,
      gripOffsetMatrix: [
        0.9925461411476135,
        4673031295254759e-24,
        -0.12186938524246216,
        0,
        0.08617470413446426,
        0.7071065306663513,
        0.7018362283706665,
        0,
        0.0861746296286583,
        -0.70710688829422,
        0.7018358707427979,
        0,
        -0.003979847766458988,
        -0.01585787907242775,
        0.04964185878634453,
        1
      ],
      numHapticActuators: 1
    },
    right: {
      gamepad: gamepadConfigRight,
      gripOffsetMatrix: [
        0.9925461411476135,
        3688163374704345e-23,
        0.12186937034130096,
        0,
        -0.08617469668388367,
        0.7071066498756409,
        0.7018361687660217,
        0,
        -0.0861746147274971,
        -0.7071068286895752,
        0.7018359899520874,
        0,
        0.003979853354394436,
        -0.01585787907242775,
        0.04964182525873184,
        1
      ],
      numHapticActuators: 1
    }
  }
};
var oculusTouchV3 = {
  profileId: "oculus-touch-v3",
  fallbackProfileIds: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
  layout: {
    left: {
      gamepad: gamepadConfigLeft,
      gripOffsetMatrix: [
        0.9925461411476135,
        20823669899527886e-24,
        -0.12186937034130096,
        0,
        0.08617465198040009,
        0.7071067094802856,
        0.701836109161377,
        0,
        0.08617466688156128,
        -0.7071067690849304,
        0.7018360495567322,
        0,
        -0.003979838453233242,
        -0.015857907012104988,
        0.04964181408286095,
        1
      ],
      numHapticActuators: 1
    },
    right: {
      gamepad: gamepadConfigRight,
      gripOffsetMatrix: [
        0.9925461411476135,
        -8329467959811154e-23,
        0.12186941504478455,
        0,
        -0.08617465943098068,
        0.7071066498756409,
        0.7018361687660217,
        0,
        -0.08617471158504486,
        -0.7071068286895752,
        0.7018359303474426,
        0,
        0.003979798872023821,
        -0.015857888385653496,
        0.049641866236925125,
        1
      ],
      numHapticActuators: 1
    }
  }
};
var metaQuestTouchPro = {
  profileId: "meta-quest-touch-pro",
  fallbackProfileIds: [
    "oculus-touch-v2",
    "oculus-touch",
    "generic-trigger-squeeze-thumbstick"
  ],
  layout: {
    left: {
      gamepad: gamepadConfigLeft,
      gripOffsetMatrix: [
        0.9925461411476135,
        -15779937356796836e-24,
        -0.12186935544013977,
        0,
        0.08617467433214188,
        0.7071067094802856,
        0.701836109161377,
        0,
        0.0861746296286583,
        -0.7071067690849304,
        0.7018360495567322,
        0,
        -0.003979836590588093,
        -0.015857847407460213,
        0.049641840159893036,
        1
      ],
      numHapticActuators: 3
    },
    right: {
      gamepad: gamepadConfigRight,
      gripOffsetMatrix: [
        0.9925461411476135,
        9267653311439972e-26,
        0.12186937034130096,
        0,
        -0.08617467433214188,
        0.7071067094802856,
        0.7018361687660217,
        0,
        -0.08617464452981949,
        -0.7071067690849304,
        0.7018360495567322,
        0,
        0.003979847766458988,
        -0.01585782691836357,
        0.04964186251163483,
        1
      ],
      numHapticActuators: 3
    }
  }
};
var metaQuestTouchPlus = {
  profileId: "meta-quest-touch-plus",
  fallbackProfileIds: [
    "oculus-touch-v3",
    "oculus-touch",
    "generic-trigger-squeeze-thumbstick"
  ],
  layout: {
    left: {
      gamepad: gamepadConfigLeft,
      gripOffsetMatrix: [
        0.9925461411476135,
        10736208366779465e-24,
        -0.12186933308839798,
        0,
        0.08617459982633591,
        0.70710688829422,
        0.7018360495567322,
        0,
        0.08617466688156128,
        -0.7071067094802856,
        0.7018362283706665,
        0,
        -0.003979803062975407,
        -0.015857873484492302,
        0.04964187368750572,
        1
      ],
      numHapticActuators: 1
    },
    right: {
      gamepad: gamepadConfigRight,
      gripOffsetMatrix: [
        0.9925461411476135,
        -26238110351073374e-24,
        0.12186934053897858,
        0,
        -0.0861746147274971,
        0.7071067690849304,
        0.7018360495567322,
        0,
        -0.08617465943098068,
        -0.7071067094802856,
        0.701836109161377,
        0,
        0.003979838453233242,
        -0.015857869759202003,
        0.04964182525873184,
        1
      ],
      numHapticActuators: 1
    }
  }
};

// node_modules/iwer/lib/device/configs/headset/meta.js
var oculusQuest1 = {
  name: "Oculus Quest 1",
  controllerConfig: oculusTouchV2,
  supportedSessionModes: ["inline", "immersive-vr", "immersive-ar"],
  supportedFeatures: [
    "viewer",
    "local",
    "local-floor",
    "bounded-floor",
    "unbounded",
    "anchors",
    "plane-detection",
    "hand-tracking"
  ],
  supportedFrameRates: [72, 80, 90],
  isSystemKeyboardSupported: true,
  internalNominalFrameRate: 72,
  environmentBlendModes: {
    ["immersive-vr"]: XREnvironmentBlendMode.Opaque,
    ["immersive-ar"]: XREnvironmentBlendMode.AlphaBlend
  },
  interactionMode: XRInteractionMode.WorldSpace,
  userAgent: "Mozilla/5.0 (X11; Linux x86_64; Quest 1) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36"
};
var metaQuest2 = {
  name: "Meta Quest 2",
  controllerConfig: oculusTouchV3,
  supportedSessionModes: ["inline", "immersive-vr", "immersive-ar"],
  supportedFeatures: [
    "viewer",
    "local",
    "local-floor",
    "bounded-floor",
    "unbounded",
    "anchors",
    "plane-detection",
    "mesh-detection",
    "hit-test",
    "hand-tracking"
  ],
  supportedFrameRates: [72, 80, 90, 120],
  isSystemKeyboardSupported: true,
  internalNominalFrameRate: 72,
  environmentBlendModes: {
    ["immersive-vr"]: XREnvironmentBlendMode.Opaque,
    ["immersive-ar"]: XREnvironmentBlendMode.AlphaBlend
  },
  interactionMode: XRInteractionMode.WorldSpace,
  userAgent: "Mozilla/5.0 (X11; Linux x86_64; Quest 2) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36"
};
var metaQuestPro = {
  name: "Meta Quest Pro",
  controllerConfig: metaQuestTouchPro,
  supportedSessionModes: ["inline", "immersive-vr", "immersive-ar"],
  supportedFeatures: [
    "viewer",
    "local",
    "local-floor",
    "bounded-floor",
    "unbounded",
    "anchors",
    "plane-detection",
    "mesh-detection",
    "hit-test",
    "hand-tracking"
  ],
  supportedFrameRates: [72, 80, 90, 120],
  isSystemKeyboardSupported: true,
  internalNominalFrameRate: 90,
  environmentBlendModes: {
    ["immersive-vr"]: XREnvironmentBlendMode.Opaque,
    ["immersive-ar"]: XREnvironmentBlendMode.AlphaBlend
  },
  interactionMode: XRInteractionMode.WorldSpace,
  userAgent: "Mozilla/5.0 (X11; Linux x86_64; Quest Pro) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36"
};
var metaQuest3 = {
  name: "Meta Quest 3",
  controllerConfig: metaQuestTouchPlus,
  supportedSessionModes: ["inline", "immersive-vr", "immersive-ar"],
  supportedFeatures: [
    "viewer",
    "local",
    "local-floor",
    "bounded-floor",
    "unbounded",
    "anchors",
    "plane-detection",
    "mesh-detection",
    "hit-test",
    "hand-tracking",
    "depth-sensing"
  ],
  supportedFrameRates: [72, 80, 90, 120],
  isSystemKeyboardSupported: true,
  internalNominalFrameRate: 90,
  environmentBlendModes: {
    ["immersive-vr"]: XREnvironmentBlendMode.Opaque,
    ["immersive-ar"]: XREnvironmentBlendMode.AlphaBlend
  },
  interactionMode: XRInteractionMode.WorldSpace,
  userAgent: "Mozilla/5.0 (X11; Linux x86_64; Quest 3) AppleWebKit/537.36 (KHTML, like Gecko) OculusBrowser/33.0.0.x.x.x Chrome/126.0.6478.122 VR Safari/537.36"
};

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo2, hi, bytes) {
  for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
    const shift = lo2 >>> i2;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo2 >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
    const shift = hi >>> i2;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin2, end2) {
    const digit1e6 = Number(dec.slice(begin2, end2));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate3(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo2, hi) {
  let bits = newBits(lo2, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate3(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo2, hi) {
  ({ lo: lo2, hi } = toUnsigned(lo2, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo2);
  }
  const low = lo2 & 16777215;
  const mid = (lo2 >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo2, hi) {
  return { lo: lo2 >>> 0, hi: hi >>> 0 };
}
function newBits(lo2, hi) {
  return { lo: lo2 | 0, hi: hi | 0 };
}
function negate3(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i2 = 0; i2 < 9; i2++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo2, hi) {
        dv.setInt32(0, lo2, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo2, hi) {
        dv.setInt32(0, lo2, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo2, hi) {
      return int64ToString(lo2, hi);
    },
    uDec(lo2, hi) {
      return uInt64ToString(lo2, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te2 = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text2) {
        return te2.encode(text2);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text2) {
        try {
          encodeURIComponent(text2);
          return true;
        } catch (_2) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
var BinaryWriter = class {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len4 = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++)
      len4 += this.chunks[i2].length;
    let bytes = new Uint8Array(len4);
    let offset = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++) {
      bytes.set(this.chunks[i2], offset);
      offset += this.chunks[i2].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev2 = this.stack.pop();
    if (!prev2)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev2.chunks;
    this.buf = prev2.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo2 = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo2, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    const tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len4 = this.uint32();
        this.pos += len4;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo2, hi] = this.varint64();
    let s2 = -(lo2 & 1);
    lo2 = (lo2 >>> 1 | (hi & 1) << 31) ^ s2;
    hi = hi >>> 1 ^ s2;
    return protoInt64.dec(lo2, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo2, hi] = this.varint64();
    return lo2 !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len4 = this.uint32(), start = this.pos;
    this.pos += len4;
    this.assertBounds();
    return this.buf.subarray(start, start + len4);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
};
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o3 = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o3 !== "NaN") {
      throw new Error("invalid float32: " + o3);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/descriptors.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js
var unsafeLocal = Symbol.for("reflect unsafe local");

// node_modules/@bufbuild/protobuf/dist/esm/create.js
var tokenZeroMessageField = Symbol();

// node_modules/@iwer/sem/lib/generated/protos/openxr_core.js
function createBaseVector2() {
  return { x: 0, y: 0 };
}
var Vector26 = {
  encode(message, writer = new BinaryWriter()) {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseVector2();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },
  create(base) {
    return Vector26.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseVector2();
    message.x = (_a2 = object.x) !== null && _a2 !== void 0 ? _a2 : 0;
    message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseExtent2() {
  return { width: 0, height: 0 };
}
var Extent2 = {
  encode(message, writer = new BinaryWriter()) {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseExtent2();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.width = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.height = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },
  create(base) {
    return Extent2.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseExtent2();
    message.width = (_a2 = object.width) !== null && _a2 !== void 0 ? _a2 : 0;
    message.height = (_b = object.height) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseVector3() {
  return { x: 0, y: 0, z: 0 };
}
var Vector322 = {
  encode(message, writer = new BinaryWriter()) {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseVector3();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },
  create(base) {
    return Vector322.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseVector3();
    message.x = (_a2 = object.x) !== null && _a2 !== void 0 ? _a2 : 0;
    message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;
    message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseExtent3() {
  return { width: 0, height: 0, depth: 0 };
}
var Extent3 = {
  encode(message, writer = new BinaryWriter()) {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    if (message.depth !== 0) {
      writer.uint32(29).float(message.depth);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseExtent3();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.width = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.height = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.depth = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.depth !== 0) {
      obj.depth = message.depth;
    }
    return obj;
  },
  create(base) {
    return Extent3.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseExtent3();
    message.width = (_a2 = object.width) !== null && _a2 !== void 0 ? _a2 : 0;
    message.height = (_b = object.height) !== null && _b !== void 0 ? _b : 0;
    message.depth = (_c = object.depth) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseQuaternion() {
  return { x: 0, y: 0, z: 0, w: 0 };
}
var Quaternion16 = {
  encode(message, writer = new BinaryWriter()) {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseQuaternion();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.z = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }
          message.w = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },
  create(base) {
    return Quaternion16.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseQuaternion();
    message.x = (_a2 = object.x) !== null && _a2 !== void 0 ? _a2 : 0;
    message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;
    message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;
    message.w = (_d = object.w) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};
function createBaseRect2D() {
  return { offset: void 0, extent: void 0 };
}
var Rect2D = {
  encode(message, writer = new BinaryWriter()) {
    if (message.offset !== void 0) {
      Vector26.encode(message.offset, writer.uint32(10).fork()).join();
    }
    if (message.extent !== void 0) {
      Extent2.encode(message.extent, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseRect2D();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.offset = Vector26.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extent = Extent2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      offset: isSet(object.offset) ? Vector26.fromJSON(object.offset) : void 0,
      extent: isSet(object.extent) ? Extent2.fromJSON(object.extent) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.offset !== void 0) {
      obj.offset = Vector26.toJSON(message.offset);
    }
    if (message.extent !== void 0) {
      obj.extent = Extent2.toJSON(message.extent);
    }
    return obj;
  },
  create(base) {
    return Rect2D.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseRect2D();
    message.offset = object.offset !== void 0 && object.offset !== null ? Vector26.fromPartial(object.offset) : void 0;
    message.extent = object.extent !== void 0 && object.extent !== null ? Extent2.fromPartial(object.extent) : void 0;
    return message;
  }
};
function createBaseRect3D() {
  return { offset: void 0, extent: void 0 };
}
var Rect3D = {
  encode(message, writer = new BinaryWriter()) {
    if (message.offset !== void 0) {
      Vector322.encode(message.offset, writer.uint32(10).fork()).join();
    }
    if (message.extent !== void 0) {
      Extent3.encode(message.extent, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseRect3D();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.offset = Vector322.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extent = Extent3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      offset: isSet(object.offset) ? Vector322.fromJSON(object.offset) : void 0,
      extent: isSet(object.extent) ? Extent3.fromJSON(object.extent) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.offset !== void 0) {
      obj.offset = Vector322.toJSON(message.offset);
    }
    if (message.extent !== void 0) {
      obj.extent = Extent3.toJSON(message.extent);
    }
    return obj;
  },
  create(base) {
    return Rect3D.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseRect3D();
    message.offset = object.offset !== void 0 && object.offset !== null ? Vector322.fromPartial(object.offset) : void 0;
    message.extent = object.extent !== void 0 && object.extent !== null ? Extent3.fromPartial(object.extent) : void 0;
    return message;
  }
};
function createBasePose() {
  return { orientation: void 0, position: void 0 };
}
var Pose = {
  encode(message, writer = new BinaryWriter()) {
    if (message.orientation !== void 0) {
      Quaternion16.encode(message.orientation, writer.uint32(10).fork()).join();
    }
    if (message.position !== void 0) {
      Vector322.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBasePose();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.orientation = Quaternion16.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.position = Vector322.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      orientation: isSet(object.orientation) ? Quaternion16.fromJSON(object.orientation) : void 0,
      position: isSet(object.position) ? Vector322.fromJSON(object.position) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.orientation !== void 0) {
      obj.orientation = Quaternion16.toJSON(message.orientation);
    }
    if (message.position !== void 0) {
      obj.position = Vector322.toJSON(message.position);
    }
    return obj;
  },
  create(base) {
    return Pose.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBasePose();
    message.orientation = object.orientation !== void 0 && object.orientation !== null ? Quaternion16.fromPartial(object.orientation) : void 0;
    message.position = object.position !== void 0 && object.position !== null ? Vector322.fromPartial(object.position) : void 0;
    return message;
  }
};
function isSet(value) {
  return value !== null && value !== void 0;
}

// node_modules/@iwer/sem/lib/generated/protos/openxr_scene.js
var DynamicObjectTypeMETA;
(function(DynamicObjectTypeMETA2) {
  DynamicObjectTypeMETA2[DynamicObjectTypeMETA2["Keyboard"] = 0] = "Keyboard";
  DynamicObjectTypeMETA2[DynamicObjectTypeMETA2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DynamicObjectTypeMETA || (DynamicObjectTypeMETA = {}));
function dynamicObjectTypeMETAFromJSON(object) {
  switch (object) {
    case 0:
    case "Keyboard":
      return DynamicObjectTypeMETA.Keyboard;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DynamicObjectTypeMETA.UNRECOGNIZED;
  }
}
function dynamicObjectTypeMETAToJSON(object) {
  switch (object) {
    case DynamicObjectTypeMETA.Keyboard:
      return "Keyboard";
    case DynamicObjectTypeMETA.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var SemanticLabelMETA;
(function(SemanticLabelMETA2) {
  SemanticLabelMETA2[SemanticLabelMETA2["UNKNOWN"] = 0] = "UNKNOWN";
  SemanticLabelMETA2[SemanticLabelMETA2["FLOOR"] = 1] = "FLOOR";
  SemanticLabelMETA2[SemanticLabelMETA2["CEILING"] = 2] = "CEILING";
  SemanticLabelMETA2[SemanticLabelMETA2["WALL_FACE"] = 3] = "WALL_FACE";
  SemanticLabelMETA2[SemanticLabelMETA2["TABLE"] = 4] = "TABLE";
  SemanticLabelMETA2[SemanticLabelMETA2["COUCH"] = 5] = "COUCH";
  SemanticLabelMETA2[SemanticLabelMETA2["DOOR_FRAME"] = 6] = "DOOR_FRAME";
  SemanticLabelMETA2[SemanticLabelMETA2["WINDOW_FRAME"] = 7] = "WINDOW_FRAME";
  SemanticLabelMETA2[SemanticLabelMETA2["OTHER"] = 8] = "OTHER";
  SemanticLabelMETA2[SemanticLabelMETA2["STORAGE"] = 9] = "STORAGE";
  SemanticLabelMETA2[SemanticLabelMETA2["BED"] = 10] = "BED";
  SemanticLabelMETA2[SemanticLabelMETA2["SCREEN"] = 11] = "SCREEN";
  SemanticLabelMETA2[SemanticLabelMETA2["LAMP"] = 12] = "LAMP";
  SemanticLabelMETA2[SemanticLabelMETA2["PLANT"] = 13] = "PLANT";
  SemanticLabelMETA2[SemanticLabelMETA2["WALL_ART"] = 14] = "WALL_ART";
  SemanticLabelMETA2[SemanticLabelMETA2["GLOBAL_MESH"] = 15] = "GLOBAL_MESH";
  SemanticLabelMETA2[SemanticLabelMETA2["INVISIBLE_WALL_FACE"] = 16] = "INVISIBLE_WALL_FACE";
  SemanticLabelMETA2[SemanticLabelMETA2["CHAIR"] = 17] = "CHAIR";
  SemanticLabelMETA2[SemanticLabelMETA2["INNER_WALL_FACE"] = 18] = "INNER_WALL_FACE";
  SemanticLabelMETA2[SemanticLabelMETA2["OTHER_ROOM_FACE"] = 19] = "OTHER_ROOM_FACE";
  SemanticLabelMETA2[SemanticLabelMETA2["OPENING"] = 20] = "OPENING";
  SemanticLabelMETA2[SemanticLabelMETA2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SemanticLabelMETA || (SemanticLabelMETA = {}));
function semanticLabelMETAFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return SemanticLabelMETA.UNKNOWN;
    case 1:
    case "FLOOR":
      return SemanticLabelMETA.FLOOR;
    case 2:
    case "CEILING":
      return SemanticLabelMETA.CEILING;
    case 3:
    case "WALL_FACE":
      return SemanticLabelMETA.WALL_FACE;
    case 4:
    case "TABLE":
      return SemanticLabelMETA.TABLE;
    case 5:
    case "COUCH":
      return SemanticLabelMETA.COUCH;
    case 6:
    case "DOOR_FRAME":
      return SemanticLabelMETA.DOOR_FRAME;
    case 7:
    case "WINDOW_FRAME":
      return SemanticLabelMETA.WINDOW_FRAME;
    case 8:
    case "OTHER":
      return SemanticLabelMETA.OTHER;
    case 9:
    case "STORAGE":
      return SemanticLabelMETA.STORAGE;
    case 10:
    case "BED":
      return SemanticLabelMETA.BED;
    case 11:
    case "SCREEN":
      return SemanticLabelMETA.SCREEN;
    case 12:
    case "LAMP":
      return SemanticLabelMETA.LAMP;
    case 13:
    case "PLANT":
      return SemanticLabelMETA.PLANT;
    case 14:
    case "WALL_ART":
      return SemanticLabelMETA.WALL_ART;
    case 15:
    case "GLOBAL_MESH":
      return SemanticLabelMETA.GLOBAL_MESH;
    case 16:
    case "INVISIBLE_WALL_FACE":
      return SemanticLabelMETA.INVISIBLE_WALL_FACE;
    case 17:
    case "CHAIR":
      return SemanticLabelMETA.CHAIR;
    case 18:
    case "INNER_WALL_FACE":
      return SemanticLabelMETA.INNER_WALL_FACE;
    case 19:
    case "OTHER_ROOM_FACE":
      return SemanticLabelMETA.OTHER_ROOM_FACE;
    case 20:
    case "OPENING":
      return SemanticLabelMETA.OPENING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SemanticLabelMETA.UNRECOGNIZED;
  }
}
function semanticLabelMETAToJSON(object) {
  switch (object) {
    case SemanticLabelMETA.UNKNOWN:
      return "UNKNOWN";
    case SemanticLabelMETA.FLOOR:
      return "FLOOR";
    case SemanticLabelMETA.CEILING:
      return "CEILING";
    case SemanticLabelMETA.WALL_FACE:
      return "WALL_FACE";
    case SemanticLabelMETA.TABLE:
      return "TABLE";
    case SemanticLabelMETA.COUCH:
      return "COUCH";
    case SemanticLabelMETA.DOOR_FRAME:
      return "DOOR_FRAME";
    case SemanticLabelMETA.WINDOW_FRAME:
      return "WINDOW_FRAME";
    case SemanticLabelMETA.OTHER:
      return "OTHER";
    case SemanticLabelMETA.STORAGE:
      return "STORAGE";
    case SemanticLabelMETA.BED:
      return "BED";
    case SemanticLabelMETA.SCREEN:
      return "SCREEN";
    case SemanticLabelMETA.LAMP:
      return "LAMP";
    case SemanticLabelMETA.PLANT:
      return "PLANT";
    case SemanticLabelMETA.WALL_ART:
      return "WALL_ART";
    case SemanticLabelMETA.GLOBAL_MESH:
      return "GLOBAL_MESH";
    case SemanticLabelMETA.INVISIBLE_WALL_FACE:
      return "INVISIBLE_WALL_FACE";
    case SemanticLabelMETA.CHAIR:
      return "CHAIR";
    case SemanticLabelMETA.INNER_WALL_FACE:
      return "INNER_WALL_FACE";
    case SemanticLabelMETA.OTHER_ROOM_FACE:
      return "OTHER_ROOM_FACE";
    case SemanticLabelMETA.OPENING:
      return "OPENING";
    case SemanticLabelMETA.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseRoomLayoutMETA() {
  return { floorUuid: "", ceilingUuid: "", wallUuids: [] };
}
var RoomLayoutMETA = {
  encode(message, writer = new BinaryWriter()) {
    if (message.floorUuid !== "") {
      writer.uint32(10).string(message.floorUuid);
    }
    if (message.ceilingUuid !== "") {
      writer.uint32(18).string(message.ceilingUuid);
    }
    for (const v2 of message.wallUuids) {
      writer.uint32(26).string(v2);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseRoomLayoutMETA();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.floorUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.ceilingUuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.wallUuids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      floorUuid: isSet2(object.floorUuid) ? globalThis.String(object.floorUuid) : "",
      ceilingUuid: isSet2(object.ceilingUuid) ? globalThis.String(object.ceilingUuid) : "",
      wallUuids: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.wallUuids) ? object.wallUuids.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    var _a2;
    const obj = {};
    if (message.floorUuid !== "") {
      obj.floorUuid = message.floorUuid;
    }
    if (message.ceilingUuid !== "") {
      obj.ceilingUuid = message.ceilingUuid;
    }
    if ((_a2 = message.wallUuids) === null || _a2 === void 0 ? void 0 : _a2.length) {
      obj.wallUuids = message.wallUuids;
    }
    return obj;
  },
  create(base) {
    return RoomLayoutMETA.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseRoomLayoutMETA();
    message.floorUuid = (_a2 = object.floorUuid) !== null && _a2 !== void 0 ? _a2 : "";
    message.ceilingUuid = (_b = object.ceilingUuid) !== null && _b !== void 0 ? _b : "";
    message.wallUuids = ((_c = object.wallUuids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
    return message;
  }
};
function createBaseSpaceContainerMETA() {
  return { uuids: [] };
}
var SpaceContainerMETA = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.uuids) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseSpaceContainerMETA();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.uuids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      uuids: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.uuids) ? object.uuids.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    var _a2;
    const obj = {};
    if ((_a2 = message.uuids) === null || _a2 === void 0 ? void 0 : _a2.length) {
      obj.uuids = message.uuids;
    }
    return obj;
  },
  create(base) {
    return SpaceContainerMETA.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseSpaceContainerMETA();
    message.uuids = ((_a2 = object.uuids) === null || _a2 === void 0 ? void 0 : _a2.map((e) => e)) || [];
    return message;
  }
};
function createBaseBoundary2DMETA() {
  return { vertices: new Uint8Array(0) };
}
var Boundary2DMETA = {
  encode(message, writer = new BinaryWriter()) {
    if (message.vertices.length !== 0) {
      writer.uint32(10).bytes(message.vertices);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseBoundary2DMETA();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.vertices = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      vertices: isSet2(object.vertices) ? bytesFromBase64(object.vertices) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.vertices.length !== 0) {
      obj.vertices = base64FromBytes(message.vertices);
    }
    return obj;
  },
  create(base) {
    return Boundary2DMETA.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseBoundary2DMETA();
    message.vertices = (_a2 = object.vertices) !== null && _a2 !== void 0 ? _a2 : new Uint8Array(0);
    return message;
  }
};
function createBaseTriangleMeshMETA() {
  return { vertices: new Uint8Array(0), indices: new Uint8Array(0) };
}
var TriangleMeshMETA = {
  encode(message, writer = new BinaryWriter()) {
    if (message.vertices.length !== 0) {
      writer.uint32(10).bytes(message.vertices);
    }
    if (message.indices.length !== 0) {
      writer.uint32(18).bytes(message.indices);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseTriangleMeshMETA();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.vertices = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.indices = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      vertices: isSet2(object.vertices) ? bytesFromBase64(object.vertices) : new Uint8Array(0),
      indices: isSet2(object.indices) ? bytesFromBase64(object.indices) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.vertices.length !== 0) {
      obj.vertices = base64FromBytes(message.vertices);
    }
    if (message.indices.length !== 0) {
      obj.indices = base64FromBytes(message.indices);
    }
    return obj;
  },
  create(base) {
    return TriangleMeshMETA.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseTriangleMeshMETA();
    message.vertices = (_a2 = object.vertices) !== null && _a2 !== void 0 ? _a2 : new Uint8Array(0);
    message.indices = (_b = object.indices) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    return message;
  }
};
function createBaseDynamicObjectMETA() {
  return { classType: 0 };
}
var DynamicObjectMETA = {
  encode(message, writer = new BinaryWriter()) {
    if (message.classType !== 0) {
      writer.uint32(8).int32(message.classType);
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseDynamicObjectMETA();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.classType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      classType: isSet2(object.classType) ? dynamicObjectTypeMETAFromJSON(object.classType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.classType !== 0) {
      obj.classType = dynamicObjectTypeMETAToJSON(message.classType);
    }
    return obj;
  },
  create(base) {
    return DynamicObjectMETA.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseDynamicObjectMETA();
    message.classType = (_a2 = object.classType) !== null && _a2 !== void 0 ? _a2 : 0;
    return message;
  }
};
function createBaseSpatialEntity() {
  return {
    uuid: "",
    semanticLabel_META: void 0,
    locatable_META: void 0,
    boundary2D_META: void 0,
    bounded2D_META: void 0,
    bounded3D_META: void 0,
    roomLayout_META: void 0,
    spaceContainer_META: void 0,
    triangleMesh_META: void 0,
    dynamicObject_META: void 0
  };
}
var SpatialEntity = {
  encode(message, writer = new BinaryWriter()) {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.semanticLabel_META !== void 0) {
      writer.uint32(16).int32(message.semanticLabel_META);
    }
    if (message.locatable_META !== void 0) {
      Pose.encode(message.locatable_META, writer.uint32(26).fork()).join();
    }
    if (message.boundary2D_META !== void 0) {
      Boundary2DMETA.encode(message.boundary2D_META, writer.uint32(34).fork()).join();
    }
    if (message.bounded2D_META !== void 0) {
      Rect2D.encode(message.bounded2D_META, writer.uint32(42).fork()).join();
    }
    if (message.bounded3D_META !== void 0) {
      Rect3D.encode(message.bounded3D_META, writer.uint32(50).fork()).join();
    }
    if (message.roomLayout_META !== void 0) {
      RoomLayoutMETA.encode(message.roomLayout_META, writer.uint32(58).fork()).join();
    }
    if (message.spaceContainer_META !== void 0) {
      SpaceContainerMETA.encode(message.spaceContainer_META, writer.uint32(66).fork()).join();
    }
    if (message.triangleMesh_META !== void 0) {
      TriangleMeshMETA.encode(message.triangleMesh_META, writer.uint32(74).fork()).join();
    }
    if (message.dynamicObject_META !== void 0) {
      DynamicObjectMETA.encode(message.dynamicObject_META, writer.uint32(82).fork()).join();
    }
    return writer;
  },
  decode(input, length5) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end2 = length5 === void 0 ? reader.len : reader.pos + length5;
    const message = createBaseSpatialEntity();
    while (reader.pos < end2) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.semanticLabel_META = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.locatable_META = Pose.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.boundary2D_META = Boundary2DMETA.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.bounded2D_META = Rect2D.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.bounded3D_META = Rect3D.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.roomLayout_META = RoomLayoutMETA.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.spaceContainer_META = SpaceContainerMETA.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.triangleMesh_META = TriangleMeshMETA.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.dynamicObject_META = DynamicObjectMETA.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      uuid: isSet2(object.uuid) ? globalThis.String(object.uuid) : "",
      semanticLabel_META: isSet2(object.semanticLabel_META) ? semanticLabelMETAFromJSON(object.semanticLabel_META) : void 0,
      locatable_META: isSet2(object.locatable_META) ? Pose.fromJSON(object.locatable_META) : void 0,
      boundary2D_META: isSet2(object.boundary2D_META) ? Boundary2DMETA.fromJSON(object.boundary2D_META) : void 0,
      bounded2D_META: isSet2(object.bounded2D_META) ? Rect2D.fromJSON(object.bounded2D_META) : void 0,
      bounded3D_META: isSet2(object.bounded3D_META) ? Rect3D.fromJSON(object.bounded3D_META) : void 0,
      roomLayout_META: isSet2(object.roomLayout_META) ? RoomLayoutMETA.fromJSON(object.roomLayout_META) : void 0,
      spaceContainer_META: isSet2(object.spaceContainer_META) ? SpaceContainerMETA.fromJSON(object.spaceContainer_META) : void 0,
      triangleMesh_META: isSet2(object.triangleMesh_META) ? TriangleMeshMETA.fromJSON(object.triangleMesh_META) : void 0,
      dynamicObject_META: isSet2(object.dynamicObject_META) ? DynamicObjectMETA.fromJSON(object.dynamicObject_META) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.semanticLabel_META !== void 0) {
      obj.semanticLabel_META = semanticLabelMETAToJSON(message.semanticLabel_META);
    }
    if (message.locatable_META !== void 0) {
      obj.locatable_META = Pose.toJSON(message.locatable_META);
    }
    if (message.boundary2D_META !== void 0) {
      obj.boundary2D_META = Boundary2DMETA.toJSON(message.boundary2D_META);
    }
    if (message.bounded2D_META !== void 0) {
      obj.bounded2D_META = Rect2D.toJSON(message.bounded2D_META);
    }
    if (message.bounded3D_META !== void 0) {
      obj.bounded3D_META = Rect3D.toJSON(message.bounded3D_META);
    }
    if (message.roomLayout_META !== void 0) {
      obj.roomLayout_META = RoomLayoutMETA.toJSON(message.roomLayout_META);
    }
    if (message.spaceContainer_META !== void 0) {
      obj.spaceContainer_META = SpaceContainerMETA.toJSON(message.spaceContainer_META);
    }
    if (message.triangleMesh_META !== void 0) {
      obj.triangleMesh_META = TriangleMeshMETA.toJSON(message.triangleMesh_META);
    }
    if (message.dynamicObject_META !== void 0) {
      obj.dynamicObject_META = DynamicObjectMETA.toJSON(message.dynamicObject_META);
    }
    return obj;
  },
  create(base) {
    return SpatialEntity.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSpatialEntity();
    message.uuid = (_a2 = object.uuid) !== null && _a2 !== void 0 ? _a2 : "";
    message.semanticLabel_META = (_b = object.semanticLabel_META) !== null && _b !== void 0 ? _b : void 0;
    message.locatable_META = object.locatable_META !== void 0 && object.locatable_META !== null ? Pose.fromPartial(object.locatable_META) : void 0;
    message.boundary2D_META = object.boundary2D_META !== void 0 && object.boundary2D_META !== null ? Boundary2DMETA.fromPartial(object.boundary2D_META) : void 0;
    message.bounded2D_META = object.bounded2D_META !== void 0 && object.bounded2D_META !== null ? Rect2D.fromPartial(object.bounded2D_META) : void 0;
    message.bounded3D_META = object.bounded3D_META !== void 0 && object.bounded3D_META !== null ? Rect3D.fromPartial(object.bounded3D_META) : void 0;
    message.roomLayout_META = object.roomLayout_META !== void 0 && object.roomLayout_META !== null ? RoomLayoutMETA.fromPartial(object.roomLayout_META) : void 0;
    message.spaceContainer_META = object.spaceContainer_META !== void 0 && object.spaceContainer_META !== null ? SpaceContainerMETA.fromPartial(object.spaceContainer_META) : void 0;
    message.triangleMesh_META = object.triangleMesh_META !== void 0 && object.triangleMesh_META !== null ? TriangleMeshMETA.fromPartial(object.triangleMesh_META) : void 0;
    message.dynamicObject_META = object.dynamicObject_META !== void 0 && object.dynamicObject_META !== null ? DynamicObjectMETA.fromPartial(object.dynamicObject_META) : void 0;
    return message;
  }
};
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// node_modules/@iwer/sem/lib/native/components/component.js
var SpatialEntityComponentType;
(function(SpatialEntityComponentType2) {
  SpatialEntityComponentType2["Locatable"] = "locatable";
  SpatialEntityComponentType2["Bounded3D"] = "bounded3D";
  SpatialEntityComponentType2["Bounded2D"] = "bounded2D";
  SpatialEntityComponentType2["TriangleMesh"] = "triangleMesh";
  SpatialEntityComponentType2["SemanticLabel"] = "semanticLabel";
})(SpatialEntityComponentType || (SpatialEntityComponentType = {}));
var SpatialEntityComponent = class extends EventTarget {
  constructor(_spatialEntity) {
    super();
    this._spatialEntity = _spatialEntity;
  }
};

// node_modules/@iwer/sem/lib/native/components/bounded2d.js
import { PlaneGeometry, Vector2 as Vector27 } from "three";
var Bounded2DComponent = class extends SpatialEntityComponent {
  constructor(spatialEntity, initData) {
    super(spatialEntity);
    this._offset = new Vector27();
    this._extent = new Vector27();
    this.type = SpatialEntityComponentType.Bounded2D;
    const { offset, extent } = initData;
    this._offset.set(offset.x, offset.y);
    this._extent.set(extent.width, extent.height);
    this.buildGeometry();
  }
  buildGeometry() {
    var _a2;
    const geometry2 = new PlaneGeometry(this._extent.x, this._extent.y);
    geometry2.translate(this._offset.x + this._extent.x / 2, this._offset.y + this._extent.y / 2, 0);
    geometry2.rotateX(Math.PI / 2);
    (_a2 = this._spatialEntity.geometry) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this._spatialEntity.geometry = geometry2;
  }
  get offset() {
    return this._offset;
  }
  get extent() {
    return this._extent;
  }
  get initData() {
    return {
      offset: this.offset,
      extent: this.extent
    };
  }
  get pbData() {
    return {
      offset: { x: this._offset.x, y: this._offset.y },
      extent: { width: this._extent.x, height: this._extent.y }
    };
  }
};

// node_modules/@iwer/sem/lib/native/components/bounded3d.js
import { BoxGeometry as BoxGeometry5, Vector3 as Vector323 } from "three";
var Bounded3DComponent = class extends SpatialEntityComponent {
  constructor(spatialEntity, initData) {
    super(spatialEntity);
    this._offset = new Vector323();
    this._extent = new Vector323();
    this.type = SpatialEntityComponentType.Bounded3D;
    const { offset, extent } = initData;
    this._offset.set(offset.x, offset.y, offset.z);
    this._extent.set(extent.width, extent.height, extent.depth);
    this.buildGeometry();
  }
  buildGeometry() {
    var _a2;
    const geometry2 = new BoxGeometry5(this._extent.x, this._extent.y, this._extent.z);
    geometry2.translate(this._offset.x + this._extent.x / 2, this._offset.y + this._extent.y / 2, this._offset.z + this._extent.z / 2);
    (_a2 = this._spatialEntity.geometry) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this._spatialEntity.geometry = geometry2;
  }
  get offset() {
    return this._offset;
  }
  get extent() {
    return this._extent;
  }
  get initData() {
    return {
      offset: this.offset,
      extent: this.extent
    };
  }
  get pbData() {
    return {
      offset: { x: this._offset.x, y: this._offset.y, z: this._offset.z },
      extent: {
        width: this._extent.x,
        height: this._extent.y,
        depth: this._extent.z
      }
    };
  }
};

// node_modules/@iwer/sem/lib/native/components/locatable.js
var LocatableComponent = class extends SpatialEntityComponent {
  constructor(spatialEntity, initData) {
    super(spatialEntity);
    this.type = SpatialEntityComponentType.Locatable;
    if (initData.position) {
      this.position.copy(initData.position);
    }
    if (initData.orientation) {
      this.orientation.copy(initData.orientation);
    }
  }
  get position() {
    return this._spatialEntity.position;
  }
  get rotation() {
    return this._spatialEntity.rotation;
  }
  get orientation() {
    return this._spatialEntity.quaternion;
  }
  get initData() {
    return {
      position: {
        x: this.position.x,
        y: this.position.y,
        z: this.position.z
      },
      orientation: {
        x: this.orientation.x,
        y: this.orientation.y,
        z: this.orientation.z,
        w: this.orientation.w
      }
    };
  }
  get pbData() {
    return {
      position: {
        x: this._spatialEntity.position.x,
        y: this._spatialEntity.position.y,
        z: this._spatialEntity.position.z
      },
      orientation: {
        x: this._spatialEntity.quaternion.x,
        y: this._spatialEntity.quaternion.y,
        z: this._spatialEntity.quaternion.z,
        w: this._spatialEntity.quaternion.w
      }
    };
  }
};

// node_modules/@iwer/sem/lib/native/components/semanticlabel.js
function convertToReadableString(str5) {
  return str5.toLowerCase().replace(/_/g, " ").trim();
}
var SemanticLabelComponent = class extends SpatialEntityComponent {
  constructor(spatialEntity, _semanticLabel) {
    super(spatialEntity);
    this._semanticLabel = _semanticLabel;
    this.type = SpatialEntityComponentType.SemanticLabel;
    this._spatialEntity.name = convertToReadableString(semanticLabelMETAToJSON(_semanticLabel));
  }
  get semanticLabel() {
    return this._semanticLabel;
  }
  set semanticLabel(value) {
    if (Object.values(SemanticLabelMETA).includes(value)) {
      this._semanticLabel = value;
    } else {
      this._semanticLabel = SemanticLabelMETA.UNRECOGNIZED;
    }
    this._spatialEntity.name = convertToReadableString(semanticLabelMETAToJSON(this._semanticLabel));
  }
  get initData() {
    return this._semanticLabel;
  }
  get pbData() {
    return this._semanticLabel;
  }
};

// node_modules/@iwer/sem/lib/native/components/trianglemesh.js
import { BufferAttribute, BufferGeometry as BufferGeometry3 } from "three";
function vec3ArrayToFloat32Array(arr) {
  const result = new Float32Array(arr.length * 3);
  let index = 0;
  for (const vec of arr) {
    result[index++] = vec.x;
    result[index++] = vec.y;
    result[index++] = vec.z;
  }
  return result;
}
var TriangleMeshComponent = class extends SpatialEntityComponent {
  constructor(spatialEntity, initData) {
    super(spatialEntity);
    this._polygonCount = 0;
    this._vertexCount = 0;
    this._dimensions = { x: 0, y: 0, z: 0 };
    this.type = SpatialEntityComponentType.TriangleMesh;
    const { vertices, indices } = initData;
    const verticesArray = new Float32Array(vertices.buffer);
    const indicesArray = new Uint32Array(indices.buffer);
    const vec3Array = [];
    for (let i2 = 0; i2 < verticesArray.length / 3; i2++) {
      vec3Array.push({
        x: verticesArray[3 * i2],
        y: verticesArray[3 * i2 + 1],
        z: verticesArray[3 * i2 + 2]
      });
    }
    this._vertices = vec3Array;
    this._indices = [...indicesArray];
    this.buildGeometry();
    const material = spatialEntity.material;
    material.polygonOffset = true;
    material.polygonOffsetFactor = 1;
    material.polygonOffsetUnits = 5e-3;
    material.color.setHex(13948116);
    spatialEntity.renderOrder = 999;
  }
  buildGeometry() {
    var _a2;
    const geometry2 = new BufferGeometry3();
    const vertices = vec3ArrayToFloat32Array(this._vertices);
    geometry2.setAttribute("position", new BufferAttribute(vertices, 3));
    geometry2.setIndex(new BufferAttribute(new Uint16Array(this._indices), 1));
    (_a2 = this._spatialEntity.geometry) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this._spatialEntity.geometry = geometry2;
    geometry2.computeVertexNormals();
    this._vertexCount = geometry2.attributes.position.count;
    this._polygonCount = geometry2.index ? geometry2.index.count / 3 : this._vertexCount / 3;
    geometry2.computeBoundingBox();
    const boundingBox = geometry2.boundingBox;
    this._dimensions = {
      x: boundingBox.max.x - boundingBox.min.x,
      y: boundingBox.max.y - boundingBox.min.y,
      z: boundingBox.max.z - boundingBox.min.z
    };
  }
  get vertexCount() {
    return this._vertexCount;
  }
  get polygonCount() {
    return this._polygonCount;
  }
  get dimensions() {
    return this._dimensions;
  }
  get initData() {
    return {
      vertices: this._vertices,
      indices: this._indices
    };
  }
  get pbData() {
    const verticesArray = vec3ArrayToFloat32Array(this._vertices);
    const indicesArray = new Uint32Array(this._indices);
    return {
      vertices: new Uint8Array(verticesArray.buffer),
      indices: new Uint8Array(indicesArray.buffer)
    };
  }
};

// node_modules/@iwer/sem/lib/native/entity.js
import { generateUUID } from "three/src/math/MathUtils.js";
var SpatialEntityType;
(function(SpatialEntityType2) {
  SpatialEntityType2["Plane"] = "plane";
  SpatialEntityType2["Box"] = "box";
  SpatialEntityType2["Mesh"] = "mesh";
})(SpatialEntityType || (SpatialEntityType = {}));
var WebXRSemanticLabelMap = {
  [SemanticLabelMETA.OTHER]: XRSemanticLabels.Other,
  [SemanticLabelMETA.TABLE]: XRSemanticLabels.Table,
  [SemanticLabelMETA.COUCH]: XRSemanticLabels.Couch,
  [SemanticLabelMETA.FLOOR]: XRSemanticLabels.Floor,
  [SemanticLabelMETA.CEILING]: XRSemanticLabels.Ceiling,
  [SemanticLabelMETA.WALL_FACE]: XRSemanticLabels.Wall,
  [SemanticLabelMETA.INVISIBLE_WALL_FACE]: XRSemanticLabels.Window,
  [SemanticLabelMETA.INNER_WALL_FACE]: XRSemanticLabels.Wall,
  [SemanticLabelMETA.DOOR_FRAME]: XRSemanticLabels.Door,
  [SemanticLabelMETA.WINDOW_FRAME]: XRSemanticLabels.Window,
  [SemanticLabelMETA.WALL_ART]: XRSemanticLabels.WallArt,
  [SemanticLabelMETA.STORAGE]: XRSemanticLabels.Shelf,
  [SemanticLabelMETA.BED]: XRSemanticLabels.Bed,
  [SemanticLabelMETA.LAMP]: XRSemanticLabels.Lamp,
  [SemanticLabelMETA.SCREEN]: XRSemanticLabels.Screen,
  [SemanticLabelMETA.PLANT]: XRSemanticLabels.Plant,
  [SemanticLabelMETA.GLOBAL_MESH]: XRSemanticLabels.GlobalMesh,
  [SemanticLabelMETA.CHAIR]: XRSemanticLabels.Couch,
  [SemanticLabelMETA.UNKNOWN]: XRSemanticLabels.Other,
  [SemanticLabelMETA.OTHER_ROOM_FACE]: XRSemanticLabels.Other,
  [SemanticLabelMETA.OPENING]: XRSemanticLabels.Other,
  [SemanticLabelMETA.UNRECOGNIZED]: XRSemanticLabels.Other
};
var SpatialEntity2 = class _SpatialEntity extends Mesh14 {
  constructor(uuid = generateUUID()) {
    super(void 0, new MeshMatcapMaterial({
      color: 16777215 * Math.random(),
      flatShading: true
    }));
    this.name = "generic spatial entity";
    this.isSpatialEntity = true;
    this._componentMap = /* @__PURE__ */ new Map();
    this._spatialUUID = uuid;
  }
  get spatialUUID() {
    return this._spatialUUID;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
  }
  addComponent(componentType, initData) {
    let component = null;
    switch (componentType) {
      case SpatialEntityComponentType.Locatable:
        component = new LocatableComponent(this, initData);
        break;
      case SpatialEntityComponentType.Bounded3D:
        component = new Bounded3DComponent(this, initData);
        break;
      case SpatialEntityComponentType.Bounded2D:
        component = new Bounded2DComponent(this, initData);
        break;
      case SpatialEntityComponentType.TriangleMesh:
        component = new TriangleMeshComponent(this, initData);
        break;
      case SpatialEntityComponentType.SemanticLabel:
        component = new SemanticLabelComponent(this, initData);
        break;
    }
    if (component) {
      this._componentMap.set(componentType, component);
    }
  }
  getComponent(componentType) {
    return this._componentMap.get(componentType);
  }
  duplicate() {
    const clone5 = new _SpatialEntity();
    this._componentMap.forEach((component, _k, _m) => {
      clone5.addComponent(component.type, component.initData);
    });
    return clone5;
  }
  get nativeEntity() {
    if (!this._nativeEntity) {
      const xrRigidTransform = new XRRigidTransform({
        x: this.position.x,
        y: this.position.y,
        z: this.position.z,
        w: 1
      }, {
        x: this.quaternion.x,
        y: this.quaternion.y,
        z: this.quaternion.z,
        w: this.quaternion.w
      });
      const semanticLabel = WebXRSemanticLabelMap[this.getComponent(SpatialEntityComponentType.SemanticLabel).semanticLabel];
      if (this.entityType === SpatialEntityType.Plane) {
        const { offset, extent } = this.getComponent(SpatialEntityComponentType.Bounded2D);
        const polygon = [
          new DOMPointReadOnly(offset.x, 0, offset.y),
          new DOMPointReadOnly(offset.x + extent.x, 0, offset.y),
          new DOMPointReadOnly(offset.x + extent.x, 0, offset.y + extent.y),
          new DOMPointReadOnly(offset.x, 0, offset.y + extent.y),
          new DOMPointReadOnly(offset.x, 0, offset.y)
        ];
        this._nativeEntity = new NativePlane(xrRigidTransform, polygon, semanticLabel);
      } else if (this.entityType === SpatialEntityType.Box || this.entityType === SpatialEntityType.Mesh) {
        const vertices = this.geometry.getAttribute("position").array;
        const indices = new Uint32Array(this.geometry.index.array);
        this._nativeEntity = new NativeMesh(xrRigidTransform, vertices, indices, semanticLabel);
      }
    }
    return this._nativeEntity;
  }
  static fromPBJSON(json) {
    const pbEntity = SpatialEntity.fromJSON(json);
    if (pbEntity.locatable_META) {
      const spatialEntity = new _SpatialEntity(pbEntity.uuid);
      spatialEntity.addComponent(SpatialEntityComponentType.Locatable, pbEntity.locatable_META);
      if (pbEntity.semanticLabel_META) {
        spatialEntity.addComponent(SpatialEntityComponentType.SemanticLabel, pbEntity.semanticLabel_META);
      }
      if (pbEntity.bounded2D_META) {
        spatialEntity.addComponent(SpatialEntityComponentType.Bounded2D, pbEntity.bounded2D_META);
      } else if (pbEntity.bounded3D_META) {
        spatialEntity.addComponent(SpatialEntityComponentType.Bounded3D, pbEntity.bounded3D_META);
      } else if (pbEntity.triangleMesh_META) {
        spatialEntity.addComponent(SpatialEntityComponentType.TriangleMesh, pbEntity.triangleMesh_META);
      }
      return spatialEntity;
    }
    return;
  }
  get entityType() {
    if (this.getComponent(SpatialEntityComponentType.Bounded2D)) {
      return SpatialEntityType.Plane;
    } else if (this.getComponent(SpatialEntityComponentType.Bounded3D)) {
      return SpatialEntityType.Box;
    } else if (this.getComponent(SpatialEntityComponentType.TriangleMesh)) {
      return SpatialEntityType.Mesh;
    }
    return;
  }
  static toPBJSON(entity) {
    var _a2, _b, _c, _d, _e2;
    const pbEntity = {
      uuid: entity.spatialUUID,
      locatable_META: (_a2 = entity.getComponent(SpatialEntityComponentType.Locatable)) === null || _a2 === void 0 ? void 0 : _a2.pbData,
      boundary2D_META: void 0,
      bounded2D_META: (_b = entity.getComponent(SpatialEntityComponentType.Bounded2D)) === null || _b === void 0 ? void 0 : _b.pbData,
      bounded3D_META: (_c = entity.getComponent(SpatialEntityComponentType.Bounded3D)) === null || _c === void 0 ? void 0 : _c.pbData,
      semanticLabel_META: (_d = entity.getComponent(SpatialEntityComponentType.SemanticLabel)) === null || _d === void 0 ? void 0 : _d.pbData,
      roomLayout_META: void 0,
      spaceContainer_META: void 0,
      triangleMesh_META: (_e2 = entity.getComponent(SpatialEntityComponentType.TriangleMesh)) === null || _e2 === void 0 ? void 0 : _e2.pbData,
      dynamicObject_META: void 0
    };
    return pbEntity;
  }
};

// node_modules/@iwer/sem/lib/sem.js
import { Color as Color2, GridHelper, Group as Group10, Matrix3, Matrix4 as Matrix45, Object3D as Object3D4, PerspectiveCamera as PerspectiveCamera4, Quaternion as Quaternion17, Raycaster, Scene as Scene2, Vector3 as Vector324, WebGLRenderer as WebGLRenderer2 } from "three";

// node_modules/@iwer/sem/lib/captures/registry.js
var Environments = {
  living_room: () => import("./living_room-PZUUXJNS.js"),
  meeting_room: () => import("./meeting_room-53N4GKOH.js"),
  music_room: () => import("./music_room-PCB7ZQWY.js"),
  office_large: () => import("./office_large-FWUFRDF3.js"),
  office_small: () => import("./office_small-CYANQGGD.js")
};

// node_modules/@iwer/sem/lib/version.js
var VERSION3 = "0.2.4";

// node_modules/@iwer/sem/lib/sem.js
var forwardVector = new Vector324(0, 0, -1);
var SyntheticEnvironmentModule = class extends EventTarget {
  constructor(xrDevice) {
    super();
    this.xrDevice = xrDevice;
    this.trackedPlanes = /* @__PURE__ */ new Set();
    this.trackedMeshes = /* @__PURE__ */ new Set();
    this.version = VERSION3;
    this.objectMap = /* @__PURE__ */ new Map();
    this.planes = new Group10();
    this.boxes = new Group10();
    this.meshes = new Group10();
    this.tempPosition = new Vector324();
    this.tempQuaternion = new Quaternion17();
    this.tempDirection = new Vector324();
    this.tempScale = new Vector324();
    this.tempMatrix = new Matrix45();
    this.raycaster = new Raycaster();
    this.hitTestTarget = new Group10();
    this.hitTestMarker = new Object3D4();
    this.worldNormal = new Vector324();
    this.normalMatrix = new Matrix3();
    this.scene = new Scene2();
    this.scene.background = new Color2(4079166);
    this.camera = new PerspectiveCamera4(50, window.innerWidth / window.innerHeight, 0.1, 40);
    this.camera.position.set(0, 1.6, 5);
    const gridHelper = new GridHelper(50, 50);
    this.scene.add(gridHelper);
    this.scene.add(this.planes, this.boxes, this.meshes);
    this.planes.renderOrder = 1;
    this.boxes.renderOrder = 2;
    this.meshes.renderOrder = 3;
    this.planes.visible = false;
    this.boxes.visible = false;
    this.renderer = new WebGLRenderer2({ antialias: true, alpha: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.domElement.style.position = "fixed";
    this.renderer.domElement.style.top = "50vh";
    this.renderer.domElement.style.left = "50vw";
    this.renderer.domElement.style.transform = "translate(-50%, -50%)";
    this.hitTestTarget.add(this.hitTestMarker);
    this.hitTestMarker.rotateX(Math.PI / 2);
  }
  get environmentCanvas() {
    return this.renderer.domElement;
  }
  get planesVisible() {
    return this.planes.visible;
  }
  set planesVisible(visible) {
    this.planes.visible = visible;
  }
  get boundingBoxesVisible() {
    return this.boxes.visible;
  }
  set boundingBoxesVisible(visible) {
    this.boxes.visible = visible;
  }
  get meshesVisible() {
    return this.meshes.visible;
  }
  set meshesVisible(visible) {
    this.meshes.visible = visible;
  }
  render() {
    this.camera.position.copy(this.xrDevice.position);
    this.camera.quaternion.copy(this.xrDevice.quaternion);
    const xrDeviceFOV = this.xrDevice.fovy / Math.PI * 180;
    let cameraMatrixNeedsUpdate = false;
    if (this.camera.fov !== xrDeviceFOV) {
      this.camera.fov = xrDeviceFOV;
      cameraMatrixNeedsUpdate = true;
    }
    const iwerCanvasDimension = this.xrDevice.canvasDimensions;
    if (iwerCanvasDimension) {
      const canvas = this.renderer.domElement;
      const resizeNeeded = canvas.width !== iwerCanvasDimension.width || canvas.height !== iwerCanvasDimension.height;
      if (resizeNeeded) {
        this.camera.aspect = iwerCanvasDimension.width / iwerCanvasDimension.height;
        this.renderer.setSize(iwerCanvasDimension.width, iwerCanvasDimension.height);
        cameraMatrixNeedsUpdate = true;
      }
    }
    if (cameraMatrixNeedsUpdate) {
      this.camera.updateProjectionMatrix();
    }
    this.renderer.render(this.scene, this.camera);
  }
  deleteAll() {
    [...this.objectMap.values()].forEach((object) => {
      object.removeFromParent();
    });
    this.objectMap.clear();
    this.trackedMeshes.clear();
    this.trackedPlanes.clear();
  }
  loadEnvironment(json) {
    this.deleteAll();
    json.spatialEntities.forEach((spatialEntityJSON) => {
      const spatialEntity = SpatialEntity2.fromPBJSON(spatialEntityJSON);
      if (spatialEntity) {
        switch (spatialEntity.entityType) {
          case SpatialEntityType.Box:
            this.boxes.add(spatialEntity);
            this.trackedMeshes.add(spatialEntity.nativeEntity);
            break;
          case SpatialEntityType.Plane:
            this.planes.add(spatialEntity);
            this.trackedPlanes.add(spatialEntity.nativeEntity);
            break;
          case SpatialEntityType.Mesh:
            this.meshes.add(spatialEntity);
            this.trackedMeshes.add(spatialEntity.nativeEntity);
            break;
        }
        const oldMesh = this.objectMap.get(spatialEntityJSON.uuid);
        if (oldMesh) {
          oldMesh.removeFromParent();
        }
        this.objectMap.set(spatialEntityJSON.uuid, spatialEntity);
      }
    });
  }
  loadDefaultEnvironment(envId) {
    if (typeof __IS_UMD__ !== "undefined" && __IS_UMD__) {
      const url = `https://www.unpkg.com/@iwer/sem@${VERSION3}/captures/${envId}.json`;
      fetch(url).then((response) => {
        if (!response.ok) {
          throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        return response.json();
      }).then((envJson) => {
        this.loadEnvironment(envJson);
      }).catch((error) => {
        console.error(`Error loading environment ${envId} from CDN`, error);
      });
    } else {
      const importEnv = Environments[envId];
      if (!importEnv) {
        console.error(`Requested environment ${envId} does not exist`);
        return;
      }
      importEnv().then((module) => {
        const envJson = module.default;
        this.loadEnvironment(envJson);
      }).catch((error) => {
        console.error(`Error loading environment ${envId} locally`, error);
      });
    }
  }
  computeHitTestResults(mat4) {
    this.tempMatrix.fromArray(mat4);
    this.tempMatrix.decompose(this.tempPosition, this.tempQuaternion, this.tempScale);
    this.tempDirection.copy(forwardVector).applyQuaternion(this.tempQuaternion).normalize();
    this.raycaster.set(this.tempPosition, this.tempDirection);
    const intersections = this.raycaster.intersectObject(this.meshes, true);
    const results = intersections.map((intersection) => {
      var _a2;
      const point = intersection.point;
      this.hitTestTarget.position.copy(point);
      if ((_a2 = intersection.face) === null || _a2 === void 0 ? void 0 : _a2.normal) {
        this.worldNormal.copy(intersection.face.normal);
        const object = intersection.object;
        this.worldNormal.applyMatrix3(this.normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
        this.hitTestTarget.lookAt(this.tempPosition.addVectors(point, this.worldNormal));
      } else {
        this.hitTestTarget.quaternion.set(0, 0, 0, 1);
      }
      this.hitTestTarget.updateMatrixWorld(true);
      return this.hitTestMarker.matrixWorld.toArray();
    });
    return results;
  }
};

// node_modules/@pmndrs/xr/dist/emulate.js
import { Euler as Euler11, Quaternion as Quaternion18 } from "three";
var configurations = { metaQuest3, metaQuest2, metaQuestPro, oculusQuest1 };
var defaultSyntheticEnvironments = [
  //default default environment:
  "office_small",
  "meeting_room",
  "living_room",
  "music_room",
  "office_large"
];
var handednessList = ["left", "none", "right"];
function emulate(options) {
  const type = typeof options === "string" ? options : options.type ?? "metaQuest3";
  const xrdevice = new XRDevice(configurations[type], typeof options === "string" ? void 0 : options);
  if (typeof options != "string") {
    applyEmulatorTransformOptions(xrdevice, options.headset);
    applyEmulatorInputSourcesOptions(xrdevice.hands, options.hand);
    applyEmulatorInputSourcesOptions(xrdevice.controllers, options.controller);
    xrdevice.primaryInputMode = options.primaryInputMode ?? "controller";
  }
  xrdevice.ipd = typeof options === "string" ? 0 : options.ipd ?? 0;
  xrdevice.installRuntime();
  xrdevice.installDevUI(DevUI);
  const syntheticEnvironment = typeof options === "string" ? true : options.syntheticEnvironment;
  if (syntheticEnvironment === false) {
    return xrdevice;
  }
  xrdevice.installSEM(SyntheticEnvironmentModule);
  if (syntheticEnvironment === null) {
    return xrdevice;
  }
  if (typeof syntheticEnvironment === "string" && defaultSyntheticEnvironments.includes(syntheticEnvironment)) {
    xrdevice.sem?.loadDefaultEnvironment(syntheticEnvironment);
    return xrdevice;
  }
  if (syntheticEnvironment === true || syntheticEnvironment === void 0) {
    xrdevice.sem?.loadDefaultEnvironment(defaultSyntheticEnvironments[0]);
    return xrdevice;
  }
  if (typeof syntheticEnvironment === "object") {
    xrdevice.sem?.loadEnvironment(syntheticEnvironment);
    return xrdevice;
  }
  fetch(syntheticEnvironment).then((response) => response.json()).then((environment) => xrdevice.sem?.loadEnvironment(environment)).catch(console.error);
  return xrdevice;
}
var eulerHelper = new Euler11();
var quaternionHelper9 = new Quaternion18();
function applyEmulatorInputSourcesOptions(xrInputSources, options) {
  if (options == null) {
    return;
  }
  for (const handedness of handednessList) {
    applyEmulatorTransformOptions(xrInputSources[handedness], options[handedness]);
  }
}
function applyEmulatorTransformOptions(target, options) {
  if (target == null || options == null) {
    return;
  }
  setVector(target.position, options.position);
  setVector(eulerHelper, options.rotation);
  setQuaternion(target.quaternion, quaternionHelper9.setFromEuler(eulerHelper));
  setQuaternion(target.quaternion, options.quaternion);
}
function setVector(target, value) {
  if (value == null) {
    return;
  }
  if (value instanceof Euler11 && target instanceof Euler11) {
    target.copy(value);
  }
  if (Array.isArray(value)) {
    target.x = value[0];
    target.y = value[1];
    target.z = value[2];
    return;
  }
  target.x = value.x;
  target.y = value.y;
  target.z = value.z;
}
function setQuaternion(target, value) {
  if (value == null) {
    return;
  }
  if (Array.isArray(value)) {
    target.x = value[0];
    target.y = value[1];
    target.z = value[2];
    target.w = value[3];
    return;
  }
  target.x = value.x;
  target.y = value.y;
  target.z = value.z;
  target.w = value.w;
}
export {
  emulate
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

webxr-layers-polyfill/build/webxr-layers-polyfill.module.js:
  (**
   * @license
   * webxr-layers-polyfill
   * Version 1.1.0
   * Copyright (c) 2021 Facebook, Inc. and its affiliates.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
  *)
  (**
   * @license
   * gl-matrix 
   * Version 3.4.3
   * Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
  *)
*/
//# sourceMappingURL=emulate-AKS6W5VK.js.map
