{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/AbstractEngine/abstractEngine.views.ts"],
  "sourcesContent": ["import type { Camera } from \"../../Cameras/camera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/**\r\n * Class used to define an additional view for the engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\r\n */\r\nexport class EngineView {\r\n    /**\r\n     * A randomly generated unique id\r\n     */\r\n    readonly id: string;\r\n    /** Defines the canvas where to render the view */\r\n    target: HTMLCanvasElement;\r\n    /**\r\n     * Defines an optional camera or array of cameras used to render the view (will use active camera / cameras else)\r\n     * Support for array of cameras @since\r\n     */\r\n    camera?: Camera | Camera[];\r\n    /** Indicates if the destination view canvas should be cleared before copying the parent canvas. Can help if the scene clear color has alpha < 1 */\r\n    clearBeforeCopy?: boolean;\r\n    /** Indicates if the view is enabled (true by default) */\r\n    enabled: boolean;\r\n    /** Defines a custom function to handle canvas size changes. (the canvas to render into is provided to the callback) */\r\n    customResize?: (canvas: HTMLCanvasElement) => void;\r\n}\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _inputElement: Nullable<HTMLElement>;\r\n\r\n        /**\r\n         * Gets or sets the  HTML element to use for attaching events\r\n         */\r\n        inputElement: Nullable<HTMLElement>;\r\n\r\n        /**\r\n         * Observable to handle when a change to inputElement occurs\r\n         * @internal\r\n         */\r\n        _onEngineViewChanged?: () => void;\r\n\r\n        /**\r\n         * Will be triggered before the view renders\r\n         */\r\n        readonly onBeforeViewRenderObservable: Observable<EngineView>;\r\n        /**\r\n         * Will be triggered after the view rendered\r\n         */\r\n        readonly onAfterViewRenderObservable: Observable<EngineView>;\r\n\r\n        /**\r\n         * Gets the current engine view\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\r\n         */\r\n        activeView: Nullable<EngineView>;\r\n\r\n        /** Gets or sets the list of views */\r\n        views: EngineView[];\r\n\r\n        /**\r\n         * Register a new child canvas\r\n         * @param canvas defines the canvas to register\r\n         * @param camera defines an optional camera or array of cameras to use with this canvas (it will overwrite the scene.activeCamera / scene.activeCameras for this view). Support for array of cameras @since\r\n         * @param clearBeforeCopy Indicates if the destination view canvas should be cleared before copying the parent canvas. Can help if the scene clear color has alpha \\< 1\r\n         * @returns the associated view\r\n         */\r\n        registerView(canvas: HTMLCanvasElement, camera?: Camera | Camera[], clearBeforeCopy?: boolean): EngineView;\r\n\r\n        /**\r\n         * Remove a registered child canvas\r\n         * @param canvas defines the canvas to remove\r\n         * @returns the current engine\r\n         */\r\n        unRegisterView(canvas: HTMLCanvasElement): AbstractEngine;\r\n\r\n        /**\r\n         * @internal\r\n         */\r\n        _renderViewStep(view: EngineView): boolean;\r\n    }\r\n}\r\n\r\nconst OnBeforeViewRenderObservable = new Observable<EngineView>();\r\nconst OnAfterViewRenderObservable = new Observable<EngineView>();\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"onBeforeViewRenderObservable\", {\r\n    get: function (this: AbstractEngine) {\r\n        return OnBeforeViewRenderObservable;\r\n    },\r\n});\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"onAfterViewRenderObservable\", {\r\n    get: function (this: AbstractEngine) {\r\n        return OnAfterViewRenderObservable;\r\n    },\r\n});\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"inputElement\", {\r\n    get: function (this: AbstractEngine) {\r\n        return this._inputElement;\r\n    },\r\n    set: function (this: AbstractEngine, value: HTMLElement) {\r\n        if (this._inputElement !== value) {\r\n            this._inputElement = value;\r\n            this._onEngineViewChanged?.();\r\n        }\r\n    },\r\n});\r\n\r\nAbstractEngine.prototype.getInputElement = function (): Nullable<HTMLElement> {\r\n    return this.inputElement || this.getRenderingCanvas();\r\n};\r\n\r\nAbstractEngine.prototype.registerView = function (canvas: HTMLCanvasElement, camera?: Camera | Camera[], clearBeforeCopy?: boolean): EngineView {\r\n    if (!this.views) {\r\n        this.views = [];\r\n    }\r\n\r\n    for (const view of this.views) {\r\n        if (view.target === canvas) {\r\n            return view;\r\n        }\r\n    }\r\n\r\n    const masterCanvas = this.getRenderingCanvas();\r\n    if (masterCanvas) {\r\n        canvas.width = masterCanvas.width;\r\n        canvas.height = masterCanvas.height;\r\n    }\r\n\r\n    const newView = { target: canvas, camera, clearBeforeCopy, enabled: true, id: (Math.random() * 100000).toFixed() };\r\n    this.views.push(newView);\r\n\r\n    if (camera && !Array.isArray(camera)) {\r\n        camera.onDisposeObservable.add(() => {\r\n            this.unRegisterView(canvas);\r\n        });\r\n    }\r\n\r\n    return newView;\r\n};\r\n\r\nAbstractEngine.prototype.unRegisterView = function (canvas: HTMLCanvasElement): AbstractEngine {\r\n    if (!this.views || this.views.length === 0) {\r\n        return this;\r\n    }\r\n\r\n    for (const view of this.views) {\r\n        if (view.target === canvas) {\r\n            const index = this.views.indexOf(view);\r\n\r\n            if (index !== -1) {\r\n                this.views.splice(index, 1);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nAbstractEngine.prototype._renderViewStep = function (view: EngineView): boolean {\r\n    const canvas = view.target;\r\n    const context = canvas.getContext(\"2d\");\r\n    if (!context) {\r\n        return true;\r\n    }\r\n    const parent = this.getRenderingCanvas()!;\r\n\r\n    OnBeforeViewRenderObservable.notifyObservers(view);\r\n    const camera = view.camera;\r\n    let previewCamera: Nullable<Camera> = null;\r\n    let previewCameras: Nullable<Camera[]> = null;\r\n    let scene: Nullable<Scene> = null;\r\n    if (camera) {\r\n        scene = Array.isArray(camera) ? camera[0].getScene() : camera.getScene();\r\n\r\n        previewCamera = scene.activeCamera;\r\n        previewCameras = scene.activeCameras;\r\n\r\n        if (Array.isArray(camera)) {\r\n            scene.activeCameras = camera;\r\n        } else {\r\n            scene.activeCamera = camera;\r\n            scene.activeCameras = null;\r\n        }\r\n    }\r\n    this.activeView = view;\r\n\r\n    if (view.customResize) {\r\n        view.customResize(canvas);\r\n    } else {\r\n        // Set sizes\r\n        const width = Math.floor(canvas.clientWidth / this._hardwareScalingLevel);\r\n        const height = Math.floor(canvas.clientHeight / this._hardwareScalingLevel);\r\n\r\n        const dimsChanged = width !== canvas.width || parent.width !== canvas.width || height !== canvas.height || parent.height !== canvas.height;\r\n        if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            this.setSize(width, height);\r\n        }\r\n    }\r\n\r\n    if (!parent.width || !parent.height) {\r\n        return false;\r\n    }\r\n\r\n    // Render the frame\r\n    this._renderFrame();\r\n\r\n    this.flushFramebuffer();\r\n\r\n    // Copy to target\r\n    if (view.clearBeforeCopy) {\r\n        context.clearRect(0, 0, parent.width, parent.height);\r\n    }\r\n    context.drawImage(parent, 0, 0);\r\n\r\n    // Restore\r\n    if (scene) {\r\n        scene.activeCameras = previewCameras;\r\n        scene.activeCamera = previewCamera;\r\n    }\r\n    OnAfterViewRenderObservable.notifyObservers(view);\r\n    return true;\r\n};\r\n\r\nAbstractEngine.prototype._renderViews = function () {\r\n    if (!this.views || this.views.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    const parent = this.getRenderingCanvas();\r\n\r\n    if (!parent) {\r\n        return false;\r\n    }\r\n\r\n    let inputElementView;\r\n    for (const view of this.views) {\r\n        if (!view.enabled) {\r\n            continue;\r\n        }\r\n        const canvas = view.target;\r\n        // Always render the view correspondent to the inputElement for last\r\n        if (canvas === this.inputElement) {\r\n            inputElementView = view;\r\n            continue;\r\n        }\r\n\r\n        if (!this._renderViewStep(view)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    if (inputElementView) {\r\n        if (!this._renderViewStep(inputElementView)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    this.activeView = null;\r\n\r\n    return true;\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
