import {
  Vector3
} from "./chunk-SAE7R3H2.js";

// node_modules/@babylonjs/core/Maths/math.path.js
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["CW"] = 0] = "CW";
  Orientation2[Orientation2["CCW"] = 1] = "CCW";
})(Orientation || (Orientation = {}));
var BezierCurve = class {
  /**
   * Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats
   * @param t defines the time
   * @param x1 defines the left coordinate on X axis
   * @param y1 defines the left coordinate on Y axis
   * @param x2 defines the right coordinate on X axis
   * @param y2 defines the right coordinate on Y axis
   * @returns the interpolated value
   */
  static Interpolate(t, x1, y1, x2, y2) {
    if (t === 0) {
      return 0;
    }
    const f0 = 1 - 3 * x2 + 3 * x1;
    const f1 = 3 * x2 - 6 * x1;
    const f2 = 3 * x1;
    let refinedT = t;
    for (let i = 0; i < 5; i++) {
      const refinedT2 = refinedT * refinedT;
      const refinedT3 = refinedT2 * refinedT;
      const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
      const slope = 1 / (3 * f0 * refinedT2 + 2 * f1 * refinedT + f2);
      refinedT -= (x - t) * slope;
      refinedT = Math.min(1, Math.max(0, refinedT));
    }
    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
  }
};
var Curve3 = class _Curve3 {
  /**
   * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve
   * @param v0 (Vector3) the origin point of the Quadratic Bezier
   * @param v1 (Vector3) the control point
   * @param v2 (Vector3) the end point of the Quadratic Bezier
   * @param nbPoints (integer) the wanted number of points in the curve
   * @returns the created Curve3
   */
  static CreateQuadraticBezier(v0, v1, v2, nbPoints) {
    nbPoints = nbPoints > 2 ? nbPoints : 3;
    const bez = [];
    const equation = (t, val0, val1, val2) => {
      const res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
      return res;
    };
    for (let i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
    }
    return new _Curve3(bez);
  }
  /**
   * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve
   * @param v0 (Vector3) the origin point of the Cubic Bezier
   * @param v1 (Vector3) the first control point
   * @param v2 (Vector3) the second control point
   * @param v3 (Vector3) the end point of the Cubic Bezier
   * @param nbPoints (integer) the wanted number of points in the curve
   * @returns the created Curve3
   */
  static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {
    nbPoints = nbPoints > 3 ? nbPoints : 4;
    const bez = [];
    const equation = (t, val0, val1, val2, val3) => {
      const res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
      return res;
    };
    for (let i = 0; i <= nbPoints; i++) {
      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
    }
    return new _Curve3(bez);
  }
  /**
   * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline
   * @param p1 (Vector3) the origin point of the Hermite Spline
   * @param t1 (Vector3) the tangent vector at the origin point
   * @param p2 (Vector3) the end point of the Hermite Spline
   * @param t2 (Vector3) the tangent vector at the end point
   * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array
   * @returns the created Curve3
   */
  static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {
    const hermite = [];
    const step = 1 / nSeg;
    for (let i = 0; i <= nSeg; i++) {
      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));
    }
    return new _Curve3(hermite);
  }
  /**
   * Returns a Curve3 object along a CatmullRom Spline curve :
   * @param points (array of Vector3) the points the spline must pass through. At least, four points required
   * @param nbPoints (integer) the wanted number of points between each curve control points
   * @param closed (boolean) optional with default false, when true forms a closed loop from the points
   * @returns the created Curve3
   */
  static CreateCatmullRomSpline(points, nbPoints, closed) {
    const catmullRom = [];
    const step = 1 / nbPoints;
    let amount = 0;
    if (closed) {
      const pointsCount = points.length;
      for (let i = 0; i < pointsCount; i++) {
        amount = 0;
        for (let c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
          amount += step;
        }
      }
      catmullRom.push(catmullRom[0]);
    } else {
      const totalPoints = [];
      totalPoints.push(points[0].clone());
      Array.prototype.push.apply(totalPoints, points);
      totalPoints.push(points[points.length - 1].clone());
      let i = 0;
      for (; i < totalPoints.length - 3; i++) {
        amount = 0;
        for (let c = 0; c < nbPoints; c++) {
          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
          amount += step;
        }
      }
      i--;
      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
    }
    return new _Curve3(catmullRom);
  }
  /**
   * Returns a Curve3 object along an arc through three vector3 points:
   * The three points should not be colinear. When they are the Curve3 is empty.
   * @param first (Vector3) the first point the arc must pass through.
   * @param second (Vector3) the second point the arc must pass through.
   * @param third (Vector3) the third point the arc must pass through.
   * @param steps (number) the larger the number of steps the more detailed the arc.
   * @param closed (boolean) optional with default false, when true forms the chord from the first and third point
   * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points
   * @returns the created Curve3
   */
  static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {
    const arc = [];
    const vec1 = second.subtract(first);
    const vec2 = third.subtract(second);
    const vec3 = first.subtract(third);
    const zAxis = Vector3.Cross(vec1, vec2);
    const len4 = zAxis.length();
    if (len4 < Math.pow(10, -8)) {
      return new _Curve3(arc);
    }
    const len1Sq = vec1.lengthSquared();
    const len2Sq = vec2.lengthSquared();
    const len3Sq = vec3.lengthSquared();
    const len4Sq = zAxis.lengthSquared();
    const len1 = vec1.length();
    const len2 = vec2.length();
    const len3 = vec3.length();
    const radius = 0.5 * len1 * len2 * len3 / len4;
    const dot1 = Vector3.Dot(vec1, vec3);
    const dot2 = Vector3.Dot(vec1, vec2);
    const dot3 = Vector3.Dot(vec2, vec3);
    const a = -0.5 * len2Sq * dot1 / len4Sq;
    const b = -0.5 * len3Sq * dot2 / len4Sq;
    const c = -0.5 * len1Sq * dot3 / len4Sq;
    const center = first.scale(a).add(second.scale(b)).add(third.scale(c));
    const radiusVec = first.subtract(center);
    const xAxis = radiusVec.normalize();
    const yAxis = Vector3.Cross(zAxis, xAxis).normalize();
    if (fullCircle) {
      const dStep = 2 * Math.PI / steps;
      for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {
        arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));
      }
      arc.push(first);
    } else {
      const dStep = 1 / steps;
      let theta = 0;
      let point = Vector3.Zero();
      do {
        point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));
        arc.push(point);
        theta += dStep;
      } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));
      arc.push(third);
      if (closed) {
        arc.push(first);
      }
    }
    return new _Curve3(arc);
  }
  /**
   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
   * A Curve3 is designed from a series of successive Vector3.
   * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object
   * @param points points which make up the curve
   */
  constructor(points) {
    this._length = 0;
    this._points = points;
    this._length = this._computeLength(points);
  }
  /**
   * @returns the Curve3 stored array of successive Vector3
   */
  getPoints() {
    return this._points;
  }
  /**
   * @returns the computed length (float) of the curve.
   */
  length() {
    return this._length;
  }
  /**
   * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
   * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
   * curveA and curveB keep unchanged.
   * @param curve the curve to continue from this curve
   * @returns the newly constructed curve
   */
  continue(curve) {
    const lastPoint = this._points[this._points.length - 1];
    const continuedPoints = this._points.slice();
    const curvePoints = curve.getPoints();
    for (let i = 1; i < curvePoints.length; i++) {
      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
    }
    const continuedCurve = new _Curve3(continuedPoints);
    return continuedCurve;
  }
  _computeLength(path) {
    let l = 0;
    for (let i = 1; i < path.length; i++) {
      l += path[i].subtract(path[i - 1]).length();
    }
    return l;
  }
};

export {
  BezierCurve,
  Curve3
};
//# sourceMappingURL=chunk-AAYY4GXB.js.map
