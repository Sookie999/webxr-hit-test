{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.ts"],
  "sourcesContent": ["import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport { RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\nimport { Logger } from \"../../../../Misc/logger\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\n\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    /**\n     * The maximum number of parallel delays that can be set per node.\n     */\n    public static MaxParallelDelayCount = 100;\n    /**\n     * Input signal: If activated the delayed activations set by this block will be canceled.\n     */\n    public readonly cancel: FlowGraphSignalConnection;\n\n    /**\n     * Input connection: The duration of the delay in seconds.\n     */\n    public readonly duration: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: The last delay index that was set.\n     */\n    public readonly lastDelayIndex: FlowGraphDataConnection<FlowGraphInteger>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\n    }\n\n    public override _preparePendingTasks(context: FlowGraphContext): void {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n\n        // active delays are global to the context\n        const activeDelays: number = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex: number = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const scene = context.configuration.scene;\n        const timer: AdvancedTimer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n        this._updateGlobalTimers(context);\n    }\n\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);\n        this._updateGlobalTimers(context);\n    }\n\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        } else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetDelay;\n    }\n\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        } else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n\n        this._updateGlobalTimers(context);\n    }\n\n    private _updateGlobalTimers(context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const globalTimers = context._getGlobalContextVariable(\"pendingDelays\", [] as AdvancedTimer[]);\n        // there should NEVER be the same index in the global and local timers, unless they are equal\n        for (let i = 0; i < timers.length; i++) {\n            if (!timers[i]) {\n                continue;\n            }\n            const timer = timers[i];\n            if (globalTimers[i] && globalTimers[i] !== timer) {\n                Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n            } else {\n                globalTimers[i] = timer;\n            }\n        }\n        context._setGlobalContextVariable(\"pendingDelays\", globalTimers);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetDelay, FlowGraphSetDelayBlock);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeM,IAAO,yBAAP,MAAO,gCAA+B,6BAA4B;EAoBpE,YAAY,QAAqC;AAC7C,UAAM,MAAM;AACZ,SAAK,SAAS,KAAK,qBAAqB,QAAQ;AAChD,SAAK,WAAW,KAAK,kBAAkB,YAAY,cAAc;AACjE,SAAK,iBAAiB,KAAK,mBAAmB,kBAAkB,0BAA0B,IAAI,iBAAiB,EAAE,CAAC;EACtH;EAEgB,qBAAqB,SAAyB;AAC1D,UAAM,WAAW,KAAK,SAAS,SAAS,OAAO;AAC/C,QAAI,WAAW,KAAK,MAAM,QAAQ,KAAK,CAAC,SAAS,QAAQ,GAAG;AACxD,aAAO,KAAK,aAAa,SAAS,oCAAoC;IAC1E;AAGA,UAAM,eAAuB,QAAQ,0BAA0B,gBAAgB,CAAC;AAChF,QAAI,gBAAgB,wBAAuB,uBAAuB;AAC9D,aAAO,KAAK,aAAa,SAAS,6BAA6B;IACnE;AAEA,UAAM,iBAAyB,QAAQ,0BAA0B,kBAAkB,EAAE;AAGrF,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAqB;AACzF,UAAM,QAAQ,QAAQ,cAAc;AACpC,UAAM,QAAuB,IAAI,cAAc;MAC3C,SAAS,WAAW;;MACpB,mBAAmB,MAAM;MACzB,SAAS,MAAM,KAAK,SAAS,OAAO,OAAO;KAC9C;AACD,UAAM,MAAK;AACX,UAAM,WAAW,iBAAiB;AAClC,SAAK,eAAe,SAAS,IAAI,iBAAiB,QAAQ,GAAG,OAAO;AACpE,YAAQ,0BAA0B,kBAAkB,QAAQ;AAE5D,WAAO,QAAQ,IAAI;AACnB,YAAQ,sBAAsB,MAAM,iBAAiB,MAAM;AAC3D,SAAK,oBAAoB,OAAO;EACpC;EAEgB,oBAAoB,SAAyB;AACzD,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAqB;AACzF,eAAW,SAAS,QAAQ;AACxB,aAAO,QAAO;IAClB;AACA,YAAQ,yBAAyB,MAAM,eAAe;AACtD,SAAK,eAAe,SAAS,IAAI,iBAAiB,EAAE,GAAG,OAAO;AAC9D,SAAK,oBAAoB,OAAO;EACpC;EAEO,SAAS,SAA2B,eAAwC;AAC/E,QAAI,kBAAkB,KAAK,QAAQ;AAC/B,WAAK,oBAAoB,OAAO;AAChC;IACJ,OAAO;AACH,WAAK,qBAAqB,OAAO;AACjC,WAAK,IAAI,gBAAgB,OAAO;IACpC;EACJ;EAEgB,eAAY;AACxB,WAAA;EACJ;EAEQ,SAAS,OAAsB,SAAyB;AAC5D,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAqB;AACzF,UAAM,QAAQ,OAAO,QAAQ,KAAK;AAClC,QAAI,UAAU,IAAI;AACd,aAAO,OAAO,OAAO,CAAC;IAC1B,OAAO;AACH,aAAO,KAAK,+EAA+E;IAC/F;AACA,YAAQ,oBAAoB,IAAI;AAChC,SAAK,KAAK,gBAAgB,OAAO;AAEjC,SAAK,oBAAoB,OAAO;EACpC;EAEQ,oBAAoB,SAAyB;AACjD,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAqB;AACzF,UAAM,eAAe,QAAQ,0BAA0B,iBAAiB,CAAA,CAAqB;AAE7F,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,UAAI,CAAC,OAAO,CAAC,GAAG;AACZ;MACJ;AACA,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,aAAa,CAAC,KAAK,aAAa,CAAC,MAAM,OAAO;AAC9C,eAAO,KAAK,+EAA+E;MAC/F,OAAO;AACH,qBAAa,CAAC,IAAI;MACtB;IACJ;AACA,YAAQ,0BAA0B,iBAAiB,YAAY;EACnE;;AA7Gc,uBAAA,wBAAwB;AAgH1C,cAAa,0BAA+B,sBAAsB;",
  "names": []
}
