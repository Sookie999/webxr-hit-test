import {
  LightConstants
} from "./chunk-WAGTS43G.js";
import {
  Node
} from "./chunk-QX3YVE2B.js";
import {
  SmartArray
} from "./chunk-SZB5QSYK.js";
import {
  Tools
} from "./chunk-S6ZVB5LK.js";
import {
  Frustum
} from "./chunk-UKGB4G3Q.js";
import {
  SerializationHelper
} from "./chunk-M3TRY6IC.js";
import {
  __decorate,
  serialize,
  serializeAsVector3
} from "./chunk-ZRPHACZ5.js";
import {
  Viewport
} from "./chunk-5LTYGTJL.js";
import {
  Matrix,
  Quaternion,
  Vector3
} from "./chunk-OEZCBW2S.js";
import {
  GetClass
} from "./chunk-MIVJKRRS.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  EngineStore
} from "./chunk-3DTNSITF.js";
import {
  Observable
} from "./chunk-GCT36VBF.js";

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.NAME_IBLCDFGENERATOR = "iblCDFGenerator";
SceneComponentConstants.NAME_CLUSTEREDLIGHTING = "ClusteredLighting";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class _Stage extends Array {
  /**
   * Hide ctor from the rest of the world.
   * @param items The items to add.
   */
  constructor(items) {
    super(...items);
  }
  /**
   * Creates a new Stage.
   * @returns A new instance of a Stage
   */
  static Create() {
    return Object.create(_Stage.prototype);
  }
  /**
   * Registers a step in an ordered way in the targeted stage.
   * @param index Defines the position to register the step in
   * @param component Defines the component attached to the step
   * @param action Defines the action to launch during the step
   */
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  /**
   * Clears all the steps from the stage.
   */
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = class _Camera extends Node {
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
  }
  /**
   * The vector the camera should consider as up.
   * (default is Vector3(0, 1, 0) aka Vector3.Up())
   */
  set upVector(vec) {
    this._upVector = vec;
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * The screen area in scene units squared
   */
  get screenArea() {
    let x = 0;
    let y = 0;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      if (this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED) {
        y = this.minZ * 2 * Math.tan(this.fov / 2);
        x = this.getEngine().getAspectRatio(this) * y;
      } else {
        x = this.minZ * 2 * Math.tan(this.fov / 2);
        y = x / this.getEngine().getAspectRatio(this);
      }
    } else {
      const halfWidth = this.getEngine().getRenderWidth() / 2;
      const halfHeight = this.getEngine().getRenderHeight() / 2;
      x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);
      y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);
    }
    return x * y;
  }
  /**
   * Define the current limit on the left side for an orthographic camera
   * In scene unit
   */
  set orthoLeft(value) {
    this._orthoLeft = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoLeft = value;
    }
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  /**
   * Define the current limit on the right side for an orthographic camera
   * In scene unit
   */
  set orthoRight(value) {
    this._orthoRight = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoRight = value;
    }
  }
  get orthoRight() {
    return this._orthoRight;
  }
  /**
   * Define the current limit on the bottom side for an orthographic camera
   * In scene unit
   */
  set orthoBottom(value) {
    this._orthoBottom = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoBottom = value;
    }
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  /**
   * Define the current limit on the top side for an orthographic camera
   * In scene unit
   */
  set orthoTop(value) {
    this._orthoTop = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoTop = value;
    }
  }
  get orthoTop() {
    return this._orthoTop;
  }
  /**
   * Sets the camera's field of view in radians based on the focal length and sensor size.
   * @param value the focal length of the camera in mm.
   * @param sensorSize the sensor width size of the camera in mm. (default is 36mm, which is a full frame sensor)
   */
  setFocalLength(value, sensorSize = 36) {
    this.fov = 2 * Math.atan(sensorSize / (2 * value));
  }
  /**
   * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
   */
  set mode(mode) {
    this._mode = mode;
    for (const rigCamera of this._rigCameras) {
      rigCamera.mode = mode;
    }
  }
  get mode() {
    return this._mode;
  }
  /**
   * Gets a flag indicating that the camera has moved in some way since the last call to Camera.update()
   */
  get hasMoved() {
    return this._hasMoved;
  }
  /**
   * Instantiates a new camera object.
   * This should not be used directly but through the inherited cameras: ArcRotate, Free...
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the position of the camera
   * @param scene Defines the scene the camera belongs too
   * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
   */
  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, scene, false);
    this._position = Vector3.Zero();
    this._upVector = Vector3.Up();
    this.oblique = null;
    this._orthoLeft = null;
    this._orthoRight = null;
    this._orthoBottom = null;
    this._orthoTop = null;
    this.fov = 0.8;
    this.projectionPlaneTilt = 0;
    this.minZ = 1;
    this.maxZ = 1e4;
    this.inertia = 0.9;
    this._mode = _Camera.PERSPECTIVE_CAMERA;
    this.isIntermediate = false;
    this.viewport = new Viewport(0, 0, 1, 1);
    this.layerMask = 268435455;
    this.fovMode = _Camera.FOVMODE_VERTICAL_FIXED;
    this.cameraRigMode = _Camera.RIG_MODE_NONE;
    this.customRenderTargets = [];
    this.outputRenderTarget = null;
    this.onViewMatrixChangedObservable = new Observable();
    this.onProjectionMatrixChangedObservable = new Observable();
    this.onAfterCheckInputsObservable = new Observable();
    this.onRestoreStateObservable = new Observable();
    this.isRigCamera = false;
    this._hasMoved = false;
    this._rigCameras = new Array();
    this._skipRendering = false;
    this._projectionMatrix = new Matrix();
    this._postProcesses = new Array();
    this._activeMeshes = new SmartArray(256);
    this._globalPosition = Vector3.Zero();
    this._computedViewMatrix = Matrix.Identity();
    this._doNotComputeProjectionMatrix = false;
    this._transformMatrix = Matrix.Zero();
    this._refreshFrustumPlanes = true;
    this._absoluteRotation = Quaternion.Identity();
    this._isCamera = true;
    this._isLeftCamera = false;
    this._isRightCamera = false;
    this.getScene().addCamera(this);
    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
      this.getScene().activeCamera = this;
    }
    this.position = position;
    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);
  }
  /**
   * Store current camera state (fov, position, etc..)
   * @returns the camera
   */
  storeState() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  }
  /**
   * Returns true if a state has been stored by calling storeState method.
   * @returns true if state has been stored.
   */
  hasStateStored() {
    return !!this._stateStored;
  }
  /**
   * Restores the camera state values if it has been stored. You must call storeState() first
   * @returns true if restored and false otherwise
   */
  _restoreStateValues() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  }
  /**
   * Restored camera state. You must call storeState() first.
   * @returns true if restored and false otherwise
   */
  restoreState() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  }
  /**
   * Gets the class name of the camera.
   * @returns the class name
   */
  getClassName() {
    return "Camera";
  }
  /**
   * Gets a string representation of the camera useful for debug purpose.
   * @param fullDetails Defines that a more verbose level of logging is required
   * @returns the string representation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /**
   * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.
   */
  applyVerticalCorrection() {
    const rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  }
  /**
   * Gets the current world space position of the camera.
   */
  get globalPosition() {
    return this._globalPosition;
  }
  /**
   * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
   * @returns the active meshe list
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Check whether a mesh is part of the current active mesh list of the camera
   * @param mesh Defines the mesh to check
   * @returns true if active, false otherwise
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Is this camera ready to be used/rendered
   * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
   * @returns true if the camera is ready
   */
  isReady(completeCheck = false) {
    if (completeCheck) {
      for (const pp of this._postProcesses) {
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return super.isReady(completeCheck);
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.obliqueAngle = void 0;
    this._cache.obliqueLength = void 0;
    this._cache.obliqueOffset = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  }
  /** @internal */
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronized()) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  }
  /** @internal */
  _isSynchronizedProjectionMatrix() {
    let isSynchronized = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!isSynchronized) {
      return false;
    }
    const engine = this.getEngine();
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      isSynchronized = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      isSynchronized = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
      if (this.oblique) {
        isSynchronized = isSynchronized && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset;
      }
    }
    return isSynchronized;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(_ignored, _noPreventDefault) {
  }
  /**
   * Detach the current controls from the specified dom element.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   */
  detachControl(_ignored) {
  }
  /**
   * Update the camera state according to the different inputs gathered during the frame.
   */
  update() {
    this._hasMoved = false;
    this._checkInputs();
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
    this.getViewMatrix();
    this.getProjectionMatrix();
  }
  /** @internal */
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  /** @internal */
  get rigCameras() {
    return this._rigCameras;
  }
  /**
   * Gets the post process used by the rig cameras
   */
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  /**
   * Internal, gets the first post process.
   * @returns the first post process to be run on this camera.
   */
  _getFirstPostProcess() {
    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (let i = 0, len = this._rigCameras.length; i < len; i++) {
      const cam = this._rigCameras[i];
      const rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        const isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  }
  /**
   * Attach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to attach to the camera
   * @param insertAt The position of the post process in case several of them are in use in the scene
   * @returns the position the post process has been inserted at
   */
  attachPostProcess(postProcess, insertAt = null) {
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  }
  /**
   * Detach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to detach from the camera
   */
  detachPostProcess(postProcess) {
    const idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  }
  /**
   * Gets the current world matrix of the camera
   * @returns the world matrix
   */
  getWorldMatrix() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  }
  /** @internal */
  _getViewMatrix() {
    return Matrix.Identity();
  }
  /**
   * Gets the current view matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the view matrix
   */
  getViewMatrix(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this._hasMoved = true;
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  }
  /**
   * Freeze the projection matrix.
   * It will prevent the cache check of the camera projection compute and can speed up perf
   * if no parameter of the camera are meant to change
   * @param projection Defines manually a projection if necessary
   */
  freezeProjectionMatrix(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  }
  /**
   * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
   */
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = false;
  }
  /**
   * Gets the current projection matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the projection matrix
   */
  getProjectionMatrix(force) {
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    const engine = this.getEngine();
    const scene = this.getScene();
    const reverseDepth = engine.useReverseDepthBuffer;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      let getProjectionMatrix;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
    } else {
      const halfWidth = engine.getRenderWidth() / 2;
      const halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        if (this.oblique) {
          Matrix.ObliqueOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      } else {
        if (this.oblique) {
          Matrix.ObliqueOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.obliqueAngle = this.oblique?.angle;
      this._cache.obliqueLength = this.oblique?.length;
      this._cache.obliqueOffset = this.oblique?.offset;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
   * @returns a Matrix
   */
  getTransformationMatrix() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  }
  _computeObliqueDistance(offset) {
    const arcRotateCamera = this;
    const targetCamera = this;
    return (arcRotateCamera.radius || (targetCamera.target ? Vector3.Distance(this.position, targetCamera.target) : this.position.length())) + offset;
  }
  /** @internal */
  _updateFrustumPlanes() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
   * @param target The object to check
   * @param checkRigCameras If the rig cameras should be checked (eg. with VR camera both eyes should be checked) (Default: false)
   * @returns true if the object is in frustum otherwise false
   */
  isInFrustum(target, checkRigCameras = false) {
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      let result = false;
      for (const cam of this.rigCameras) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      }
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param target The object to check
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRay(length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param refRay the ray to (re)use when setting the values
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRayToRef(refRay, length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      const index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else {
      let i2 = this._postProcesses.length;
      while (--i2 >= 0) {
        const postProcess = this._postProcesses[i2];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    let i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets.length = 0;
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get isRightCamera() {
    return this._isRightCamera;
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get leftCamera() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0];
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get rightCamera() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1];
  }
  /**
   * Gets the left camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getLeftTarget() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  }
  /**
   * Gets the right camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getRightTarget() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  }
  /**
   * @internal
   */
  setCameraRigMode(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      const leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      const rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setRigMode(rigParams) {
  }
  /** @internal */
  _getVRProjectionMatrix() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  }
  /**
   * @internal
   */
  setCameraRigParameter(name, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name] = value;
    if (name === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  }
  /**
   * needs to be overridden by children so sub has required properties to be copied
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name, cameraIndex) {
    return null;
  }
  /**
   * May need to be overridden by children
   * @internal
   */
  _updateRigCameras() {
    for (let i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === _Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  }
  /** @internal */
  _setupInputs() {
  }
  /**
   * Serialiaze the camera setup to a json representation
   * @returns the JSON representation
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Clones the current camera.
   * @param name The cloned camera name
   * @param newParent The cloned camera's new parent (none by default)
   * @returns the cloned camera
   */
  clone(name, newParent = null) {
    const camera = SerializationHelper.Clone(_Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  }
  /**
   * Gets the direction of the camera relative to a given local axis.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @returns the direction
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Returns the current camera absolute rotation
   */
  get absoluteRotation() {
    this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
    return this._absoluteRotation;
  }
  /**
   * Gets the direction of the camera relative to a given local axis into a passed vector.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @param result Defines the vector to store the result in
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  }
  /**
   * Gets a camera constructor for a given camera type
   * @param type The type of the camera to construct (should be equal to one of the camera class name)
   * @param name The name of the camera the result will be able to instantiate
   * @param scene The scene the result will construct the camera in
   * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
   * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
   * @returns a factory method to construct the camera
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
    const constructorFunc = Node.Construct(type, name, scene, {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return () => _Camera._CreateDefaultParsedCamera(name, scene);
  }
  /**
   * Compute the world  matrix of the camera.
   * @returns the camera world matrix
   */
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  /**
   * Parse a JSON and creates the camera from the parsed information
   * @param parsedCamera The JSON to parse
   * @param scene The scene to instantiate the camera in
   * @returns the newly constructed camera
   */
  static Parse(parsedCamera, scene) {
    const type = parsedCamera.type;
    const construct = _Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (parsedCamera.parentInstanceIndex !== void 0) {
      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        const parsedAnimation = parsedCamera.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  }
  /** @internal */
  _calculateHandednessMultiplier() {
    let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
    if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
      handednessMultiplier *= -1;
    }
    return handednessMultiplier;
  }
};
Camera._CreateDefaultParsedCamera = (name, scene) => {
  throw _WarnImport("UniversalCamera");
};
Camera.PERSPECTIVE_CAMERA = 0;
Camera.ORTHOGRAPHIC_CAMERA = 1;
Camera.FOVMODE_VERTICAL_FIXED = 0;
Camera.FOVMODE_HORIZONTAL_FIXED = 1;
Camera.RIG_MODE_NONE = 0;
Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Camera.RIG_MODE_VR = 20;
Camera.RIG_MODE_CUSTOM = 22;
Camera.ForceAttachControlToAlwaysPreventDefault = false;
__decorate([
  serializeAsVector3("position")
], Camera.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("upVector")
], Camera.prototype, "_upVector", void 0);
__decorate([
  serialize()
], Camera.prototype, "orthoLeft", null);
__decorate([
  serialize()
], Camera.prototype, "orthoRight", null);
__decorate([
  serialize()
], Camera.prototype, "orthoBottom", null);
__decorate([
  serialize()
], Camera.prototype, "orthoTop", null);
__decorate([
  serialize()
], Camera.prototype, "fov", void 0);
__decorate([
  serialize()
], Camera.prototype, "projectionPlaneTilt", void 0);
__decorate([
  serialize()
], Camera.prototype, "minZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "maxZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "inertia", void 0);
__decorate([
  serialize()
], Camera.prototype, "mode", null);
__decorate([
  serialize()
], Camera.prototype, "layerMask", void 0);
__decorate([
  serialize()
], Camera.prototype, "fovMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "cameraRigMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "interaxialDistance", void 0);
__decorate([
  serialize()
], Camera.prototype, "isStereoscopicSideBySide", void 0);

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = class {
};
KeyboardEventTypes.KEYDOWN = 1;
KeyboardEventTypes.KEYUP = 2;
var KeyboardInfo = class {
  /**
   * Instantiates a new keyboard info.
   * This class is used to store keyboard related info for the onKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var KeyboardInfoPre = class extends KeyboardInfo {
  /**
   * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
   * @deprecated use skipOnKeyboardObservable property instead
   */
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(value) {
    this.skipOnKeyboardObservable = value;
  }
  /**
   * Instantiates a new keyboard pre info.
   * This class is used to store keyboard related info for the onPreKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    super(type, event);
    this.type = type;
    this.event = event;
    this.skipOnKeyboardObservable = false;
  }
};

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = class {
};
EventConstants.DOM_DELTA_PIXEL = 0;
EventConstants.DOM_DELTA_LINE = 1;
EventConstants.DOM_DELTA_PAGE = 2;

// node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js
function AddClipPlaneUniforms(uniforms) {
  if (uniforms.indexOf("vClipPlane") === -1) {
    uniforms.push("vClipPlane");
  }
  if (uniforms.indexOf("vClipPlane2") === -1) {
    uniforms.push("vClipPlane2");
  }
  if (uniforms.indexOf("vClipPlane3") === -1) {
    uniforms.push("vClipPlane3");
  }
  if (uniforms.indexOf("vClipPlane4") === -1) {
    uniforms.push("vClipPlane4");
  }
  if (uniforms.indexOf("vClipPlane5") === -1) {
    uniforms.push("vClipPlane5");
  }
  if (uniforms.indexOf("vClipPlane6") === -1) {
    uniforms.push("vClipPlane6");
  }
}
function PrepareStringDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);
  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);
  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);
  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);
  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);
  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);
  if (clipPlane) {
    defines.push("#define CLIPPLANE");
  }
  if (clipPlane2) {
    defines.push("#define CLIPPLANE2");
  }
  if (clipPlane3) {
    defines.push("#define CLIPPLANE3");
  }
  if (clipPlane4) {
    defines.push("#define CLIPPLANE4");
  }
  if (clipPlane5) {
    defines.push("#define CLIPPLANE5");
  }
  if (clipPlane6) {
    defines.push("#define CLIPPLANE6");
  }
}
function PrepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  let changed = false;
  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);
  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);
  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);
  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);
  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);
  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);
  if (defines["CLIPPLANE"] !== clipPlane) {
    defines["CLIPPLANE"] = clipPlane;
    changed = true;
  }
  if (defines["CLIPPLANE2"] !== clipPlane2) {
    defines["CLIPPLANE2"] = clipPlane2;
    changed = true;
  }
  if (defines["CLIPPLANE3"] !== clipPlane3) {
    defines["CLIPPLANE3"] = clipPlane3;
    changed = true;
  }
  if (defines["CLIPPLANE4"] !== clipPlane4) {
    defines["CLIPPLANE4"] = clipPlane4;
    changed = true;
  }
  if (defines["CLIPPLANE5"] !== clipPlane5) {
    defines["CLIPPLANE5"] = clipPlane5;
    changed = true;
  }
  if (defines["CLIPPLANE6"] !== clipPlane6) {
    defines["CLIPPLANE6"] = clipPlane6;
    changed = true;
  }
  return changed;
}
function BindClipPlane(effect, primaryHolder, secondaryHolder) {
  let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;
  SetClipPlane(effect, "vClipPlane", clipPlane);
  clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;
  SetClipPlane(effect, "vClipPlane2", clipPlane);
  clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;
  SetClipPlane(effect, "vClipPlane3", clipPlane);
  clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;
  SetClipPlane(effect, "vClipPlane4", clipPlane);
  clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;
  SetClipPlane(effect, "vClipPlane5", clipPlane);
  clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;
  SetClipPlane(effect, "vClipPlane6", clipPlane);
}
function SetClipPlane(effect, uniformName, clipPlane) {
  if (clipPlane) {
    effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
  }
}

// node_modules/@babylonjs/core/Materials/materialHelper.functions.js
var TempFogColor = { r: 0, g: 0, b: 0 };
var TmpMorphInfluencers = {
  NUM_MORPH_INFLUENCERS: 0,
  NORMAL: false,
  TANGENT: false,
  UV: false,
  UV2: false,
  COLOR: false
};
function BindLogDepth(defines, effect, scene) {
  if (!defines || defines["LOGARITHMICDEPTH"] || defines.indexOf && defines.indexOf("LOGARITHMICDEPTH") >= 0) {
    const camera = scene.activeCamera;
    if (camera.mode === 1) {
      Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
    }
    effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
  }
}
function BindFogParameters(scene, mesh, effect, linearSpace = false) {
  if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== 0) {
    effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
    if (linearSpace) {
      scene.fogColor.toLinearSpaceToRef(TempFogColor, scene.getEngine().useExactSrgbConversions);
      effect.setColor3("vFogColor", TempFogColor);
    } else {
      effect.setColor3("vFogColor", scene.fogColor);
    }
  }
}
function PrepareDefinesAndAttributesForMorphTargets(morphTargetManager, defines, attribs, mesh, usePositionMorph, useNormalMorph, useTangentMorph, useUVMorph, useUV2Morph, useColorMorph) {
  const numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;
  if (numMorphInfluencers <= 0) {
    return 0;
  }
  defines.push("#define MORPHTARGETS");
  if (morphTargetManager.hasPositions) {
    defines.push("#define MORPHTARGETTEXTURE_HASPOSITIONS");
  }
  if (morphTargetManager.hasNormals) {
    defines.push("#define MORPHTARGETTEXTURE_HASNORMALS");
  }
  if (morphTargetManager.hasTangents) {
    defines.push("#define MORPHTARGETTEXTURE_HASTANGENTS");
  }
  if (morphTargetManager.hasUVs) {
    defines.push("#define MORPHTARGETTEXTURE_HASUVS");
  }
  if (morphTargetManager.hasUV2s) {
    defines.push("#define MORPHTARGETTEXTURE_HASUV2S");
  }
  if (morphTargetManager.hasColors) {
    defines.push("#define MORPHTARGETTEXTURE_HASCOLORS");
  }
  if (morphTargetManager.supportsPositions && usePositionMorph) {
    defines.push("#define MORPHTARGETS_POSITION");
  }
  if (morphTargetManager.supportsNormals && useNormalMorph) {
    defines.push("#define MORPHTARGETS_NORMAL");
  }
  if (morphTargetManager.supportsTangents && useTangentMorph) {
    defines.push("#define MORPHTARGETS_TANGENT");
  }
  if (morphTargetManager.supportsUVs && useUVMorph) {
    defines.push("#define MORPHTARGETS_UV");
  }
  if (morphTargetManager.supportsUV2s && useUV2Morph) {
    defines.push("#define MORPHTARGETS_UV2");
  }
  if (morphTargetManager.supportsColors && useColorMorph) {
    defines.push("#define MORPHTARGETS_COLOR");
  }
  defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
  if (morphTargetManager.isUsingTextureForTargets) {
    defines.push("#define MORPHTARGETS_TEXTURE");
  }
  TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = numMorphInfluencers;
  TmpMorphInfluencers.NORMAL = useNormalMorph;
  TmpMorphInfluencers.TANGENT = useTangentMorph;
  TmpMorphInfluencers.UV = useUVMorph;
  TmpMorphInfluencers.UV2 = useUV2Morph;
  TmpMorphInfluencers.COLOR = useColorMorph;
  PrepareAttributesForMorphTargets(attribs, mesh, TmpMorphInfluencers, usePositionMorph);
  return numMorphInfluencers;
}
function PrepareAttributesForMorphTargets(attribs, mesh, defines, usePositionMorph = true) {
  const influencers = defines["NUM_MORPH_INFLUENCERS"];
  if (influencers > 0 && EngineStore.LastCreatedEngine) {
    const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
    const manager = mesh.morphTargetManager;
    if (manager?.isUsingTextureForTargets) {
      return;
    }
    const position = manager && manager.supportsPositions && usePositionMorph;
    const normal = manager && manager.supportsNormals && defines["NORMAL"];
    const tangent = manager && manager.supportsTangents && defines["TANGENT"];
    const uv = manager && manager.supportsUVs && defines["UV1"];
    const uv2 = manager && manager.supportsUV2s && defines["UV2"];
    const color = manager && manager.supportsColors && defines["VERTEXCOLOR"];
    for (let index = 0; index < influencers; index++) {
      if (position) {
        attribs.push(`position` + index);
      }
      if (normal) {
        attribs.push(`normal` + index);
      }
      if (tangent) {
        attribs.push(`tangent` + index);
      }
      if (uv) {
        attribs.push(`uv_` + index);
      }
      if (uv2) {
        attribs.push(`uv2_` + index);
      }
      if (color) {
        attribs.push(`color` + index);
      }
      if (attribs.length > maxAttributesCount) {
        Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
      }
    }
  }
}
function PushAttributesForInstances(attribs, needsPreviousMatrices = false) {
  attribs.push("world0");
  attribs.push("world1");
  attribs.push("world2");
  attribs.push("world3");
  if (needsPreviousMatrices) {
    attribs.push("previousWorld0");
    attribs.push("previousWorld1");
    attribs.push("previousWorld2");
    attribs.push("previousWorld3");
  }
}
function BindMorphTargetParameters(abstractMesh, effect) {
  const manager = abstractMesh.morphTargetManager;
  if (!abstractMesh || !manager) {
    return;
  }
  effect.setFloatArray("morphTargetInfluences", manager.influences);
}
function BindSceneUniformBuffer(effect, sceneUbo) {
  sceneUbo.bindToEffect(effect, "Scene");
}
function PrepareDefinesForMergedUV(texture, defines, key) {
  defines._needUVs = true;
  defines[key] = true;
  if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {
    defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
    defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
  } else {
    defines[key + "DIRECTUV"] = 0;
  }
}
function BindTextureMatrix(texture, uniformBuffer, key) {
  const matrix = texture.getTextureMatrix();
  uniformBuffer.updateMatrix(key + "Matrix", matrix);
}
function PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {
  const enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
  if (enabled) {
    attribs.push("bakedVertexAnimationSettingsInstanced");
  }
}
function CopyBonesTransformationMatrices(source, target) {
  target.set(source);
  return target;
}
function BindBonesParameters(mesh, effect, prePassConfiguration) {
  if (!effect || !mesh) {
    return;
  }
  if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
    mesh.computeBonesUsingShaders = false;
  }
  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
    const skeleton = mesh.skeleton;
    if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
      const boneTexture = skeleton.getTransformMatrixTexture(mesh);
      effect.setTexture("boneSampler", boneTexture);
      effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
    } else {
      const matrices = skeleton.getTransformMatrices(mesh);
      if (matrices) {
        effect.setMatrices("mBones", matrices);
        if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
          if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
          }
          effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
          CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
        }
      }
    }
  }
}
function BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {
  light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
}
function BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {
  const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
  for (let i = 0; i < len; i++) {
    const light = mesh.lightSources[i];
    BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
  }
}
function PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {
  if (defines["NUM_BONE_INFLUENCERS"] > 0) {
    fallbacks.addCPUSkinningFallback(0, mesh);
    attribs.push(`matricesIndices`);
    attribs.push(`matricesWeights`);
    if (defines["NUM_BONE_INFLUENCERS"] > 4) {
      attribs.push(`matricesIndicesExtra`);
      attribs.push(`matricesWeightsExtra`);
    }
  }
}
function PrepareAttributesForInstances(attribs, defines) {
  if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
    PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
  }
  if (defines.INSTANCESCOLOR) {
    attribs.push(`instanceColor`);
  }
}
function HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {
  let lightFallbackRank = 0;
  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
    if (!defines["LIGHT" + lightIndex]) {
      break;
    }
    if (lightIndex > 0) {
      lightFallbackRank = rank + lightIndex;
      fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
    }
    if (!defines["SHADOWS"]) {
      if (defines["SHADOW" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOW" + lightIndex);
      }
      if (defines["SHADOWPCF" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
      }
      if (defines["SHADOWPCSS" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
      }
      if (defines["SHADOWPOISSON" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
      }
      if (defines["SHADOWESM" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
      }
      if (defines["SHADOWCLOSEESM" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
      }
    }
  }
  return lightFallbackRank++;
}
function GetFogState(mesh, scene) {
  return scene.fogEnabled && mesh.applyFog && scene.fogMode !== 0;
}
function PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false, useVertexPulling = false, renderingMesh) {
  if (defines._areMiscDirty) {
    defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
    defines["POINTSIZE"] = pointsCloud;
    defines["FOG"] = fogEnabled && GetFogState(mesh, scene);
    defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
    defines["ALPHATEST"] = alphaTest;
    defines["DECAL_AFTER_DETAIL"] = applyDecalAfterDetail;
    defines["USE_VERTEX_PULLING"] = useVertexPulling;
    const indexBuffer = renderingMesh?.geometry?.getIndexBuffer();
    defines["VERTEX_PULLING_USE_INDEX_BUFFER"] = !!indexBuffer;
    defines["VERTEX_PULLING_INDEX_BUFFER_32BITS"] = indexBuffer ? indexBuffer.is32Bits : false;
  }
}
function PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {
  if (!defines._areLightsDirty) {
    return defines._needNormals;
  }
  let lightIndex = 0;
  const state = {
    needNormals: defines._needNormals,
    // prevents overriding previous reflection or other needs for normals
    needRebuild: false,
    lightmapMode: false,
    shadowEnabled: false,
    specularEnabled: false
  };
  if (scene.lightsEnabled && !disableLighting) {
    for (const light of mesh.lightSources) {
      PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
      lightIndex++;
      if (lightIndex === maxSimultaneousLights) {
        break;
      }
    }
  }
  defines["SPECULARTERM"] = state.specularEnabled;
  defines["SHADOWS"] = state.shadowEnabled;
  for (let index = lightIndex; index < maxSimultaneousLights; index++) {
    if (defines["LIGHT" + index] !== void 0) {
      defines["LIGHT" + index] = false;
      defines["HEMILIGHT" + index] = false;
      defines["POINTLIGHT" + index] = false;
      defines["DIRLIGHT" + index] = false;
      defines["SPOTLIGHT" + index] = false;
      defines["AREALIGHT" + index] = false;
      defines["CLUSTLIGHT" + index] = false;
      defines["SHADOW" + index] = false;
      defines["SHADOWCSM" + index] = false;
      defines["SHADOWCSMDEBUG" + index] = false;
      defines["SHADOWCSMNUM_CASCADES" + index] = false;
      defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
      defines["SHADOWCSMNOBLEND" + index] = false;
      defines["SHADOWCSM_RIGHTHANDED" + index] = false;
      defines["SHADOWPCF" + index] = false;
      defines["SHADOWPCSS" + index] = false;
      defines["SHADOWPOISSON" + index] = false;
      defines["SHADOWESM" + index] = false;
      defines["SHADOWCLOSEESM" + index] = false;
      defines["SHADOWCUBE" + index] = false;
      defines["SHADOWLOWQUALITY" + index] = false;
      defines["SHADOWMEDIUMQUALITY" + index] = false;
    }
  }
  const caps = scene.getEngine().getCaps();
  if (defines["SHADOWFLOAT"] === void 0) {
    state.needRebuild = true;
  }
  defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
  defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
  if (state.needRebuild) {
    defines.rebuild();
  }
  return state.needNormals;
}
function PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {
  state.needNormals = true;
  if (defines["LIGHT" + lightIndex] === void 0) {
    state.needRebuild = true;
  }
  defines["LIGHT" + lightIndex] = true;
  defines["SPOTLIGHT" + lightIndex] = false;
  defines["HEMILIGHT" + lightIndex] = false;
  defines["POINTLIGHT" + lightIndex] = false;
  defines["DIRLIGHT" + lightIndex] = false;
  defines["AREALIGHT" + lightIndex] = false;
  light.prepareLightSpecificDefines(defines, lightIndex);
  defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
  defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
  defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
  switch (light.falloffType) {
    case LightConstants.FALLOFF_GLTF:
      defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
      break;
    case LightConstants.FALLOFF_PHYSICAL:
      defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
      break;
    case LightConstants.FALLOFF_STANDARD:
      defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
      break;
  }
  if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
    state.specularEnabled = true;
  }
  defines["SHADOW" + lightIndex] = false;
  defines["SHADOWCSM" + lightIndex] = false;
  defines["SHADOWCSMDEBUG" + lightIndex] = false;
  defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
  defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
  defines["SHADOWCSMNOBLEND" + lightIndex] = false;
  defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
  defines["SHADOWPCF" + lightIndex] = false;
  defines["SHADOWPCSS" + lightIndex] = false;
  defines["SHADOWPOISSON" + lightIndex] = false;
  defines["SHADOWESM" + lightIndex] = false;
  defines["SHADOWCLOSEESM" + lightIndex] = false;
  defines["SHADOWCUBE" + lightIndex] = false;
  defines["SHADOWLOWQUALITY" + lightIndex] = false;
  defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
  if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
    const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();
    if (shadowGenerator) {
      const shadowMap = shadowGenerator.getShadowMap();
      if (shadowMap) {
        if (shadowMap.renderList && shadowMap.renderList.length > 0) {
          state.shadowEnabled = true;
          shadowGenerator.prepareDefines(defines, lightIndex);
        }
      }
    }
  }
  if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {
    state.lightmapMode = true;
    defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
    defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;
  } else {
    defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
    defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
  }
}
function PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {
  let changed = PrepareDefinesForCamera(scene, defines);
  if (useClipPlane !== false) {
    changed = PrepareDefinesForClipPlanes(material, scene, defines);
  }
  if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
    defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
    changed = true;
  }
  if (defines["INSTANCES"] !== useInstances) {
    defines["INSTANCES"] = useInstances;
    changed = true;
  }
  if (defines["THIN_INSTANCES"] !== useThinInstances) {
    defines["THIN_INSTANCES"] = useThinInstances;
    changed = true;
  }
  if (changed) {
    defines.markAsUnprocessed();
  }
}
function PrepareDefinesForBones(mesh, defines) {
  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
    defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
    const materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
    if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
      defines["BONETEXTURE"] = true;
    } else {
      defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
      defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
      const prePassRenderer = mesh.getScene().prePassRenderer;
      if (prePassRenderer && prePassRenderer.enabled) {
        const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
        defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
      }
    }
  } else {
    defines["NUM_BONE_INFLUENCERS"] = 0;
    defines["BonesPerMesh"] = 0;
    if (defines["BONETEXTURE"] !== void 0) {
      defines["BONETEXTURE"] = false;
    }
  }
}
function PrepareDefinesForMorphTargets(mesh, defines) {
  const manager = mesh.morphTargetManager;
  if (manager) {
    defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
    defines["MORPHTARGETS_UV2"] = manager.supportsUV2s && defines["UV2"];
    defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
    defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
    defines["MORPHTARGETS_POSITION"] = manager.supportsPositions;
    defines["MORPHTARGETS_COLOR"] = manager.supportsColors;
    defines["MORPHTARGETTEXTURE_HASUVS"] = manager.hasUVs;
    defines["MORPHTARGETTEXTURE_HASUV2S"] = manager.hasUV2s;
    defines["MORPHTARGETTEXTURE_HASTANGENTS"] = manager.hasTangents;
    defines["MORPHTARGETTEXTURE_HASNORMALS"] = manager.hasNormals;
    defines["MORPHTARGETTEXTURE_HASPOSITIONS"] = manager.hasPositions;
    defines["MORPHTARGETTEXTURE_HASCOLORS"] = manager.hasColors;
    defines["NUM_MORPH_INFLUENCERS"] = manager.numMaxInfluencers || manager.numInfluencers;
    defines["MORPHTARGETS"] = defines["NUM_MORPH_INFLUENCERS"] > 0;
    defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
  } else {
    defines["MORPHTARGETS_UV"] = false;
    defines["MORPHTARGETS_UV2"] = false;
    defines["MORPHTARGETS_TANGENT"] = false;
    defines["MORPHTARGETS_NORMAL"] = false;
    defines["MORPHTARGETS_POSITION"] = false;
    defines["MORPHTARGETS_COLOR"] = false;
    defines["MORPHTARGETTEXTURE_HASUVS"] = false;
    defines["MORPHTARGETTEXTURE_HASUV2S"] = false;
    defines["MORPHTARGETTEXTURE_HASTANGENTS"] = false;
    defines["MORPHTARGETTEXTURE_HASNORMALS"] = false;
    defines["MORPHTARGETTEXTURE_HASPOSITIONS"] = false;
    defines["MORPHTARGETTEXTURE_HAS_COLORS"] = false;
    defines["MORPHTARGETS"] = false;
    defines["NUM_MORPH_INFLUENCERS"] = 0;
  }
}
function PrepareDefinesForBakedVertexAnimation(mesh, defines) {
  const manager = mesh.bakedVertexAnimationManager;
  defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
}
function PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {
  if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
    return false;
  }
  defines._normals = defines._needNormals;
  defines._uvs = defines._needUVs;
  defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(`normal`);
  if (defines._needNormals && mesh.isVerticesDataPresent(`tangent`)) {
    defines["TANGENT"] = true;
  }
  for (let i = 1; i <= 6; ++i) {
    defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`) : false;
  }
  if (useVertexColor) {
    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(`color`);
    defines["VERTEXCOLOR"] = hasVertexColors;
    defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
  }
  if (mesh.isVerticesDataPresent(`instanceColor`) && (mesh.hasInstances || mesh.hasThinInstances)) {
    defines["INSTANCESCOLOR"] = true;
  }
  if (useBones) {
    PrepareDefinesForBones(mesh, defines);
  }
  if (useMorphTargets) {
    PrepareDefinesForMorphTargets(mesh, defines);
  }
  if (useBakedVertexAnimation) {
    PrepareDefinesForBakedVertexAnimation(mesh, defines);
  }
  return true;
}
function PrepareDefinesForMultiview(scene, defines) {
  if (scene.activeCamera) {
    const previousMultiview = defines.MULTIVIEW;
    defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
    if (defines.MULTIVIEW != previousMultiview) {
      defines.markAsUnprocessed();
    }
  }
}
function PrepareDefinesForOIT(scene, defines, needAlphaBlending) {
  const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
  const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
  defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
  defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
  if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
    defines.markAsUnprocessed();
  }
}
function PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {
  const previousPrePass = defines.PREPASS;
  if (!defines._arePrePassDirty) {
    return;
  }
  const texturesList = [
    {
      type: 1,
      define: "PREPASS_POSITION",
      index: "PREPASS_POSITION_INDEX"
    },
    {
      type: 9,
      define: "PREPASS_LOCAL_POSITION",
      index: "PREPASS_LOCAL_POSITION_INDEX"
    },
    {
      type: 2,
      define: "PREPASS_VELOCITY",
      index: "PREPASS_VELOCITY_INDEX"
    },
    {
      type: 11,
      define: "PREPASS_VELOCITY_LINEAR",
      index: "PREPASS_VELOCITY_LINEAR_INDEX"
    },
    {
      type: 3,
      define: "PREPASS_REFLECTIVITY",
      index: "PREPASS_REFLECTIVITY_INDEX"
    },
    {
      type: 0,
      define: "PREPASS_IRRADIANCE",
      index: "PREPASS_IRRADIANCE_INDEX"
    },
    {
      type: 7,
      define: "PREPASS_ALBEDO_SQRT",
      index: "PREPASS_ALBEDO_SQRT_INDEX"
    },
    {
      type: 5,
      define: "PREPASS_DEPTH",
      index: "PREPASS_DEPTH_INDEX"
    },
    {
      type: 10,
      define: "PREPASS_SCREENSPACE_DEPTH",
      index: "PREPASS_SCREENSPACE_DEPTH_INDEX"
    },
    {
      type: 6,
      define: "PREPASS_NORMAL",
      index: "PREPASS_NORMAL_INDEX"
    },
    {
      type: 8,
      define: "PREPASS_WORLD_NORMAL",
      index: "PREPASS_WORLD_NORMAL_INDEX"
    }
  ];
  if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
    defines.PREPASS = true;
    defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
    defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;
    defines.PREPASS_COLOR = true;
    defines.PREPASS_COLOR_INDEX = 0;
    for (let i = 0; i < texturesList.length; i++) {
      const index = scene.prePassRenderer.getIndex(texturesList[i].type);
      if (index !== -1) {
        defines[texturesList[i].define] = true;
        defines[texturesList[i].index] = index;
      } else {
        defines[texturesList[i].define] = false;
      }
    }
  } else {
    defines.PREPASS = false;
    for (let i = 0; i < texturesList.length; i++) {
      defines[texturesList[i].define] = false;
    }
  }
  if (defines.PREPASS != previousPrePass) {
    defines.markAsUnprocessed();
    defines.markAsImageProcessingDirty();
  }
}
function PrepareDefinesForCamera(scene, defines) {
  let changed = false;
  if (scene.activeCamera) {
    const wasOrtho = defines["CAMERA_ORTHOGRAPHIC"] ? 1 : 0;
    const wasPersp = defines["CAMERA_PERSPECTIVE"] ? 1 : 0;
    const isOrtho = scene.activeCamera.mode === 1 ? 1 : 0;
    const isPersp = scene.activeCamera.mode === 0 ? 1 : 0;
    if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {
      defines["CAMERA_ORTHOGRAPHIC"] = isOrtho === 1;
      defines["CAMERA_PERSPECTIVE"] = isPersp === 1;
      changed = true;
    }
  }
  return changed;
}
function PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false, iesLightTexture = false, clusteredLightTextures = false) {
  if (uniformBuffersList) {
    uniformBuffersList.push("Light" + lightIndex);
  }
  if (updateOnlyBuffersList) {
    return;
  }
  uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightWidth" + lightIndex, "vLightHeight" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "vNumLights" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
  samplersList.push("shadowTexture" + lightIndex);
  samplersList.push("depthTexture" + lightIndex);
  uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
  if (projectedLightTexture) {
    samplersList.push("projectionLightTexture" + lightIndex);
    uniformsList.push("textureProjectionMatrix" + lightIndex);
  }
  if (iesLightTexture) {
    samplersList.push("iesLightTexture" + lightIndex);
  }
  if (clusteredLightTextures) {
    samplersList.push("lightDataTexture" + lightIndex);
    samplersList.push("tileMaskTexture" + lightIndex);
  }
}
function PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {
  let uniformsList;
  let uniformBuffersList;
  if (uniformsListOrOptions.uniformsNames) {
    const options = uniformsListOrOptions;
    uniformsList = options.uniformsNames;
    uniformBuffersList = options.uniformBuffersNames;
    samplersList = options.samplers;
    defines = options.defines;
    maxSimultaneousLights = options.maxSimultaneousLights || 0;
  } else {
    uniformsList = uniformsListOrOptions;
    if (!samplersList) {
      samplersList = [];
    }
  }
  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
    if (!defines["LIGHT" + lightIndex]) {
      break;
    }
    PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList, false, defines["IESLIGHTTEXTURE" + lightIndex], defines["CLUSTLIGHT" + lightIndex]);
  }
  if (defines["NUM_MORPH_INFLUENCERS"]) {
    uniformsList.push("morphTargetInfluences");
    uniformsList.push("morphTargetCount");
  }
  if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
    uniformsList.push("bakedVertexAnimationSettings");
    uniformsList.push("bakedVertexAnimationTextureSizeInverted");
    uniformsList.push("bakedVertexAnimationTime");
    samplersList.push("bakedVertexAnimationTexture");
  }
}

export {
  SceneComponentConstants,
  Stage,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  EventConstants,
  AddClipPlaneUniforms,
  PrepareStringDefinesForClipPlanes,
  BindClipPlane,
  BindLogDepth,
  BindFogParameters,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareAttributesForMorphTargets,
  PushAttributesForInstances,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  PrepareDefinesForMergedUV,
  BindTextureMatrix,
  PrepareAttributesForBakedVertexAnimation,
  BindBonesParameters,
  BindLights,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  HandleFallbacksForShadows,
  PrepareDefinesForMisc,
  PrepareDefinesForLights,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForAttributes,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareDefinesForCamera,
  PrepareUniformsAndSamplersList,
  Camera
};
//# sourceMappingURL=chunk-QOP5NI3Q.js.map
