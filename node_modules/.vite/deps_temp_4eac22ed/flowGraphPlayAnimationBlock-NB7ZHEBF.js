import {
  AnimationGroup
} from "./chunk-QC2UWP5V.js";
import {
  FlowGraphAsyncExecutionBlock
} from "./chunk-V7OD57DN.js";
import "./chunk-7T64QMON.js";
import "./chunk-7HLYKKC3.js";
import {
  RichTypeAny,
  RichTypeBoolean,
  RichTypeNumber
} from "./chunk-24E766OR.js";
import "./chunk-74Y5RBMR.js";
import "./chunk-ZZAFB4NW.js";
import "./chunk-FZVH2M7E.js";
import "./chunk-TOAF46MT.js";
import "./chunk-6W4IL5BZ.js";
import "./chunk-GJUHN7CQ.js";
import "./chunk-TXNJXLHN.js";
import "./chunk-T2KPYHB2.js";
import "./chunk-GFXF2AHA.js";
import "./chunk-M53QMGBN.js";
import "./chunk-TTTM2ZA3.js";
import "./chunk-UQXX2ELX.js";
import "./chunk-HCQBYAVY.js";
import "./chunk-WFUT4Z3P.js";
import "./chunk-ZUYDMD2E.js";
import "./chunk-VUEY77GS.js";
import "./chunk-4U4OQIRL.js";
import "./chunk-ZNU3MEW5.js";
import "./chunk-QOP5NI3Q.js";
import "./chunk-HXUTTYUP.js";
import "./chunk-WAGTS43G.js";
import "./chunk-Z6JOOBR6.js";
import "./chunk-4NB4CRH6.js";
import "./chunk-QX3YVE2B.js";
import "./chunk-SZB5QSYK.js";
import "./chunk-HH35OB2V.js";
import "./chunk-6IPU5VHY.js";
import "./chunk-S6ZVB5LK.js";
import "./chunk-GSPIZSPI.js";
import "./chunk-45CX3ICK.js";
import "./chunk-BCSSHDM5.js";
import "./chunk-ET26GHHM.js";
import "./chunk-UKGB4G3Q.js";
import "./chunk-7ZXDP25H.js";
import "./chunk-FF6PSLVD.js";
import "./chunk-5WNYDBYJ.js";
import "./chunk-M3TRY6IC.js";
import "./chunk-ZRPHACZ5.js";
import "./chunk-AFHJPRX3.js";
import "./chunk-NOD22NBO.js";
import "./chunk-5LTYGTJL.js";
import "./chunk-HDYUJUBP.js";
import "./chunk-2ZEUD233.js";
import "./chunk-7XY2OFQB.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-I4NFOKIT.js";
import "./chunk-OEZCBW2S.js";
import {
  RegisterClass
} from "./chunk-MIVJKRRS.js";
import "./chunk-NTQN2BXV.js";
import "./chunk-VHGUPH2V.js";
import "./chunk-OWCZTH5B.js";
import "./chunk-CZRRPEW3.js";
import "./chunk-J4DZ2XK7.js";
import "./chunk-3DTNSITF.js";
import "./chunk-GCT36VBF.js";
import "./chunk-FX6MN5HL.js";
import "./chunk-HKJ2B2AA.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/Animation/flowGraphPlayAnimationBlock.js
var FlowGraphPlayAnimationBlock = class extends FlowGraphAsyncExecutionBlock {
  constructor(config) {
    super(config, ["animationLoop", "animationEnd", "animationGroupLoop"]);
    this.config = config;
    this.speed = this.registerDataInput("speed", RichTypeNumber);
    this.loop = this.registerDataInput("loop", RichTypeBoolean);
    this.from = this.registerDataInput("from", RichTypeNumber, 0);
    this.to = this.registerDataInput("to", RichTypeNumber);
    this.currentFrame = this.registerDataOutput("currentFrame", RichTypeNumber);
    this.currentTime = this.registerDataOutput("currentTime", RichTypeNumber);
    this.currentAnimationGroup = this.registerDataOutput("currentAnimationGroup", RichTypeAny);
    this.animationGroup = this.registerDataInput("animationGroup", RichTypeAny, config?.animationGroup);
    this.animation = this.registerDataInput("animation", RichTypeAny);
    this.object = this.registerDataInput("object", RichTypeAny);
  }
  /**
   * @internal
   * @param context
   */
  _preparePendingTasks(context) {
    const ag = this.animationGroup.getValue(context);
    const animation = this.animation.getValue(context);
    if (!ag && !animation) {
      return this._reportError(context, "No animation or animation group provided");
    } else {
      const currentAnimationGroup = this.currentAnimationGroup.getValue(context);
      if (currentAnimationGroup && currentAnimationGroup !== ag) {
        currentAnimationGroup.dispose();
      }
      let animationGroupToUse = ag;
      if (animation && !animationGroupToUse) {
        const target = this.object.getValue(context);
        if (!target) {
          return this._reportError(context, "No target object provided");
        }
        const animationsArray = Array.isArray(animation) ? animation : [animation];
        const name = animationsArray[0].name;
        animationGroupToUse = new AnimationGroup("flowGraphAnimationGroup-" + name + "-" + target.name, context.configuration.scene);
        let isInterpolation = false;
        const interpolationAnimations = context._getGlobalContextVariable("interpolationAnimations", []);
        for (const anim of animationsArray) {
          animationGroupToUse.addTargetedAnimation(anim, target);
          if (interpolationAnimations.indexOf(anim.uniqueId) !== -1) {
            isInterpolation = true;
          }
        }
        if (isInterpolation) {
          this._checkInterpolationDuplications(context, animationsArray, target);
        }
      }
      const speed = this.speed.getValue(context) || 1;
      const from = this.from.getValue(context) ?? 0;
      const to = this.to.getValue(context) || animationGroupToUse.to;
      const loop = !isFinite(to) || this.loop.getValue(context);
      this.currentAnimationGroup.setValue(animationGroupToUse, context);
      const currentlyRunningAnimationGroups = context._getGlobalContextVariable("currentlyRunningAnimationGroups", []);
      if (currentlyRunningAnimationGroups.indexOf(animationGroupToUse.uniqueId) !== -1) {
        animationGroupToUse.stop();
      }
      try {
        animationGroupToUse.start(loop, speed, from, to);
        animationGroupToUse.onAnimationGroupEndObservable.add(() => this._onAnimationGroupEnd(context));
        animationGroupToUse.onAnimationEndObservable.add(() => this._eventsSignalOutputs["animationEnd"]._activateSignal(context));
        animationGroupToUse.onAnimationLoopObservable.add(() => this._eventsSignalOutputs["animationLoop"]._activateSignal(context));
        animationGroupToUse.onAnimationGroupLoopObservable.add(() => this._eventsSignalOutputs["animationGroupLoop"]._activateSignal(context));
        currentlyRunningAnimationGroups.push(animationGroupToUse.uniqueId);
        context._setGlobalContextVariable("currentlyRunningAnimationGroups", currentlyRunningAnimationGroups);
      } catch (e) {
        this._reportError(context, e);
      }
    }
  }
  _reportError(context, error) {
    super._reportError(context, error);
    this.currentFrame.setValue(-1, context);
    this.currentTime.setValue(-1, context);
  }
  /**
   * @internal
   */
  _executeOnTick(_context) {
    const ag = this.currentAnimationGroup.getValue(_context);
    if (ag) {
      this.currentFrame.setValue(ag.getCurrentFrame(), _context);
      this.currentTime.setValue(ag.animatables[0]?.elapsedTime ?? 0, _context);
    }
  }
  _execute(context) {
    this._startPendingTasks(context);
  }
  _onAnimationGroupEnd(context) {
    this._removeFromCurrentlyRunning(context, this.currentAnimationGroup.getValue(context));
    this._resetAfterCanceled(context);
    this.done._activateSignal(context);
  }
  /**
   * The idea behind this function is to check every running animation group and check if the targeted animations it uses are interpolation animations.
   * If they are, we want to see that they don't collide with the current interpolation animations that are starting to play.
   * If they do, we want to stop the already-running animation group.
   * @internal
   */
  _checkInterpolationDuplications(context, animation, target) {
    const currentlyRunningAnimationGroups = context._getGlobalContextVariable("currentlyRunningAnimationGroups", []);
    for (const uniqueId of currentlyRunningAnimationGroups) {
      const ag = context.assetsContext.animationGroups.find((ag2) => ag2.uniqueId === uniqueId);
      if (ag) {
        for (const anim of ag.targetedAnimations) {
          for (const animToCheck of animation) {
            if (anim.animation.targetProperty === animToCheck.targetProperty && anim.target === target) {
              this._stopAnimationGroup(context, ag);
            }
          }
        }
      }
    }
  }
  _stopAnimationGroup(context, animationGroup) {
    animationGroup.stop(true);
    animationGroup.dispose();
    this._removeFromCurrentlyRunning(context, animationGroup);
  }
  _removeFromCurrentlyRunning(context, animationGroup) {
    const currentlyRunningAnimationGroups = context._getGlobalContextVariable("currentlyRunningAnimationGroups", []);
    const idx = currentlyRunningAnimationGroups.indexOf(animationGroup.uniqueId);
    if (idx !== -1) {
      currentlyRunningAnimationGroups.splice(idx, 1);
      context._setGlobalContextVariable("currentlyRunningAnimationGroups", currentlyRunningAnimationGroups);
    }
  }
  /**
   * @internal
   * Stop any currently running animations.
   */
  _cancelPendingTasks(context) {
    const ag = this.currentAnimationGroup.getValue(context);
    if (ag) {
      this._stopAnimationGroup(context, ag);
    }
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return "FlowGraphPlayAnimationBlock";
  }
};
RegisterClass("FlowGraphPlayAnimationBlock", FlowGraphPlayAnimationBlock);
export {
  FlowGraphPlayAnimationBlock
};
//# sourceMappingURL=flowGraphPlayAnimationBlock-NB7ZHEBF.js.map
