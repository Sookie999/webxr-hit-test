{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    /**\r\n     * Which pointer ID is currently down (only for mouse events, not used for touch events)\r\n     */\r\n    private _currentMousePointerIdDown: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (\r\n                p.type !== PointerEventTypes.POINTERDOWN &&\r\n                p.type !== PointerEventTypes.POINTERDOUBLETAP &&\r\n                isTouch &&\r\n                this._pointA?.pointerId !== evt.pointerId &&\r\n                this._pointB?.pointerId !== evt.pointerId\r\n            ) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentMousePointerIdDown === -1 && !isTouch) {\r\n                    this._currentMousePointerIdDown = evt.pointerId;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    if (element) {\r\n                        element.focus();\r\n                    }\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentMousePointerIdDown = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        if (element) {\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n        }\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                if (inputElement) {\r\n                    inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n                }\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentMousePointerIdDown = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public override buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public override onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public override onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst FfMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? FfMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20; i++) {\r\n                            // 20 iterations should be enough to converge\r\n                            if (estimatedTargetRadius <= targetInertia) {\r\n                                // We do not want a negative radius, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            if (Math.abs(targetInertia * this.camera.inertia) < 0.001) {\r\n                                // We do not want to go below a certain threshold, so we break out of the loop\r\n                                break;\r\n                            }\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
