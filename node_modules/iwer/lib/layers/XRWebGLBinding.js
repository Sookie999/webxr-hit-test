/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { P_SESSION } from '../private.js';
import { XRSession } from '../session/XRSession.js';
/**
 * XRProjectionLayer implementation that mimics the behavior of XRWebGLLayer
 * but with the projection layer API surface.
 */
class XRProjectionLayer {
    constructor(_session, context, _init = {}) {
        this._fixedFoveation = 0;
        console.log('[IWER] XRProjectionLayer constructor:', {
            context: context.constructor.name,
            canvas: context.canvas,
            drawingBufferWidth: context.drawingBufferWidth,
            drawingBufferHeight: context.drawingBufferHeight,
            init: _init
        });
        this.context = context;
    }
    /**
     * Texture width - maps to XRWebGLLayer.framebufferWidth
     */
    get textureWidth() {
        const width = this.context.drawingBufferWidth;
        console.log('[IWER] XRProjectionLayer.textureWidth:', width);
        return width;
    }
    /**
     * Texture height - maps to XRWebGLLayer.framebufferHeight
     */
    get textureHeight() {
        const height = this.context.drawingBufferHeight;
        console.log('[IWER] XRProjectionLayer.textureHeight:', height);
        return height;
    }
    /**
     * Ignore depth values - matches XRWebGLLayer behavior
     */
    get ignoreDepthValues() {
        console.log('[IWER] XRProjectionLayer.ignoreDepthValues: true');
        return true;
    }
    /**
     * Fixed foveation setting
     */
    get fixedFoveation() {
        console.log('[IWER] XRProjectionLayer.fixedFoveation get:', this._fixedFoveation);
        return this._fixedFoveation;
    }
    set fixedFoveation(value) {
        console.log('[IWER] XRProjectionLayer.fixedFoveation set:', value);
        this._fixedFoveation = value;
    }
    /**
     * Layout type for the projection layer
     */
    get layout() {
        console.log('[IWER] XRProjectionLayer.layout: mono');
        return 'mono';
    }
    /**
     * Blend texture source alpha
     */
    get blendTextureSourceAlpha() {
        console.log('[IWER] XRProjectionLayer.blendTextureSourceAlpha: false');
        return false;
    }
    /**
     * Chromatic aberration correction
     */
    get chromaticAberrationCorrection() {
        console.log('[IWER] XRProjectionLayer.chromaticAberrationCorrection: true');
        return true;
    }
}
/**
 * XRWebGLBinding provides methods to create WebGL resources
 * that are compatible with WebXR rendering.
 *
 * This implementation provides a polyfill that ensures three.js r179+
 * gets the same behavior as the XRWebGLLayer fallback path.
 */
export class XRWebGLBinding {
    constructor(session, context, _layerInit = {}) {
        console.log('[IWER] XRWebGLBinding constructor called:', {
            session: session.constructor.name,
            context: context.constructor.name,
            canvas: context.canvas,
            drawingBufferWidth: context.drawingBufferWidth,
            drawingBufferHeight: context.drawingBufferHeight,
            layerInit: _layerInit
        });
        // Validate session
        if (!(session instanceof XRSession)) {
            console.error('[IWER] XRWebGLBinding: Invalid session type');
            throw new TypeError('XRWebGLBinding constructor argument 1 is not of type XRSession');
        }
        // Check if session has ended
        if (session[P_SESSION].ended) {
            console.error('[IWER] XRWebGLBinding: Session has ended');
            throw new DOMException('Session has ended', 'InvalidStateError');
        }
        // Validate WebGL context
        if (!context || (!(context instanceof WebGLRenderingContext) &&
            !(context instanceof WebGL2RenderingContext))) {
            console.error('[IWER] XRWebGLBinding: Invalid WebGL context');
            throw new TypeError('XRWebGLBinding constructor argument 2 is not a valid WebGL context');
        }
        this.session = session;
        this.context = context;
        console.log('[IWER] XRWebGLBinding constructor completed successfully');
    }
    /**
     * Creates a projection layer that behaves exactly like XRWebGLLayer
     * but with the projection layer API surface that three.js r179+ expects.
     */
    createProjectionLayer(init = {}) {
        console.log('[IWER] XRWebGLBinding.createProjectionLayer called with init:', init);
        const projectionLayer = new XRProjectionLayer(this.session, this.context, init);
        console.log('[IWER] XRWebGLBinding.createProjectionLayer created layer:', {
            textureWidth: projectionLayer.textureWidth,
            textureHeight: projectionLayer.textureHeight,
            ignoreDepthValues: projectionLayer.ignoreDepthValues,
            layout: projectionLayer.layout
        });
        return projectionLayer;
    }
    /**
     * Gets the viewport for a given view and layer.
     * This is used by three.js for sub-image rendering.
     */
    getViewSubImage(_layer, _view) {
        console.log('[IWER] XRWebGLBinding.getViewSubImage called:', {
            layer: _layer,
            view: _view
        });
        // For emulation, return a basic sub-image that matches the canvas dimensions
        const canvas = this.context.canvas;
        const result = {
            viewport: {
                x: 0,
                y: 0,
                width: canvas.width || this.context.drawingBufferWidth,
                height: canvas.height || this.context.drawingBufferHeight,
            },
            texture: null, // three.js will handle texture creation
        };
        console.log('[IWER] XRWebGLBinding.getViewSubImage returning:', result);
        return result;
    }
    /**
     * Gets a depth sub-image for the given layer and view.
     */
    getDepthSubImage(_layer, _view) {
        console.log('[IWER] XRWebGLBinding.getDepthSubImage called:', {
            layer: _layer,
            view: _view
        });
        // Return null - depth rendering is handled by three.js WebGLRenderer
        console.log('[IWER] XRWebGLBinding.getDepthSubImage returning: null');
        return null;
    }
    /**
     * Gets the native framebuffer scale factor.
     */
    static getNativeFramebufferScaleFactor(session) {
        console.log('[IWER] XRWebGLBinding.getNativeFramebufferScaleFactor called:', session);
        if (!(session instanceof XRSession)) {
            console.error('[IWER] XRWebGLBinding.getNativeFramebufferScaleFactor: Invalid session');
            throw new TypeError('getNativeFramebufferScaleFactor must be passed a session.');
        }
        if (session[P_SESSION].ended) {
            console.log('[IWER] XRWebGLBinding.getNativeFramebufferScaleFactor: Session ended, returning 0.0');
            return 0.0;
        }
        console.log('[IWER] XRWebGLBinding.getNativeFramebufferScaleFactor returning: 1.0');
        // Return 1.0 for emulation - matches XRWebGLLayer implementation
        return 1.0;
    }
}
//# sourceMappingURL=XRWebGLBinding.js.map